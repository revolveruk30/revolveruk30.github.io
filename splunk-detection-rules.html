<html>
<title>SPLUNK Detection Rules</title>
<meta name="robots" content="noindex,nofollow" />
<link rel="stylesheet" href="w2.css">

<head>
<style>
html, body {
background-color: #f0f0f0;
}

.w3-topbar {
width: 100%;
height:5%;
background-color: black;
position: fixed;
top: 1px;
overflow: hidden;
}
#myInput {
background-repeat: no-repeat;
width: 40%;
border: 1px solid #ddd;
margin-left: 300px;
text-align: center;
font-family: "Roboto", sans-serif
}
#keywords {
background-repeat: no-repeat;
width: 28%;
border: 1px solid #ddd;
border: 1px solid #ddd;
margin-bottom: 2px;
margin-left: 300px;
text-align: center;
font-family: "Roboto", sans-serif
}
#myUL {
list-style-type: none;
padding: 0;
text-align: center;
margin-top: 10px;
width: 80%;
word-wrap: break-word;
}
#myUL li a {
margin-top: -1px;
padding: 8px;
text-decoration: none;
font-size: 14px;
color: black;
display: block
}
}
</style>
</head>
<body>
<!-- Topbar -->
<div class="w3-topbar"></div>
<!-- Sidebar -->
<BR>
<p>
<BR>
<center><H3>SPLUNK Detection Rules</H3></center>
<BR>
<input type="text" id="myInput" onkeyup="myFunction()" placeholder="Filter Paragraph by Keyword" title="Search">
<form method="GET" onsubmit="myHilitor.apply(hilite.value); return false;">
<input type="text" id="keywords" size="20" name="hilite" placeholder="Highlight Multiple Keywords">
<input type="submit" value="Apply">
<input type="button" value="Remove" onclick="myHilitor.remove();">
</span>
</form>
</nav>
<div class="w3-main w3-theme-l5" style="margin-left:200px, margin-right:150px">
<div id="playground">
<center>
<ul id="myUL">
<p>


<li><a href="#">NAME: 3CX Supply Chain Attack Network Indicators

DESCRIPTION:  The analytic provided below employs the Network_Resolution datamodel to detect domain indicators associated with the 3CX supply chain attack. By leveraging this query, you can efficiently conduct retrospective analysis of your data to uncover potential compromises.

SEARCH:  '| tstats `security_content_summariesonly` values(DNS.answer) as IPs min(_time) as firstTime from datamodel=Network_Resolution by DNS.src, DNS.query  | `drop_dm_object_name(DNS)`  | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)`  | lookup 3cx_ioc_domains domain as query OUTPUT Description isIOC  | search isIOC=true  | `3cx_supply_chain_attack_network_indicators_filter`'



<li><a href="#">NAME: 7zip CommandLine To SMB Share Path

DESCRIPTION:  This search is to detect a suspicious 7z process with commandline pointing  to SMB network share. This technique was seen in CONTI LEAK tools where it use 7z  to archive a sensitive files and place it in network share tmp folder. This search  is a good hunting query that may give analyst a hint why specific user try to archive  a file pointing to SMB user which is un usual.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where (Processes.process_name ="7z.exe"  OR Processes.process_name = "7za.exe" OR Processes.original_file_name = "7z.exe"  OR Processes.original_file_name =  "7za.exe") AND (Processes.process="*\\C$\\*"  OR Processes.process="*\\Admin$\\*" OR Processes.process="*\\IPC$\\*") by Processes.original_file_name  Processes.parent_process_name Processes.parent_process Processes.process_name Processes.process  Processes.parent_process_id Processes.process_id  Processes.dest Processes.user  | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `7zip_commandline_to_smb_share_path_filter`'



<li><a href="#">NAME: Access LSASS Memory for Dump Creation

DESCRIPTION:  The following analytic detects the dumping of the LSASS process memory,  which occurs during credential dumping attacks.The detection is made by using Sysmon  logs, specifically EventCode 10, which is related to lsass.exe. This helps to search  for indicators of LSASS memory dumping such as specific call traces to dbgcore.dll  and dbghelp.dll. This detection is important because it prevents credential dumping  attacks and the theft of sensitive information such as login credentials, which  can be used to gain unauthorized access to systems and data. False positives might  occur due to legitimate administrative tasks. Next steps include reviewing and investigating  each case, given the high risk associated with potential credential dumping attacks.

SEARCH:  '`sysmon` EventCode=10 TargetImage=*lsass.exe CallTrace=*dbgcore.dll* OR CallTrace=*dbghelp.dll*  | stats count min(_time) as firstTime max(_time) as lastTime by dest, TargetImage,  TargetProcessId, SourceImage, SourceProcessId  | `security_content_ctime(firstTime)`|  `security_content_ctime(lastTime)` | `access_lsass_memory_for_dump_creation_filter` '



<li><a href="#">NAME: Account Discovery With Net App

DESCRIPTION:  This search is to detect a potential account discovery series of command  used by several malware or attack to recon the target machine. This technique is  also seen in some note worthy malware like trickbot where it runs a cmd process,  or even drop its module that will execute the said series of net command. This series  of command are good correlation search and indicator of attacker recon if seen in  the machines within a none technical user or department (HR, finance, ceo and etc)  network.

SEARCH:  '| tstats `security_content_summariesonly` values(Processes.process) as process  values(Processes.parent_process) as parent_process values(Processes.process_id)  as process_id count min(_time) as firstTime max(_time) as lastTime from datamodel=Endpoint.Processes  where `process_net` AND (Processes.process="* user *" OR  Processes.process="*config*"  OR Processes.process="*view /all*") by  Processes.process_name Processes.dest Processes.user  Processes.parent_process_name | where count >=4 | `drop_dm_object_name(Processes)`  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `account_discovery_with_net_app_filter`'



<li><a href="#">NAME: Active Directory Lateral Movement Identified

DESCRIPTION:  The primary objective of this correlation rule is to detect and alert on potential lateral movement activities within an organization's Active Directory (AD) environment. By identifying multiple analytics associated with the Active Directory Lateral Movement analytic story, security analysts can gain better insight into possible threats and respond accordingly to mitigate risks.  The correlation rule will trigger an alert when multiple analytics from the Active Directory Lateral Movement analytic story are detected within a specified time frame.   The rule will generate an alert if a predetermined threshold of correlated analytics is reached within the specified time frame. This threshold can be customized to suit the needs and risk appetite of the organization.

SEARCH:  '| tstats `security_content_summariesonly` min(_time) as firstTime max(_time) as lastTime sum(All_Risk.calculated_risk_score) as risk_score, count(All_Risk.calculated_risk_score) as risk_event_count, values(All_Risk.annotations.mitre_attack.mitre_tactic_id) as annotations.mitre_attack.mitre_tactic_id, dc(All_Risk.annotations.mitre_attack.mitre_tactic_id) as mitre_tactic_id_count, values(All_Risk.annotations.mitre_attack.mitre_technique_id) as annotations.mitre_attack.mitre_technique_id, dc(All_Risk.annotations.mitre_attack.mitre_technique_id) as mitre_technique_id_count, values(All_Risk.tag) as tag, values(source) as source, dc(source) as source_count from datamodel=Risk.All_Risk where All_Risk.analyticstories="Active Directory Lateral Movement" All_Risk.risk_object_type="system" by All_Risk.risk_object All_Risk.risk_object_type All_Risk.annotations.mitre_attack.mitre_tactic   | `drop_dm_object_name(All_Risk)`   | `security_content_ctime(firstTime)`   | `security_content_ctime(lastTime)`   | where source_count >= 4   | `active_directory_lateral_movement_identified_filter`'



<li><a href="#">NAME: Active Directory Privilege Escalation Identified

DESCRIPTION:  The primary objective of this correlation rule is to detect and alert on potential privilege escalation activities within an organization's Active Directory (AD) environment. By identifying multiple analytics associated with the Active Directory Privilege Escalation analytic story, security analysts can gain better insight into possible threats and respond accordingly to mitigate risks.  The correlation rule will trigger an alert when multiple analytics from the Active Directory Privilege Escalation analytic story are detected within a specified time frame.   The rule will generate an alert if a predetermined threshold of correlated analytics is reached within the specified time frame. This threshold can be customized to suit the needs and risk appetite of the organization.

SEARCH:  '| tstats `security_content_summariesonly` min(_time) as firstTime max(_time) as lastTime sum(All_Risk.calculated_risk_score) as risk_score, count(All_Risk.calculated_risk_score) as risk_event_count, values(All_Risk.annotations.mitre_attack.mitre_tactic_id) as annotations.mitre_attack.mitre_tactic_id, dc(All_Risk.annotations.mitre_attack.mitre_tactic_id) as mitre_tactic_id_count, values(All_Risk.annotations.mitre_attack.mitre_technique_id) as annotations.mitre_attack.mitre_technique_id, dc(All_Risk.annotations.mitre_attack.mitre_technique_id) as mitre_technique_id_count, values(All_Risk.tag) as tag, values(source) as source, dc(source) as source_count from datamodel=Risk.All_Risk where All_Risk.analyticstories="Active Directory Privilege Escalation" All_Risk.risk_object_type="system" by All_Risk.risk_object All_Risk.risk_object_type All_Risk.annotations.mitre_attack.mitre_tactic   | `drop_dm_object_name(All_Risk)`   | `security_content_ctime(firstTime)`   | `security_content_ctime(lastTime)`   | where source_count >= 4   | `active_directory_privilege_escalation_identified_filter`'



<li><a href="#">NAME: Active Setup Registry Autostart

DESCRIPTION:  This analytic is to detect a suspicious modification of the active setup  registry for persistence and privilege escalation. This technique was seen in several  malware (poisonIvy), adware and APT to gain persistence to the compromised machine  upon boot up. This TTP is a good indicator to further check the process id that  do the modification since modification of this registry is not commonly done. check  the legitimacy of the file and process involve in this rules to check if it is a  valid setup installer that creating or modifying this registry.

SEARCH:  '| tstats `security_content_summariesonly` count FROM datamodel=Endpoint.Registry WHERE (Registry.registry_value_name= "StubPath" Registry.registry_path = "*\\SOFTWARE\\Microsoft\\Active Setup\\Installed Components*") BY _time span=1h Registry.registry_path Registry.registry_key_name Registry.registry_value_name Registry.registry_value_data Registry.process_guid Registry.dest Registry.user   | `drop_dm_object_name(Registry)`  | `security_content_ctime(firstTime)`   | `security_content_ctime(lastTime)`| `active_setup_registry_autostart_filter`'



<li><a href="#">NAME: Add DefaultUser And Password In Registry

DESCRIPTION:  this search is to detect a suspicious registry modification to implement  auto admin logon to a host. This technique was seen in BlackMatter ransomware to  automatically logon to the compromise host after  triggering a safemode boot to  continue encrypting the whole network. This behavior is not a common practice and  really a suspicious TTP or alert need to be consider if found within then network  premise.

SEARCH:  '| tstats `security_content_summariesonly` count FROM datamodel=Endpoint.Registry WHERE (Registry.registry_path= "*SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon*" AND Registry.registry_value_name= DefaultPassword OR Registry.registry_value_name= DefaultUserName) BY _time span=1h Registry.registry_path Registry.registry_key_name Registry.registry_value_name Registry.dest Registry.registry_value_data Registry.process_guid   | `drop_dm_object_name(Registry)`  | `security_content_ctime(firstTime)`   | `security_content_ctime(lastTime)`  | `add_defaultuser_and_password_in_registry_filter`'



<li><a href="#">NAME: Add or Set Windows Defender Exclusion

DESCRIPTION:  This analytic will identify a suspicious process command-line related  to Windows Defender exclusion feature. This command is abused by adversaries, malware  authors and red teams to bypass Windows Defender Antivirus products by excluding  folder path, file path, process and extensions. From its real time or schedule scan  to execute their malicious code. This is a good indicator for defense evasion and  to look further for events after this behavior.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where (Processes.process = "*Add-MpPreference  *" OR Processes.process = "*Set-MpPreference *") AND Processes.process="*-exclusion*"  by Processes.dest Processes.user Processes.parent_process Processes.parent_process_name  Processes.process_name Processes.original_file_name Processes.process Processes.process_id  Processes.parent_process_id | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `add_or_set_windows_defender_exclusion_filter`'



<li><a href="#">NAME: AdsiSearcher Account Discovery

DESCRIPTION:  The following analytic utilizes PowerShell Script Block Logging (EventCode=4104)  to identify the `[Adsisearcher]` type accelerator being used to query Active Directory  for domain groups. Red Teams and adversaries may leverage `[Adsisearcher]` to enumerate  domain users for situational awareness and Active Directory Discovery.

SEARCH:  '`powershell` EventCode=4104 ScriptBlockText = "*[adsisearcher]*" ScriptBlockText  = "*objectcategory=user*" ScriptBlockText = "*.findAll()*" | stats count min(_time)  as firstTime max(_time) as lastTime by EventCode Computer ScriptBlockText UserID  | rename Computer as dest, UserID as user | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `adsisearcher_account_discovery_filter`'



<li><a href="#">NAME: Allow File And Printing Sharing In Firewall

DESCRIPTION:  This search is to detect a suspicious modification of firewall to allow  file and printer sharing. This technique was seen in ransomware to be able to discover  more machine connected to the compromised host to encrypt more files

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where `process_netsh` Processes.process=  "*firewall*" Processes.process= "*group=\"File and Printer Sharing\"*"  Processes.process="*enable=Yes*"  by Processes.dest Processes.user Processes.parent_process Processes.process_name  Processes.process Processes.process_id Processes.parent_process_id Processes.parent_process_name  Processes.original_file_name | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `allow_file_and_printing_sharing_in_firewall_filter`'



<li><a href="#">NAME: Allow Inbound Traffic By Firewall Rule Registry

DESCRIPTION:  The following analytic detects a potential suspicious modification of firewall  rule registry allowing inbound traffic in specific port with public profile. This  technique was identified when an adversary wants to grant remote access to a machine  by allowing the traffic in a firewall rule.

SEARCH:  '| tstats `security_content_summariesonly` count FROM datamodel=Endpoint.Registry WHERE (Registry.registry_path= "*\\System\\CurrentControlSet\\Services\\SharedAccess\\Parameters\\FirewallPolicy\\FirewallRules\\*" Registry.registry_value_data = "*|Action=Allow|*" Registry.registry_value_data = "*|Dir=In|*"  Registry.registry_value_data = "*|LPort=*") BY _time span=1h Registry.registry_path Registry.registry_key_name Registry.registry_value_name Registry.registry_value_data Registry.process_guid  Registry.dest Registry.user  | `drop_dm_object_name(Registry)`  | `security_content_ctime(firstTime)`   | `security_content_ctime(lastTime)`  | `allow_inbound_traffic_by_firewall_rule_registry_filter`'



<li><a href="#">NAME: Allow Inbound Traffic In Firewall Rule

DESCRIPTION:  The following analytic identifies suspicious PowerShell command to allow  inbound traffic inbound to a specific local port within the public profile. This  technique was seen in some attacker want to have a remote access to a machine by  allowing the traffic in firewall rule.

SEARCH:  '`powershell` EventCode=4104 Message = "*firewall*" Message = "*Inbound*"  Message = "*Allow*"  Message = "*-LocalPort*" | stats count min(_time) as firstTime  max(_time) as lastTime by EventCode Message ComputerName User | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `allow_inbound_traffic_in_firewall_rule_filter`'



<li><a href="#">NAME: Allow Network Discovery In Firewall

DESCRIPTION:  This search is to detect a suspicious modification to the firewall to  allow network discovery on a machine. This technique was seen in couple of ransomware  (revil, reddot) to discover other machine connected to the compromised host to encrypt  more files.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where `process_netsh` Processes.process=  "*firewall*" Processes.process= "*group=\"Network Discovery\"*"  Processes.process="*enable*"  Processes.process="*Yes*" by Processes.dest Processes.user Processes.parent_process  Processes.original_file_name Processes.process_name Processes.process Processes.process_id  Processes.parent_process_id Processes.parent_process_name | `drop_dm_object_name(Processes)`  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `allow_network_discovery_in_firewall_filter`'



<li><a href="#">NAME: Allow Operation with Consent Admin

DESCRIPTION:  This analytic identifies a potential privilege escalation attempt to  perform malicious task. This registry modification is designed to allow the `Consent  Admin` to perform an operation that requires elevation without consent or credentials.  We also found this in some attacker to gain privilege escalation to the compromise  machine.

SEARCH:  '| tstats `security_content_summariesonly` count FROM datamodel=Endpoint.Registry WHERE (Registry.registry_path= "*\\Microsoft\\Windows\\CurrentVersion\\Policies\\System*" Registry.registry_value_name = ConsentPromptBehaviorAdmin Registry.registry_value_data = "0x00000000") BY _time span=1h Registry.registry_path Registry.registry_key_name Registry.registry_value_name Registry.registry_value_data Registry.process_guid Registry.dest Registry.user  | `drop_dm_object_name(Registry)`  | `security_content_ctime(firstTime)`   | `security_content_ctime(lastTime)`  | `allow_operation_with_consent_admin_filter`'



<li><a href="#">NAME: Anomalous usage of 7zip

DESCRIPTION:  The following detection identifies a 7z.exe spawned from `Rundll32.exe`  or `Dllhost.exe`. It is assumed that the adversary has brought in `7z.exe` and `7z.dll`.  It has been observed where an adversary will rename `7z.exe`. Additional coverage  may be required to identify the behavior of renamed instances of `7z.exe`. During  triage, identify the source of injection into `Rundll32.exe` or `Dllhost.exe`. Capture  any files written to disk and analyze as needed. Review parallel processes for additional  behaviors. Typically, archiving files will result in exfiltration.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.parent_process_name  IN ("rundll32.exe", "dllhost.exe") Processes.process_name=*7z* by Processes.dest  Processes.user Processes.parent_process Processes.parent_process_name Processes.process_name Processes.process  Processes.process_id Processes.parent_process_id | `drop_dm_object_name(Processes)`  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`| `anomalous_usage_of_7zip_filter`'



<li><a href="#">NAME: Any Powershell DownloadFile

DESCRIPTION:  The following analytic identifies the use of PowerShell downloading a  file using `DownloadFile` method. This particular method is utilized in many different  PowerShell frameworks to download files and output to disk. Identify the source  (IP/domain) and destination file and triage appropriately. If AMSI logging or PowerShell  transaction logs are available, review for further details of the implant.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where `process_powershell` Processes.process=*DownloadFile*  by Processes.dest Processes.user Processes.parent_process Processes.process_name  Processes.parent_process_name Processes.original_file_name Processes.process Processes.process_id  Processes.parent_process_id | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)`|  `security_content_ctime(lastTime)`| `any_powershell_downloadfile_filter`'



<li><a href="#">NAME: Any Powershell DownloadString

DESCRIPTION:  The following analytic identifies the use of PowerShell downloading a  file using `DownloadString` method. This particular method is utilized in many different  PowerShell frameworks to download files and output to disk. Identify the source  (IP/domain) and destination file and triage appropriately. If AMSI logging or PowerShell  transaction logs are available, review for further details of the implant.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where `process_powershell` Processes.process=*.DownloadString*  by  Processes.dest Processes.user Processes.parent_process Processes.parent_process_name  Processes.process_name Processes.original_file_name Processes.process Processes.process_id  Processes.parent_process_id | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)`|  `security_content_ctime(lastTime)`| `any_powershell_downloadstring_filter`'



<li><a href="#">NAME: Attacker Tools On Endpoint

DESCRIPTION:  |-  The following analytic detects the use of tools that are commonly exploited by cybercriminals since these tools are usually associated with malicious activities such as unauthorized access, network scanning, or data exfiltration and pose a significant threat to an organization's security infrastructure. It also provides enhanced visibility into potential security threats and helps to proactively detect and respond to mitigate the risks associated with cybercriminal activities. This detection is made by examining the process activity on the host, specifically focusing on processes that are known to be associated with attacker tool names. This detection is important because it acts as an early warning system for potential security incidents that allows you to respond to security incidents promptly. False positives might occur due to legitimate administrative activities that can resemble malicious actions. You must develop a comprehensive understanding of typical endpoint activities and behaviors within the organization to accurately interpret and respond to the alerts generated by this analytic. This ensures a proper balance between precision and minimizing false positives.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime values(Processes.process) as process values(Processes.parent_process)  as parent_process from datamodel=Endpoint.Processes where Processes.dest!=unknown  Processes.user!=unknown by Processes.dest Processes.user Processes.process_name  Processes.process | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `drop_dm_object_name(Processes)` | lookup attacker_tools attacker_tool_names AS  process_name OUTPUT description | search description !=false| `attacker_tools_on_endpoint_filter`'



<li><a href="#">NAME: Attempted Credential Dump From Registry via Reg exe

DESCRIPTION:  Monitor for execution of reg.exe with parameters specifying an export  of keys that contain hashed credentials that attackers may try to crack offline.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.process_name=reg*  OR Processes.process_name=cmd* Processes.process=*save* (Processes.process=*HKEY_LOCAL_MACHINE\\Security*  OR Processes.process=*HKEY_LOCAL_MACHINE\\SAM* OR Processes.process=*HKEY_LOCAL_MACHINE\\System*  OR Processes.process=*HKLM\\Security* OR Processes.process=*HKLM\\System* OR Processes.process=*HKLM\\SAM*)  by Processes.dest Processes.user Processes.parent_process Processes.parent_process_name  Processes.process_name  Processes.original_file_name Processes.process Processes.process_id Processes.parent_process_id  | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)`| `security_content_ctime(lastTime)`  | `attempted_credential_dump_from_registry_via_reg_exe_filter`'



<li><a href="#">NAME: Attempt To Add Certificate To Untrusted Store

DESCRIPTION:  |-  The following analytic detects whether a process is attempting to add a certificate to the untrusted certificate store, which might result in security tools being disabled. The detection is made by focusing on process activities and command-line arguments that are related to the 'certutil -addstore' command. This detection is important because it helps to identify attackers who might add a certificate to the untrusted certificate store to disable security tools and gain unauthorized access to a system. False positives might occur since legitimate reasons might exist for a process to add a certificate to the untrusted certificate store, such as system administration tasks. Next steps include conducting an extensive triage and investigation prior to taking any action. Additionally, you must understand the importance of trust and its subversion in system security.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime values(Processes.process)  as process max(_time) as lastTime from datamodel=Endpoint.Processes where `process_certutil`  (Processes.process=*-addstore*) by Processes.dest Processes.user Processes.parent_process  Processes.parent_process_name Processes.process_name Processes.process Processes.process_id  Processes.parent_process_id | `drop_dm_object_name("Processes")` | `security_content_ctime(firstTime)`  |`security_content_ctime(lastTime)` | `attempt_to_add_certificate_to_untrusted_store_filter`'



<li><a href="#">NAME: Attempt To Stop Security Service

DESCRIPTION:  |-  The following analytic detects attempts to stop security-related services on the endpoint and helps to mitigate potential threats earlier, thereby minimizing the impact on the organization's security. The detection is made by using a Splunk query that searches for processes that involve the "sc.exe" command and include the phrase "stop" in their command. The query collects information such as the process name, process ID, parent process, user, destination, and timestamps. The detection is important because attempts to stop security-related services can indicate malicious activity or an attacker's attempt to disable security measures. This can impact the organization's security posture and can lead to the compromise of the endpoint and potentially the entire network. Disabling security services can allow attackers to gain unauthorized access, exfiltrate sensitive data, or launch further attacks, such as malware installation or privilege escalation. False positives might occur since there might be legitimate reasons for stopping these services in certain situations. Therefore, you must exercise caution and consider the context of the activity before taking any action. Next steps include reviewing the identified process and its associated details. You must also investigate any on-disk artifacts related to the process and review concurrent processes to determine the source of the attack.

SEARCH:  '| tstats `security_content_summariesonly` values(Processes.process) as process  min(_time) as firstTime max(_time) as lastTime from datamodel=Endpoint.Processes  where `process_net` OR  Processes.process_name = sc.exe Processes.process="* stop  *" by Processes.dest Processes.user Processes.parent_process Processes.parent_process_name  Processes.process_name Processes.original_file_name Processes.process Processes.process_id  Processes.parent_process_id | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` |lookup security_services_lookup service as  process OUTPUTNEW category, description | search category=security | `attempt_to_stop_security_service_filter`'



<li><a href="#">NAME: Auto Admin Logon Registry Entry

DESCRIPTION:  this search is to detect a suspicious registry modification to implement  auto admin logon to a host. This technique was seen in BlackMatter ransomware to  automatically logon to the compromise host after  triggering a safemode boot to  continue encrypting the whole network. This behavior is not a common practice and  really a suspicious TTP or alert need to be consider if found within then network  premise.

SEARCH:  '| tstats `security_content_summariesonly` count FROM datamodel=Endpoint.Registry WHERE (Registry.registry_path= "*SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon*" AND Registry.registry_value_name=AutoAdminLogon AND Registry.registry_value_data=1) BY _time span=1h Registry.registry_path Registry.registry_key_name Registry.registry_value_name Registry.registry_value_data Registry.process_guid Registry.dest  | `drop_dm_object_name(Registry)`  | where isnotnull(registry_value_data)  | `security_content_ctime(firstTime)`   | `security_content_ctime(lastTime)`  | `auto_admin_logon_registry_entry_filter`'



<li><a href="#">NAME: Batch File Write to System32

DESCRIPTION:  The search looks for a batch file (.bat) written to the Windows system  directory tree.

SEARCH:  '| tstats `security_content_summariesonly` count FROM datamodel=Endpoint.Processes where Processes.process_name=* by _time span=1h Processes.process_guid Processes.process_name Processes.dest Processes.user | `drop_dm_object_name(Processes)` | join process_guid     [| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time) as lastTime FROM datamodel=Endpoint.Filesystem    where Filesystem.file_path IN ("*\\system32\\*", "*\\syswow64\\*") Filesystem.file_name="*.bat" by _time span=1h Filesystem.dest Filesystem.file_create_time Filesystem.file_name Filesystem.file_path Filesystem.process_guid     | `drop_dm_object_name(Filesystem)`]| table dest user file_create_time, file_name, file_path, process_name, firstTime, lastTime | dedup file_create_time| `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`| `batch_file_write_to_system32_filter`'



<li><a href="#">NAME: Bcdedit Command Back To Normal Mode Boot

DESCRIPTION:  This search is to detect a suspicious bcdedit commandline to configure  the host from safe mode back to normal boot configuration. This technique was seen  in blackMatter ransomware where it force the compromised host to boot in safe mode  to continue its encryption and bring back to normal boot using bcdedit deletevalue  command. This TTP can be a good alert for host that booted from safe mode forcefully  since it need to modify the boot configuration to bring it back to normal.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.process_name = bcdedit.exe  Processes.process="*/deletevalue*" Processes.process="*{current}*"  Processes.process="*safeboot*"  by Processes.process_name Processes.process Processes.parent_process_name Processes.dest  Processes.user |`drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `bcdedit_command_back_to_normal_mode_boot_filter`'



<li><a href="#">NAME: BCDEdit Failure Recovery Modification

DESCRIPTION:  This search looks for flags passed to bcdedit.exe modifications to the  built-in Windows error recovery boot configurations. This is typically used by ransomware  to prevent recovery.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.process_name = bcdedit.exe  Processes.process="*recoveryenabled*" (Processes.process="* no*") by Processes.process_name  Processes.process Processes.parent_process_name Processes.dest Processes.user |  `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `bcdedit_failure_recovery_modification_filter`'



<li><a href="#">NAME: BITSAdmin Download File

DESCRIPTION:  The following query identifies Microsoft Background Intelligent Transfer  Service utility `bitsadmin.exe` using the `transfer` parameter to download a remote  object. In addition, look for `download` or `upload` on the command-line, the switches  are not required to perform a transfer. Capture any files downloaded. Review the  reputation of the IP or domain used. Typically once executed, a follow on command  will be used to execute the dropped file. Note that the network connection or file  modification events related will not spawn or create from `bitsadmin.exe`, but the  artifacts will appear in a parallel process of `svchost.exe` with a command-line  similar to `svchost.exe -k netsvcs -s BITS`. It's important to review all parallel  and child processes to capture any behaviors and artifacts. In some suspicious and  malicious instances, BITS jobs will be created. You can use `bitsadmin /list /verbose`  to list out the jobs during investigation.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where `process_bitsadmin` Processes.process  IN ("*transfer*", "*addfile*") by Processes.dest Processes.user Processes.parent_process  Processes.parent_process_name Processes.original_file_name Processes.process_name  Processes.process Processes.process_id Processes.parent_process_id | `drop_dm_object_name(Processes)`  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `bitsadmin_download_file_filter`'



<li><a href="#">NAME: BITS Job Persistence

DESCRIPTION:  The following query identifies Microsoft Background Intelligent Transfer  Service utility `bitsadmin.exe` scheduling a BITS job to persist on an endpoint.  The query identifies the parameters used to create, resume or add a file to a BITS  job. Typically seen combined in a oneliner or ran in sequence. If identified, review  the BITS job created and capture any files written to disk. It is possible for BITS  to be used to upload files and this may require further network data analysis to  identify. You can use `bitsadmin /list /verbose` to list out the jobs during investigation.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where `process_bitsadmin` Processes.process  IN (*create*, *addfile*, *setnotifyflags*, *setnotifycmdline*, *setminretrydelay*,  *setcustomheaders*, *resume* ) by Processes.dest Processes.user Processes.original_file_name  Processes.parent_process Processes.parent_process_name Processes.process_name Processes.process  Processes.process_id Processes.parent_process_id | `drop_dm_object_name(Processes)`  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `bits_job_persistence_filter`'



<li><a href="#">NAME: CertUtil Download With URLCache and Split Arguments

DESCRIPTION:  Certutil.exe may download a file from a remote destination using `-urlcache`.  This behavior does require a URL to be passed on the command-line. In addition,  `-f` (force) and `-split` (Split embedded ASN.1 elements, and save to files) will  be used. It is not entirely common for `certutil.exe` to contact public IP space.  However, it is uncommon for `certutil.exe` to write files to world writeable paths.\  During triage, capture any files on disk and review. Review the reputation of the  remote IP or domain in question.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where `process_certutil` (Processes.process=*urlcache*  Processes.process=*split*) OR Processes.process=*urlcache* by Processes.dest Processes.user  Processes.parent_process Processes.parent_process_name Processes.process_name Processes.process  Processes.process_id Processes.original_file_name Processes.parent_process_id |  `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `certutil_download_with_urlcache_and_split_arguments_filter`'



<li><a href="#">NAME: CertUtil Download With VerifyCtl and Split Arguments

DESCRIPTION:  'Certutil.exe may download a file from a remote destination using `-VerifyCtl`.  This behavior does require a URL to be passed on the command-line. In addition,  `-f` (force) and `-split` (Split embedded ASN.1 elements, and save to files) will  be used. It is not entirely common for `certutil.exe` to contact public IP space.  \ During triage, capture any files on disk and review. Review the reputation of  the remote IP or domain in question. Using `-VerifyCtl`, the file will either be  written to the current working directory or `%APPDATA%\..\LocalLow\Microsoft\CryptnetUrlCache\Content\<hash>`. '

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where `process_certutil` (Processes.process=*verifyctl*  Processes.process=*split*) OR Processes.process=*verifyctl* by Processes.dest Processes.user  Processes.original_file_name Processes.parent_process Processes.parent_process_name  Processes.process_name Processes.process Processes.process_id Processes.parent_process_id  | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `certutil_download_with_verifyctl_and_split_arguments_filter`'



<li><a href="#">NAME: Certutil exe certificate extraction

DESCRIPTION:  This search looks for arguments to certutil.exe indicating the manipulation  or extraction of Certificate. This certificate can then be used to sign new authentication  tokens specially inside Federated environments such as Windows ADFS.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.process_name=certutil.exe  Processes.process = "*-exportPFX*" by Processes.dest Processes.user Processes.parent_process  Processes.parent_process_name Processes.process_name Processes.process Processes.process_id  Processes.parent_process_id | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `certutil_exe_certificate_extraction_filter`'



<li><a href="#">NAME: CertUtil With Decode Argument

DESCRIPTION:  CertUtil.exe may be used to `encode` and `decode` a file, including PE  and script code. Encoding will convert a file to base64 with `-----BEGIN CERTIFICATE-----`  and `-----END CERTIFICATE-----` tags. Malicious usage will include decoding a encoded  file that was downloaded. Once decoded, it will be loaded by a parallel process.  Note that there are two additional command switches that may be used - `encodehex`  and `decodehex`. Similarly, the file will be encoded in HEX and later decoded for  further execution. During triage, identify the source of the file being decoded.  Review its contents or execution behavior for further analysis.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where `process_certutil` Processes.process=*decode*  by Processes.dest Processes.user Processes.parent_process Processes.parent_process_name  Processes.process_name Processes.process Processes.process_id Processes.parent_process_id  | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `certutil_with_decode_argument_filter`'



<li><a href="#">NAME: Change Default File Association

DESCRIPTION:  This analytic is developed to detect suspicious registry modification  to change the default file association of windows to malicious payload. This technique  was seen in some APT where it modify the default process to run file association,  like .txt to notepad.exe. Instead notepad.exe it will point to a Script or other  payload that will load malicious commands to the compromised host.

SEARCH:  '| tstats `security_content_summariesonly` count  min(_time) as firstTime  max(_time) as lastTime FROM datamodel=Endpoint.Registry where Registry.registry_path  ="*\\shell\\open\\command\\*" Registry.registry_path = "*HKCR\\*" by Registry.dest  Registry.user  Registry.registry_path Registry.registry_key_name Registry.registry_value_name |  `security_content_ctime(lastTime)` | `security_content_ctime(firstTime)` | `drop_dm_object_name(Registry)`  | `change_default_file_association_filter`'



<li><a href="#">NAME: Change To Safe Mode With Network Config

DESCRIPTION:  This search is to detect a suspicious bcdedit commandline to configure  the host to boot in safe mode with network config. This technique was seen in blackMatter  ransomware where it force the compromised host to boot in safe mode to continue  its encryption and bring back to normal boot using bcdedit deletevalue command.  This TTP can be a good alert for host that booted from safe mode forcefully since  it need to modify the boot configuration to bring it back to normal.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.process_name = bcdedit.exe  Processes.process="*/set*" Processes.process="*{current}*"  Processes.process="*safeboot*"  Processes.process="*network*" by Processes.process_name Processes.process Processes.parent_process_name  Processes.dest Processes.user |`drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `change_to_safe_mode_with_network_config_filter`'



<li><a href="#">NAME: CHCP Command Execution

DESCRIPTION:  This search is to detect execution of chcp.exe application. this utility  is used to change the active code page of the console. This technique was seen in  icedid malware to know the locale region/language/country of the compromise host.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.process_name=chcp.com  Processes.parent_process_name = cmd.exe (Processes.parent_process=*/c* OR Processes.parent_process=*/k*)  by  Processes.process_name Processes.process Processes.parent_process_name Processes.parent_process  Processes.process_id Processes.parent_process_id Processes.dest Processes.user |  `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `chcp_command_execution_filter`'



<li><a href="#">NAME: Check Elevated CMD using whoami

DESCRIPTION:  This search is to detect a suspicious whoami execution to check if the  cmd or shell instance process is with elevated privileges. This technique was seen  in FIN7 js implant where it execute this as part of its data collection to the infected  machine to check if the running shell cmd process is elevated or not. This TTP is  really a good alert for known attacker that recon on the targetted host. This command  is not so commonly executed by a normal user or even an admin to check if a process  is elevated.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where  Processes.process = "*whoami*"  Processes.process = "*/group*" Processes.process = "* find *" Processes.process  = "*12288*" by Processes.dest Processes.user Processes.parent_process Processes.process_name  Processes.process Processes.process_id Processes.parent_process_id | `drop_dm_object_name(Processes)`  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `check_elevated_cmd_using_whoami_filter`'



<li><a href="#">NAME: Child Processes of Spoolsv exe

DESCRIPTION:  This search looks for child processes of spoolsv.exe. This activity is  associated with a POC privilege-escalation exploit associated with CVE-2018-8440.  Spoolsv.exe is the process associated with the Print Spooler service in Windows  and typically runs as SYSTEM.

SEARCH:  '| tstats `security_content_summariesonly` count values(Processes.process_name)  as process_name values(Processes.process) as process min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.parent_process_name=spoolsv.exe  AND Processes.process_name!=regsvr32.exe by Processes.dest Processes.parent_process  Processes.user | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `child_processes_of_spoolsv_exe_filter` '



<li><a href="#">NAME: Clear Unallocated Sector Using Cipher App

DESCRIPTION:  this search is to detect execution of `cipher.exe` to clear the unallocated  sectors of a specific disk. This technique was seen in some ransomware to make it  impossible to forensically recover deleted files.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.process_name = "cipher.exe"  Processes.process = "*/w:*" by Processes.parent_process_name Processes.parent_process  Processes.process_name Processes.process Processes.dest Processes.user Processes.process_id  Processes.process_guid | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `clear_unallocated_sector_using_cipher_app_filter`'



<li><a href="#">NAME: Clop Common Exec Parameter

DESCRIPTION:  The following analytics are designed to identifies some CLOP ransomware  variant that using arguments to execute its main code or feature of its code. In  this variant if the parameter is "runrun", CLOP ransomware will try to encrypt files  in network shares and if it is "temp.dat", it will try to read from some stream  pipe or file start encrypting files within the infected local machines. This technique  can be also identified as an anti-sandbox technique to make its code non-responsive  since it is waiting for some parameter to execute properly.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.process_name != "*temp.dat*"  Processes.process = "*runrun*" OR Processes.process = "*temp.dat*" by Processes.dest  Processes.user Processes.parent_process Processes.parent_process_name Processes.process_name  Processes.process Processes.process_id Processes.parent_process_id | `drop_dm_object_name(Processes)`  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `clop_common_exec_parameter_filter`'



<li><a href="#">NAME: Clop Ransomware Known Service Name

DESCRIPTION:  This detection is to identify the common service name created by the  CLOP ransomware as part of its persistence and high privilege code execution in  the infected machine. Ussually CLOP ransomware use StartServiceCtrlDispatcherW API  in creating this service entry.

SEARCH:  '`wineventlog_system` EventCode=7045 Service_Name IN ("SecurityCenterIBM",  "WinCheckDRVs") | stats count min(_time) as firstTime max(_time) as lastTime by dest  EventCode Service_File_Name Service_Name Service_Start_Type Service_Type | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `clop_ransomware_known_service_name_filter`'



<li><a href="#">NAME: Cmdline Tool Not Executed In CMD Shell

DESCRIPTION:  The following analytic identifies a non-standard parent process (not  matching CMD, PowerShell, or Explorer) spawning `ipconfig.exe` or `systeminfo.exe`.  This particular behavior was seen in FIN7's JSSLoader .NET payload. This is also  typically seen when an adversary is injected into another process performing different  discovery techniques. This event stands out as a TTP since these tools are commonly  executed with a shell application or Explorer parent, and not by another application.  This TTP is a good indicator for an adversary gathering host information, but one  possible false positive might be an automated tool used by a system administator.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where (Processes.process_name = "ipconfig.exe"  OR Processes.process_name = "systeminfo.exe" OR Processes.process_name = "net.exe"  OR Processes.process_name = "net1.exe" OR Processes.process_name = "arp.exe" OR  Processes.process_name = "nslookup.exe" OR Processes.process_name = "route.exe"  OR Processes.process_name = "netstat.exe" OR Processes.process_name = "whoami.exe")  AND NOT (Processes.parent_process_name = "cmd.exe" OR Processes.parent_process_name  = "powershell*" OR Processes.parent_process_name="pwsh.exe" OR Processes.parent_process_name  = "explorer.exe") by Processes.parent_process_name Processes.parent_process Processes.process_name  Processes.original_file_name Processes.process_id Processes.process Processes.dest  Processes.user | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `cmdline_tool_not_executed_in_cmd_shell_filter`'



<li><a href="#">NAME: CMD Carry Out String Command Parameter

DESCRIPTION:  The following analytic identifies command-line arguments where `cmd.exe  /c` is used to execute a program. `cmd /c` is used to run commands in MS-DOS and  terminate after command or process completion. This technique is commonly seen in  adversaries and malware to execute batch command using different shell like PowerShell  or different process other than `cmd.exe`. This is a good hunting query for suspicious  command-line made by a script or relative process execute it.

SEARCH:  '| tstats `security_content_summariesonly` min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where `process_cmd` AND Processes.process="*  /c*" by Processes.dest Processes.user Processes.parent_process_name Processes.parent_process  Processes.process_name Processes.original_file_name Processes.process Processes.process_id  Processes.parent_process_id | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `cmd_carry_out_string_command_parameter_filter`'



<li><a href="#">NAME: CMD Echo Pipe - Escalation

DESCRIPTION:  This analytic identifies a common behavior by Cobalt Strike and other  frameworks where the adversary will escalate privileges, either via `jump` (Cobalt  Strike PTH) or `getsystem`, using named-pipe impersonation. A suspicious event will  look like `cmd.exe /c echo 4sgryt3436 > \\.\Pipe\5erg53`.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where `process_cmd` OR Processes.process=*%comspec%*  (Processes.process=*echo* AND Processes.process=*pipe*) by Processes.dest Processes.user  Processes.parent_process Processes.parent_process_name Processes.process_name Processes.original_file_name  Processes.process Processes.process_id Processes.parent_process_id | `drop_dm_object_name(Processes)`  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `cmd_echo_pipe___escalation_filter`'



<li><a href="#">NAME: CMLUA Or CMSTPLUA UAC Bypass

DESCRIPTION:  The following analytic detects a potential process using COM Object like CMLUA  or CMSTPLUA to bypass UAC. This technique has been used by ransomware adversaries  to gain administrative privileges to its running process.

SEARCH:  '`sysmon` EventCode=7  ImageLoaded IN ("*\\CMLUA.dll", "*\\CMSTPLUA.dll",  "*\\CMLUAUTIL.dll") NOT(process_name IN("CMSTP.exe", "CMMGR32.exe")) NOT(Image IN("*\\windows\\*",  "*\\program files*")) | stats count min(_time) as firstTime max(_time) as lastTime  by dest Image ImageLoaded process_name EventCode Signed ProcessId | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `cmlua_or_cmstplua_uac_bypass_filter`'



<li><a href="#">NAME: Cobalt Strike Named Pipes

DESCRIPTION:  'The following analytic identifies the use of default or publicly known  named pipes used with Cobalt Strike. A named pipe is a named, one-way or duplex  pipe for communication between the pipe server and one or more pipe clients. Cobalt  Strike uses named pipes in many ways and has default values used with the Artifact  Kit and Malleable C2 Profiles. The following query assists with identifying these  default named pipes. Each EDR product presents named pipes a little different. Consider  taking the values and generating a query based on the product of choice. \  Upon triage, review the process performing the named pipe. If it is explorer.exe,  It is possible it was injected into by another process. Review recent parallel processes  to identify suspicious patterns or behaviors. A parallel process may have a network  connection, review and follow the connection back to identify any file modifications.'

SEARCH:  '`sysmon` EventID=17 OR EventID=18 PipeName IN (\\msagent_*, \\DserNamePipe*,  \\srvsvc_*, \\postex_*, \\status_*, \\MSSE-*, \\spoolss_*, \\win_svc*, \\ntsvcs*,  \\winsock*, \\UIA_PIPE*)  | stats count min(_time) as firstTime max(_time) as lastTime  by dest, process_name, process_id process_path, PipeName | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `cobalt_strike_named_pipes_filter`'



<li><a href="#">NAME: Common Ransomware Extensions

DESCRIPTION:  "The following analytic detects Searches for file modifications that commonly occur with Ransomware to detect modifications to files with extensions that are commonly used by Ransomware. The detection is made by searches for changes in the datamodel=Endpoint.Filesystem, specifically modifications to file extensions that match those commonly used by Ransomware. The detection is important because it suggests that an attacker is attempting to encrypt or otherwise modify files in the environment using malware, potentially leading to data loss that can cause significant damage to an organization's data and systems. False positives might occur so the SOC must investigate the affected system to determine the source of the modification and take appropriate action to contain and remediate the attack."

SEARCH:  '| tstats `security_content_summariesonly` min(_time) as firstTime max(_time)  as lastTime count latest(Filesystem.user) as user values(Filesystem.file_path) as  file_path from datamodel=Endpoint.Filesystem by Filesystem.file_name Filesystem.dest  _time span=1h | `drop_dm_object_name(Filesystem)` | rex field=file_name "(?<file_extension>\.[^\.]+)$"  | rex field=file_path "(?<true_file_path>([^\\\]*\\\)*).*" | stats min(firstTime)  as firstTime max(lastTime) as lastTime latest(user) as user dc(true_file_path) as  path_count dc(file_name) as file_count latest(file_name) as file_name latest(true_file_path)  as file_path by dest file_extension | `security_content_ctime(lastTime)` | `security_content_ctime(firstTime)`  | `ransomware_extensions` | where path_count > 1 OR file_count > 20 | `common_ransomware_extensions_filter`'



<li><a href="#">NAME: Common Ransomware Notes

DESCRIPTION:  The search looks for files created with names matching those typically  used in ransomware notes that tell the victim how to get their data back.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime values(Filesystem.user) as user values(Filesystem.dest) as dest values(Filesystem.file_path)  as file_path from datamodel=Endpoint.Filesystem by Filesystem.file_name | `drop_dm_object_name(Filesystem)`  | `security_content_ctime(lastTime)` | `security_content_ctime(firstTime)` | `ransomware_notes`  | `common_ransomware_notes_filter`'



<li><a href="#">NAME: ConnectWise ScreenConnect Path Traversal

DESCRIPTION:  This analytic detects attempts to exploit the ConnectWise ScreenConnect CVE-2024-1708 vulnerability, which allows an attacker to perform path traversal attacks by manipulating the file_path and file_name parameters in the URL. The vulnerability, identified as critical with a CVSS score of 9.8, enables unauthorized users to access sensitive files and directories on the host system, potentially leading to the exfiltration of sensitive data or the execution of arbitrary code. The search query provided looks for file system events that could indicate exploitation attempts. This detection is crucial for identifying and responding to active exploitation of this vulnerability in environments running affected versions of ScreenConnect (23.9.7 and prior). It is recommended to update to version 23.9.8 or above immediately to remediate the issue, as detailed in the ConnectWise security advisory and further analyzed by Huntress researchers.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time) as lastTime from datamodel=Endpoint.Filesystem where Filesystem.file_path IN ("*\\ScreenConnect\\App_Extensions\\*") Filesystem.file_name IN ("*.aspx","*.ashx") by Filesystem.file_create_time Filesystem.process_id Filesystem.process_guid Filesystem.file_name Filesystem.file_path Filesystem.dest  | `drop_dm_object_name(Filesystem)`  | `security_content_ctime(firstTime)`   | `security_content_ctime(lastTime)`   | `connectwise_screenconnect_path_traversal_filter`'



<li><a href="#">NAME: ConnectWise ScreenConnect Path Traversal Windows SACL

DESCRIPTION:  This analytic detects attempts to exploit the ConnectWise ScreenConnect CVE-2024-1708 vulnerability utilizing Windows SACL EventCode 4663, which allows an attacker to perform path traversal attacks by manipulating the file_path and file_name parameters in the URL. The vulnerability, identified as critical with a CVSS score of 9.8, enables unauthorized users to access sensitive files and directories on the host system, potentially leading to the exfiltration of sensitive data or the execution of arbitrary code. The search query provided looks for file system events that could indicate exploitation attempts. This detection is crucial for identifying and responding to active exploitation of this vulnerability in environments running affected versions of ScreenConnect (23.9.7 and prior). It is recommended to update to version 23.9.8 or above immediately to remediate the issue, as detailed in the ConnectWise security advisory and further analyzed by Huntress researchers.

SEARCH:  '`wineventlog_security` EventCode=4663  ProcessName=*\\ScreenConnect.Service.exe file_path IN ("*\\ScreenConnect\\App_Extensions\\*") file_name IN ("*.aspx","*.ashx")  | stats count min(_time) as firstTime max(_time) as lastTime by  ObjectName ObjectType ProcessName AccessMask process_id EventCode Computer Caller_User_Name   | rename Computer as dest Caller_User_Name as user ProcessName as process_name  |  `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)`   | `connectwise_screenconnect_path_traversal_windows_sacl_filter`'



<li><a href="#">NAME: Conti Common Exec parameter

DESCRIPTION:  This search detects the suspicious commandline argument of revil ransomware  to encrypt specific or all local drive and network shares of the compromised machine  or host.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.process = "*-m local*"  OR Processes.process = "*-m net*" OR Processes.process = "*-m all*" OR Processes.process  = "*-nomutex*" by Processes.process_name Processes.process Processes.parent_process_name  Processes.parent_process Processes.dest Processes.user Processes.process_id Processes.process_guid  | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `conti_common_exec_parameter_filter`'



<li><a href="#">NAME: Control Loading from World Writable Directory

DESCRIPTION:  The following detection identifies control.exe loading either a .cpl  or .inf from a writable directory. This is related to CVE-2021-40444. During triage,  review parallel processes, parent and child, for further suspicious behaviors. In  addition, capture file modifications and analyze.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where (Processes.process_name=control.exe  OR Processes.original_file_name=CONTROL.EXE) AND Processes.process IN ("*\\appdata\\*",  "*\\windows\\temp\\*", "*\\programdata\\*") by Processes.dest Processes.user Processes.parent_process_name  Processes.process_name Processes.process Processes.process_id Processes.parent_process_id  Processes.original_file_name | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `control_loading_from_world_writable_directory_filter`'



<li><a href="#">NAME: Create local admin accounts using net exe

DESCRIPTION:  |-  The following analytic detects the creation of local administrator accounts using the net.exe command to mitigate the risks associated with unauthorized access and prevent further damage to the environment by responding to potential threats earlier and taking appropriate actions to protect the organization's systems and data. This detection is made by a Splunk query to search for processes with the name net.exe or net1.exe that include the "/add" parameter and have specific keywords related to administrator accounts in their process name. This detection is important because the creation of unauthorized local administrator accounts might indicate that an attacker has successfully created a new administrator account and is trying to gain persistent access to a system or escalate their privileges for data theft, or other malicious activities. False positives might occur since there might be legitimate uses of the net.exe command and the creation of administrator accounts in certain circumstances. You must consider the context of the activity and other indicators of compromise before taking any action. For next steps, review the details of the identified process, including the user, parent process, and parent process name. Examine any relevant on-disk artifacts and look for concurrent processes to determine the source of the attack.

SEARCH:  '| tstats `security_content_summariesonly` count values(Processes.user) as  user values(Processes.parent_process) as parent_process values(parent_process_name)  as parent_process_name min(_time) as firstTime max(_time) as lastTime from datamodel=Endpoint.Processes  where (Processes.process_name=net.exe OR Processes.process_name=net1.exe) AND Processes.process=*/add*  AND (Processes.process=*administrators* OR Processes.process=*administratoren* OR  Processes.process=*administrateurs* OR Processes.process=*administrador* OR Processes.process=*amministratori*  OR Processes.process=*administratorer*) by Processes.process Processes.process_name Processes.parent_process_name  Processes.dest Processes.user| `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `create_local_admin_accounts_using_net_exe_filter`'



<li><a href="#">NAME: Create or delete windows shares using net exe

DESCRIPTION:  |-  The following analytic detects the creation or deletion of hidden shares using the net.exe command for prompt response and mitigation to enhance the overall security posture of the organization and protect against potential data breaches, malware infections, and other damaging outcomes. This detection is made by searching for processes that involve the use of net.exe and filters for actions related to creation or deletion of shares. This detection is important because it suggests that an attacker is attempting to manipulate or exploit the network by creating or deleting hidden shares. The creation or deletion of hidden shares can indicate malicious activity since attackers might use hidden shares to exfiltrate data, distribute malware, or establish persistence within a network. The impact of such an attack can vary, but it often involves unauthorized access to sensitive information, disruption of services, or the introduction of malware. False positives might occur since legitimate actions can also involve the use of net.exe. An extensive triage and investigation is necessary to determine the intent and nature of the detected activity. Next steps include reviewing the details of the process involving the net.exe command, including the user, parent process, and timestamps during the triage. Additionally, capture and inspect any relevant on-disk artifacts and review concurrent processes to identify the source of the attack.

SEARCH:  '| tstats `security_content_summariesonly` count values(Processes.user) as  user values(Processes.parent_process) as parent_process min(_time) as firstTime  max(_time) as lastTime from datamodel=Endpoint.Processes where `process_net` by  Processes.process Processes.process_name  Processes.parent_process_name Processes.original_file_name  Processes.dest | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)`|  `security_content_ctime(lastTime)` | search process=*share* | `create_or_delete_windows_shares_using_net_exe_filter` '



<li><a href="#">NAME: Create Remote Thread into LSASS

DESCRIPTION:  "The following analytic detects the creation of a remote thread in the Local Security Authority Subsystem Service (LSASS), which is a common tactic used by adversaries to steal user authentication credentials, known as credential dumping. The detection is made by leveraging Sysmon Event ID 8 logs and searches for processes that create remote threads in lsass.exe. This is an unusual activity that is generally linked to credential theft or credential dumping, which is a significant threat to network security. The detection is important because it helps to detect potential credential dumping attacks, which can result in significant damage to an organization's security. False positives might occur though the confidence level of this alert is high. There might be cases where legitimate tools can access LSASS and generate similar logs. Therefore, you must understand the broader context of such events and differentiate between legitimate activities and possible threats."

SEARCH:  '`sysmon` EventID=8 TargetImage=*lsass.exe | stats count min(_time) as firstTime  max(_time) as lastTime by dest, EventCode, TargetImage, TargetProcessId | `security_content_ctime(firstTime)`| `security_content_ctime(lastTime)`  | `create_remote_thread_into_lsass_filter`'



<li><a href="#">NAME: Create Remote Thread In Shell Application

DESCRIPTION:  This search is to detect suspicious process injection in command shell.  This technique was seen in IcedID where it execute cmd.exe process to inject its  shellcode as part of its execution as banking trojan. It is really uncommon to have  a create remote thread execution in the following application.

SEARCH:  '`sysmon` EventCode=8 TargetImage IN ("*\\cmd.exe", "*\\powershell*") | stats  count min(_time) as firstTime max(_time) as lastTime by  TargetImage TargetProcessId  SourceProcessId  EventCode StartAddress SourceImage dest |rename SourceImage as process_name| `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `create_remote_thread_in_shell_application_filter`'



<li><a href="#">NAME: Creation of lsass Dump with Taskmgr

DESCRIPTION:  Detect the hands on keyboard behavior of Windows Task Manager creating  a process dump of lsass.exe. Upon this behavior occurring, a file write/modification  will occur in the users profile under \AppData\Local\Temp. The dump file, lsass.dmp,  cannot be renamed, however if the dump occurs more than once, it will be named lsass  (2).dmp.

SEARCH:  '`sysmon` EventID=11 process_name=taskmgr.exe TargetFilename=*lsass*.dmp |  stats count min(_time) as firstTime max(_time) as lastTime by dest, object_category,  process_name, TargetFilename  | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `creation_of_lsass_dump_with_taskmgr_filter`'



<li><a href="#">NAME: Creation of Shadow Copy

DESCRIPTION:  Monitor for signs that Vssadmin or Wmic has been used to create a shadow  copy.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where (Processes.process_name=vssadmin.exe  Processes.process=*create* Processes.process=*shadow*) OR (Processes.process_name=wmic.exe  Processes.process=*shadowcopy* Processes.process=*create*) by Processes.dest Processes.user  Processes.process_name Processes.process  Processes.parent_process_name Processes.parent_process Processes.process_id  Processes.parent_process_id | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)`|  `security_content_ctime(lastTime)` | `creation_of_shadow_copy_filter`'



<li><a href="#">NAME: Creation of Shadow Copy with wmic and powershell

DESCRIPTION:  |-  The following analytic detects the use of two specific tools, wmic and Powershell, to create a shadow copy to identify potential threats earlier and take appropriate actions to mitigate the risks. This detection is made by a Splunk query that searches for processes in the Endpoint.Processes data model where either the process name contains "wmic" or "Powershell" and the process command contains "shadowcopy" and "create". This detection is important because it suggests that an attacker is attempting to manipulate or access data in an unauthorized manner, which can lead to data theft, data manipulation, or other malicious activities. Attackers might use shadow copies to backup and exfiltrate sensitive data or to hide their tracks by restoring files to a previous state after an attack. Next steps include reviewing the user associated with the process, the process name, the original file name, the process command, and the destination of the process. Additionally, examine any relevant on-disk artifacts and review other concurrent processes to determine the source of the attack.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where `process_wmic` OR `process_powershell`  Processes.process=*shadowcopy* Processes.process=*create* by Processes.user Processes.process_name  Processes.original_file_name Processes.parent_process_name Processes.process Processes.dest  | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)`| `security_content_ctime(lastTime)`  | `creation_of_shadow_copy_with_wmic_and_powershell_filter`'



<li><a href="#">NAME: Credential Dumping via Copy Command from Shadow Copy

DESCRIPTION:  "The following analytic detects the use of the copy command to dump credentials from a shadow copy so that you can detect potential threats earlier and mitigate the risks associated with credential dumping. The detection is made by using a Splunk query to search for specific processes that indicate credential dumping activity. The query looks for processes with command lines that include references to certain files, such as \"sam\", \"security\", \"system\", and \"ntds.dit\", located in system directories like \"system32\" or \"windows\". The detection is important because it suggests that an attacker is attempting to extract credentials from a shadow copy. Credential dumping is a common technique used by attackers to obtain sensitive login information and gain unauthorized access to systems to escalate privileges, move laterally within the network, or gain unauthorized access to sensitive data. False positives might occur since legitimate processes might also reference these files. During triage, it is crucial to review the process details, including the source and the command that is run. Additionally, you must capture and analyze any relevant on-disk artifacts and investigate concurrent processes to determine the source of the attack"

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where `process_cmd` (Processes.process=*\\system32\\config\\sam*  OR Processes.process=*\\system32\\config\\security* OR Processes.process=*\\system32\\config\\system*  OR Processes.process=*\\windows\\ntds\\ntds.dit*) by Processes.dest Processes.user  Processes.process_name Processes.process  Processes.parent_process Processes.original_file_name  Processes.process_id Processes.parent_process_id  Processes.parent_process_name  | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)`| `security_content_ctime(lastTime)`  | `credential_dumping_via_copy_command_from_shadow_copy_filter` '



<li><a href="#">NAME: Credential Dumping via Symlink to Shadow Copy

DESCRIPTION:  |-  The following analytic detects the creation of a symlink to a shadow copy to identify potential threats earlier and mitigate the risks associated with symlink creation to shadow copies.  The detection is made by using a Splunk query that searches for processes with commands containing "mklink" and "HarddiskVolumeShadowCopy". This analytic retrieves information such as the destination, user, process name, process ID, parent process, original file name, and parent process ID from the Endpoint.Processes data model.  The detection is important because it indicates potential malicious activity since attackers might use this technique to manipulate or delete shadow copies, which are used for system backup and recovery. This detection helps to determine if an attacker is attempting to cover their tracks or prevent data recovery in the event of an incident. The impact of such an attack can be significant since it can hinder incident response efforts, prevent data restoration, and potentially lead to data loss or compromise. Next steps include reviewing the details of the process, such as the destination and the user responsible for creating the symlink. Additionally, you must examine the parent process, any relevant on-disk artifacts, and concurrent processes to identify the source of the attack.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where `process_cmd` Processes.process=*mklink*  Processes.process=*HarddiskVolumeShadowCopy* by Processes.dest Processes.user Processes.process_name  Processes.process  Processes.parent_process Processes.parent_process_name Processes.original_file_name  Processes.process_id Processes.parent_process_id | `drop_dm_object_name(Processes)`  | `security_content_ctime(firstTime)`| `security_content_ctime(lastTime)` | `credential_dumping_via_symlink_to_shadow_copy_filter`'



<li><a href="#">NAME: CSC Net On The Fly Compilation

DESCRIPTION:  this analytic is to detect a suspicious compile before delivery approach  of .net compiler csc.exe. This technique was seen in several adversaries, malware  and even in red teams to take advantage the csc.exe .net compiler tool to compile  on the fly a malicious .net code to evade detection from security product. This  is a good hunting query to check further the file or process created after this  event and check the file path that passed to csc.exe which is the .net code. Aside  from that, powershell is capable of using this compiler in executing .net code in  a powershell script so filter on that case is needed.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where `process_csc` Processes.process  = "*/noconfig*" Processes.process = "*/fullpaths*" Processes.process = "*@*" by  Processes.dest Processes.user Processes.parent_process_name Processes.parent_process  Processes.process_name Processes.process Processes.process_id Processes.parent_process_id  | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `csc_net_on_the_fly_compilation_filter`'



<li><a href="#">NAME: Curl Download and Bash Execution

DESCRIPTION:  The following analytic identifies the use of curl on Linux or MacOS attempting  to download a file from a remote source and pipe it to bash. This is typically found  with coinminers and most recently with CVE-2021-44228, a vulnerability in Log4j.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.process_name=curl  (Processes.process="*-s *") OR (Processes.process="*|*" AND Processes.process="*bash*")  by Processes.dest Processes.user Processes.parent_process_name Processes.process_name  Processes.process Processes.process_id Processes.parent_process_id | `drop_dm_object_name(Processes)`  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `curl_download_and_bash_execution_filter`'



<li><a href="#">NAME: Delete ShadowCopy With PowerShell

DESCRIPTION:  This following analytic detects PowerShell command to delete shadow copy  using the WMIC PowerShell module. This technique was seen used by a recent adversary  to deploy DarkSide Ransomware where it executed a child process of PowerShell to  execute a hex encoded command to delete shadow copy. This hex encoded command was  able to be decrypted by PowerShell log.

SEARCH:  '`powershell` EventCode=4104 ScriptBlockText= "*ShadowCopy*" (ScriptBlockText  = "*Delete*" OR ScriptBlockText = "*Remove*") | stats count min(_time) as firstTime  max(_time) as lastTime by Opcode Computer UserID EventCode ScriptBlockText | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `delete_shadowcopy_with_powershell_filter`'



<li><a href="#">NAME: Deleting Of Net Users

DESCRIPTION:  This analytic will detect a suspicious net.exe/net1.exe command-line  to delete a user on a system. This technique may be use by an administrator for  legitimate purposes, however this behavior has been used in the wild to impair some  user or deleting adversaries tracks created during its lateral movement additional  systems. During triage, review parallel processes for additional behavior. Identify  any other user accounts created before or after.

SEARCH:  '| tstats `security_content_summariesonly` values(Processes.process) as process  values(Processes.parent_process) as parent_process values(Processes.process_id)  as process_id count min(_time) as firstTime max(_time) as lastTime from datamodel=Endpoint.Processes  where `process_net` AND Processes.process="*user*" AND  Processes.process="*/delete*"  by  Processes.process_name Processes.original_file_name Processes.dest Processes.user  Processes.parent_process_name | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `deleting_of_net_users_filter`'



<li><a href="#">NAME: Deleting Shadow Copies

DESCRIPTION:  The vssadmin.exe utility is used to interact with the Volume Shadow Copy  Service.  Wmic is an interface to the Windows Management Instrumentation.  This  search looks for either of these tools being used to delete shadow copies.

SEARCH:  '| tstats `security_content_summariesonly` count values(Processes.process)  as process values(Processes.parent_process) as parent_process min(_time) as firstTime  max(_time) as lastTime from datamodel=Endpoint.Processes where (Processes.process_name=vssadmin.exe  OR Processes.process_name=wmic.exe) Processes.process=*delete* Processes.process=*shadow*  by Processes.user Processes.process_name Processes.parent_process_name Processes.dest  |  `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)`| `security_content_ctime(lastTime)`  | `deleting_shadow_copies_filter`'



<li><a href="#">NAME: Detection of tools built by NirSoft

DESCRIPTION:  This search looks for specific command-line arguments that may indicate  the execution of tools made by Nirsoft, which are legitimate, but may be abused  by attackers.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) values(Processes.process)  as process max(_time) as lastTime from datamodel=Endpoint.Processes where (Processes.process="*  /stext *" OR Processes.process="* /scomma *" ) by Processes.parent_process Processes.process_name  Processes.user | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)`  |`security_content_ctime(lastTime)` | `detection_of_tools_built_by_nirsoft_filter`'



<li><a href="#">NAME: Detect ARP Poisoning

DESCRIPTION:  By enabling Dynamic ARP Inspection as a Layer 2 Security measure on the  organization's network devices, we will be able to detect ARP Poisoning attacks  in the Infrastructure.

SEARCH:  '`cisco_networks` facility="PM" mnemonic="ERR_DISABLE" disable_cause="arp-inspection"  | eval src_interface=src_int_prefix_long+src_int_suffix | stats min(_time) AS firstTime  max(_time) AS lastTime count BY host src_interface | `security_content_ctime(firstTime)`|`security_content_ctime(lastTime)`|  `detect_arp_poisoning_filter`'



<li><a href="#">NAME: Detect AzureHound Command-Line Arguments

DESCRIPTION:  The following analytic identifies the common command-line argument used  by AzureHound `Invoke-AzureHound`. Being the script is FOSS, function names may  be modified, but these changes are dependent upon the operator. In most instances  the defaults are used. This analytic works to identify the common command-line attributes  used. It does not cover the entirety of every argument in order to avoid false positives.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.process IN ("*invoke-azurehound*")  by Processes.dest Processes.user Processes.parent_process Processes.process_name Processes.parent_process_name  Processes.process Processes.process_id Processes.parent_process_id | `drop_dm_object_name(Processes)`  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `detect_azurehound_command_line_arguments_filter`'



<li><a href="#">NAME: Detect AzureHound File Modifications

DESCRIPTION:  The following analytic is similar to SharpHound file modifications, but  this instance covers the use of Invoke-AzureHound. AzureHound is the SharpHound  equivilent but for Azure. It's possible this may never be seen in an environment  as most attackers may execute this tool remotely. Once execution is complete, a  zip file with a similar name will drop `20210601090751-azurecollection.zip`. In  addition to the zip, multiple .json files will be written to disk, which are in  the zip.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Filesystem where Filesystem.file_name IN ("*-azurecollection.zip",  "*-azprivroleadminrights.json", "*-azglobaladminrights.json", "*-azcloudappadmins.json",  "*-azapplicationadmins.json") by Filesystem.file_create_time Filesystem.process_id  Filesystem.file_name  Filesystem.file_path Filesystem.dest Filesystem.user | `drop_dm_object_name(Filesystem)` | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `detect_azurehound_file_modifications_filter`'



<li><a href="#">NAME: Detect Baron Samedit CVE-2021-3156

DESCRIPTION:  |-  The following analytic detects a specific type of vulnerability known as a heap-based buffer overflow in the sudoedit command, commonly referred to as Baron Samedit CVE-2021-3156. The detection is made by a Splunk query that searches for instances of the sudoedit command with the "-s" flag followed by a double quote. This combination of parameters is indicative of the vulnerability being exploited. The detection is important because it suggests that an attacker is attempting to exploit the Baron Samedit vulnerability. The Baron Samedit vulnerability allows an attacker to gain elevated privileges on a Linux system and run arbitrary code with root privileges, potentially leading to complete control over the affected system. The impact of a successful attack can be severe since it allows the attacker to bypass security measures and gain unauthorized access to sensitive data or systems. This can result in data breaches, unauthorized modifications, or even complete system compromise. Next steps include being aware of this vulnerability and actively monitoring any attempts to exploit it. By detecting and responding to such attacks in a timely manner, you can prevent or minimize the potential damage caused by the heap-based buffer overflow of sudoedit.

SEARCH:  '`linux_hosts` "sudoedit -s \\" | `detect_baron_samedit_cve_2021_3156_filter`'



<li><a href="#">NAME: Detect Baron Samedit CVE-2021-3156 Segfault

DESCRIPTION:  |-  The following analytic detects the occurrence of a heap-based buffer overflow in sudoedit.The detection is made by using a Splunk query to identify Linux hosts where the terms "sudoedit" and "segfault" appear in the logs. The detection is important because the heap-based buffer overflow vulnerability in sudoedit can be exploited by attackers to gain elevated root privileges on a vulnerable system, which might lead to the compromise of sensitive data, unauthorized access, and other malicious activities. False positives might occur. Therefore, you must review the logs and investigate further before taking any action.

SEARCH:  '`linux_hosts` TERM(sudoedit) TERM(segfault) | stats count min(_time) as firstTime  max(_time) as lastTime by host | where count > 5 | `detect_baron_samedit_cve_2021_3156_segfault_filter`'



<li><a href="#">NAME: Detect Baron Samedit CVE-2021-3156 via OSQuery

DESCRIPTION:  "The following analytic detects the heap-based buffer overflow for the sudoedit command and identifies instances where the command \"sudoedit -s *\" is run using the osquery_process data source. This indicates that the sudoedit command is used with the \"-s\" flag, which is associated with the heap-based buffer overflow vulnerability. The detection is important because it indicates a potential security vulnerability, specifically Baron Samedit CVE-2021-3156, which helps to identify and respond to potential heap-based buffer overflow attacks to enhance the security posture of the organization. This vulnerability allows an attacker to escalate privileges and potentially gain unauthorized access to the system. If the attack is successful, the attacker can gain full control of the system, run arbitrary code, or access sensitive data. Such attacks can lead to data breaches, unauthorized access, and potential disruption of critical systems. False positives might occur since the legitimate use of the sudoedit command with the \"-s\" flag can also trigger this detection. You must carefully review and validate the findings before taking any action. Next steps include investigating all true positive detections promptly, reviewing the associated processes, gather relevant artifacts, identifying the source of the attack to contain the threat, mitigate the risks, and prevent further damage to the environment."

SEARCH:  '`osquery_process` | search "columns.cmdline"="sudoedit -s \\*" | `detect_baron_samedit_cve_2021_3156_via_osquery_filter`'



<li><a href="#">NAME: Detect Certify Command Line Arguments

DESCRIPTION:  The following analytic identifies when the attacker tool Certify or Certipy  are used to enumerate Active Directory Certificate Services (AD CS) environments.  The default command line arguments of these tools are similar and perform near identical  enumeration or exploitation functions.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.process IN ("* find  *","* auth *","* request *","* req *","* download *",) AND Processes.process IN  ("* /vulnerable*","* /enrolleeSuppliesSubject *","* /json /outfile*","* /ca*", "*  -username *","* -u *") by Processes.dest Processes.user Processes.parent_process  Processes.process_name Processes.process Processes.process_id Processes.parent_process_id  | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`|  `detect_certify_command_line_arguments_filter`'



<li><a href="#">NAME: Detect Certify With PowerShell Script Block Logging

DESCRIPTION:  The following analytic identifies when the attacker tool  Certify is used through an in-memory PowerShell function to enumerate Active Directory Certificate Services (AD CS) environments. The default command line arguments for the binary version of this tools are similar to PowerShell calls and perform near identical enumeration or exploitation functions.

SEARCH:  '`powershell` EventCode=4104 (ScriptBlockText IN ("*find *") AND ScriptBlockText IN ("* /vulnerable*","* -vulnerable*","* /enrolleeSuppliesSubject *","* /json /outfile*")) OR (ScriptBlockText IN (,"*auth *","*req *",) AND ScriptBlockText IN ("* -ca *","* -username *","* -u *")) OR (ScriptBlockText IN ("*request *","*download *") AND ScriptBlockText IN ("* /ca:*"))| stats count min(_time) as firstTime max(_time) as lastTime list(ScriptBlockText) as command Values(OpCode) as reason values(Path) as file_name values(UserID) as user by _time Computer EventCode | `security_content_ctime(firstTime)`| `security_content_ctime(lastTime)`| eval file_name = case(isnotnull(file_name),file_name,true(),"unknown")| eval signature = substr(command,0,256)| rename Computer as dest,EventCode as signature_id| `detect_certify_with_powershell_script_block_logging_filter`'



<li><a href="#">NAME: Detect Certipy File Modifications

DESCRIPTION:  The following analytic identifies when the attacker tool Certipy is used to enumerate Active Directory Certificate Services (AD CS) environments. The default behavior of this toolkit drops a number of file uniquely named files or file extensions related to it's information gathering and exfiltration process.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) AS firstTime max(_time) AS lastTime values(Processes.process_current_directory) as process_current_directory FROM datamodel=Endpoint.Processes where Processes.action="allowed" BY _time span=1h Processes.user Processes.dest Processes.process_id Processes.process_name Processes.process Processes.process_path Processes.parent_process_name Processes.parent_process Processes.process_guid Processes.action|`drop_dm_object_name(Processes)` | join max=0 dest process_guid [| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time) as lastTime from datamodel=Endpoint.Filesystem where Filesystem.file_name IN ("*_certipy.zip", "*_certipy.txt", "*_certipy.json", "*.ccache") by Filesystem.file_create_time Filesystem.process_id Filesystem.process_guid Filesystem.file_name Filesystem.file_path Filesystem.dest| `drop_dm_object_name(Filesystem)` ]| fields firstTime lastTime user dest file_create_time file_name file_path parent_process_name parent_process process_name process_path process_current_directory process process_guid process_id| where isnotnull(file_name)| `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`| `detect_certipy_file_modifications_filter`'



<li><a href="#">NAME: Detect Computer Changed with Anonymous Account

DESCRIPTION:  This search looks for Event Code 4742 (Computer Change) or EventCode  4624 (An account was successfully logged on) with an anonymous account.

SEARCH:  '`wineventlog_security` EventCode=4624 OR EventCode=4742 TargetUserName="ANONYMOUS  LOGON" LogonType=3 | stats count values(host) as host, values(TargetDomainName)  as Domain, values(user) as user | `detect_computer_changed_with_anonymous_account_filter`'



<li><a href="#">NAME: Detect Copy of ShadowCopy with Script Block Logging

DESCRIPTION:  'The following analytic utilizes PowerShell Script Block Logging (EventCode=4104)  to identify suspicious PowerShell execution. Script Block Logging captures the command  sent to PowerShell, the full command to be executed. Upon enabling, logs will output  to Windows event logs. Dependent upon volume, enable on critical endpoints or all.  \  This analytic identifies `copy` or `[System.IO.File]::Copy` being used to capture  the SAM, SYSTEM or SECURITY hives identified in script block. This will catch the  most basic use cases for credentials being taken for offline cracking. \  During triage, review parallel processes using an EDR product or 4688 events. It  will be important to understand the timeline of events around this activity. Review  the entire logged PowerShell script block.'

SEARCH:  '`powershell` EventCode=4104 Message IN ("*copy*","*[System.IO.File]::Copy*")  AND Message IN ("*System32\\config\\SAM*", "*System32\\config\\SYSTEM*","*System32\\config\\SECURITY*")  | stats count min(_time) as firstTime max(_time) as lastTime by OpCode ComputerName  User EventCode Message | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `detect_copy_of_shadowcopy_with_script_block_logging_filter`'



<li><a href="#">NAME: Detect Credential Dumping through LSASS access

DESCRIPTION:  The following analytic detects the reading of lsass memory, which is  consistent with credential dumping. Reading lsass memory is a common technique used  by attackers to steal credentials from the Windows operating system. The detection  is made by monitoring the sysmon events and filtering for specific access permissions  (0x1010 and 0x1410) on the lsass.exe process helps identify potential instances  of credential dumping.The detection is important because it suggests that an attacker  is attempting to extract credentials from the lsass memory, which can lead to unauthorized  access, data breaches, and compromise of sensitive information. Credential dumping  is often a precursor to further attacks, such as lateral movement, privilege escalation,  or data exfiltration. False positives can occur due to legitimate actions that involve  accessing lsass memory. Therefore, extensive triage and investigation are necessary  to differentiate between malicious and benign activities.

SEARCH:  '`sysmon` EventCode=10 TargetImage=*lsass.exe (GrantedAccess=0x1010 OR GrantedAccess=0x1410)  | stats count min(_time) as firstTime max(_time) as lastTime by dest, SourceImage,  SourceProcessId, TargetImage, TargetProcessId, EventCode, GrantedAccess | `security_content_ctime(firstTime)`|  `security_content_ctime(lastTime)` | `detect_credential_dumping_through_lsass_access_filter` '



<li><a href="#">NAME: Detect DGA domains using pretrained model in DSDL

DESCRIPTION:  The following analytic uses a pre trained deep learning model to detect  Domain Generation Algorithm (DGA) generated domains. The model is trained independently  and is then made available for download. One of the prominent indicators of a domain  being DGA generated is if the domain name consists of unusual character sequences  or concatenated dictionary words. Adversaries often use clever techniques to obfuscate  machine generated domain names as human generated. Predicting DGA generated domain  names requires analysis and building a model based on carefully chosen features.  The deep learning model we have developed uses the domain name to analyze patterns  of character sequences along with carefully chosen custom features to predict if  a domain is DGA generated. The model takes a domain name consisting of second-level  and top-level domain names as input and outputs a dga_score. Higher the dga_score,  the more likely the input domain is a DGA domain. The threshold for flagging a domain  as DGA is set at 0.5.

SEARCH:  '| tstats `security_content_summariesonly` values(DNS.answer) as IPs min(_time)  as firstTime  max(_time) as lastTime from datamodel=Network_Resolution by DNS.src,  DNS.query | `drop_dm_object_name(DNS)` | rename query AS domain | fields IPs, src,  domain, firstTime, lastTime | apply pretrained_dga_model_dsdl | rename pred_dga_proba  AS dga_score | where dga_score>0.5 | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)`  | table src, domain, IPs, firstTime, lastTime, dga_score | `detect_dga_domains_using_pretrained_model_in_dsdl_filter`'



<li><a href="#">NAME: Detect DNS Data Exfiltration using pretrained model in DSDL

DESCRIPTION:  The following analytic uses a pre trained deep learning model to  detect DNS data exfiltration. The model is trained on the data we collected  and is inferred on live data. This detection detects low throughput DNS  Tunneling (data exfiltration) using features computed from past events between  the same src and domain. The search uses macros from URL ToolBox app to  generate features used by the model. The model is a deep learning model that  accepts DNS request as input along with a few custom features to generate a  pred_is_exfiltration_proba score. The higher the pred_is_exfiltration_proba,  the more likely the DNS request is data exfiltration. The threshold for  flagging a request as DNS exfiltration is set at 0.5.

SEARCH:  '| tstats `security_content_summariesonly` count from  datamodel=Network_Resolution by DNS.src _time DNS.query |  `drop_dm_object_name("DNS")` | sort - _time,src, query | streamstats count as  rank by src query | where rank < 10 | table src,query,rank,_time | apply  detect_dns_data_exfiltration_using_pretrained_model_in_dsdl | table  src,_time,query,rank,pred_is_dns_data_exfiltration_proba,pred_is_dns_data_exfiltration  | where rank == 1 | rename pred_is_dns_data_exfiltration_proba as  is_exfiltration_score | rename pred_is_dns_data_exfiltration as  is_exfiltration | where is_exfiltration_score > 0.5 |  `security_content_ctime(_time)` |  table src, _time,query,is_exfiltration_score,is_exfiltration |  `detect_dns_data_exfiltration_using_pretrained_model_in_dsdl_filter`'



<li><a href="#">NAME: Detect Empire with PowerShell Script Block Logging

DESCRIPTION:  'The following analytic utilizes PowerShell Script Block Logging (EventCode=4104)  to identify suspicious PowerShell execution. Script Block Logging captures the command  sent to PowerShell, the full command to be executed. Upon enabling, logs will output  to Windows event logs. Dependent upon volume, enable on critical endpoints or all.  \  This analytic identifies the common PowerShell stager used by PowerShell-Empire.  Each stager that may use PowerShell all uses the same pattern. The initial HTTP  will be base64 encoded and use `system.net.webclient`. Note that some obfuscation  may evade the analytic. \  During triage, review parallel processes using an EDR product or 4688 events. It  will be important to understand the timeline of events around this activity. Review  the entire logged PowerShell script block.'

SEARCH:  '`powershell` EventCode=4104  (ScriptBlockText=*system.net.webclient* AND  ScriptBlockText=*frombase64string*) | stats count min(_time) as firstTime max(_time)  as lastTime by Opcode Computer UserID EventCode ScriptBlockText | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `detect_empire_with_powershell_script_block_logging_filter`'



<li><a href="#">NAME: Detect Excessive Account Lockouts From Endpoint

DESCRIPTION:  This search identifies endpoints that have caused a relatively high number  of account lockouts in a short period.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime values(All_Changes.user) as user from datamodel=Change.All_Changes where  All_Changes.result="*lock*" by All_Changes.dest All_Changes.result |`drop_dm_object_name("All_Changes")`  |`drop_dm_object_name("Account_Management")`| `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | search count > 5 | `detect_excessive_account_lockouts_from_endpoint_filter`'



<li><a href="#">NAME: Detect Excessive User Account Lockouts

DESCRIPTION:  This search detects user accounts that have been locked out a relatively  high number of times in a short period.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Change.All_Changes where  All_Changes.result="*locked  out*" by All_Changes.user All_Changes.result |`drop_dm_object_name("All_Changes")`  |`drop_dm_object_name("Account_Management")`| `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | search count > 5 | `detect_excessive_user_account_lockouts_filter`'



<li><a href="#">NAME: Detect Exchange Web Shell

DESCRIPTION:  'The following query identifies suspicious .aspx created in 3 paths identified  by Microsoft as known drop locations for Exchange exploitation related to HAFNIUM  group and recently disclosed vulnerablity named ProxyShell and ProxyNotShell. Paths  include: `\HttpProxy\owa\auth\`, `\inetpub\wwwroot\aspnet_client\`, and `\HttpProxy\OAB\`.  Upon triage, the suspicious .aspx file will likely look obvious on the surface.  inspect the contents for script code inside. Identify additional log sources, IIS  included, to review source and other potential exploitation. It is often the case  that a particular threat is only applicable to a specific subset of systems in your  environment. Typically analytics to detect those threats are written without the  benefit of being able to only target those systems as well. Writing analytics against  all systems when those behaviors are limited to identifiable subsets of those systems  is suboptimal. Consider the case ProxyShell vulnerability on Microsoft Exchange  Servers. With asset information, a hunter can limit their analytics to systems that  have been identified as Exchange servers. A hunter may start with the theory that  the exchange server is communicating with new systems that it has not previously.  If this theory is run against all publicly facing systems, the amount of noise it  will generate will likely render this theory untenable. However, using the asset  information to limit this analytic to just the Exchange servers will reduce the  noise allowing the hunter to focus only on the systems where this behavioral change  is relevant.'

SEARCH:  '| tstats `security_content_summariesonly` count FROM datamodel=Endpoint.Processes  where Processes.process_name=System  by _time span=1h Processes.process_id Processes.process_name  Processes.dest Processes.user | `drop_dm_object_name(Processes)` | join process_guid, _time [|  tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime FROM datamodel=Endpoint.Filesystem where Filesystem.file_path IN ("*\\HttpProxy\\owa\\auth\\*",  "*\\inetpub\\wwwroot\\aspnet_client\\*", "*\\HttpProxy\\OAB\\*") Filesystem.file_name  IN( "*.aspx", "*.ashx") by _time span=1h Filesystem.user Filesystem.dest Filesystem.file_create_time  Filesystem.file_name Filesystem.file_path | `drop_dm_object_name(Filesystem)` |  fields _time dest user file_create_time file_name file_path process_name process_path  process] | dedup file_create_time | table dest user file_create_time, file_name, file_path,  process_name | `detect_exchange_web_shell_filter`'



<li><a href="#">NAME: Detect hosts connecting to dynamic domain providers

DESCRIPTION:  Malicious actors often abuse legitimate Dynamic DNS services to host  malicious payloads or interactive Command And Control nodes. Attackers will automate  domain resolution changes by routing dynamic domains to countless IP addresses to  circumvent firewall blocks, block lists as well as frustrate a network defenders  analytic and investigative processes. This search will look for DNS queries made  from within your infrastructure to suspicious dynamic domains.

SEARCH:  '| tstats `security_content_summariesonly` count values(DNS.answer) as answer  min(_time) as firstTime from datamodel=Network_Resolution by DNS.query host | `drop_dm_object_name("DNS")`  | `security_content_ctime(firstTime)` | `dynamic_dns_providers` | `detect_hosts_connecting_to_dynamic_domain_providers_filter`'



<li><a href="#">NAME: Detect HTML Help Renamed

DESCRIPTION:  The following analytic identifies a renamed instance of hh.exe (HTML  Help) executing a Compiled HTML Help (CHM). This particular technique will load  Windows script code from a compiled help file. CHM files may contain nearly any  file type embedded, but only execute html/htm. Upon a successful execution, the  following script engines may be used for execution - JScript, VBScript, VBScript.Encode,  JScript.Encode, JScript.Compact. Analyst may identify vbscript.dll or jscript.dll  loading into hh.exe upon execution. The "htm" and "html" file extensions were the  only extensions observed to be supported for the execution of Shortcut commands  or WSH script code. During investigation, identify script content origination. Validate  it is the legitimate version of hh.exe by reviewing the PE metadata. hh.exe is natively  found in C:\Windows\system32 and C:\Windows\syswow64.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.process_name!=hh.exe  AND Processes.original_file_name=HH.EXE by Processes.dest Processes.user Processes.parent_process_name  Processes.original_file_name Processes.process_name Processes.process Processes.process_id  Processes.parent_process_id | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `detect_html_help_renamed_filter`'



<li><a href="#">NAME: Detect HTML Help Spawn Child Process

DESCRIPTION:  The following analytic identifies hh.exe (HTML Help) execution of a Compiled  HTML Help (CHM) that spawns a child process. This particular technique will load  Windows script code from a compiled help file. CHM files may contain nearly any  file type embedded, but only execute html/htm. Upon a successful execution, the  following script engines may be used for execution - JScript, VBScript, VBScript.Encode,  JScript.Encode, JScript.Compact. Analyst may identify vbscript.dll or jscript.dll  loading into hh.exe upon execution. The "htm" and "html" file extensions were the  only extensions observed to be supported for the execution of Shortcut commands  or WSH script code. During investigation, identify script content origination. Review  child process events and investigate further. hh.exe is natively found in C:\Windows\system32  and C:\Windows\syswow64.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.parent_process_name=hh.exe  by Processes.dest Processes.user Processes.parent_process_name Processes.parent_process Processes.process_name   Processes.process Processes.process_id Processes.parent_process_id | `drop_dm_object_name(Processes)`  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `detect_html_help_spawn_child_process_filter`'



<li><a href="#">NAME: Detect HTML Help URL in Command Line

DESCRIPTION:  The following analytic identifies hh.exe (HTML Help) execution of a Compiled  HTML Help (CHM) file from a remote url. This particular technique will load Windows  script code from a compiled help file. CHM files may  contain nearly any file type  embedded, but only execute html/htm. Upon a successful execution, the following  script engines may be used for execution - JScript, VBScript, VBScript.Encode, JScript.Encode,  JScript.Compact. Analyst may identify vbscript.dll or jscript.dll loading into hh.exe  upon execution. The "htm" and "html" file extensions were the only extensions observed  to be supported for the execution of Shortcut commands or WSH script code. During  investigation, identify script content origination. Review reputation of remote  IP and domain. Some instances, it is worth decompiling the .chm file to review its  original contents. hh.exe is natively found in C:\Windows\system32 and C:\Windows\syswow64.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where `process_hh` Processes.process=*http*  by Processes.dest Processes.user  Processes.parent_process_name Processes.parent_process Processes.original_file_name  Processes.process_name Processes.process Processes.process_id Processes.parent_process_id  | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `detect_html_help_url_in_command_line_filter`'



<li><a href="#">NAME: Detect HTML Help Using InfoTech Storage Handlers

DESCRIPTION:  The following analytic identifies hh.exe (HTML Help) execution of a Compiled  HTML Help (CHM) file using InfoTech Storage Handlers. This particular technique  will load Windows script code from a compiled help file, using InfoTech Storage  Handlers. itss.dll will load upon execution. Three InfoTech Storage handlers are  supported - ms-its, its, mk:@MSITStore. ITSS may be used to launch a specific html/htm  file from within a CHM file. CHM files may contain nearly any file type embedded.  Upon a successful execution, the following script engines may be used for execution  - JScript, VBScript, VBScript.Encode, JScript.Encode, JScript.Compact. Analyst may  identify vbscript.dll or jscript.dll loading into hh.exe upon execution. The "htm"  and "html" file extensions were the only extensions observed to be supported for  the execution of Shortcut commands or WSH script code. During investigation, identify  script content origination. hh.exe is natively found in C:\Windows\system32 and  C:\Windows\syswow64.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where `process_hh` Processes.process  IN ("*its:*", "*mk:@MSITStore:*") by Processes.dest Processes.user Processes.parent_process  Processes.process_name Processes.process Processes.process_id Processes.parent_process_id  | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `detect_html_help_using_infotech_storage_handlers_filter`'



<li><a href="#">NAME: Detect IPv6 Network Infrastructure Threats

DESCRIPTION:  By enabling IPv6 First Hop Security as a Layer 2 Security measure on  the organization's network devices, we will be able to detect various attacks such  as packet forging in the Infrastructure.

SEARCH:  '`cisco_networks` facility="SISF" mnemonic IN ("IP_THEFT","MAC_THEFT","MAC_AND_IP_THEFT","PAK_DROP")  | eval src_interface=src_int_prefix_long+src_int_suffix | eval dest_interface=dest_int_prefix_long+dest_int_suffix  | stats min(_time) AS firstTime max(_time) AS lastTime values(src_mac) AS src_mac  values(src_vlan) AS src_vlan values(mnemonic) AS mnemonic values(vendor_explanation)  AS vendor_explanation values(src_ip) AS src_ip values(dest_ip) AS dest_ip values(dest_interface)  AS dest_interface values(action) AS action count BY host src_interface | table host  src_interface dest_interface src_mac src_ip dest_ip src_vlan mnemonic vendor_explanation  action count | `security_content_ctime(firstTime)` |`security_content_ctime(lastTime)`  | `detect_ipv6_network_infrastructure_threats_filter`'



<li><a href="#">NAME: Detect Large Outbound ICMP Packets

DESCRIPTION:  This search looks for outbound ICMP packets with a packet size larger  than 1,000 bytes. Various threat actors have been known to use ICMP as a command  and control channel for their attack infrastructure. Large ICMP packets from an  endpoint to a remote host may be indicative of this activity.

SEARCH:  '| tstats `security_content_summariesonly` count earliest(_time) as firstTime  latest(_time) as lastTime values(All_Traffic.action) values(All_Traffic.bytes) from  datamodel=Network_Traffic where All_Traffic.action !=blocked All_Traffic.dest_category  !=internal (All_Traffic.protocol=icmp OR All_Traffic.transport=icmp) All_Traffic.bytes  > 1000 by All_Traffic.src_ip All_Traffic.dest_ip | `drop_dm_object_name("All_Traffic")`  | search ( dest_ip!=10.0.0.0/8 AND dest_ip!=172.16.0.0/12 AND dest_ip!=192.168.0.0/16)  | `security_content_ctime(firstTime)`|`security_content_ctime(lastTime)` | `detect_large_outbound_icmp_packets_filter`'



<li><a href="#">NAME: Detect Mimikatz With PowerShell Script Block Logging

DESCRIPTION:  'The following analytic utilizes PowerShell Script Block Logging (EventCode=4104)  to identify suspicious PowerShell execution. Script Block Logging captures the command  sent to PowerShell, the full command to be executed. Upon enabling, logs will output  to Windows event logs. Dependent upon volume, enable no critical endpoints or all.  \  This analytic identifies common Mimikatz functions that may be identified in the  script block, including `mimikatz`. This will catch the most basic use cases for  Pass the Ticket, Pass the Hash and `-DumprCreds`. \  During triage, review parallel processes using an EDR product or 4688 events. It  will be important to understand the timeline of events around this activity. Review  the entire logged PowerShell script block.'

SEARCH:  '`powershell` EventCode=4104 ScriptBlockText IN (*mimikatz*, *-dumpcr*, *sekurlsa::pth*,  *kerberos::ptt*, *kerberos::golden*) | stats count min(_time) as firstTime max(_time)  as lastTime by Opcode Computer UserID EventCode ScriptBlockText | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `detect_mimikatz_with_powershell_script_block_logging_filter`'



<li><a href="#">NAME: Detect mshta inline hta execution

DESCRIPTION:  The following analytic identifies "mshta.exe" execution with inline protocol  handlers. "JavaScript", "VBScript", and "About" are the only supported options when  invoking HTA content directly on the command-line. The search will return the first  time and last time these command-line arguments were used for these executions,  as well as the target system, the user, process "mshta.exe" and its parent process.

SEARCH:  '| tstats `security_content_summariesonly` count values(Processes.process)  as process values(Processes.parent_process) as parent_process min(_time) as firstTime  max(_time) as lastTime from datamodel=Endpoint.Processes where `process_mshta` (Processes.process=*vbscript*  OR Processes.process=*javascript* OR Processes.process=*about*) by Processes.user  Processes.process_name Processes.original_file_name Processes.parent_process_name  Processes.dest  | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)`|  `security_content_ctime(lastTime)` | `detect_mshta_inline_hta_execution_filter`'



<li><a href="#">NAME: Detect mshta renamed

DESCRIPTION:  The following analytic identifies renamed instances of mshta.exe executing.  Mshta.exe is natively found in C:\Windows\system32 and C:\Windows\syswow64. This  analytic utilizes the internal name of the PE to identify if is the legitimate mshta  binary. Further analysis should be performed to review the executed content and  validation it is the real mshta.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.process_name!=mshta.exe  AND Processes.original_file_name=MSHTA.EXE by Processes.dest Processes.user Processes.parent_process_name  Processes.process_name Processes.process Processes.process_id Processes.parent_process_id  Processes.original_file_name | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `detect_mshta_renamed_filter`'



<li><a href="#">NAME: Detect MSHTA Url in Command Line

DESCRIPTION:  This analytic identifies when Microsoft HTML Application Host (mshta.exe)  utility is used to make remote http connections. Adversaries may use mshta.exe to  proxy the download and execution of remote .hta files. The analytic identifies command  line arguments of http and https being used. This technique is commonly used by  malicious software to bypass preventative controls. The search will return the first  time and last time these command-line arguments were used for these executions,  as well as the target system, the user, process "rundll32.exe" and its parent process.

SEARCH:  '| tstats `security_content_summariesonly` count values(Processes.process)  as process values(Processes.parent_process) as parent_process min(_time) as firstTime  max(_time) as lastTime from datamodel=Endpoint.Processes where `process_mshta` (Processes.process="*http://*"  OR Processes.process="*https://*") by Processes.user Processes.process_name Processes.parent_process_name  Processes.original_file_name Processes.dest  | `drop_dm_object_name(Processes)`  | `security_content_ctime(firstTime)`| `security_content_ctime(lastTime)` | `detect_mshta_url_in_command_line_filter`'



<li><a href="#">NAME: Detect New Local Admin account

DESCRIPTION:  |-  The following analytic detects the creation of new accounts that have been elevated to local administrators so that you can take immediate action to mitigate the risks and prevent further unauthorized access or malicious activities. This detection is made by using the Splunk query `wineventlog_security` EventCode=4720 OR (EventCode=4732 Group_Name=Administrators) to search for relevant security events in the Windows event log. When a new account is created or an existing account is added to the Administrators group, this analytic identifies this behavior by looking for EventCode 4720 (A user account was created) or EventCode 4732 (A member was added to a security-enabled global group). This analytic specifically focuses on events where the Group_Name is set to Administrators. This detection is important because it suggests that an attacker has gained elevated privileges and can perform malicious actions with administrative access. This can lead to significant impact, such as unauthorized access to sensitive data, unauthorized modifications to systems or configurations, and potential disruption of critical services. identifying this behavior is crucial for a Security Operations Center (SOC). Next steps include reviewing the details of the security event, including the user account that was created or added to the Administrators group. Also, examine the time span between the first and last occurrence of the event to determine if the behavior is ongoing. Additionally, consider any contextual information, such as the destination where the account was created or added to understand the scope and potential impact of the attack.

SEARCH:  '`wineventlog_security` EventCode=4720 OR (EventCode=4732 Group_Name=Administrators) | transaction src_user connected=false maxspan=180m | rename src_user as user | stats count min(_time) as firstTime max(_time) as lastTime by user dest | `security_content_ctime(firstTime)`| `security_content_ctime(lastTime)` | `detect_new_local_admin_account_filter`'



<li><a href="#">NAME: Detect Outbound LDAP Traffic

DESCRIPTION:  Malicious actors often abuse misconfigured LDAP servers or applications  that use the LDAP servers in organizations. Outbound LDAP traffic should not be  allowed outbound through your perimeter firewall.  This search will help determine  if you have any LDAP connections to IP addresses outside of private (RFC1918) address  space.

SEARCH:  '| tstats earliest(_time) as earliest_time latest(_time) as latest_time values(All_Traffic.dest_ip)  as dest_ip from datamodel=Network_Traffic.All_Traffic where All_Traffic.dest_port  = 389 OR All_Traffic.dest_port = 636 AND NOT (All_Traffic.dest_ip = 10.0.0.0/8 OR  All_Traffic.dest_ip=192.168.0.0/16 OR All_Traffic.dest_ip = 172.16.0.0/12) by All_Traffic.src_ip  All_Traffic.dest_ip |`drop_dm_object_name("All_Traffic")` | where src_ip != dest_ip  | `security_content_ctime(latest_time)`  | `security_content_ctime(earliest_time)`  |`detect_outbound_ldap_traffic_filter`'



<li><a href="#">NAME: Detect Outbound SMB Traffic

DESCRIPTION:  This search looks for outbound SMB connections made by hosts within your  network to the Internet. SMB traffic is used for Windows file-sharing activity.  One of the techniques often used by attackers involves retrieving the credential  hash using an SMB request made to a compromised server controlled by the threat  actor.

SEARCH:  '| tstats `security_content_summariesonly` earliest(_time) as start_time latest(_time)  as end_time values(All_Traffic.action) as action values(All_Traffic.app) as app  values(All_Traffic.dest_ip) as dest_ip values(All_Traffic.dest_port) as dest_port  values(sourcetype) as sourcetype count from datamodel=Network_Traffic where ((All_Traffic.dest_port=139  OR All_Traffic.dest_port=445 OR All_Traffic.app="smb") AND NOT (All_Traffic.action="blocked"  OR All_Traffic.dest_category="internal" OR All_Traffic.dest_ip=10.0.0.0/8 OR All_Traffic.dest_ip=172.16.0.0/12  OR All_Traffic.dest_ip=192.168.0.0/16 OR All_Traffic.dest_ip=100.64.0.0/10)) by  All_Traffic.src_ip | `drop_dm_object_name("All_Traffic")` | `security_content_ctime(start_time)`  | `security_content_ctime(end_time)` | `detect_outbound_smb_traffic_filter`'



<li><a href="#">NAME: Detect Outlook exe writing a zip file

DESCRIPTION:  This search looks for execution of process `outlook.exe` where the process  is writing a `.zip` file to the disk.

SEARCH:  '| tstats `security_content_summariesonly`  min(_time) as firstTime max(_time)  as lastTime FROM datamodel=Endpoint.Processes where Processes.process_name=outlook.exe  by _time span=5m Processes.parent_process_id Processes.process_id Processes.dest  Processes.process_name Processes.parent_process_name Processes.user | `drop_dm_object_name(Processes)`  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | rename  process_id as malicious_id| rename parent_process_id as outlook_id| join malicious_id  type=inner[| tstats `security_content_summariesonly` count values(Filesystem.file_path)  as file_path values(Filesystem.file_name) as file_name  FROM datamodel=Endpoint.Filesystem  where (Filesystem.file_path=*.zip*   OR Filesystem.file_name=*.lnk ) AND (Filesystem.file_path=C:\\Users*  OR Filesystem.file_path=*Local\\Temp*) by  _time span=5m Filesystem.process_id Filesystem.file_hash  Filesystem.dest  | `drop_dm_object_name(Filesystem)` | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | rename process_id as malicious_id| fields  malicious_id outlook_id dest file_path file_name file_hash count file_id] | table  firstTime lastTime user malicious_id outlook_id process_name parent_process_name  file_name  file_path | where file_name != "" | `detect_outlook_exe_writing_a_zip_file_filter` '



<li><a href="#">NAME: Detect Path Interception By Creation Of program exe

DESCRIPTION:  'The detection Detect Path Interception By Creation Of program exe is  detecting the abuse of unquoted service paths, which is a popular technique for  privilege escalation. '

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.parent_process_name=services.exe  by Processes.user Processes.process_name Processes.parent_process_name Processes.process Processes.dest | `drop_dm_object_name(Processes)`  | rex field=process "^.*?\\\\(?<service_process>[^\\\\]*\.(?:exe|bat|com|ps1))"  | eval process_name = lower(process_name) | eval service_process = lower(service_process)  | where process_name != service_process | `security_content_ctime(firstTime)` |  `security_content_ctime(lastTime)` | `detect_path_interception_by_creation_of_program_exe_filter`'



<li><a href="#">NAME: Detect Port Security Violation

DESCRIPTION:  By enabling Port Security on a Cisco switch you can restrict input to  an interface by limiting and identifying MAC addresses of the workstations that  are allowed to access the port. When you assign secure MAC addresses to a secure  port, the port does not forward packets with source addresses outside the group  of defined addresses. If you limit the number of secure MAC addresses to one and  assign a single secure MAC address, the workstation attached to that port is assured  the full bandwidth of the port. If a port is configured as a secure port and the  maximum number of secure MAC addresses is reached, when the MAC address of a workstation  attempting to access the port is different from any of the identified secure MAC  addresses, a security violation occurs.

SEARCH:  '`cisco_networks` (facility="PM" mnemonic="ERR_DISABLE" disable_cause="psecure-violation")  OR (facility="PORT_SECURITY" mnemonic="PSECURE_VIOLATION" OR mnemonic="PSECURE_VIOLATION_VLAN")  | eval src_interface=src_int_prefix_long+src_int_suffix | stats min(_time) AS firstTime  max(_time) AS lastTime values(disable_cause) AS disable_cause values(src_mac) AS  src_mac values(src_vlan) AS src_vlan values(action) AS action count by host src_interface  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `detect_port_security_violation_filter`'



<li><a href="#">NAME: Detect processes used for System Network Configuration Discovery

DESCRIPTION:  This search looks for fast execution of processes used for system network  configuration discovery on the endpoint.

SEARCH:  '| tstats `security_content_summariesonly` count values(Processes.process)  as process values(Processes.parent_process) as parent_process min(_time) as firstTime  max(_time) as lastTime from datamodel=Endpoint.Processes where NOT Processes.user  IN ("","unknown") by Processes.dest Processes.process_name Processes.parent_process_name Processes.user _time  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `drop_dm_object_name(Processes)`  | search `system_network_configuration_discovery_tools` | transaction dest connected=false  maxpause=5m |where eventcount>=5 | table firstTime lastTime dest user process_name  process parent_process parent_process_name eventcount | `detect_processes_used_for_system_network_configuration_discovery_filter`'



<li><a href="#">NAME: Detect Prohibited Applications Spawning cmd exe

DESCRIPTION:  This search looks for executions of cmd.exe spawned by a process that  is often abused by attackers and that does not typically launch cmd.exe.

SEARCH:  '| tstats `security_content_summariesonly` count values(Processes.process)  as process min(_time) as firstTime max(_time) as lastTime from datamodel=Endpoint.Processes  where `process_cmd` by Processes.parent_process_name Processes.process_name Processes.original_file_name  Processes.dest Processes.user| `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)`|  `security_content_ctime(lastTime)` |search [`prohibited_apps_launching_cmd`] | `detect_prohibited_applications_spawning_cmd_exe_filter`'



<li><a href="#">NAME: Detect PsExec With accepteula Flag

DESCRIPTION:  This search looks for events where `PsExec.exe` is run with the `accepteula`  flag in the command line. PsExec is a built-in Windows utility that enables you  to execute processes on other systems. It is fully interactive for console applications.  This tool is widely used for launching interactive command prompts on remote systems.  Threat actors leverage this extensively for executing code on compromised systems.  If an attacker is running PsExec for the first time, they will be prompted to accept  the end-user license agreement (EULA), which can be passed as the argument `accepteula`  within the command line.

SEARCH:  '| tstats `security_content_summariesonly` values(Processes.process) as process  min(_time) as firstTime max(_time) as lastTime from datamodel=Endpoint.Processes  where `process_psexec` Processes.process=*accepteula* by Processes.dest Processes.user  Processes.parent_process_name Processes.process_name Processes.process Processes.process_id  Processes.parent_process_id | `drop_dm_object_name(Processes)`| `security_content_ctime(firstTime)`|  `security_content_ctime(lastTime)` | `detect_psexec_with_accepteula_flag_filter`'



<li><a href="#">NAME: Detect Rare Executables

DESCRIPTION:  This search will return a table of processes in the a given window, remove  process names which are in the allowed list and list out the top 30 rare processes  discovered on different hosts.

SEARCH:  '| tstats `security_content_summariesonly` count values(Processes.dest) as  dest values(Processes.user) as user min(_time) as firstTime max(_time) as lastTime  from datamodel=Endpoint.Processes by Processes.process_name | rename Processes.process_name  as process | `filter_rare_process_allow_list` | sort count | head 30 | rex field=user  "(?<user_domain>.*)\\\\(?<user_name>.*)" | `security_content_ctime(firstTime)` |  `security_content_ctime(lastTime)` | `detect_rare_executables_filter` '



<li><a href="#">NAME: Detect RClone Command-Line Usage

DESCRIPTION:  This analytic identifies commonly used command-line arguments used by  `rclone.exe` to initiate a file transfer. Some arguments were negated as they are  specific to the configuration used by adversaries. In particular, an adversary may  list the files or directories of the remote file share using `ls` or `lsd`, which  is not indicative of malicious behavior. During triage, at this stage of a ransomware  event, exfiltration is about to occur or has already. Isolate the endpoint and continue  investigating by review file modifications and parallel processes.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where `process_rclone` Processes.process  IN ("*copy*", "*mega*", "*pcloud*", "*ftp*", "*--config*", "*--progress*", "*--no-check-certificate*",  "*--ignore-existing*", "*--auto-confirm*", "*--transfers*", "*--multi-thread-streams*")  by  Processes.dest Processes.user Processes.parent_process Processes.parent_process_name Processes.process_name Processes.process  Processes.process_id Processes.parent_process_id | `drop_dm_object_name(Processes)`  | `security_content_ctime(firstTime)` |  `security_content_ctime(lastTime)` | `detect_rclone_command_line_usage_filter`'



<li><a href="#">NAME: Detect Regasm Spawning a Process

DESCRIPTION:  The following analytic identifies regasm.exe spawning a process. This  particular technique has been used in the wild to bypass application control products.  Regasm.exe and Regsvcs.exe are signed by Microsoft. Spawning of a child process  is rare from either process and should be investigated further. During investigation,  identify and retrieve the content being loaded. Review parallel processes for additional  suspicious behavior. Gather any other file modifications and review accordingly.  regsvcs.exe and regasm.exe are natively found in C:\Windows\Microsoft.NET\Framework\v*\regasm|regsvcs.exe  and C:\Windows\Microsoft.NET\Framework64\v*\regasm|regsvcs.exe.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.parent_process_name=regasm.exe  by Processes.dest Processes.user Processes.parent_process Processes.parent_process_name Processes.process_name  Processes.process Processes.process_id Processes.parent_process_id | `drop_dm_object_name(Processes)`  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `detect_regasm_spawning_a_process_filter`'



<li><a href="#">NAME: Detect Regasm with Network Connection

DESCRIPTION:  The following analytic identifies regasm.exe with a network connection  to a public IP address, exluding private IP space. This particular technique has  been used in the wild to bypass application control products. Regasm.exe and Regsvcs.exe  are signed by Microsoft. By contacting a remote Command And Control server, the  adversary will have the ability to escalate privileges and complete the objectives.  During investigation, identify and retrieve the content being loaded. Review parallel  processes for additional suspicious behavior. Gather any other file modifications  and review accordingly. Review the reputation of the remote IP or domain and block  as needed. regsvcs.exe and regasm.exe are natively found in C:\Windows\Microsoft.NET\Framework\v*\regasm|regsvcs.exe  and C:\Windows\Microsoft.NET\Framework64\v*\regasm|regsvcs.exe.

SEARCH:  '`sysmon` EventID=3 dest_ip!=10.0.0.0/8 dest_ip!=172.16.0.0/12 dest_ip!=192.168.0.0/16  process_name=regasm.exe  | stats count min(_time) as firstTime  max(_time) as lastTime by dest, user, process_name, src_ip, dest_ip | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `detect_regasm_with_network_connection_filter`'



<li><a href="#">NAME: Detect Regasm with no Command Line Arguments

DESCRIPTION:  The following analytic identifies regasm.exe with no command line arguments.  This particular behavior occurs when another process injects into regasm.exe, no  command line arguments will be present. During investigation, identify any network  connections and parallel processes. Identify any suspicious module loads related  to credential dumping or file writes. Regasm.exe are natively found in `C:\Windows\Microsoft.NET\Framework\v*\regasm|regsvcs.exe`  and `C:\Windows\Microsoft.NET\Framework64\v*\regasm|regsvcs.exe`.

SEARCH:  '| tstats `security_content_summariesonly` count FROM datamodel=Endpoint.Processes where `process_regasm` by _time span=1h  Processes.process_id Processes.process_name Processes.dest Processes.user Processes.process_path Processes.process  Processes.parent_process_name | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | regex process="(?i)(regasm\.exe.{0,4}$)" | `detect_regasm_with_no_command_line_arguments_filter`'



<li><a href="#">NAME: Detect Regsvcs Spawning a Process

DESCRIPTION:  The following analytic identifies regsvcs.exe spawning a process. This  particular technique has been used in the wild to bypass application control products.  Regasm.exe and Regsvcs.exe are signed by Microsoft. Spawning of a child process  is rare from either process and should be investigated further. During investigation,  identify and retrieve the content being loaded. Review parallel processes for additional  suspicious behavior. Gather any other file modifications and review accordingly.  regsvcs.exe and regasm.exe are natively found in C:\Windows\Microsoft.NET\Framework\v*\regasm|regsvcs.exe  and C:\Windows\Microsoft.NET\Framework64\v*\regasm|regsvcs.exe.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.parent_process_name=regsvcs.exe  by Processes.parent_process_name Processes.dest Processes.user Processes.parent_process Processes.process_name  Processes.process Processes.process_id Processes.parent_process_id | `drop_dm_object_name(Processes)`  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `detect_regsvcs_spawning_a_process_filter`'



<li><a href="#">NAME: Detect Regsvcs with Network Connection

DESCRIPTION:  The following analytic identifies Regsvcs.exe with a network connection  to a public IP address, exluding private IP space. This particular technique has  been used in the wild to bypass application control products. Regasm.exe and Regsvcs.exe  are signed by Microsoft. By contacting a remote Command And Control server, the  adversary will have the ability to escalate privileges and complete the objectives.  During investigation, identify and retrieve the content being loaded. Review parallel  processes for additional suspicious behavior. Gather any other file modifications  and review accordingly. Review the reputation of the remote IP or domain and block  as needed. regsvcs.exe and regasm.exe are natively found in C:\Windows\Microsoft.NET\Framework\v*\regasm|regsvcs.exe  and C:\Windows\Microsoft.NET\Framework64\v*\regasm|regsvcs.exe.

SEARCH:  '`sysmon` EventID=3 dest_ip!=10.0.0.0/8 dest_ip!=172.16.0.0/12 dest_ip!=192.168.0.0/16  process_name=regsvcs.exe  | stats count min(_time) as firstTime  max(_time) as lastTime by dest, user, process_name, src_ip, dest_ip | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `detect_regsvcs_with_network_connection_filter`'



<li><a href="#">NAME: Detect Regsvcs with No Command Line Arguments

DESCRIPTION:  The following analytic identifies regsvcs.exe with no command line arguments.  This particular behavior occurs when another process injects into regsvcs.exe, no  command line arguments will be present. During investigation, identify any network  connections and parallel processes. Identify any suspicious module loads related  to credential dumping or file writes. Regasm.exe are natively found in C:\Windows\Microsoft.NET\Framework\v*\regasm|regsvcs.exe  and C:\Windows\Microsoft.NET\Framework64\v*\regasm|regsvcs.exe.

SEARCH:  '| tstats `security_content_summariesonly` count FROM datamodel=Endpoint.Processes  where `process_regsvcs` by _time span=1h  Processes.process_id Processes.process_name  Processes.dest Processes.user Processes.process_path Processes.process  Processes.parent_process_name  | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | regex process="(?i)(regsvcs\.exe.{0,4}$)"| `detect_regsvcs_with_no_command_line_arguments_filter`'



<li><a href="#">NAME: Detect Regsvr32 Application Control Bypass

DESCRIPTION:  'Adversaries may abuse Regsvr32.exe to proxy execution of malicious code.  Regsvr32.exe is a command-line program used to register and unregister object linking  and embedding controls, including dynamic link libraries (DLLs), on Windows systems.  Regsvr32.exe is also a Microsoft signed binary.This variation of the technique is  often referred to as a "Squiblydoo" attack. \  Upon investigating, look for network connections to remote destinations (internal  or external). Be cautious to modify the query to look for "scrobj.dll", the ".dll"  is not required to load scrobj. "scrobj.dll" will be loaded by "regsvr32.exe" upon  execution. '

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where `process_regsvr32` Processes.process=*scrobj*  by Processes.dest Processes.user Processes.parent_process Processes.process_name Processes.parent_process_name  Processes.process Processes.original_file_name Processes.process_id Processes.parent_process_id  | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)`| `security_content_ctime(lastTime)`  | `detect_regsvr32_application_control_bypass_filter`'



<li><a href="#">NAME: Detect Remote Access Software Usage DNS

DESCRIPTION:  The following analytic detects when a known remote access software domains are contacted from within the environment. Adversaries use these utilities to retain remote access capabilities to the environment. Utilities in the lookup include AnyDesk, GoToMyPC, LogMeIn, TeamViewer and much more. Review the lookup for the entire list and add any others.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time) as lastTime values(DNS.answer) as answer from datamodel=Network_Resolution by DNS.src DNS.query  | `drop_dm_object_name("DNS")`   | `security_content_ctime(firstTime)`   | `security_content_ctime(lastTime)`  | lookup remote_access_software remote_domain AS query OUTPUT isutility, description as signature, comment_reference as desc, category  | eval dest = query  | search isutility = True  | `detect_remote_access_software_usage_dns_filter`'



<li><a href="#">NAME: Detect Remote Access Software Usage File

DESCRIPTION:  The following analytic detects when a file from a known remote access software is written to disk within the environment. Adversaries use these utilities to retain remote access capabilities to the environment. Utilities in the lookup include AnyDesk, GoToMyPC, LogMeIn, TeamViewer and much more. Review the lookup for the entire list and add any others.

SEARCH:  '| tstats `security_content_summariesonly` count, min(_time) as firstTime, max(_time) as lastTime, values(Filesystem.file_path) as file_path from datamodel=Endpoint.Filesystem by Filesystem.dest, Filesystem.user, Filesystem.file_name  | `security_content_ctime(firstTime)`   | `security_content_ctime(lastTime)`   | `drop_dm_object_name(Filesystem)`   | lookup remote_access_software remote_utility AS file_name OUTPUT isutility, description as signature, comment_reference as desc, category  | search isutility = TRUE  | `detect_remote_access_software_usage_file_filter`'



<li><a href="#">NAME: Detect Remote Access Software Usage FileInfo

DESCRIPTION:  The following analytic detects when process with file or code signing attributes from a known remote access software is executed with the environment. Adversaries use these utilities to retain remote access capabilities to the environment. Utilities in the lookup include AnyDesk, GoToMyPC, LogMeIn, TeamViewer and much more. Review the lookup for the entire list and add any others.

SEARCH:  '`sysmon` EventCode=1  | stats count min(_time) as firstTime max(_time) as lastTime, values(Company) as Company values(Product) as Product by dest, user, parent_process_name, process_name, process  | lookup remote_access_software remote_utility_fileinfo AS Product OUTPUT isutility, description as signature, comment_reference as desc, category  | search isutility = True  | `detect_remote_access_software_usage_fileinfo_filter`'



<li><a href="#">NAME: Detect Remote Access Software Usage Process

DESCRIPTION:  The following analytic detects when a known remote access software is executed within the environment. Adversaries use these utilities to retain remote access capabilities to the environment. Utilities in the lookup include AnyDesk, GoToMyPC, LogMeIn, TeamViewer and much more. Review the lookup for the entire list and add any others.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time) as lastTime values(Processes.parent_process) as parent_process from datamodel=Endpoint.Processes where Processes.dest!=unknown Processes.process!=unknown by Processes.dest Processes.user Processes.process_name Processes.process   | `security_content_ctime(firstTime)`   | `security_content_ctime(lastTime)`   | `drop_dm_object_name(Processes)`   | lookup remote_access_software remote_utility AS process_name OUTPUT isutility, description as signature, comment_reference as desc, category  | search isutility = True  | `detect_remote_access_software_usage_process_filter`'



<li><a href="#">NAME: Detect Remote Access Software Usage Traffic

DESCRIPTION:  The following analytic detects when a known remote access software application traffic is detected from within the environment. Adversaries use these utilities to retain remote access capabilities to the environment. Utilities in the lookup include AnyDesk, GoToMyPC, LogMeIn, TeamViewer and much more. Review the lookup for the entire list and add any others.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time) as lastTime values(All_Traffic.dest_port) as dest_port latest(user) as user from datamodel=Network_Traffic by All_Traffic.src All_Traffic.dest, All_Traffic.app  | `drop_dm_object_name("All_Traffic")`   | `security_content_ctime(firstTime)`   | `security_content_ctime(lastTime)`  | lookup remote_access_software remote_appid AS app OUTPUT isutility, description as signature, comment_reference as desc, category  | search isutility = True  | `detect_remote_access_software_usage_traffic_filter`'



<li><a href="#">NAME: Detect Renamed 7-Zip

DESCRIPTION:  The following analytic identifies renamed 7-Zip usage using Sysmon. At  this stage of an attack, review parallel processes and file modifications for data  that is staged or potentially have been exfiltrated. This analytic utilizes the  OriginalFileName to capture the renamed process. During triage, validate this is  the legitimate version of `7zip` by reviewing the PE metadata. In addition, review  parallel processes for further suspicious behavior.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where (Processes.original_file_name=7z*.exe  AND Processes.process_name!=7z*.exe) by Processes.dest Processes.user Processes.parent_process_name  Processes.process_name Processes.process Processes.process_id Processes.parent_process_id  Processes.original_file_name | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `detect_renamed_7_zip_filter`'



<li><a href="#">NAME: Detect Renamed PSExec

DESCRIPTION:  The following analytic identifies renamed instances of `PsExec.exe` being  utilized on an endpoint. Most instances, it is highly probable to capture `Psexec.exe`  or other SysInternal utility usage with the command-line argument of `-accepteula`.  During triage, validate this is the legitimate version of `PsExec` by reviewing  the PE metadata. In addition, review parallel processes for further suspicious behavior.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where (Processes.process_name!=psexec.exe  OR Processes.process_name!=psexec64.exe) AND Processes.original_file_name=psexec.c  by Processes.dest Processes.user Processes.parent_process_name Processes.process_name  Processes.process Processes.process_id Processes.parent_process_id Processes.original_file_name  | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `detect_renamed_psexec_filter`'



<li><a href="#">NAME: Detect Renamed RClone

DESCRIPTION:  The following analytic identifies the usage of `rclone.exe`, renamed,  being used to exfiltrate data to a remote destination. RClone has been used by multiple  ransomware groups to exfiltrate data. In many instances, it will be downloaded from  the legitimate site and executed accordingly. During triage, isolate the endpoint  and begin to review parallel processes for additional behavior. At this stage, the  adversary may have staged data to be exfiltrated.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where (Processes.original_file_name=rclone.exe  AND Processes.process_name!=rclone.exe) by Processes.dest Processes.user Processes.parent_process_name  Processes.process_name Processes.process Processes.process_id Processes.parent_process_id  Processes.original_file_name | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `detect_renamed_rclone_filter`'



<li><a href="#">NAME: Detect Renamed WinRAR

DESCRIPTION:  The following analtyic identifies renamed instances of `WinRAR.exe`.  In most cases, it is not common for WinRAR to be used renamed, however it is common  to be installed by a third party application and executed from a non-standard path.  During triage, validate additional metadata from the binary that this is `WinRAR`.  Review parallel processes and file modifications.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.original_file_name=WinRAR.exe  (Processes.process_name!=rar.exe OR Processes.process_name!=winrar.exe) by Processes.dest  Processes.user Processes.parent_process_name Processes.process_name Processes.process  Processes.process_id Processes.parent_process_id Processes.original_file_name |  `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `detect_renamed_winrar_filter`'



<li><a href="#">NAME: Detect Rogue DHCP Server

DESCRIPTION:  By enabling DHCP Snooping as a Layer 2 Security measure on the organization's  network devices, we will be able to detect unauthorized DHCP servers handing out  DHCP leases to devices on the network (Man in the Middle attack).

SEARCH:  '`cisco_networks` facility="DHCP_SNOOPING" mnemonic="DHCP_SNOOPING_UNTRUSTED_PORT"  | stats min(_time) AS firstTime max(_time) AS lastTime count values(message_type)  AS message_type values(src_mac) AS src_mac BY host | `security_content_ctime(firstTime)`|`security_content_ctime(lastTime)`|  `detect_rogue_dhcp_server_filter`'



<li><a href="#">NAME: Detect RTLO In File Name

DESCRIPTION:  This search is used to detect the abuse of the right-to-left override (RTLO or RLO)  character (U+202E) RTLO. This technique is used by adversaries to disguise a string and/or   file name to make it appear benign. The RTLO character is a non-printing Unicode   character that causes the text that follows it to be displayed in reverse.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time) as lastTime values(Filesystem.file_create_time) as file_create_time from datamodel=Endpoint.Filesystem where Filesystem.file_name!=unknown by Filesystem.dest Filesystem.user Filesystem.process_id Filesystem.file_name Filesystem.file_path| `drop_dm_object_name(Filesystem)`| `security_content_ctime(firstTime)`| `security_content_ctime(lastTime)`| regex file_name =  "\\x{202E}"| rex field=file_name "(?<RTLO_file_1>.+)(?<RTLO_exist_file>\\x{202E})(?<RTLO_file_2>.+)"| eval file_name_with_RTLO=file_name| eval file_name=RTLO_file_1.RTLO_file_2| fields - RTLO*| `detect_rtlo_in_file_name_filter`'



<li><a href="#">NAME: Detect RTLO In Process

DESCRIPTION:  This search is used to detect the abuse of the right-to-left override  (RTLO or RLO) character (U+202E) RTLO. This technique is used by adversaries to  disguise a string and/or file name to make it appear benign. The RTLO character  is a non-printing Unicode character that causes the text that follows it to be displayed  in reverse.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.process!=unknown AND  Processes.action=allowed by Processes.dest Processes.user Processes.original_file_name  Processes.parent_process_name Processes.parent_process Processes.process_name Processes.process  Processes.process_id Processes.process_guid Processes.parent_process_id | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `drop_dm_object_name(Processes)` | regex  process="\\x{202E}" | rex field=process "(?<RTLO_command_1>.+)(?<RTLO_exist_process>\\x{202E})(?<RTLO_command_2>.+)"  | eval process_with_RTLO=process | eval process=RTLO_command_1.RTLO_command_2 |  fields - RTLO* | `detect_rtlo_in_process_filter`'



<li><a href="#">NAME: Detect Rundll32 Application Control Bypass - advpack

DESCRIPTION:  The following analytic identifies rundll32.exe loading advpack.dll and  ieadvpack.dll by calling the LaunchINFSection function on the command line. This  particular technique will load script code from a file. Upon a successful execution,  the following module loads may occur - clr.dll, jscript.dll and scrobj.dll. During  investigation, identify script content origination. Generally, a child process will  spawn from rundll32.exe, but that may be bypassed based on script code contents.  Rundll32.exe is natively found in C:\Windows\system32 and C:\Windows\syswow64. During  investigation, review any network connections and obtain the script content executed.  It's possible other files are on disk.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where `process_rundll32` Processes.process=*advpack*  by Processes.dest Processes.user Processes.parent_process_name Processes.original_file_name  Processes.process_name Processes.process Processes.process_id Processes.parent_process_id  | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `detect_rundll32_application_control_bypass___advpack_filter`'



<li><a href="#">NAME: Detect Rundll32 Application Control Bypass - setupapi

DESCRIPTION:  The following analytic identifies rundll32.exe loading setupapi.dll and  iesetupapi.dll by calling the LaunchINFSection function on the command line. This  particular technique will load script code from a file. Upon a successful execution,  the following module loads may occur - clr.dll, jscript.dll and scrobj.dll. During  investigation, identify script content origination. Generally, a child process will  spawn from rundll32.exe, but that may be bypassed based on script code contents.  Rundll32.exe is natively found in C:\Windows\system32 and C:\Windows\syswow64. During  investigation, review any network connections and obtain the script content executed.  It's possible other files are on disk.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where `process_rundll32` Processes.process=*setupapi*  by Processes.dest Processes.user Processes.parent_process_name Processes.original_file_name  Processes.process_name Processes.process Processes.process_id Processes.parent_process_id  | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `detect_rundll32_application_control_bypass___setupapi_filter`'



<li><a href="#">NAME: Detect Rundll32 Application Control Bypass - syssetup

DESCRIPTION:  The following analytic identifies rundll32.exe loading syssetup.dll by  calling the LaunchINFSection function on the command line. This particular technique  will load script code from a file. Upon a successful execution, the following module  loads may occur - clr.dll, jscript.dll and scrobj.dll. During investigation, identify  script content origination. Generally, a child process will spawn from rundll32.exe,  but that may be bypassed based on script code contents. Rundll32.exe is natively  found in C:\Windows\system32 and C:\Windows\syswow64. During investigation, review  any network connections and obtain the script content executed. It's possible other  files are on disk.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where `process_rundll32` Processes.process=*syssetup*  by Processes.dest Processes.user Processes.parent_process_name Processes.original_file_name  Processes.process_name Processes.process Processes.process_id Processes.parent_process_id  | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `detect_rundll32_application_control_bypass___syssetup_filter`'



<li><a href="#">NAME: Detect Rundll32 Inline HTA Execution

DESCRIPTION:  The following analytic identifies "rundll32.exe" execution with inline  protocol handlers. "JavaScript", "VBScript", and "About" are the only supported  options when invoking HTA content directly on the command-line. This type of behavior  is commonly observed with fileless malware or application whitelisting bypass techniques.  The search will return the first time and last time these command-line arguments  were used for these executions, as well as the target system, the user, process  "rundll32.exe" and its parent process.

SEARCH:  '| tstats `security_content_summariesonly` count values(Processes.process)  as process values(Processes.parent_process) as parent_process min(_time) as firstTime  max(_time) as lastTime from datamodel=Endpoint.Processes where `process_rundll32`  (Processes.process=*vbscript* OR Processes.process=*javascript* OR Processes.process=*about*)  by Processes.user Processes.process_name Processes.parent_process_name Processes.original_file_name  Processes.dest  | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)`|  `security_content_ctime(lastTime)` | `detect_rundll32_inline_hta_execution_filter`'



<li><a href="#">NAME: Detect SharpHound Command-Line Arguments

DESCRIPTION:  The following analytic identifies common command-line arguments used  by SharpHound `-collectionMethod` and `invoke-bloodhound`. Being the script is FOSS,  function names may be modified, but these changes are dependent upon the operator.  In most instances the defaults are used. This analytic works to identify the common  command-line attributes used. It does not cover the entirety of every argument in  order to avoid false positives.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.process IN ("*-collectionMethod*","*invoke-bloodhound*")  by Processes.dest Processes.user Processes.parent_process Processes.process_name  Processes.process Processes.process_id Processes.parent_process_id | `drop_dm_object_name(Processes)`  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `detect_sharphound_command_line_arguments_filter`'



<li><a href="#">NAME: Detect SharpHound File Modifications

DESCRIPTION:  SharpHound is used as a reconnaissance collector, ingestor, for BloodHound.  SharpHound will query the domain controller and begin gathering all the data related  to the domain and trusts. For output, it will drop a .zip file upon completion following  a typical pattern that is often not changed. This analytic focuses on the default  file name scheme. Note that this may be evaded with different parameters within  SharpHound, but that depends on the operator. `-randomizefilenames` and `-encryptzip`  are two examples. In addition, executing SharpHound via .exe or .ps1 without any  command-line arguments will still perform activity and dump output to the default  filename. Example default filename `20210601181553_BloodHound.zip`. SharpHound creates  multiple temp files following the same pattern `20210601182121_computers.json`,  `domains.json`, `gpos.json`, `ous.json` and `users.json`. Tuning may be required,  or remove these json's entirely if it is too noisy. During traige, review parallel  processes for further suspicious behavior. Typically, the process executing the  `.ps1` ingestor will be PowerShell.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Filesystem where Filesystem.file_name IN ("*bloodhound.zip",  "*_computers.json", "*_gpos.json", "*_domains.json", "*_users.json", "*_groups.json",  "*_ous.json", "*_containers.json") by Filesystem.file_create_time Filesystem.process_id  Filesystem.file_name  Filesystem.file_path Filesystem.dest Filesystem.user| `drop_dm_object_name(Filesystem)` | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `detect_sharphound_file_modifications_filter`'



<li><a href="#">NAME: Detect SharpHound Usage

DESCRIPTION:  The following analytic identifies SharpHound binary usage by using the  original filena,e. In addition to renaming the PE, other coverage is available to  detect command-line arguments. This particular analytic looks for the original_file_name  of `SharpHound.exe` and the process name. It is possible older instances of SharpHound.exe  have different original filenames. Dependent upon the operator, the code may be  re-compiled and the attributes removed or changed to anything else. During triage,  review the metadata of the binary in question. Review parallel processes for suspicious  behavior. Identify the source of this binary.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where (Processes.process_name=sharphound.exe  OR Processes.original_file_name=SharpHound.exe) by Processes.dest Processes.user  Processes.parent_process_name Processes.original_file_name Processes.process_name  Processes.process Processes.process_id Processes.parent_process_id | `drop_dm_object_name(Processes)`  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `detect_sharphound_usage_filter`'



<li><a href="#">NAME: Detect SNICat SNI Exfiltration

DESCRIPTION:  This search looks for commands that the SNICat tool uses in the TLS SNI  field.

SEARCH:  '`zeek_ssl` | rex field=server_name "(?<snicat>(LIST|LS|SIZE|LD|CB|CD|EX|ALIVE|EXIT|WHERE|finito)-[A-Za-z0-9]{16}\.)"  | stats count by src_ip dest_ip server_name snicat | where count>0 | table src_ip  dest_ip server_name snicat | `detect_snicat_sni_exfiltration_filter`'



<li><a href="#">NAME: Detect Software Download To Network Device

DESCRIPTION:  Adversaries may abuse netbooting to load an unauthorized network device  operating system from a Trivial File Transfer Protocol (TFTP) server. TFTP boot  (netbooting) is commonly used by network administrators to load configuration-controlled  network device images from a centralized management server. Netbooting is one option  in the boot sequence and can be used to centralize, manage, and control device images.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Network_Traffic where (All_Traffic.transport=udp AND  All_Traffic.dest_port=69) OR (All_Traffic.transport=tcp AND All_Traffic.dest_port=21)  OR (All_Traffic.transport=tcp AND All_Traffic.dest_port=22) AND All_Traffic.dest_category!=common_software_repo_destination  AND All_Traffic.src_category=network OR All_Traffic.src_category=router OR All_Traffic.src_category=switch  by All_Traffic.src All_Traffic.dest All_Traffic.dest_port | `drop_dm_object_name("All_Traffic")`  | `security_content_ctime(firstTime)`| `security_content_ctime(lastTime)` | `detect_software_download_to_network_device_filter`'



<li><a href="#">NAME: Detect suspicious DNS TXT records using pretrained model in DSDL

DESCRIPTION:  The following analytic uses a pre trained deep learning model to detect  suspicious DNS TXT records. The model is trained independently and is then made  available for download. The DNS TXT records are categorized into commonly identified  types like email, verification, http using regular expressions https://www.tide-project.nl/blog/wtmc2020/.  The TXT records that do not match regular expressions for well known types are labeled  as 1 for "unknown/suspicious" and otherwise 0 for "not suspicious". The deep learning  model we have developed uses DNS TXT responses to analyze patterns of character  sequences to predict if a DNS TXT is suspicious or not. The higher the pred_is_unknown_proba,  the more likely the DNS TXT record is suspicious. The threshold for flagging a domain  as suspicious is set at 0.5.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Network_Resolution where DNS.message_type=response AND  DNS.record_type=TXT by DNS.src DNS.dest DNS.answer DNS.record_type | `drop_dm_object_name("DNS")`  | rename answer as text | fields firstTime, lastTime, message_type,record_type,src,dest,  text | apply detect_suspicious_dns_txt_records_using_pretrained_model_in_dsdl |  rename predicted_is_unknown as is_suspicious_score | where is_suspicious_score >  0.5 | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | table src,dest,text,record_type, firstTime, lastTime,is_suspicious_score | `detect_suspicious_dns_txt_records_using_pretrained_model_in_dsdl_filter`'



<li><a href="#">NAME: Detect suspicious processnames using pretrained model in DSDL

DESCRIPTION:  The following analytic uses a pre-trained Deep Learning model to predict  whether a processname is suspicious or not. Malwares and malicious programs such  as ransomware often use tactics, techniques, and procedures (TTPs) such as copying  malicious files to the local machine to propagate themselves across the network.  A key indicator of compromise is that after a successful execution of the malware,  it copies itself as an executable file with a randomly generated filename and places  this file in one of the directories. Such techniques are seen in several malwares  such as TrickBot. We develop machine learning model that uses a Recurrent Neural  Network (RNN) to distinguish between malicious and benign processnames. The model  is trained independently and is then made available for download. We use a character  level RNN to classify malicious vs. benign processnames. The higher is_malicious_prob,  the more likely is the processname to be suspicious (between [0,1]). The threshold  for flagging a processname as suspicious is set as 0.5.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes by Processes.process_name Processes.parent_process_name  Processes.process Processes.user Processes.dest | `drop_dm_object_name(Processes)`  | rename process_name as text | fields text, parent_process_name, process, user,  dest | apply detect_suspicious_processnames_using_pretrained_model_in_dsdl | rename  predicted_label as is_suspicious_score | rename text as process_name | where is_suspicious_score  > 0.5 | `detect_suspicious_processnames_using_pretrained_model_in_dsdl_filter`'



<li><a href="#">NAME: Detect Traffic Mirroring

DESCRIPTION:  Adversaries may leverage traffic mirroring in order to automate data  exfiltration over compromised network infrastructure. Traffic mirroring is a native  feature for some network devices and used for network analysis and may be configured  to duplicate traffic and forward to one or more destinations for analysis by a network  analyzer or other monitoring device.

SEARCH:  '`cisco_networks` (facility="MIRROR" mnemonic="ETH_SPAN_SESSION_UP") OR (facility="SPAN"  mnemonic="SESSION_UP") OR (facility="SPAN" mnemonic="PKTCAP_START") OR (mnemonic="CFGLOG_LOGGEDCMD"  command="monitor session*") | stats min(_time) AS firstTime max(_time) AS lastTime  count BY host facility mnemonic | `security_content_ctime(firstTime)`|`security_content_ctime(lastTime)`  | `detect_traffic_mirroring_filter`'



<li><a href="#">NAME: Detect Unauthorized Assets by MAC address

DESCRIPTION:  By populating the organization's assets within the assets_by_str.csv,  we will be able to detect unauthorized devices that are trying to connect with the  organization's network by inspecting DHCP request packets, which are issued by devices  when they attempt to obtain an IP address from the DHCP server. The MAC address  associated with the source of the DHCP request is checked against the list of known  devices, and reports on those that are not found.

SEARCH:  '| tstats `security_content_summariesonly` count from datamodel=Network_Sessions  where nodename=All_Sessions.DHCP All_Sessions.tag=dhcp by All_Sessions.dest_ip All_Sessions.dest_mac  | dedup All_Sessions.dest_mac| `drop_dm_object_name("Network_Sessions")`|`drop_dm_object_name("All_Sessions")`  | search NOT [| inputlookup asset_lookup_by_str |rename mac as dest_mac | fields  + dest_mac] | `detect_unauthorized_assets_by_mac_address_filter`'



<li><a href="#">NAME: Detect Use of cmd exe to Launch Script Interpreters

DESCRIPTION:  This search looks for the execution of the cscript.exe or wscript.exe  processes, with a parent of cmd.exe. The search will return the count, the first  and last time this execution was seen on a machine, the user, and the destination  of the machine

SEARCH:  '| tstats `security_content_summariesonly` count  min(_time) as firstTime max(_time) as lastTime from datamodel=Endpoint.Processes  where Processes.parent_process_name="cmd.exe" (Processes.process_name=cscript.exe  OR Processes.process_name =wscript.exe) by Processes.parent_process Processes.process_name Processes.process  Processes.user Processes.dest | `drop_dm_object_name("Processes")` | `security_content_ctime(firstTime)`|`security_content_ctime(lastTime)`  | `detect_use_of_cmd_exe_to_launch_script_interpreters_filter`'



<li><a href="#">NAME: Detect Webshell Exploit Behavior

DESCRIPTION:  This search is used to detect the abuse of web applications by adversaries.  Adversaries may install a backdoor or script onto web servers by exploiting known  vulnerabilities or misconfigruations. Web shells are used to establish persistent  access to systems and provide a set of executable functions or a command-line interface  on the system hosting the Web server.

SEARCH:  '| tstats `security_content_summariesonly` count max(_time) as lastTime, min(_time)  as firstTime from datamodel=Endpoint.Processes where (Processes.process_name IN  ("arp.exe","at.exe","bash.exe","bitsadmin.exe","certutil.exe","cmd.exe","cscript.exe",  "dsget.exe","dsquery.exe","find.exe","findstr.exe","fsutil.exe","hostname.exe","ipconfig.exe","ksh.exe","nbstat.exe",  "net.exe","net1.exe","netdom.exe","netsh.exe","netstat.exe","nltest.exe","nslookup.exe","ntdsutil.exe","pathping.exe",  "ping.exe","powershell.exe","pwsh.exe","qprocess.exe","query.exe","qwinsta.exe","reg.exe","rundll32.exe","sc.exe",  "scrcons.exe","schtasks.exe","sh.exe","systeminfo.exe","tasklist.exe","tracert.exe","ver.exe","vssadmin.exe",  "wevtutil.exe","whoami.exe","wmic.exe","wscript.exe","wusa.exe","zsh.exe") AND Processes.parent_process_name  IN ("w3wp.exe", "http*.exe", "nginx*.exe", "php*.exe", "php-cgi*.exe","tomcat*.exe"))  by Processes.dest,Processes.user,Processes.parent_process,Processes.parent_process_name,Processes.process,Processes.process_name  | `drop_dm_object_name("Processes")` | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `detect_webshell_exploit_behavior_filter`'



<li><a href="#">NAME: Detect Windows DNS SIGRed via Splunk Stream

DESCRIPTION:  "Ensure that the following prerequisites are met: (i) Both Splunk Stream DNS and TCP data are ingested. (ii) The macros 'stream:dns' and 'stream:tcp' are replaced with the appropriate configurations that are specific to your Splunk environment. The following analytic detects SIGRed exploitation attempts. SIGRed is a critical wormable vulnerability found in Windows DNS servers, known as CVE-2020-1350, which allows remote code execution. The detection is made by using an experimental search that focuses on identifying specific indicators that might suggest the presence of the SIGRed exploit such as DNS SIG records, KEY records, and TCP payloads greater than 65KB. This detection is important because it detects and responds to potential SIGRed exploitation attempts and minimizes the risk of a successful attack and its impact on the organization's infrastructure and data. False positives might occur due to the experimental nature of this analytic. Next steps include reviewing and investigating each case thoroughly given the potential for unauthorized Windows DNS server access, data breaches, and service disruptions. Additionally, you must stay updated with Microsoft's guidance on the SIGRed vulnerability."

SEARCH:  '`stream_dns` | spath "query_type{}" | search "query_type{}" IN (SIG,KEY)  | spath protocol_stack | search protocol_stack="ip:tcp:dns" | append [search `stream_tcp`  bytes_out>65000] | `detect_windows_dns_sigred_via_splunk_stream_filter` | stats  count by flow_id | where count>1 | fields - count'



<li><a href="#">NAME: Detect Windows DNS SIGRed via Zeek

DESCRIPTION:  |-  The following analytic detects the presence of SIGRed, a critical DNS vulnerability, using Zeek DNS and Zeek Conn data. SIGRed vulnerability allows attackers to run remote code on Windows DNS servers. By detecting SIGRed early, you can prevent further damage and protect the organization's network infrastructure. The detection is made by identifying specific DNS query types (SIG and KEY) in the Zeek DNS data and checks for high data transfer in the Zeek Conn data. If multiple instances of these indicators are found within a flow, it suggests the presence of SIGRed. The detection is important because it indicates a potential compromise of Windows DNS servers that suggests that an attacker might have gained unauthorized access to the DNS server and can run arbitrary code. The impact of this attack can be severe, leading to data exfiltration, unauthorized access, or disruption of critical services. Next steps include investigating the affected flow and taking immediate action to mitigate the vulnerability. This can involve patching the affected DNS server, isolating the server from the network, or conducting a forensic analysis to determine the extent of the compromise.

SEARCH:  '| tstats `security_content_summariesonly` count from datamodel=Network_Resolution  where DNS.query_type IN (SIG,KEY) by DNS.flow_id | rename DNS.flow_id as flow_id  | append [| tstats  `security_content_summariesonly` count from datamodel=Network_Traffic  where All_Traffic.bytes_in>65000 by All_Traffic.flow_id | rename All_Traffic.flow_id  as flow_id] | `detect_windows_dns_sigred_via_zeek_filter` | stats count by flow_id  | where count>1 | fields - count '



<li><a href="#">NAME: Detect WMI Event Subscription Persistence

DESCRIPTION:  'The following analytic identifies the use of WMI Event Subscription  to establish persistence or perform privilege escalation.  WMI can be used to install  event filters, providers, consumers, and bindings that execute code when a defined  event occurs. WMI subscription execution is proxied by the WMI Provider Host process  (WmiPrvSe.exe) and thus may result in elevated SYSTEM privileges. This analytic  is restricted by commonly added process execution and a path. If the volume is low  enough, remove the values and flag on any new subscriptions.\  All event subscriptions have three components \  1. Filter - WQL Query for the events we want. EventID equals 19 \  1. Consumer - An action to take upon triggering the filter. EventID equals 20 \  1. Binding - Registers a filter to a consumer. EventID equals 21 \  Monitor for the creation of new WMI EventFilter, EventConsumer, and FilterToConsumerBinding.  It may be pertinent to review all 3 to identify the flow of execution. In addition,  EventCode 4104 may assist with any other PowerShell script usage that registered  the subscription.'

SEARCH:  '`sysmon` EventID=20 | stats count min(_time) as firstTime max(_time) as lastTime  by Computer User Destination | rename Computer as dest | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `detect_wmi_event_subscription_persistence_filter`'



<li><a href="#">NAME: Detect Zerologon via Zeek

DESCRIPTION:  |-  The following analytic detects attempts to exploit the Zerologon CVE-2020-1472 vulnerability through Zeek RPC. By detecting attempts to exploit the Zerologon vulnerability through Zeek RPC, SOC analysts can identify potential threats earlier and take appropriate action to mitigate the risks. This detection is made by a Splunk query that looks for specific Zeek RPC operations, including NetrServerPasswordSet2, NetrServerReqChallenge, and NetrServerAuthenticate3, which are aggregated by source and destination IP address and time. This detection is important because it suggests that an attacker is attempting to exploit the Zerologon vulnerability to gain unauthorized access to the domain controller. Zerologon vulnerability is a critical vulnerability that allows attackers to take over domain controllers without authentication, leading to a complete takeover of an organization's IT infrastructure. The impact of such an attack can be severe, potentially leading to data theft, ransomware, or other devastating outcomes. False positives might occur since legitimate Zeek RPC activity can trigger the analytic. Next steps include reviewing the identified source and destination IP addresses and the specific RPC operations used. Capture and inspect any relevant on-disk artifacts, and review concurrent processes to identify the attack source upon triage .

SEARCH:  '`zeek_rpc` operation IN (NetrServerPasswordSet2,NetrServerReqChallenge,NetrServerAuthenticate3)  | bin span=5m _time | stats values(operation) dc(operation) as opscount count(eval(operation=="NetrServerReqChallenge"))  as challenge count(eval(operation=="NetrServerAuthenticate3")) as authcount count(eval(operation=="NetrServerPasswordSet2"))  as passcount count as totalcount by _time,src_ip,dest_ip | search opscount=3 authcount>4  passcount>0 | search `detect_zerologon_via_zeek_filter`'



<li><a href="#">NAME: Disabled Kerberos Pre-Authentication Discovery With Get-ADUser

DESCRIPTION:  The following analytic utilizes PowerShell Script Block Logging (EventCode=4104)  to identify the execution of the `Get-ADUser` commandlet with specific parameters.  `Get-ADUser` is part of the Active Directory PowerShell module used to manage Windows  Active Directory networks. As the name suggests, `Get-ADUser` is used to query for  domain users. With the appropiate parameters, Get-ADUser allows adversaries to discover  domain accounts with Kerberos Pre Authentication disabled.\ Red Teams and adversaries  alike use may abuse Get-ADUSer to enumerate these accounts and attempt to crack  their passwords offline.

SEARCH:  ' `powershell` EventCode=4104 (ScriptBlockText = "*Get-ADUser*" AND ScriptBlockText="*4194304*")  | stats count min(_time)  as firstTime max(_time) as lastTime by Opcode Computer  UserID EventCode ScriptBlockText | rename Computer as dest | `security_content_ctime(firstTime)`  | `disabled_kerberos_pre_authentication_discovery_with_get_aduser_filter`'



<li><a href="#">NAME: Disabled Kerberos Pre-Authentication Discovery With PowerView

DESCRIPTION:  The following analytic utilizes PowerShell Script Block Logging (EventCode=4104)  to identify the execution of the `Get-DomainUser` commandlet with specific parameters.  `Get-DomainUser` is part of PowerView, a PowerShell tool used to perform enumeration  on Windows Active Directory networks. As the name suggests, `Get-DomainUser` is  used to identify domain users and combining it with `-PreauthNotRequired` allows  adversaries to discover domain accounts with Kerberos Pre Authentication disabled.\  Red Teams and adversaries alike use may leverage PowerView to enumerate these accounts  and attempt to crack their passwords offline.

SEARCH:  ' `powershell` EventCode=4104 (ScriptBlockText = "*Get-DomainUser*" AND ScriptBlockText="*PreauthNotRequired*")  | stats count min(_time)  as firstTime max(_time) as lastTime by Opcode Computer  UserID EventCode ScriptBlockText | rename Computer as dest | `security_content_ctime(firstTime)` | `disabled_kerberos_pre_authentication_discovery_with_powerview_filter`'



<li><a href="#">NAME: Disable AMSI Through Registry

DESCRIPTION:  this search is to identify modification in registry to disable AMSI windows  feature to evade detections. This technique was seen in several ransomware, RAT  and even APT to impaire defenses of the compromise machine and to be able to execute  payload with minimal alert as much as possible.

SEARCH:  '| tstats `security_content_summariesonly` count FROM datamodel=Endpoint.Registry  WHERE (Registry.registry_path= "*\\SOFTWARE\\Microsoft\\Windows Script\\Settings\\AmsiEnable"  Registry.registry_value_data = "0x00000000") BY _time span=1h Registry.registry_path  Registry.registry_key_name Registry.registry_value_name Registry.registry_value_data  Registry.process_guid Registry.dest Registry.user | `drop_dm_object_name(Registry)`  | where isnotnull(registry_value_data) | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `disable_amsi_through_registry_filter`'



<li><a href="#">NAME: Disable Defender AntiVirus Registry

DESCRIPTION:  This particular behavior is typically executed when an adversary or malware  gains access to an endpoint and begins to perform execution and to evade detections.  Usually, a batch (.bat) file will be executed and multiple registry and scheduled  task modifications will occur. During triage, review parallel processes and identify  any further file modifications. Endpoint should be isolated.

SEARCH:  '| tstats `security_content_summariesonly` count FROM datamodel=Endpoint.Registry WHERE (Registry.registry_path = "*\\Policies\\Microsoft\\Windows Defender*" Registry.registry_value_name IN ("DisableAntiSpyware","DisableAntiVirus") Registry.registry_value_data = 0x00000001) BY _time span=1h Registry.registry_path Registry.registry_key_name Registry.registry_value_name Registry.registry_value_data Registry.process_guid Registry.user Registry.dest   | `drop_dm_object_name(Registry)`  | where isnotnull(registry_value_data)  | `security_content_ctime(firstTime)`   | `security_content_ctime(lastTime)`  | `disable_defender_antivirus_registry_filter`'



<li><a href="#">NAME: Disable Defender BlockAtFirstSeen Feature

DESCRIPTION:  This analytic is intended to detect a suspicious modification of the  Windows registry to disable a Windows Defender feature. This technique is intended  to bypass or evade detection from Windows Defender AV, specifically the BlockAtFirstSeen  feature where it blocks suspicious files the first time seen on the host.

SEARCH:  '| tstats `security_content_summariesonly` count FROM datamodel=Endpoint.Registry  WHERE (Registry.registry_path = "*\\Microsoft\\Windows Defender\\SpyNet*" Registry.registry_value_name  = DisableBlockAtFirstSeen Registry.registry_value_data = 0x00000001) BY _time span=1h  Registry.registry_path Registry.registry_key_name Registry.registry_value_name Registry.registry_value_data  Registry.process_guid Registry.user Registry.dest | `drop_dm_object_name(Registry)`  | where isnotnull(registry_value_data) | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `disable_defender_blockatfirstseen_feature_filter`'



<li><a href="#">NAME: Disable Defender Enhanced Notification

DESCRIPTION:  This analytic is intended to detect a suspicious modification of registry  to disable windows defender features. This technique attempts to bypass or evade  detection from Windows Defender AV, specifically the Enhanced Notification feature  where a user or admin would receive alerts.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) AS firstTime max(_time)  AS lastTime FROM datamodel=Endpoint.Processes BY _time span=1h Processes.user Processes.process_id  Processes.process_name Processes.process Processes.process_path Processes.dest Processes.parent_process_name  Processes.parent_process Processes.process_guid | `drop_dm_object_name(Processes)`  | join process_guid [ | tstats `security_content_summariesonly` count FROM datamodel=Endpoint.Registry  WHERE (Registry.registry_path = "*Microsoft\\Windows Defender\\Reporting*" Registry.registry_value_name  = DisableEnhancedNotifications Registry.registry_value_data = 0x00000001) BY _time  span=1h Registry.registry_path Registry.registry_key_name Registry.registry_value_name  Registry.registry_value_data Registry.process_guid | `drop_dm_object_name(Registry)`]  | fields firstTime lastTime dest user parent_process_name parent_process process_name  process_path process registry_key_name registry_path registry_value_name registry_value_data  process_guid | where isnotnull(registry_value_data) | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `disable_defender_antivirus_registry_filter`'



<li><a href="#">NAME: Disable Defender MpEngine Registry

DESCRIPTION:  This particular behavior is typically executed when an adversary or malware  gains access to an endpoint and begins to perform execution and to evade detections.  Usually, a batch (.bat) file will be executed and multiple registry and scheduled  task modifications will occur. During triage, review parallel processes and identify  any further file modifications. Endpoint should be isolated.

SEARCH:  '| tstats `security_content_summariesonly` count FROM datamodel=Endpoint.Registry WHERE (Registry.registry_path = "*\\Policies\\Microsoft\\Windows Defender\\MpEngine*" Registry.registry_value_name = MpEnablePus Registry.registry_value_data = 0x00000000) BY _time span=1h Registry.registry_path Registry.registry_key_name Registry.registry_value_name Registry.registry_value_data Registry.process_guid Registry.user Registry.dest   | `drop_dm_object_name(Registry)`   | where isnotnull(registry_value_data)  | `security_content_ctime(firstTime)`   | `security_content_ctime(lastTime)`  | `disable_defender_mpengine_registry_filter`'



<li><a href="#">NAME: Disable Defender Spynet Reporting

DESCRIPTION:  This analytic is intended to detect a suspicious modification of registry  to disable Windows Defender feature. This technique is intended to bypass or evade  detection from Windows Defender AV product, specifically the spynet reporting for  Defender telemetry.

SEARCH:  '| tstats `security_content_summariesonly` count FROM datamodel=Endpoint.Registry  WHERE (Registry.registry_path = "*\\Microsoft\\Windows Defender\\SpyNet*" Registry.registry_value_name  = SpynetReporting Registry.registry_value_data = 0x00000000) BY _time span=1h Registry.registry_path  Registry.registry_key_name Registry.registry_value_name Registry.registry_value_data  Registry.process_guid Registry.user Registry.dest  | `drop_dm_object_name(Registry)`  | where isnotnull(registry_value_data) | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `disable_defender_spynet_reporting_filter`'



<li><a href="#">NAME: Disable Defender Submit Samples Consent Feature

DESCRIPTION:  This analytic is intended to detect a suspicious modification of the  Windows registry to disable a Windows Defender feature. This technique is intended  to bypass or evade detection from Windows Defender AV, specifically the feature  that submits samples for further analysis.

SEARCH:  '| tstats `security_content_summariesonly` count FROM datamodel=Endpoint.Registry  WHERE (Registry.registry_path = "*\\Microsoft\\Windows Defender\\SpyNet*" Registry.registry_value_name  = SubmitSamplesConsent Registry.registry_value_data = 0x00000000) BY _time span=1h  Registry.user Registry.dest Registry.registry_path Registry.registry_key_name Registry.registry_value_name  Registry.registry_value_data Registry.process_guid | `drop_dm_object_name(Registry)`  | where isnotnull(registry_value_data) | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `disable_defender_submit_samples_consent_feature_filter`'



<li><a href="#">NAME: Disable ETW Through Registry

DESCRIPTION:  This search is to identify modification in registry to disable ETW windows  feature to evade detections. This technique was seen in several ransomware, RAT  and even APT to impaire defenses of the compromise machine and to be able to execute  payload with minimal alert as much as possible.

SEARCH:  '| tstats `security_content_summariesonly` count FROM datamodel=Endpoint.Registry  WHERE (Registry.registry_path= "*\\SOFTWARE\\Microsoft\\.NETFramework\\ETWEnabled"  Registry.registry_value_data = "0x00000000") BY _time span=1h Registry.dest Registry.registry_path  Registry.registry_key_name Registry.registry_value_name Registry.registry_value_data  Registry.process_guid | `drop_dm_object_name(Registry)` | where isnotnull(registry_value_data)  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `disable_etw_through_registry_filter`'



<li><a href="#">NAME: Disable Logs Using WevtUtil

DESCRIPTION:  This search is to detect execution of wevtutil.exe to disable logs. This  technique was seen in several ransomware to disable the event logs to evade alerts  and detections.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.process_name = "wevtutil.exe"  Processes.process = "*sl*" Processes.process = "*/e:false*" by Processes.parent_process_name  Processes.parent_process Processes.process_name Processes.process Processes.dest  Processes.user Processes.process_id Processes.process_guid | `drop_dm_object_name(Processes)`  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `disable_logs_using_wevtutil_filter`'



<li><a href="#">NAME: Disable Registry Tool

DESCRIPTION:  This search identifies modification of registry to disable the regedit  or registry tools of the windows operating system. Since registry tool is a swiss  knife in analyzing registry, malware such as RAT or trojan Spy disable this application  to prevent the removal of their registry entry such as persistence, file less components  and defense evasion.

SEARCH:  '| tstats `security_content_summariesonly` count FROM datamodel=Endpoint.Registry  WHERE (Registry.registry_path= "*\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System\\DisableRegistryTools"  Registry.registry_value_data = "0x00000001") BY _time span=1h  Registry.user Registry.dest Registry.registry_path  Registry.registry_key_name Registry.registry_value_name Registry.registry_value_data  Registry.process_guid | `drop_dm_object_name(Registry)`| where isnotnull(registry_value_data)  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `disable_registry_tool_filter`'



<li><a href="#">NAME: Disable Schedule Task

DESCRIPTION:  This analytic is to detect a suspicious commandline to disable existing  schedule task. This technique is used by adversaries or commodity malware like IcedID  to disable security application (AV products) in the targetted host to evade detections.  This TTP is a good pivot to check further why and what other process run before  and after this detection. check which process execute the commandline and what task  is disabled. parent child process is quite valuable in this scenario too.

SEARCH:  '| tstats `security_content_summariesonly` count  min(_time) as firstTime  max(_time) as lastTime from datamodel=Endpoint.Processes where Processes.process_name=schtasks.exe  Processes.process=*/change*  Processes.process=*/disable* by Processes.user Processes.process_name  Processes.process Processes.parent_process_name Processes.parent_process Processes.dest  | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `disable_schedule_task_filter`'



<li><a href="#">NAME: Disable Security Logs Using MiniNt Registry

DESCRIPTION:  This analytic is to detect a suspicious registry modification to disable  security audit logs. This technique was shared by a researcher to disable Security  logs of windows by adding this registry. The Windows will think it is WinPE and  will not log any event to the Security Log

SEARCH:  '| tstats `security_content_summariesonly` count FROM datamodel=Endpoint.Registry  WHERE (Registry.registry_path="*\\Control\\MiniNt\\*") BY _time span=1h  Registry.user  Registry.dest Registry.registry_path Registry.registry_key_name Registry.registry_value_name  Registry.registry_value_data Registry.process_guid | `drop_dm_object_name(Registry)`  | where isnotnull(registry_value_data) | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `disable_security_logs_using_minint_registry_filter`'



<li><a href="#">NAME: Disable Show Hidden Files

DESCRIPTION:  The following analytic is to identify a modification in the Windows registry  to prevent users from seeing all the files with hidden attributes. This event or  techniques are known on some worm and trojan spy malware that will drop hidden files  on the infected machine.

SEARCH:  '| tstats `security_content_summariesonly` count FROM datamodel=Endpoint.Registry WHERE (Registry.registry_path= "*\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Advanced\\Hidden" OR (Registry.registry_path= "*\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Advanced\\HideFileExt" Registry.registry_value_data = "0x00000001") OR (Registry.registry_path= "*\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Advanced\\ShowSuperHidden" Registry.registry_value_data = "0x00000000" )) BY _time span=1h Registry.user Registry.dest Registry.registry_path Registry.registry_key_name Registry.registry_value_name Registry.registry_value_data Registry.process_guid | `drop_dm_object_name(Registry)`| where isnotnull(registry_value_data) | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `disable_show_hidden_files_filter`'



<li><a href="#">NAME: Disable UAC Remote Restriction

DESCRIPTION:  This analytic is to detect a suspicious modification of registry to disable  UAC remote restriction. This technique was well documented in Microsoft page where  attacker may modify this registry value to bypassed UAC feature of windows host.  This is a good indicator that some tries to bypassed UAC to suspicious process or  gain privilege escalation.

SEARCH:  '| tstats `security_content_summariesonly` count FROM datamodel=Endpoint.Registry  WHERE (Registry.registry_path="*\\CurrentVersion\\Policies\\System*" Registry.registry_value_name="LocalAccountTokenFilterPolicy"  Registry.registry_value_data="0x00000001"  ) BY _time span=1h Registry.user Registry.dest  Registry.registry_path Registry.registry_key_name Registry.registry_value_name Registry.registry_value_data  Registry.process_guid | `drop_dm_object_name(Registry)`| where isnotnull(registry_value_data)  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `disable_uac_remote_restriction_filter`'



<li><a href="#">NAME: Disable Windows App Hotkeys

DESCRIPTION:  The following analytic detects a suspicious registry modification to disable Windows  hotkey (shortcut keys) for native Windows applications. This technique is commonly  used to disable certain or several Windows applications like `taskmgr.exe` and `cmd.exe`.  This technique is used to impair the analyst in analyzing and removing the attacker  implant in compromised systems.

SEARCH:  '| tstats `security_content_summariesonly` count FROM datamodel=Endpoint.Registry  WHERE (Registry.registry_path="*\\Windows NT\\CurrentVersion\\Image File Execution  Options\\*" AND Registry.registry_value_data= "HotKey Disabled" AND Registry.registry_value_name  = "Debugger") BY _time span=1h Registry.dest Registry.user Registry.registry_path Registry.registry_key_name  Registry.registry_value_name Registry.registry_value_data Registry.process_guid  | `drop_dm_object_name(Registry)` | where isnotnull(registry_value_data)  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `disable_windows_app_hotkeys_filter`'



<li><a href="#">NAME: Disable Windows Behavior Monitoring

DESCRIPTION:  This search is to identifies a modification in registry to disable the  windows denfender real time behavior monitoring. This event or technique is commonly  seen in RAT, bot, or Trojan to disable AV to evade detections.

SEARCH:  '| tstats `security_content_summariesonly` count FROM datamodel=Endpoint.Registry  WHERE (Registry.registry_path= "*\\SOFTWARE\\Policies\\Microsoft\\Windows Defender\\Real-Time  Protection\\DisableBehaviorMonitoring" OR Registry.registry_path= "*\\SOFTWARE\\Policies\\Microsoft\\Windows  Defender\\Real-Time Protection\\DisableOnAccessProtection" OR Registry.registry_path=  "*\\SOFTWARE\\Policies\\Microsoft\\Windows Defender\\Real-Time Protection\\DisableScanOnRealtimeEnable"  OR Registry.registry_path= "*\\SOFTWARE\\Microsoft\\Windows Defender\\Real-Time  Protection\\DisableRealtimeMonitoring" OR Registry.registry_path= "*\\Real-Time  Protection\\DisableIntrusionPreventionSystem" OR Registry.registry_path= "*\\Real-Time  Protection\\DisableIOAVProtection" OR Registry.registry_path= "*\\Real-Time Protection\\DisableScriptScanning"  AND Registry.registry_value_data = "0x00000001") BY _time span=1h Registry.dest  Registry.user Registry.registry_path Registry.registry_key_name Registry.registry_value_name  Registry.registry_value_data Registry.process_guid | `drop_dm_object_name(Registry)`  | where isnotnull(registry_value_data) | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `disable_windows_behavior_monitoring_filter`'



<li><a href="#">NAME: Disable Windows SmartScreen Protection

DESCRIPTION:  The following search identifies a modification of registry to disable  the smartscreen protection of windows machine. This is windows feature provide an  early warning system against website that might engage in phishing attack or malware  distribution. This modification are seen in RAT malware to cover their tracks upon  downloading other of its component or other payload.

SEARCH:  '| tstats `security_content_summariesonly` count FROM datamodel=Endpoint.Registry  WHERE Registry.registry_path IN ("*\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\SmartScreenEnabled", "*\\Microsoft\\Windows\\System\\EnableSmartScreen")    Registry.registry_value_data  IN ("Off", "0")   BY _time span=1h Registry.dest Registry.user Registry.registry_path Registry.registry_key_name Registry.registry_value_name Registry.registry_value_data Registry.process_guid   | `drop_dm_object_name(Registry)`  | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)`   | `disable_windows_smartscreen_protection_filter`'



<li><a href="#">NAME: Disabling CMD Application

DESCRIPTION:  This search is to identify modification in registry to disable cmd prompt  application. This technique is commonly seen in RAT, Trojan or WORM to prevent triaging  or deleting there samples through cmd application which is one of the tool of analyst  to traverse on directory and files.

SEARCH:  '| tstats `security_content_summariesonly` count FROM datamodel=Endpoint.Registry  WHERE (Registry.registry_path= "*\\SOFTWARE\\Policies\\Microsoft\\Windows\\System\\DisableCMD"  Registry.registry_value_data = "0x00000001") BY _time span=1h Registry.dest Registry.user Registry.registry_path  Registry.registry_key_name Registry.registry_value_name Registry.registry_value_data  Registry.process_guid | `drop_dm_object_name(Registry)` | where isnotnull(registry_value_data)  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `disabling_cmd_application_filter`'



<li><a href="#">NAME: Disabling ControlPanel

DESCRIPTION:  this search is to identify registry modification to disable control panel  window. This technique is commonly seen in malware to prevent their artifacts ,  persistence removed on the infected machine.

SEARCH:  '| tstats `security_content_summariesonly` count FROM datamodel=Endpoint.Registry  WHERE (Registry.registry_path= "*\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer\\NoControlPanel"  Registry.registry_value_data = "0x00000001") BY _time span=1h Registry.dest Registry.user Registry.registry_path  Registry.registry_key_name Registry.registry_value_name Registry.registry_value_data  Registry.process_guid | `drop_dm_object_name(Registry)`| where isnotnull(registry_value_data)  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `disabling_controlpanel_filter`'



<li><a href="#">NAME: Disabling Defender Services

DESCRIPTION:  This particular behavior is typically executed when an adversaries or  malware gains access to an endpoint and beings to perform execution and to evade  detections. Usually, a batch (.bat) will be executed and multiple registry and scheduled  task modifications will occur. During triage, review parallel processes and identify  any further file modifications. Endpoint should be isolated.

SEARCH:  '| tstats `security_content_summariesonly` count FROM datamodel=Endpoint.Registry  WHERE (Registry.registry_path = "*\\System\\CurrentControlSet\\Services\\*" AND  (Registry.registry_path IN("*WdBoot*", "*WdFilter*", "*WdNisDrv*", "*WdNisSvc*","*WinDefend*",  "*SecurityHealthService*")) AND Registry.registry_value_name = Start Registry.registry_value_data  = 0x00000004) BY _time span=1h Registry.dest Registry.user Registry.registry_path Registry.registry_key_name  Registry.registry_value_name Registry.registry_value_data Registry.process_guid  | `drop_dm_object_name(Registry)`| where isnotnull(registry_value_data)  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `disabling_defender_services_filter`'



<li><a href="#">NAME: Disabling Firewall with Netsh

DESCRIPTION:  This search is to identifies suspicious firewall disabling using netsh  application. this technique is commonly seen in malware that tries to communicate  or download its component or other payload to its C2 server.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where `process_netsh` Processes.process=  "*firewall*" (Processes.process= "*off*" OR  Processes.process= "*disable*") by  Processes.dest Processes.user Processes.parent_process Processes.process_name Processes.original_file_name  Processes.process Processes.process_id Processes.parent_process_id | `drop_dm_object_name(Processes)`  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `disabling_firewall_with_netsh_filter`'



<li><a href="#">NAME: Disabling FolderOptions Windows Feature

DESCRIPTION:  This search is to identify registry modification to disable folder options  feature of windows to show hidden files, file extension and etc. This technique  used by malware in combination if disabling show hidden files feature to hide their  files and also to hide the file extension to lure the user base on file icons or  fake file extensions.

SEARCH:  '| tstats `security_content_summariesonly` count FROM datamodel=Endpoint.Registry  WHERE (Registry.registry_path= "*\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer\\NoFolderOptions"  Registry.registry_value_data = "0x00000001") BY _time span=1h Registry.dest Registry.user  Registry.registry_path Registry.registry_key_name Registry.registry_value_name Registry.registry_value_data  Registry.process_guid | `drop_dm_object_name(Registry)`| where isnotnull(registry_value_data)  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `disabling_folderoptions_windows_feature_filter`'



<li><a href="#">NAME: Disabling Net User Account

DESCRIPTION:  This analytic will identify a suspicious command-line that disables a  user account using the `net.exe` utility native to Windows. This technique may used  by the adversaries to interrupt availability of such users to do their malicious  act.

SEARCH:  '| tstats `security_content_summariesonly` values(Processes.process) as process  values(Processes.parent_process) as parent_process values(Processes.process_id)  as process_id count min(_time) as firstTime max(_time) as lastTime from datamodel=Endpoint.Processes  where `process_net` AND Processes.process="*user*" AND Processes.process="*/active:no*"  by  Processes.process_name Processes.original_file_name Processes.dest Processes.user  Processes.parent_process_name | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `disabling_net_user_account_filter`'



<li><a href="#">NAME: Disabling NoRun Windows App

DESCRIPTION:  This search is to identify modification of registry to disable run application  in window start menu. this application is known to be a helpful shortcut to windows  OS user to run known application and also to execute some reg or batch script. This  technique is used malware to make cleaning of its infection more harder by preventing  known application run easily through run shortcut.

SEARCH:  '| tstats `security_content_summariesonly` count FROM datamodel=Endpoint.Registry  WHERE (Registry.registry_path= "*\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer\\NoRun"  Registry.registry_value_data = "0x00000001") BY _time span=1h Registry.dest Registry.user Registry.registry_path  Registry.registry_key_name Registry.registry_value_name Registry.registry_value_data  Registry.process_guid | `drop_dm_object_name(Registry)`| where isnotnull(registry_value_data)  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `disabling_norun_windows_app_filter`'



<li><a href="#">NAME: Disabling Remote User Account Control

DESCRIPTION:  The search looks for modifications to registry keys that control the  enforcement of Windows User Account Control (UAC).

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime FROM datamodel=Endpoint.Registry where Registry.registry_path=*HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System\\EnableLUA*  Registry.registry_value_data="0x00000000" by Registry.dest, Registry.registry_key_name  Registry.user Registry.registry_path Registry.registry_value_data Registry.action  | `drop_dm_object_name(Registry)` | `disabling_remote_user_account_control_filter`'



<li><a href="#">NAME: Disabling SystemRestore In Registry

DESCRIPTION:  The following search identifies the modification of registry related  in disabling the system restore of a machine. This event or behavior are seen in  some RAT malware to make the restore of the infected machine  difficult and keep  their infection on the box.

SEARCH:  '| tstats `security_content_summariesonly` count FROM datamodel=Endpoint.Registry  WHERE (Registry.registry_path= "*\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\SystemRestore\\DisableSR"  OR Registry.registry_path= "*\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\SystemRestore\\DisableConfig"  OR Registry.registry_path= "*\\SOFTWARE\\Policies\\Microsoft\\Windows NT\\SystemRestore\\DisableSR"  OR Registry.registry_path= "*\\SOFTWARE\\Policies\\Microsoft\\Windows NT\\SystemRestore\\DisableConfig"  Registry.registry_value_data = "0x00000001") BY _time span=1h  Registry.dest Registry.user Registry.registry_path  Registry.registry_key_name Registry.registry_value_name Registry.registry_value_data  Registry.process_guid | `drop_dm_object_name(Registry)`| where isnotnull(registry_value_data)  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `disabling_systemrestore_in_registry_filter`'



<li><a href="#">NAME: Disabling Task Manager

DESCRIPTION:  This search is to identifies modification of registry to disable the  task manager of windows operating system. this event or technique are commonly seen  in malware such as RAT, Trojan, TrojanSpy or worm to prevent the user to terminate  their process.

SEARCH:  '| tstats `security_content_summariesonly` count FROM datamodel=Endpoint.Registry  WHERE (Registry.registry_path= "*\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System\\DisableTaskMgr"  Registry.registry_value_data = "0x00000001") BY _time span=1h Registry.dest Registry.user Registry.registry_path  Registry.registry_key_name Registry.registry_value_name Registry.registry_value_data  Registry.process_guid | `drop_dm_object_name(Registry)` | where isnotnull(registry_value_data)  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `disabling_task_manager_filter`'



<li><a href="#">NAME: Disabling Windows Local Security Authority Defences via Registry

DESCRIPTION:  This detection looks for the deletion of registry keys which disable  LSA protection and MS Defender Device Guard.

SEARCH:  '| tstats `security_content_summariesonly` min(_time) as _time from datamodel=Endpoint.Registry  where Registry.registry_path IN ("*\\SYSTEM\\CurrentControlSet\\Control\\Lsa\\LsaCfgFlags",  "*\\SOFTWARE\\Policies\\Microsoft\\Windows\\DeviceGuard\\*", "*\\SYSTEM\\CurrentControlSet\\Control\\Lsa\\RunAsPPL")  Registry.action IN (deleted, unknown) by Registry.action Registry.registry_path  Registry.process_guid Registry.dest Registry.user| `drop_dm_object_name(Registry)` | join type=outer process_guid  [| tstats `security_content_summariesonly` count FROM datamodel=Endpoint.Processes  by Processes.user Processes.process_name Processes.process Processes.dest Processes.parent_process_name  Processes.parent_process Processes.process_guid | `drop_dm_object_name(Processes)`]  | table _time action dest user parent_process_name parent_process process_name process  process_guid registry_path | `disabling_windows_local_security_authority_defences_via_registry_filter`'



<li><a href="#">NAME: DLLHost with no Command Line Arguments with Network

DESCRIPTION:  The following analytic identifies DLLHost.exe with no command line arguments  with a network connection. It is unusual for DLLHost.exe to execute with no command  line arguments present. This particular behavior is common with malicious software,  including Cobalt Strike. During investigation, triage any network connections and  parallel processes. Identify any suspicious module loads related to credential dumping  or file writes. DLLHost.exe is natively found in C:\Windows\system32 and C:\Windows\syswow64.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime FROM datamodel=Endpoint.Processes where Processes.process_name=dllhost.exe  Processes.action!="blocked" by host _time span=1h Processes.process_id Processes.process_name  Processes.dest Processes.process_path Processes.process Processes.parent_process_name  Processes.parent_process | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | regex process="(?i)(dllhost\.exe.{0,4}$)"  | rename dest as src | join host process_id [| tstats `security_content_summariesonly`  count latest(All_Traffic.dest) as dest latest(All_Traffic.dest_ip) as dest_ip latest(All_Traffic.dest_port)  as dest_port FROM datamodel=Network_Traffic.All_Traffic where All_Traffic.dest_port  != 0 by host All_Traffic.process_id | `drop_dm_object_name(All_Traffic)`] | `dllhost_with_no_command_line_arguments_with_network_filter`'



<li><a href="#">NAME: DNS Exfiltration Using Nslookup App

DESCRIPTION:  this search is to detect potential DNS exfiltration using nslookup application.  This technique are seen in couple of malware and APT group to exfiltrated collected  data in a infected machine or infected network. This detection is looking for unique  use of nslookup where it tries to use specific record type, TXT, A, AAAA, that are  commonly used by attacker and also the retry parameter which is designed to query  C2 DNS multiple tries.

SEARCH:  '| tstats `security_content_summariesonly` values(Processes.process) as process  values(Processes.process_id) as process_id values(Processes.parent_process) as parent_process  count min(_time) as firstTime max(_time) as lastTime from datamodel=Endpoint.Processes  where Processes.process_name = "nslookup.exe" Processes.process = "*-querytype=*"  OR Processes.process="*-qt=*" OR Processes.process="*-q=*" OR Processes.process="-type=*"  OR Processes.process="*-retry=*" by Processes.dest Processes.user Processes.process_name Processes.process Processes.parent_process_name  |  `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `dns_exfiltration_using_nslookup_app_filter`'



<li><a href="#">NAME: DNS Query Length Outliers - MLTK

DESCRIPTION:  This search allows you to identify DNS requests that are unusually large  for the record type being requested in your environment.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as start_time  max(_time) as end_time values(DNS.src) as src values(DNS.dest) as dest from datamodel=Network_Resolution  by DNS.query DNS.record_type | search DNS.record_type=* |  `drop_dm_object_name(DNS)`  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | eval  query_length = len(query) | apply dns_query_pdfmodel threshold=0.01 | rename "IsOutlier(query_length)"  as isOutlier | search isOutlier > 0 | sort -query_length | table start_time end_time  query record_type count src dest query_length | `dns_query_length_outliers___mltk_filter` '



<li><a href="#">NAME: DNS Query Length With High Standard Deviation

DESCRIPTION:  This search allows you to identify DNS requests and compute the standard  deviation on the length of the names being resolved, then filter on two times the  standard deviation to show you those queries that are unusually large for your environment.

SEARCH:  '| tstats `security_content_summariesonly` count from datamodel=Network_Resolution  where NOT DNS.record_type IN("Pointer","PTR") by DNS.query host| `drop_dm_object_name("DNS")`  | eval tlds=split(query,".") | eval tld=mvindex(tlds,-1) | eval tld_len=len(tld)  | search tld_len<=24 | eval query_length = len(query) | table host query query_length  record_type count | eventstats stdev(query_length) AS stdev avg(query_length) AS  avg p50(query_length) AS p50| where query_length>(avg+stdev*2) | eval z_score=(query_length-avg)/stdev  | `dns_query_length_with_high_standard_deviation_filter`'



<li><a href="#">NAME: Domain Account Discovery with Dsquery

DESCRIPTION:  This analytic looks for the execution of `dsquery.exe` with command-line  arguments utilized to discover  domain users. The `user` argument returns a list  of all users registered in the domain. Red Teams and adversaries alike engage in  remote system discovery for situational awareness and Active Directory Discovery.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.process_name="dsquery.exe"  AND Processes.process = "*user*" by Processes.dest Processes.user Processes.parent_process  Processes.process_name Processes.process Processes.process_id Processes.parent_process_id  Processes.parent_process_name | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `domain_account_discovery_with_dsquery_filter`'



<li><a href="#">NAME: Domain Account Discovery With Net App

DESCRIPTION:  This analytic looks for the execution of `net.exe` or `net1.exe` with  command-line arguments utilized to query for domain users. Red Teams and adversaries  alike may use net.exe to enumerate domain users for situational awareness and Active  Directory Discovery.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where `process_net` AND Processes.process  = "* user*" AND Processes.process = "*/do*" by Processes.dest Processes.user Processes.parent_process  Processes.process_name Processes.process Processes.process_id Processes.parent_process_id  Processes.parent_process_name | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `domain_account_discovery_with_net_app_filter`'



<li><a href="#">NAME: Domain Account Discovery with Wmic

DESCRIPTION:  This analytic looks for the execution of `wmic.exe` with command-line  arguments utilized to query for domain users. Red Teams and adversaries alike use  wmic.exe to enumerate domain users for situational awareness and Active Directory  Discovery.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.process_name="wmic.exe"  AND Processes.process = "*/NAMESPACE:\\\\root\\directory\\ldap*" AND Processes.process  = "*ds_user*" AND Processes.process = "*GET*" AND Processes.process = "*ds_samaccountname*"  by Processes.dest Processes.user Processes.parent_process Processes.process_name  Processes.process Processes.process_id Processes.parent_process_id Processes.parent_process_name  | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `domain_account_discovery_with_wmic_filter`'



<li><a href="#">NAME: Domain Controller Discovery with Nltest

DESCRIPTION:  This analytic looks for the execution of `nltest.exe` with command-line  arguments utilized to discover remote systems. The arguments `/dclist:` and '/dsgetdc:',  can be used to return a list of all domain controllers. Red Teams and adversaries  alike may use nltest.exe to identify domain controllers in a Windows Domain for  situational awareness and Active Directory Discovery.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where (Processes.process_name="nltest.exe")  (Processes.process="*/dclist:*" OR Processes.process="*/dsgetdc:*") by Processes.dest  Processes.user Processes.parent_process Processes.process_name Processes.process  Processes.process_id Processes.parent_process_id | `drop_dm_object_name(Processes)`  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `domain_controller_discovery_with_nltest_filter`'



<li><a href="#">NAME: Domain Controller Discovery with Wmic

DESCRIPTION:  This analytic looks for the execution of `wmic.exe` with command-line  arguments utilized to discover remote systems. The arguments utilized in this command  line return a list of all domain controllers in a Windows domain. Red Teams and  adversaries alike use *.exe to identify remote systems for situational awareness  and Active Directory Discovery.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where (Processes.process_name="wmic.exe")  (Processes.process="" OR Processes.process="*DomainControllerAddress*") by Processes.dest  Processes.user Processes.parent_process Processes.process_name Processes.process  Processes.process_id Processes.parent_process_id | `drop_dm_object_name(Processes)`  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `domain_controller_discovery_with_wmic_filter`'



<li><a href="#">NAME: Domain Group Discovery with Adsisearcher

DESCRIPTION:  The following analytic utilizes PowerShell Script Block Logging (EventCode=4104)  to identify the `[Adsisearcher]` type accelerator being used to query Active Directory  for domain groups. Red Teams and adversaries may leverage `[Adsisearcher]` to enumerate  domain groups for situational awareness and Active Directory Discovery.

SEARCH:  '`powershell` EventCode=4104 (Message = "*[adsisearcher]*" AND Message = "*(objectcategory=group)*"  AND Message = "*findAll()*") | stats count min(_time) as firstTime max(_time) as  lastTime by EventCode Message ComputerName User | rename ComputerName as dest |rename User as user | `security_content_ctime(firstTime)`  | `domain_group_discovery_with_adsisearcher_filter`'



<li><a href="#">NAME: Domain Group Discovery With Dsquery

DESCRIPTION:  This analytic looks for the execution of `dsquery.exe` with command-line  arguments utilized to query for domain groups. The argument `group`, returns a list  of all domain groups. Red Teams and adversaries alike use may leverage dsquery.exe  to enumerate domain groups for situational awareness and Active Directory Discovery.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where (Processes.process_name="dsquery.exe")  (Processes.process="*group*") by Processes.dest Processes.user Processes.parent_process  Processes.process_name Processes.process Processes.process_id Processes.parent_process_id  | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `domain_group_discovery_with_dsquery_filter`'



<li><a href="#">NAME: Domain Group Discovery With Net

DESCRIPTION:  This analytic looks for the execution of `net.exe` with command-line  arguments utilized to query for domain groups. The argument `group /domain`, returns  a list of all domain groups. Red Teams and adversaries alike use net.exe to enumerate  domain groups for situational awareness and Active Directory Discovery.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where (Processes.process_name="net.exe"  OR Processes.process_name="net1.exe") (Processes.process=*group* AND Processes.process=*/do*)  by Processes.dest Processes.user Processes.parent_process Processes.process_name  Processes.process Processes.process_id Processes.parent_process_id | `drop_dm_object_name(Processes)`  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `domain_group_discovery_with_net_filter`'



<li><a href="#">NAME: Domain Group Discovery With Wmic

DESCRIPTION:  This analytic looks for the execution of `wmic.exe` with command-line  arguments utilized to query for domain groups. The arguments utilized in this command  return a list of all domain groups. Red Teams and adversaries alike use wmic.exe  to enumerate domain groups for situational awareness and Active Directory Discovery.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where (Processes.process_name="wmic.exe")  (Processes.process=*/NAMESPACE:\\\\root\\directory\\ldap* AND Processes.process=*ds_group*  AND Processes.process="*GET ds_samaccountname*") by Processes.dest Processes.user  Processes.parent_process Processes.process_name Processes.process Processes.process_id  Processes.parent_process_id | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `domain_group_discovery_with_wmic_filter`'



<li><a href="#">NAME: Download Files Using Telegram

DESCRIPTION:  The following analytic will identify a suspicious download by the Telegram  application on a Windows system. This behavior was identified on a honeypot where  the adversary gained access, installed Telegram and followed through with downloading  different network scanners (port, bruteforcer, masscan) to the system and later  used to mapped the whole network and further move laterally.

SEARCH:  '`sysmon` EventCode= 15 process_name = "telegram.exe" TargetFilename = "*:Zone.Identifier"  |stats count min(_time) as firstTime max(_time) as lastTime by dest EventCode  process_name process_id TargetFilename Hash | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `download_files_using_telegram_filter`'



<li><a href="#">NAME: Drop IcedID License dat

DESCRIPTION:  This search is to detect dropping a suspicious file named as "license.dat"  in %appdata%. This behavior seen in latest IcedID malware that contain the actual  core bot that will be injected in other process to do banking stealing.

SEARCH:  '`sysmon` EventCode= 11  TargetFilename = "*\\license.dat" AND (TargetFilename="*\\appdata\\*"  OR TargetFilename="*\\programdata\\*") |stats count min(_time) as firstTime max(_time)  as lastTime by TargetFilename EventCode process_id  process_name dest | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `drop_icedid_license_dat_filter`'



<li><a href="#">NAME: DSQuery Domain Discovery

DESCRIPTION:  'The following analytic identifies "dsquery.exe" execution with arguments  looking for `TrustedDomain` query directly on the command-line. This is typically  indicative of an Administrator or adversary perform domain trust discovery. Note  that this query does not identify any other variations of "Dsquery.exe" usage.\  Within this detection, it is assumed `dsquery.exe` is not moved or renamed.\  The search will return the first time and last time these command-line arguments  were used for these executions, as well as the target system, the user, process  "dsquery.exe" and its parent process.\  DSQuery.exe is natively found in `C:\Windows\system32` and `C:\Windows\syswow64`  and only on Server operating system.\  The following DLL(s) are loaded when DSQuery.exe is launched `dsquery.dll`. If found  loaded by another process, it is possible dsquery is running within that process  context in memory.\  In addition to trust discovery, review parallel processes for additional behaviors  performed. Identify the parent process and capture any files (batch files, for example)  being used.'

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.process_name=dsquery.exe  Processes.process=*trustedDomain* by Processes.dest Processes.user Processes.parent_process_name Processes.parent_process  Processes.process_name Processes.process Processes.process_id Processes.parent_process_id  | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `dsquery_domain_discovery_filter`'



<li><a href="#">NAME: Dump LSASS via comsvcs DLL

DESCRIPTION:  |-  The following analytic detects the behavior of dumping credentials from memory, a tactic commonly used by adversaries to exploit the Local Security Authority Subsystem Service (LSASS) in Windows, which manages system-level authentication. The detection is made by monitoring logs with process information from endpoints and identifying instances where the rundll32 process is used in conjunction with the comsvcs.dll and MiniDump. This indicates potential LSASS dumping attempts used by threat actors to obtain valuable credentials. The detection is important because credential theft can lead to broader system compromise, persistence, lateral movement, and escalated privileges. No legitimate use of this technique has been identified yet. This behavior is often part of more extensive attack campaigns and is associated with numerous threat groups that use the stolen credentials to access sensitive information or systems, leading to data theft, ransomware attacks, or other damaging outcomes. False positives can occur since legitimate uses of the LSASS process can cause benign activities to be flagged. Next steps include reviewing the processes involved in the LSASS dumping attempt after triage and inspecting any relevant on-disk artifacts and concurrent processes to identify the attack source.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where `process_rundll32` Processes.process=*comsvcs.dll*  Processes.process=*MiniDump* by Processes.user Processes.parent_process_name Processes.process_name  Processes.original_file_name Processes.process Processes.dest | `drop_dm_object_name(Processes)`  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `dump_lsass_via_comsvcs_dll_filter`'



<li><a href="#">NAME: Dump LSASS via procdump

DESCRIPTION:  'Detect procdump.exe dumping the lsass process. This query looks for  both -mm and -ma usage. -mm will produce a mini dump file and -ma will write a dump  file with all process memory. Both are highly suspect and should be reviewed. This  query does not monitor for the internal name (original_file_name=procdump) of the  PE or look for procdump64.exe. Modify the query as needed.\  During triage, confirm this is procdump.exe executing. If it is the first time a  Sysinternals utility has been ran, it is possible there will be a -accepteula on  the command line. Review other endpoint data sources for cross process (injection)  into lsass.exe.'

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where `process_procdump` (Processes.process=*-ma*  OR Processes.process=*-mm*) Processes.process=*lsass* by Processes.user Processes.parent_process_name Processes.process_name  Processes.process Processes.original_file_name Processes.dest | `drop_dm_object_name(Processes)`  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `dump_lsass_via_procdump_filter`'



<li><a href="#">NAME: Elevated Group Discovery With Net

DESCRIPTION:  This analytic looks for the execution of `net.exe` or `net1.exe`  with  command-line arguments utilized to query for specific elevated domain groups. Red  Teams and adversaries alike use net.exe to enumerate elevated domain groups for  situational awareness and Active Directory Discovery to identify high privileged  users.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where (Processes.process_name="net.exe"  OR Processes.process_name="net1.exe") (Processes.process="*group*" AND Processes.process="*/do*")  (Processes.process="*Domain Admins*" OR Processes.process="*Enterprise Admins*"  OR Processes.process="*Schema Admins*" OR Processes.process="*Account Operators*"  OR Processes.process="*Server Operators*" OR Processes.process="*Protected Users*"  OR Processes.process="*Dns Admins*") by Processes.dest Processes.user Processes.parent_process  Processes.process_name Processes.process Processes.process_id Processes.parent_process_id  | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `elevated_group_discovery_with_net_filter`'



<li><a href="#">NAME: Elevated Group Discovery with PowerView

DESCRIPTION:  The following analytic utilizes PowerShell Script Block Logging (EventCode=4104)  to identify the execution of the `Get-DomainGroupMember` commandlet. `Get-DomainGroupMember`  is part of PowerView, a PowerShell tool used to perform enumeration on Windows domains.  As the name suggests, `Get-DomainGroupMember` is used to list the members of an  specific domain group. Red Teams and adversaries alike use PowerView to enumerate  elevated domain groups for situational awareness and Active Directory Discovery  to identify high privileged users.

SEARCH:  '`powershell` EventCode=4104 (Message = "*Get-DomainGroupMember*") AND Message  IN ("*Domain Admins*","*Enterprise Admins*", "*Schema Admins*", "*Account Operators*"  , "*Server Operators*", "*Protected Users*",  "*Dns Admins*") | stats count min(_time)  as firstTime max(_time) as lastTime by EventCode Message ComputerName User | rename ComputerName as dest, User as user | `security_content_ctime(firstTime)`  | `elevated_group_discovery_with_powerview_filter`'



<li><a href="#">NAME: Elevated Group Discovery With Wmic

DESCRIPTION:  This analytic looks for the execution of `wmic.exe` with command-line  arguments utilized to query for specific domain groups. Red Teams and adversaries  alike use net.exe to enumerate elevated domain groups for situational awareness  and Active Directory Discovery to identify high privileged users.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where (Processes.process_name="wmic.exe")  (Processes.process=*/NAMESPACE:\\\\root\\directory\\ldap*) (Processes.process="*Domain  Admins*" OR Processes.process="*Enterprise Admins*" OR Processes.process="*Schema  Admins*" OR Processes.process="*Account Operators*" OR Processes.process="*Server  Operators*" OR Processes.process="*Protected Users*" OR Processes.process="*Dns  Admins*") by Processes.dest Processes.user Processes.parent_process Processes.process_name  Processes.process Processes.process_id Processes.parent_process_id | `drop_dm_object_name(Processes)`  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `elevated_group_discovery_with_wmic_filter`'



<li><a href="#">NAME: Enable RDP In Other Port Number

DESCRIPTION:  This search is to detect a modification to registry to enable rdp to  a machine with different port number. This technique was seen in some atttacker  tries to do lateral movement and remote access to a compromised machine to gain  control of it.

SEARCH:  '| tstats `security_content_summariesonly` count FROM datamodel=Endpoint.Registry  WHERE (Registry.registry_path="*HKLM\\SYSTEM\\CurrentControlSet\\Control\\Terminal  Server\\WinStations\\RDP-Tcp*" Registry.registry_value_name = "PortNumber") BY _time  span=1h Registry.dest Registry.user Registry.registry_path Registry.registry_key_name Registry.registry_value_name  Registry.registry_value_data Registry.process_guid | `drop_dm_object_name(Registry)` | where isnotnull(registry_value_data) | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `enable_rdp_in_other_port_number_filter`'



<li><a href="#">NAME: Enable WDigest UseLogonCredential Registry

DESCRIPTION:  This analytic is to detect a suspicious registry modification to enable  plain text credential feature of windows. This technique was used by several malware  and also by mimikatz to be able to dumpe the a plain text credential to the compromised  or target host. This TTP is really a good indicator that someone wants to dump the  crendential of the host so it must be a good pivot for credential dumping techniques.

SEARCH:  '| tstats `security_content_summariesonly` count FROM datamodel=Endpoint.Registry  WHERE (Registry.registry_path="*\\System\\CurrentControlSet\\Control\\SecurityProviders\\WDigest\\*"  Registry.registry_value_name = "UseLogonCredential" Registry.registry_value_data=0x00000001) BY _time span=1h Registry.dest Registry.user Registry.registry_path Registry.registry_key_name  Registry.registry_value_name Registry.registry_value_data Registry.process_guid  | `drop_dm_object_name(Registry)` | where isnotnull(registry_value_data)  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `enable_wdigest_uselogoncredential_registry_filter`'



<li><a href="#">NAME: Enumerate Users Local Group Using Telegram

DESCRIPTION:  This analytic will detect a suspicious Telegram process enumerating all  network users in a local group. This technique was seen in a Monero infected honeypot  to mapped all the users on the compromised system. EventCode 4798 is generated when  a process enumerates a user's security-enabled local groups on a computer or device.

SEARCH:  '`wineventlog_security` EventCode=4798  Process_Name = "*\\telegram.exe" |  stats count min(_time) as firstTime max(_time) as lastTime by user dest EventCode  Process_Name  Process_ID Account_Name Account_Domain Logon_ID Security_ID Message  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `enumerate_users_local_group_using_telegram_filter`'



<li><a href="#">NAME: Esentutl SAM Copy

DESCRIPTION:  The following analytic identifies the process - `esentutl.exe` - being  used to capture credentials stored in ntds.dit or the SAM file on disk. During triage,  review parallel processes and determine if legitimate activity. Upon determination  of illegitimate activity, take further action to isolate and contain the threat.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where `process_esentutl` Processes.process  IN ("*ntds*", "*SAM*") by Processes.dest Processes.user Processes.parent_process_name  Processes.process_name Processes.original_file_name Processes.process Processes.process_id  Processes.parent_process_id | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `esentutl_sam_copy_filter`'



<li><a href="#">NAME: ETW Registry Disabled

DESCRIPTION:  This analytic is to detect a registry modification to disable ETW feature  of windows. This technique is to evade EDR appliance to evade detections and hide  its execution from audit logs.

SEARCH:  '| tstats `security_content_summariesonly` count FROM datamodel=Endpoint.Registry  WHERE (Registry.registry_path="*\\SOFTWARE\\Microsoft\\.NETFramework*" Registry.registry_value_name  = ETWEnabled Registry.registry_value_data=0x00000000) BY _time span=1h Registry.dest  Registry.user Registry.registry_path Registry.registry_key_name Registry.registry_value_name  Registry.registry_value_data Registry.process_guid | `drop_dm_object_name(Registry)`  | where isnotnull(registry_value_data) | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `etw_registry_disabled_filter`'



<li><a href="#">NAME: Eventvwr UAC Bypass

DESCRIPTION:  The following search identifies Eventvwr bypass by identifying the registry  modification into a specific path that eventvwr.msc looks to (but is not valid)  upon execution. A successful attack will include a suspicious command to be executed  upon eventvwr.msc loading. Upon triage, review the parallel processes that have  executed. Identify any additional registry modifications on the endpoint that may  look suspicious. Remediate as necessary.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) AS firstTime max(_time)  AS lastTime FROM datamodel=Endpoint.Processes BY _time span=1h Processes.user Processes.process_id  Processes.process_name Processes.process Processes.process_path Processes.dest Processes.parent_process_name  Processes.parent_process Processes.process_guid | `drop_dm_object_name(Processes)`  | join process_guid [ | tstats `security_content_summariesonly` count FROM datamodel=Endpoint.Registry  WHERE (Registry.registry_path="*mscfile\\shell\\open\\command\\*") BY _time span=1h  Registry.registry_path Registry.registry_key_name Registry.registry_value_name Registry.registry_value_data  Registry.process_guid | `drop_dm_object_name(Registry)`] | fields firstTime lastTime  dest user parent_process_name parent_process process_name process_path process registry_key_name  registry_path registry_value_name registry_value_data process_guid | where isnotnull(registry_value_data)  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `eventvwr_uac_bypass_filter`'



<li><a href="#">NAME: Excel Spawning PowerShell

DESCRIPTION:  The following detection identifies Microsoft Excel spawning PowerShell.  Typically, this is not common behavior and not default with Excel.exe. Excel.exe  will generally be found in the following path `C:\Program Files\Microsoft Office\root\Office16`  (version will vary). PowerShell spawning from Excel.exe is common for a spearphishing  attachment and is actively used. Albeit, the command executed will most likely be  encoded and captured via another detection. During triage, review parallel processes  and identify any files that may have been written.

SEARCH:  '| tstats `security_content_summariesonly` count values(Processes.process)  min(_time) as firstTime max(_time) as lastTime from datamodel=Endpoint.Processes  where Processes.parent_process_name="excel.exe" `process_powershell` by Processes.parent_process Processes.parent_process_name  Processes.process_name Processes.user Processes.dest Processes.original_file_name  | `drop_dm_object_name("Processes")` | `security_content_ctime(firstTime)`|`security_content_ctime(lastTime)`  | `excel_spawning_powershell_filter`'



<li><a href="#">NAME: Excel Spawning Windows Script Host

DESCRIPTION:  The following detection identifies Microsoft Excel spawning Windows Script  Host - `cscript.exe` or `wscript.exe`. Typically, this is not common behavior and  not default with Excel.exe. Excel.exe will generally be found in the following path  `C:\Program Files\Microsoft Office\root\Office16` (version will vary). `cscript.exe`  or `wscript.exe` default location is `c:\windows\system32\` or c:windows\syswow64`.  `cscript.exe` or `wscript.exe` spawning from Excel.exe is common for a spearphishing  attachment and is actively used. Albeit, the command-line executed will most likely  be obfuscated and captured via another detection. During triage, review parallel  processes and identify any files that may have been written. Review the reputation  of the remote destination and block accordingly.

SEARCH:  '| tstats `security_content_summariesonly` count values(Processes.process)  min(_time) as firstTime max(_time) as lastTime from datamodel=Endpoint.Processes  where Processes.parent_process_name="excel.exe" Processes.process_name IN ("cscript.exe",  "wscript.exe")  by Processes.parent_process Processes.parent_process_name Processes.process_name Processes.user  Processes.dest | `drop_dm_object_name("Processes")` | `security_content_ctime(firstTime)`|`security_content_ctime(lastTime)`  | `excel_spawning_windows_script_host_filter`'



<li><a href="#">NAME: Excessive Attempt To Disable Services

DESCRIPTION:  This analytic will identify suspicious series of command-line to disable  several services. This technique is seen where the adversary attempts to disable  security app services or other malware services to complete the objective on the  compromised system.

SEARCH:  '| tstats `security_content_summariesonly` values(Processes.process) as process  values(Processes.process_id) as process_id count min(_time) as firstTime max(_time)  as lastTime  from datamodel=Endpoint.Processes where   Processes.process_name =  "sc.exe" AND Processes.process="*config*" OR Processes.process="*Disabled*" by Processes.process_name  Processes.parent_process_name Processes.dest Processes.user _time span=1m | where  count >=4 | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `excessive_attempt_to_disable_services_filter`'



<li><a href="#">NAME: Excessive distinct processes from Windows Temp

DESCRIPTION:  This analytic will identify suspicious series of process executions.  We  have observed that post exploit framework tools like Koadic and Meterpreter will  launch an excessive number of processes with distinct file paths from Windows\Temp  to execute actions on objective.  This behavior is extremely anomalous compared  to typical application behaviors that use Windows\Temp.

SEARCH:  '| tstats `security_content_summariesonly` values(Processes.process) as process  distinct_count(Processes.process) as distinct_process_count  min(_time) as firstTime  max(_time) as lastTime from datamodel=Endpoint.Processes where Processes.process_path  = "*\\Windows\\Temp\\*" by Processes.dest Processes.user  _time span=20m | where  distinct_process_count > 37 | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `excessive_distinct_processes_from_windows_temp_filter`'



<li><a href="#">NAME: Excessive DNS Failures

DESCRIPTION:  This search identifies DNS query failures by counting the number of DNS  responses that do not indicate success, and trigger on more than 50 occurrences.

SEARCH:  '| tstats `security_content_summariesonly` count from datamodel=Network_Resolution  where nodename=DNS "DNS.reply_code"!="No Error" "DNS.reply_code"!="NoError" DNS.reply_code!="unknown"  NOT "DNS.query"="*.arpa" "DNS.query"="*.*" by "DNS.src" "DNS.query" "DNS.reply_code"  | `drop_dm_object_name("DNS")` | lookup cim_corporate_web_domain_lookup domain as  query OUTPUT domain | where isnull(domain) | lookup update=true alexa_lookup_by_str  domain as query OUTPUT rank | where isnull(rank) | eventstats max(count) as mc by  src reply_code | eval mode_query=if(count=mc, query, null()) | stats sum(count)  as count values(mode_query) as query values(mc) as max_query_count by src reply_code  | where count>50 | `get_asset(src)` | `excessive_dns_failures_filter` '



<li><a href="#">NAME: Excessive File Deletion In WinDefender Folder

DESCRIPTION:  This analytic will identify excessive file deletion events in the Windows  Defender folder. This technique was seen in the WhisperGate malware campaign in  which adversaries abused Nirsofts advancedrun.exe to gain administrative privilege  to then execute PowerShell commands to delete files within the Windows Defender  application folder. This behavior is a good indicator the offending process is trying  to corrupt a Windows Defender installation.

SEARCH:  '`sysmon` EventCode=23 TargetFilename = "*\\ProgramData\\Microsoft\\Windows  Defender*" | stats values(TargetFilename) as deleted_files min(_time) as firstTime  max(_time) as lastTime count by user EventCode Image ProcessID dest |where count  >=50 | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `excessive_file_deletion_in_windefender_folder_filter`'



<li><a href="#">NAME: Excessive number of service control start as disabled

DESCRIPTION:  This detection targets behaviors observed when threat actors have used  sc.exe to modify services. We observed malware in a honey pot spawning numerous  sc.exe processes in a short period of time, presumably to impair defenses, possibly  to block others from compromising the same machine.  This detection will alert when  we see both an excessive number of sc.exe processes launched with specific commandline  arguments to disable the start of certain services.

SEARCH:  '| tstats `security_content_summariesonly` distinct_count(Processes.process)  as distinct_cmdlines values(Processes.process_id) as process_ids min(_time) as firstTime  max(_time) as lastTime FROM datamodel=Endpoint.Processes WHERE Processes.process_name  = "sc.exe" AND Processes.process="*start= disabled*" by Processes.dest Processes.user  Processes.parent_process Processes.process_name Processes.parent_process_id, _time  span=30m | where distinct_cmdlines >= 8 | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `excessive_number_of_service_control_start_as_disabled_filter`'



<li><a href="#">NAME: Excessive number of taskhost processes

DESCRIPTION:  This detection targets behaviors observed in post exploit kits like Meterpreter  and Koadic that are run in memory.  We have observed that these tools must invoke  an excessive number of taskhost.exe and taskhostex.exe processes to complete various  actions (discovery, lateral movement, etc.).  It is extremely uncommon in the course  of normal operations to see so many distinct taskhost and taskhostex processes running  concurrently in a short time frame.

SEARCH:  '| tstats `security_content_summariesonly` values(Processes.process_id) as  process_ids  min(_time) as firstTime max(_time) as lastTime FROM datamodel=Endpoint.Processes  WHERE Processes.process_name = "taskhost.exe" OR Processes.process_name = "taskhostex.exe"  BY Processes.dest Processes.process_name _time span=1h | `drop_dm_object_name(Processes)`  | eval pid_count=mvcount(process_ids) | eval taskhost_count_=if(process_name ==  "taskhost.exe", pid_count, 0) | eval taskhostex_count_=if(process_name == "taskhostex.exe",  pid_count, 0) | stats sum(taskhost_count_) as taskhost_count, sum(taskhostex_count_)  as taskhostex_count by _time, dest, firstTime, lastTime | where taskhost_count >  10 and taskhostex_count > 10 | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `excessive_number_of_taskhost_processes_filter`'



<li><a href="#">NAME: Excessive Service Stop Attempt

DESCRIPTION:  This analytic identifies suspicious series of attempt to kill multiple  services on a system using either `net.exe` or `sc.exe`. This technique is use by  adversaries to terminate security services or other related services to continue  there objective and evade detections.

SEARCH:  '| tstats `security_content_summariesonly` values(Processes.process) as process  values(Processes.process_id) as process_id count min(_time) as firstTime max(_time)  as lastTime  from datamodel=Endpoint.Processes where `process_net` OR  Processes.process_name  = "sc.exe" OR  Processes.process_name = "net1.exe" AND Processes.process="*stop*"  OR Processes.process="*delete*" by Processes.process_name Processes.original_file_name  Processes.parent_process_name Processes.dest Processes.user _time span=1m | where  count >=5 | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `excessive_service_stop_attempt_filter`'



<li><a href="#">NAME: Excessive Usage Of Cacls App

DESCRIPTION:  The following analytic identifies excessive usage of `cacls.exe`, `xcacls.exe`  or `icacls.exe` application to change file or folder permission. This behavior is  commonly seen where the adversary attempts to impair some users from deleting or  accessing its malware components or artifact from the compromised system.

SEARCH:  '| tstats `security_content_summariesonly` values(Processes.process) as process  values(Processes.process_id) as process_id  values(Processes.process_name) as process_name  count min(_time) as firstTime max(_time) as lastTime  from datamodel=Endpoint.Processes  where Processes.process_name = "cacls.exe" OR Processes.process_name = "icacls.exe"  OR Processes.process_name = "XCACLS.exe" by Processes.parent_process_name Processes.parent_process  Processes.dest Processes.user _time span=1m | where count >=10 | `drop_dm_object_name(Processes)`  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `excessive_usage_of_cacls_app_filter`'



<li><a href="#">NAME: Excessive Usage Of Net App

DESCRIPTION:  This analytic identifies excessive usage of `net.exe` or `net1.exe` within  a bucket of time (1 minute). This behavior was seen in a Monero incident where the  adversary attempts to create many users, delete and disable users as part of its  malicious behavior.

SEARCH:  '| tstats `security_content_summariesonly` values(Processes.process) as process  values(Processes.process_id) as process_id count min(_time) as firstTime max(_time)  as lastTime  from datamodel=Endpoint.Processes where `process_net` by Processes.process_name  Processes.parent_process_name Processes.original_file_name Processes.dest Processes.user  _time span=1m | where count >=10 | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `excessive_usage_of_net_app_filter`'



<li><a href="#">NAME: Excessive Usage of NSLOOKUP App

DESCRIPTION:  This search is to detect potential DNS exfiltration using nslookup application.  This technique are seen in couple of malware and APT group to exfiltrated collected  data in a infected machine or infected network. This detection is looking for unique  use of nslookup where it tries to use specific record type (TXT, A, AAAA) that are  commonly used by attacker and also the retry parameter which is designed to query  C2 DNS multiple tries.

SEARCH:  '`sysmon` EventCode = 1 process_name = "nslookup.exe" | bucket _time span=1m  | stats count as numNsLookup by dest, _time | eventstats avg(numNsLookup) as  avgNsLookup, stdev(numNsLookup) as stdNsLookup, count as numSlots by dest |  eval upperThreshold=(avgNsLookup + stdNsLookup *3) | eval isOutlier=if(numNsLookup  > 20 and numNsLookup >= upperThreshold, 1, 0) | search isOutlier=1 | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `excessive_usage_of_nslookup_app_filter`'



<li><a href="#">NAME: Excessive Usage Of SC Service Utility

DESCRIPTION:  This search is to detect a suspicious excessive usage of sc.exe in a  host machine. This technique was seen in several ransomware , xmrig and other malware  to create, modify, delete or disable a service may related to security application  or to gain privilege escalation.

SEARCH:  '`sysmon` EventCode = 1 process_name = "sc.exe" |  bucket _time span=15m |  stats values(process) as process count as numScExe by dest, _time |  eventstats  avg(numScExe) as avgScExe, stdev(numScExe) as stdScExe, count as numSlots by dest  |  eval upperThreshold=(avgScExe + stdScExe *3) |  eval isOutlier=if(avgScExe >  5 and avgScExe >= upperThreshold, 1, 0) |  search isOutlier=1 | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `excessive_usage_of_sc_service_utility_filter`'



<li><a href="#">NAME: Excessive Usage Of Taskkill

DESCRIPTION:  This analytic identifies excessive usage of `taskkill.exe` application.  This application is commonly used by adversaries to evade detections by killing  security product processes or even other processes to evade detection.

SEARCH:  '| tstats `security_content_summariesonly` values(Processes.process) as process  values(Processes.process_id) as process_id count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.process_name = "taskkill.exe"  by  Processes.parent_process_name Processes.process_name Processes.dest Processes.user  _time span=1m | where count >=10 | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `excessive_usage_of_taskkill_filter`'



<li><a href="#">NAME: Exchange PowerShell Abuse via SSRF

DESCRIPTION:  'This analytic identifies suspicious behavior related to ProxyShell against  on-premise Microsoft Exchange servers. This analytic has been replaced by GUID d436f9e7-0ee7-4a47-864b-6dea2c4e2752  which utilizes the Web Datamodel. \  Modification of this analytic is requried to ensure fields are mapped accordingly.  \  A suspicious event will have `PowerShell`, the method `POST` and `autodiscover.json`.  This is indicative of accessing PowerShell on the back end of Exchange with SSRF.  \  An event will look similar to `POST /autodiscover/autodiscover.json a=dsxvu@fnsso.flq/powershell/?X-Rps-CAT=VgEAVAdXaW5kb3d...`  (abbreviated) \  Review the source attempting to perform this activity against your environment.  In addition, review PowerShell logs and access recently granted to Exchange roles.'

SEARCH:  '`exchange` c_uri="*//autodiscover*" cs_uri_query="*PowerShell*" cs_method="POST"  | stats count min(_time) as firstTime max(_time) as lastTime by dest, cs_uri_query,  cs_method, c_uri | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `exchange_powershell_abuse_via_ssrf_filter`'



<li><a href="#">NAME: Exchange PowerShell Module Usage

DESCRIPTION:  'The following analytic identifies the usage of Exchange PowerShell modules  that were recently used for a proof of concept related to ProxyShell. Adversaries  may abuse a limited set of PwSh Modules related to Exchange once gained access via  ProxyShell or ProxyNotShell.\  Inherently, the usage of the modules is not malicious, but reviewing parallel processes,  and user, of the session will assist with determining the intent. \  Module - New-MailboxExportRequest will begin the process of exporting contents of  a primary mailbox or archive to a .pst file. \  Module - New-managementroleassignment can assign a management role to a management  role group, management role assignment policy, user, or universal security group  (USG). \  Module - New-MailboxSearch cmdlet to create a mailbox search and either get an estimate  of search results, place search results on In-Place Hold or copy them to a Discovery  mailbox. You can also place all contents in a mailbox on hold by not specifying  a search query, which accomplishes similar results as Litigation Hold. \ Module  - Get-Recipient cmdlet to view existing recipient objects in your organization.  This cmdlet returns all mail-enabled objects (for example, mailboxes, mail users,  mail contacts, and distribution groups).'

SEARCH:  '`powershell` EventCode=4104 ScriptBlockText IN ("*New-MailboxExportRequest*",  "*New-ManagementRoleAssignment*", "*New-MailboxSearch*", "*Get-Recipient*", "Search-Mailbox")  | stats count min(_time) as firstTime max(_time) as lastTime by Opcode Computer  UserID EventCode ScriptBlockText | rename Computer as dest |rename UserID as user | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `exchange_powershell_module_usage_filter`'



<li><a href="#">NAME: Executables Or Script Creation In Suspicious Path

DESCRIPTION:  This analytic identifies potentially malicious executables or scripts  by examining a list of suspicious file paths on Windows Operating System. The purpose  of this technique is to uncover files with known file extensions that could be used  by adversaries to evade detection and persistence. The suspicious file paths selected  for investigation are typically uncommon and uncommonly associated with executable  or script files. By scrutinizing these paths, we can proactively identify potential  security threats and enhance overall system security.

SEARCH:  '|tstats `security_content_summariesonly` values(Filesystem.file_path) as  file_path count min(_time) as firstTime max(_time) as lastTime from datamodel=Endpoint.Filesystem  where (Filesystem.file_name = *.exe OR Filesystem.file_name = *.dll OR Filesystem.file_name  = *.sys OR Filesystem.file_name = *.com OR Filesystem.file_name = *.vbs OR Filesystem.file_name  = *.vbe OR Filesystem.file_name = *.js OR Filesystem.file_name = *.ps1 OR Filesystem.file_name  = *.bat OR Filesystem.file_name = *.cmd OR Filesystem.file_name = *.pif) AND ( Filesystem.file_path  = *\\windows\\fonts\\* OR Filesystem.file_path = *\\windows\\temp\\* OR Filesystem.file_path  = *\\users\\public\\* OR Filesystem.file_path = *\\windows\\debug\\* OR Filesystem.file_path  = *\\Users\\Administrator\\Music\\* OR Filesystem.file_path = *\\Windows\\servicing\\*  OR Filesystem.file_path = *\\Users\\Default\\* OR Filesystem.file_path = *Recycle.bin*  OR Filesystem.file_path = *\\Windows\\Media\\* OR Filesystem.file_path = *\\Windows\\repair\\*  OR Filesystem.file_path = *\\AppData\\Local\\Temp* OR Filesystem.file_path = *\\PerfLogs\\*)  by Filesystem.file_create_time Filesystem.process_id  Filesystem.file_name Filesystem.user  | `drop_dm_object_name(Filesystem)` | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `executables_or_script_creation_in_suspicious_path_filter`'



<li><a href="#">NAME: Executable File Written in Administrative SMB Share

DESCRIPTION:  The following analytic identifies executable files (.exe or .dll) being  written to Windows administrative SMB shares (Admin$, IPC$, C$). This represents  suspicious behavior as its commonly used by tools like PsExec/PaExec and others  to stage service binaries before creating and starting a Windows service on remote  endpoints. Red Teams and adversaries alike may abuse administrative shares for lateral  movement and remote code execution. The Trickbot malware family also implements  this behavior to try to infect other machines in the infected network.

SEARCH:  '`wineventlog_security` EventCode=5145 RelativeTargetName IN ("*.exe","*.dll") ObjectType=File ShareName IN ("\\\\*\\C$","\\\\*\\IPC$","\\\\*\\admin$") AccessMask= "0x2" | stats min(_time) as firstTime max(_time) as lastTime count by EventCode ShareName RelativeTargetName ObjectType AccessMask src_user src_port IpAddress | `security_content_ctime(firstTime)`  | `executable_file_written_in_administrative_smb_share_filter`'



<li><a href="#">NAME: Execute Javascript With Jscript COM CLSID

DESCRIPTION:  This analytic will identify suspicious process of cscript.exe where it  tries to execute javascript using jscript.encode CLSID (COM OBJ). This technique  was seen in ransomware (reddot ransomware) where it execute javascript with this  com object with combination of amsi disabling technique.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.process_name = "cscript.exe"  Processes.process="*-e:{F414C262-6AC0-11CF-B6D1-00AA00BBBB58}*" by Processes.parent_process_name  Processes.process_name Processes.process Processes.parent_process Processes.process_id  Processes.dest Processes.user | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `execute_javascript_with_jscript_com_clsid_filter`'



<li><a href="#">NAME: Execution of File with Multiple Extensions

DESCRIPTION:  This search looks for processes launched from files that have double  extensions in the file name. This is typically done to obscure the "real" file extension  and make it appear as though the file being accessed is a data file, as opposed  to executable content.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.process IN ("*.doc.exe",  "*.xls.exe","*.ppt.exe", "*.htm.exe", "*.html.exe", "*.txt.exe", "*.pdf.exe", "*.docx.exe",  "*.xlsx.exe", "*.pptx.exe","*.one.exe", "*.bat.exe", "*rtf.exe") by Processes.dest  Processes.user Processes.process Processes.process_name Processes.parent_process | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `drop_dm_object_name(Processes)` | `execution_of_file_with_multiple_extensions_filter`'



<li><a href="#">NAME: Extraction of Registry Hives

DESCRIPTION:  The following analytic identifies the use of `reg.exe` exporting Windows  Registry hives containing credentials. Adversaries may use this technique to export  registry hives for offline credential access attacks. Typically found executed from  a untrusted process or script. Upon execution, a file will be written to disk.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where `process_reg` (Processes.process=*save*  OR Processes.process=*export*) AND (Processes.process="*\sam *" OR Processes.process="*\system  *" OR Processes.process="*\security *") by Processes.dest Processes.user Processes.parent_process  Processes.process_name Processes.parent_process_name Processes.process Processes.process_id Processes.parent_process_id  | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `extraction_of_registry_hives_filter`'



<li><a href="#">NAME: F5 BIG-IP iControl REST Vulnerability CVE-2022-1388

DESCRIPTION:  The following analytic identifies a recent unauthenticated remote code  execution vulnerablity against the F5 BIG-IP iControl REST API. The analytic identifies  the URI path found in the POCs and the HTTP Method of POST. In addition, the request  header will have the commands that may be executed in fields utilcmdargs and the  auth field of X-F5-Auth-Token, which may have a random base64 encoded value.

SEARCH:  '| tstats count from datamodel=Web where Web.url="*/mgmt/tm/util/bash*" Web.http_method="POST"  by Web.http_user_agent Web.http_method, Web.url,Web.url_length Web.src, Web.dest  | `drop_dm_object_name("Web")` | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `f5_big_ip_icontrol_rest_vulnerability_cve_2022_1388_filter`'



<li><a href="#">NAME: File with Samsam Extension

DESCRIPTION:  |-  The following analytic detects file writes with extensions that are consistent with a SamSam ransomware attack to proactively detect and respond to potential SamSam ransomware attacks, minimizing the impact and reducing the likelihood of successful ransomware infections. This detection is made by a Splunk query to search for specific file extensions that are commonly associated with SamSam ransomware, such as .stubbin, .berkshire, .satoshi, .sophos, and .keyxml. This identifies file extensions in the file names of the written files. If any file write events with these extensions are found, it suggests a potential SamSam ransomware attack. This detection is important because SamSam ransomware is a highly destructive and financially motivated attack and suggests that the organization is at risk of having its files encrypted and held for ransom, which can lead to significant financial losses, operational disruptions, and reputational damage. False positives might occur since legitimate files with these extensions can exist in the environment. Therefore, next steps include conducting a careful analysis and triage to confirm the presence of a SamSam ransomware attack. Next steps include taking immediate action to contain the attack, mitigate the impact, and prevent further spread of the ransomware. This might involve isolating affected systems, restoring encrypted files from backups, and conducting a thorough investigation to identify the attack source and prevent future incidents.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime values(Filesystem.user) as user values(Filesystem.dest) as dest values(Filesystem.file_path)  as file_path from datamodel=Endpoint.Filesystem by Filesystem.file_name | `drop_dm_object_name(Filesystem)`  | `security_content_ctime(lastTime)` | `security_content_ctime(firstTime)`| rex  field=file_name "(?<file_extension>\.[^\.]+)$" | search file_extension=.stubbin  OR file_extension=.berkshire OR file_extension=.satoshi OR file_extension=.sophos  OR file_extension=.keyxml | `file_with_samsam_extension_filter`'



<li><a href="#">NAME: Firewall Allowed Program Enable

DESCRIPTION:  The following analytic detects a potential suspicious modification of firewall  rule allowing to execute specific application. This technique was identified when  an adversary and red teams to bypassed firewall file execution restriction in a  targetted host. Take note that this event or command can run by administrator during  testing or allowing legitimate tool or application.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.process = "*firewall*"  Processes.process = "*allow*" Processes.process = "*add*" Processes.process = "*ENABLE*"  by Processes.dest Processes.user Processes.parent_process_name Processes.parent_process  Processes.process_name Processes.process Processes.process_id Processes.parent_process_id  | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `firewall_allowed_program_enable_filter`'



<li><a href="#">NAME: First Time Seen Child Process of Zoom

DESCRIPTION:  This search looks for child processes spawned by zoom.exe or zoom.us  that has not previously been seen.

SEARCH:  '| tstats `security_content_summariesonly` min(_time) as firstTime values(Processes.parent_process_name)  as parent_process_name values(Processes.parent_process_id) as parent_process_id  values(Processes.process_name) as process_name values(Processes.process) as process  from datamodel=Endpoint.Processes where (Processes.parent_process_name=zoom.exe  OR Processes.parent_process_name=zoom.us) by Processes.process_id Processes.dest  | `drop_dm_object_name(Processes)` | lookup zoom_first_time_child_process dest as  dest process_name as process_name OUTPUT firstTimeSeen | where isnull(firstTimeSeen)  OR firstTimeSeen > relative_time(now(), "`previously_seen_zoom_child_processes_window`")  | `security_content_ctime(firstTime)` | table firstTime dest, process_id, process_name,  parent_process_id, parent_process_name |`first_time_seen_child_process_of_zoom_filter`'



<li><a href="#">NAME: First Time Seen Running Windows Service

DESCRIPTION:  This search looks for the first and last time a Windows service is seen  running in your environment. This table is then cached.

SEARCH:  '`wineventlog_system` EventCode=7036 | rex field=Message "The (?<service>[-\(\)\s\w]+)  service entered the (?<state>\w+) state" | where state="running" | lookup previously_seen_running_windows_services  service as service OUTPUT firstTimeSeen | where isnull(firstTimeSeen) OR firstTimeSeen  > relative_time(now(), `previously_seen_windows_services_window`) | table _time  dest service | `first_time_seen_running_windows_service_filter`'



<li><a href="#">NAME: FodHelper UAC Bypass

DESCRIPTION:  'Fodhelper.exe has a known UAC bypass as it attempts to look for specific  registry keys upon execution, that do not exist. Therefore, an attacker can write  its malicious commands in these registry keys to be executed by fodhelper.exe with  the highest privilege. \  1. `HKCU:\Software\Classes\ms-settings\shell\open\command`\  1. `HKCU:\Software\Classes\ms-settings\shell\open\command\DelegateExecute`\  1. `HKCU:\Software\Classes\ms-settings\shell\open\command\(default)`\  Upon triage, fodhelper.exe will have a child process and read access will occur  on the registry keys. Isolate the endpoint and review parallel processes for additional  behavior.'

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.parent_process_name=fodhelper.exe  by Processes.dest Processes.user Processes.parent_process Processes.parent_process_name Processes.process_name  Processes.process Processes.process_id Processes.parent_process_id | `drop_dm_object_name(Processes)`  | `security_content_ctime(firstTime)`| `security_content_ctime(lastTime)` | `fodhelper_uac_bypass_filter`'



<li><a href="#">NAME: Fsutil Zeroing File

DESCRIPTION:  This search is to detect a suspicious fsutil process to zeroing a target  file. This technique was seen in lockbit ransomware where it tries to zero out its  malware path as part of its defense evasion after encrypting the compromised host.

SEARCH:  '| tstats `security_content_summariesonly` count values(Processes.process)  as process values(Processes.parent_process) as parent_process min(_time) as firstTime  max(_time) as lastTime from datamodel=Endpoint.Processes where Processes.process_name=fsutil.exe  Processes.process="*setzerodata*" by Processes.user Processes.process_name Processes.parent_process_name  Processes.dest  Processes.process Processes.parent_process | `drop_dm_object_name(Processes)`  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `fsutil_zeroing_file_filter`'



<li><a href="#">NAME: GetAdComputer with PowerShell

DESCRIPTION:  This analytic looks for the execution of `powershell.exe` with command-line  arguments utilized to discover remote systems. The `Get-AdComputer' commandlet returns  a list of all domain computers. Red Teams and adversaries alike may use this commandlet  to identify remote systems for situational awareness and Active Directory Discovery.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where (Processes.process_name="powershell.exe")  (Processes.process=*Get-AdComputer*) by Processes.dest Processes.user Processes.parent_process  Processes.process_name Processes.process Processes.process_id Processes.parent_process_id  | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `getadcomputer_with_powershell_filter`'



<li><a href="#">NAME: GetAdComputer with PowerShell Script Block

DESCRIPTION:  The following analytic utilizes PowerShell Script Block Logging (EventCode=4104)  to identify the execution of the `Get-AdGroup` commandlet. The `Get-AdGroup` commandlet  is used to return a list of all domain computers. Red Teams and adversaries may  leverage this commandlet to enumerate domain computers for situational awareness  and Active Directory Discovery.

SEARCH:  '`powershell` EventCode=4104 (ScriptBlockText = "*Get-AdComputer*") | stats  count min(_time) as firstTime max(_time) as lastTime by Opcode Computer UserID EventCode  ScriptBlockText | `security_content_ctime(firstTime)` | `getadcomputer_with_powershell_script_block_filter`'



<li><a href="#">NAME: GetAdGroup with PowerShell

DESCRIPTION:  This analytic looks for the execution of `powershell.exe` with command-line  arguments utilized to query for domain groups. The `Get-AdGroup` commandlnet is  used to return a list of all groups available in a Windows Domain. Red Teams and  adversaries alike may leverage this commandlet to enumerate domain groups for situational  awareness and Active Directory Discovery.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where (Processes.process_name="powershell.exe")  (Processes.process=*Get-AdGroup*) by Processes.dest Processes.user Processes.parent_process  Processes.process_name Processes.process Processes.process_id Processes.parent_process_id  | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `getadgroup_with_powershell_filter`'



<li><a href="#">NAME: GetAdGroup with PowerShell Script Block

DESCRIPTION:  The following analytic utilizes PowerShell Script Block Logging (EventCode=4104)  to identify the execution of the `Get-AdGroup` commandlet. The `Get-AdGroup` commandlet  is used to return a list of all domain groups. Red Teams and adversaries may leverage  this commandlet to enumerate domain groups for situational awareness and Active  Directory Discovery.

SEARCH:  '`powershell` EventCode=4104 ScriptBlockText = "*Get-ADGroup*" | stats count  min(_time) as firstTime max(_time) as lastTime by EventCode ScriptBlockText Computer UserID | rename Computer as dest, UserID as user | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `getadgroup_with_powershell_script_block_filter`'



<li><a href="#">NAME: GetCurrent User with PowerShell

DESCRIPTION:  This analytic looks for the execution of `powerhsell.exe` with command-line  arguments that execute the `GetCurrent` method of the WindowsIdentity .NET class.  This method returns an object that represents the current Windows user. Red Teams  and adversaries may leverage this method to identify the logged user on a compromised  endpoint for situational awareness and Active Directory Discovery.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where (Processes.process_name="powershell.exe")  (Processes.process=*System.Security.Principal.WindowsIdentity* OR Processes.process=*GetCurrent()*)  by Processes.dest Processes.user Processes.parent_process Processes.process_name  Processes.process Processes.process_id Processes.parent_process_id | `drop_dm_object_name(Processes)`  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `getcurrent_user_with_powershell_filter`'



<li><a href="#">NAME: GetCurrent User with PowerShell Script Block

DESCRIPTION:  The following analytic utilizes PowerShell Script Block Logging (EventCode=4104)  to identify the execution of the `GetCurrent` method of the WindowsIdentity .NET  class. This method returns an object that represents the current Windows user. Red  Teams and adversaries may leverage this method to identify the logged user on a  compromised endpoint for situational awareness and Active Directory Discovery.

SEARCH:  '`powershell` EventCode=4104 ScriptBlockText = "*[System.Security.Principal.WindowsIdentity]*"  ScriptBlockText  = "*GetCurrent()*" | stats count min(_time) as firstTime max(_time) as lastTime  by EventCode ScriptBlockText Computer UserID | rename Computer as dest, UserID as user | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `getcurrent_user_with_powershell_script_block_filter`'



<li><a href="#">NAME: GetDomainComputer with PowerShell

DESCRIPTION:  This analytic looks for the execution of `powershell.exe` with command-line  arguments utilized to discover remote systems. `Get-DomainComputer` is part of PowerView,  a PowerShell tool used to perform enumeration on Windows domains. Red Teams and  adversaries alike may leverage PowerView to enumerate domain groups for situational  awareness and Active Directory Discovery.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where (Processes.process_name="powershell.exe")  (Processes.process=*Get-DomainComputer*) by Processes.dest Processes.user Processes.parent_process  Processes.process_name Processes.process Processes.process_id Processes.parent_process_id  | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `getdomaincomputer_with_powershell_filter`'



<li><a href="#">NAME: GetDomainComputer with PowerShell Script Block

DESCRIPTION:  The following analytic utilizes PowerShell Script Block Logging (EventCode=4104)  to identify the execution of the `Get-DomainComputer` commandlet. `GetDomainComputer`  is part of PowerView, a PowerShell tool used to perform enumeration on Windows domains.  Red Teams and adversaries alike may use PowerView to enumerate domain computers  for situational awareness and Active Directory Discovery.

SEARCH:  '`powershell` EventCode=4104 (ScriptBlockText = "*Get-DomainComputer*") |  stats count min(_time) as firstTime max(_time) as lastTime by Opcode Computer UserID  EventCode ScriptBlockText | `security_content_ctime(firstTime)` | `getdomaincomputer_with_powershell_script_block_filter`'



<li><a href="#">NAME: GetDomainController with PowerShell

DESCRIPTION:  This analytic looks for the execution of `powershell.exe` with command-line  arguments utilized to discover remote systems. `Get-DomainController` is part of  PowerView, a PowerShell tool used to perform enumeration on Windows domains. Red  Teams and adversaries alike may leverage PowerView to enumerate domain groups for  situational awareness and Active Directory Discovery.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where (Processes.process_name="powershell.exe")  (Processes.process=*Get-DomainController*) by Processes.dest Processes.user Processes.parent_process  Processes.process_name Processes.process Processes.process_id Processes.parent_process_id  | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `getdomaincontroller_with_powershell_filter`'



<li><a href="#">NAME: GetDomainController with PowerShell Script Block

DESCRIPTION:  The following analytic utilizes PowerShell Script Block Logging (EventCode=4104)  to identify the execution of the `Get-DomainController` commandlet. `Get-DomainController`  is part of PowerView, a PowerShell tool used to perform enumeration on Windows domains.  Red Teams and adversaries alike may use PowerView to enumerate domain computers  for situational awareness and Active Directory Discovery.

SEARCH:  '`powershell` EventCode=4104 (ScriptBlockText = "*Get-DomainController*")  | stats count min(_time) as firstTime max(_time) as lastTime by Opcode Computer  UserID EventCode ScriptBlockText | `security_content_ctime(firstTime)` | `getdomaincontroller_with_powershell_script_block_filter`'



<li><a href="#">NAME: GetDomainGroup with PowerShell

DESCRIPTION:  This analytic looks for the execution of `powershell.exe` with command-line  arguments utilized to query for domain groups. `Get-DomainGroup` is part of PowerView,  a PowerShell tool used to perform enumeration on Windows domains. Red Teams and  adversaries alike may leverage PowerView to enumerate domain groups for situational  awareness and Active Directory Discovery.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where (Processes.process_name="powershell.exe")  (Processes.process=*Get-DomainGroup*) by Processes.dest Processes.user Processes.parent_process  Processes.process_name Processes.process Processes.process_id Processes.parent_process_id  | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `getdomaingroup_with_powershell_filter`'



<li><a href="#">NAME: GetDomainGroup with PowerShell Script Block

DESCRIPTION:  The following analytic utilizes PowerShell Script Block Logging (EventCode=4104)  to identify the execution of the `Get-DomainGroup` commandlet. `Get-DomainGroup`  is part of PowerView, a PowerShell tool used to perform enumeration on Windows domains.  As the name suggests, `Get-DomainGroup` is used to query domain groups. Red Teams  and adversaries may leverage this function to enumerate domain groups for situational  awareness and Active Directory Discovery.

SEARCH:  '`powershell` EventCode=4104 (ScriptBlockText = "*Get-DomainGroup*") | stats  count min(_time) as firstTime max(_time) as lastTime by Opcode Computer UserID EventCode  ScriptBlockText | `security_content_ctime(firstTime)` | `getdomaingroup_with_powershell_script_block_filter`'



<li><a href="#">NAME: GetLocalUser with PowerShell

DESCRIPTION:  This analytic looks for the execution of `powershell.exe` with command-line  arguments utilized to query for local users. The `Get-LocalUser` commandlet is used  to return a list of all local users. Red Teams and adversaries may leverage this  commandlet to enumerate users for situational awareness and Active Directory Discovery.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where (Processes.process_name="powershell.exe")  (Processes.process=*Get-LocalUser*) by Processes.dest Processes.user Processes.parent_process  Processes.process_name Processes.process Processes.process_id Processes.parent_process_id  | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `getlocaluser_with_powershell_filter`'



<li><a href="#">NAME: GetLocalUser with PowerShell Script Block

DESCRIPTION:  The following analytic utilizes PowerShell Script Block Logging (EventCode=4104)  to identify the execution of the `Get-LocalUser` commandlet. The `Get-LocalUser`  commandlet is used to return a list of all local users. Red Teams and adversaries  may leverage this commandlet to enumerate users for situational awareness and Active  Directory Discovery.

SEARCH:  '`powershell` EventCode=4104 (ScriptBlockText = "*Get-LocalUser*") | stats  count min(_time) as firstTime max(_time) as lastTime by EventCode ScriptBlockText  Computer user_id | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `getlocaluser_with_powershell_script_block_filter`'



<li><a href="#">NAME: GetNetTcpconnection with PowerShell

DESCRIPTION:  This analytic looks for the execution of `powershell.exe` with command-line  utilized to get a listing of network connections on a compromised system. The `Get-NetTcpConnection`  commandlet lists the current TCP connections. Red Teams and adversaries alike may  use this commandlet for situational awareness and Active Directory Discovery.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where (Processes.process_name="powershell.exe")  (Processes.process=*Get-NetTcpConnection*) by Processes.dest Processes.user Processes.parent_process  Processes.process_name Processes.process Processes.process_id Processes.parent_process_id  | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `getnettcpconnection_with_powershell_filter`'



<li><a href="#">NAME: GetNetTcpconnection with PowerShell Script Block

DESCRIPTION:  The following analytic utilizes PowerShell Script Block Logging (EventCode=4104)  to identify the execution of the `Get-NetTcpconnection ` commandlet. This commandlet  is used to return a listing of network connections on a compromised system. Red  Teams and adversaries alike may use this commandlet for situational awareness and  Active Directory Discovery.

SEARCH:  '`powershell` EventCode=4104 (ScriptBlockText = "*Get-NetTcpconnection*")  | stats count min(_time) as firstTime max(_time) as lastTime by Opcode Computer  UserID EventCode ScriptBlockText | `security_content_ctime(firstTime)` | `getnettcpconnection_with_powershell_script_block_filter`'



<li><a href="#">NAME: GetWmiObject Ds Computer with PowerShell

DESCRIPTION:  This analytic looks for the execution of `powershell.exe` with command-line  arguments utilized to discover remote systems. The `Get-WmiObject` commandlet combined  with the `DS_Computer` parameter can be used to return a list of all domain computers.  Red Teams and adversaries alike may leverage WMI in this case, using PowerShell,  to enumerate domain groups for situational awareness and Active Directory Discovery.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where (Processes.process_name="powershell.exe")  (Processes.process=*Get-WmiObject* AND Processes.process="*namespace root\\directory\\ldap*"  AND Processes.process="*class ds_computer*") by Processes.dest Processes.user Processes.parent_process  Processes.process_name Processes.process Processes.process_id Processes.parent_process_id  | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `getwmiobject_ds_computer_with_powershell_filter`'



<li><a href="#">NAME: GetWmiObject Ds Computer with PowerShell Script Block

DESCRIPTION:  The following analytic utilizes PowerShell Script Block Logging (EventCode=4104)  to identify the execution of the `Get-WmiObject` commandlet. The `DS_Computer` class  parameter leverages WMI to query for all domain computers. Red Teams and adversaries  may leverage this commandlet to enumerate domain computers for situational awareness  and Active Directory Discovery.

SEARCH:  '`powershell` EventCode=4104 (ScriptBlockText=*Get-WmiObject* AND ScriptBlockText="*namespace  root\\directory\\ldap*" AND ScriptBlockText="*class ds_computer*") | stats count  min(_time) as firstTime max(_time) as lastTime by Opcode Computer UserID EventCode  ScriptBlockText | `security_content_ctime(firstTime)` | `getwmiobject_ds_computer_with_powershell_script_block_filter`'



<li><a href="#">NAME: GetWmiObject Ds Group with PowerShell

DESCRIPTION:  This analytic looks for the execution of `powershell.exe` with command-line  arguments utilized to query for domain groups. The `Get-WmiObject` commandlet combined  with the `-class ds_group` parameter can be used to return the full list of groups  in a Windows domain. Red Teams and adversaries alike may leverage WMI in this case,  using PowerShell, to enumerate domain groups for situational awareness and Active  Directory Discovery.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where (Processes.process_name="powershell.exe")  (Processes.process=*Get-WmiObject* AND Processes.process="*namespace root\\directory\\ldap*"  AND Processes.process="*class ds_group*") by Processes.dest Processes.user Processes.parent_process  Processes.process_name Processes.process Processes.process_id Processes.parent_process_id  | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `getwmiobject_ds_group_with_powershell_filter`'



<li><a href="#">NAME: GetWmiObject Ds Group with PowerShell Script Block

DESCRIPTION:  The following analytic utilizes PowerShell Script Block Logging (EventCode=4104)  to identify the execution of the `Get-WmiObject` commandlet used with specific parameters  . The `DS_Group` parameter leverages WMI to query for all domain groups. Red Teams  and adversaries may leverage this commandlet to enumerate domain groups for situational  awareness and Active Directory Discovery.

SEARCH:  '`powershell` EventCode=4104 (ScriptBlockText=*Get-WmiObject* AND ScriptBlockText="*namespace  root\\directory\\ldap*" AND ScriptBlockText="*class ds_group*") | stats count min(_time)  as firstTime max(_time) as lastTime by Opcode Computer UserID EventCode ScriptBlockText | rename Computer as dest | rename UserID as user  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`|`getwmiobject_ds_group_with_powershell_script_block_filter`'



<li><a href="#">NAME: GetWmiObject DS User with PowerShell

DESCRIPTION:  This analytic looks for the execution of `powershell.exe` with command-line  arguments utilized to query for domain users. The `Get-WmiObject` commandlet combined  with the `-class ds_user` parameter can be used to return the full list of users  in a Windows domain. Red Teams and adversaries alike may leverage WMI in this case,  using PowerShell, to enumerate domain users for situational awareness and Active  Directory Discovery.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where (Processes.process_name="cmd.exe"  OR Processes.process_name="powershell*") AND Processes.process = "*get-wmiobject*"  AND Processes.process = "*ds_user*" AND Processes.process = "*root\\directory\\ldap*"  AND Processes.process = "*-namespace*" by Processes.dest Processes.user Processes.parent_process  Processes.process_name Processes.process Processes.process_id Processes.parent_process_id  Processes.parent_process_name | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `getwmiobject_ds_user_with_powershell_filter`'



<li><a href="#">NAME: GetWmiObject DS User with PowerShell Script Block

DESCRIPTION:  The following analytic utilizes PowerShell Script Block Logging (EventCode=4104)  to identify the execution of the `Get-WmiObject` commandlet. The `DS_User` class  parameter leverages WMI to query for all domain users. Red Teams and adversaries  may leverage this commandlet to enumerate domain users for situational awareness  and Active Directory Discovery.

SEARCH:  '`powershell` EventCode=4104 ScriptBlockText = "*get-wmiobject*" ScriptBlockText  = "*ds_user*" ScriptBlockText = "*-namespace*" ScriptBlockText = "*root\\directory\\ldap*"  | stats count min(_time) as firstTime max(_time) as lastTime by Opcode Computer  UserID EventCode ScriptBlockText | rename Computer as dest | rename UserID as user| `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `getwmiobject_ds_user_with_powershell_script_block_filter`'



<li><a href="#">NAME: GetWmiObject User Account with PowerShell

DESCRIPTION:  This analytic looks for the execution of `powershell.exe` with command-line  arguments utilized to query local users. The `Get-WmiObject` commandlet combined  with the `Win32_UserAccount` parameter is used to return a list of all local users.  Red Teams and adversaries may leverage this commandlet to enumerate users for situational  awareness and Active Directory Discovery.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where (Processes.process_name="powershell.exe")  (Processes.process=*Get-WmiObject* AND Processes.process=*Win32_UserAccount*) by  Processes.dest Processes.user Processes.parent_process Processes.process_name Processes.process  Processes.process_id Processes.parent_process_id | `drop_dm_object_name(Processes)`  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `getwmiobject_user_account_with_powershell_filter`'



<li><a href="#">NAME: GetWmiObject User Account with PowerShell Script Block

DESCRIPTION:  The following analytic utilizes PowerShell Script Block Logging (EventCode=4104)  to identify the execution of the `Get-WmiObject` commandlet used with specific parameters.  The `Win32_UserAccount` parameter is used to return a list of all local users. Red  Teams and adversaries may leverage this commandlet to enumerate users for situational  awareness and Active Directory Discovery.

SEARCH:  '`powershell` EventCode=4104 (ScriptBlockText="*Get-WmiObject*" AND ScriptBlockText="*Win32_UserAccount*")  | stats count min(_time) as firstTime max(_time) as lastTime by EventCode ScriptBlockText  Computer UserID | `security_content_ctime(firstTime)` | `getwmiobject_user_account_with_powershell_script_block_filter`'



<li><a href="#">NAME: Get ADDefaultDomainPasswordPolicy with Powershell

DESCRIPTION:  This analytic looks for the execution of `powershell.exe` executing the  Get-ADDefaultDomainPasswordPolicy commandlet used to obtain the password policy  in a Windows domain. Red Teams and adversaries alike may use PowerShell to enumerate  domain policies for situational awareness and Active Directory Discovery.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where (Processes.process_name="cmd.exe"  OR Processes.process_name="powershell*") AND Processes.process = "*Get-ADDefaultDomainPasswordPolicy*"  by Processes.dest Processes.user Processes.parent_process Processes.process_name  Processes.process Processes.process_id Processes.parent_process_id Processes.parent_process_name  | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `get_addefaultdomainpasswordpolicy_with_powershell_filter`'



<li><a href="#">NAME: Get ADDefaultDomainPasswordPolicy with Powershell Script Block

DESCRIPTION:  The following analytic utilizes PowerShell Script Block Logging (EventCode=4104)  to identify the execution of the `Get-ADDefaultDomainPasswordPolicy` commandlet  used to obtain the password policy in a Windows domain. Red Teams and adversaries  alike may use PowerShell to enumerate domain policies for situational awareness  and Active Directory Discovery.

SEARCH:  '`powershell` EventCode=4104 ScriptBlockText ="*Get-ADDefaultDomainPasswordPolicy*"  | stats count min(_time) as firstTime max(_time) as lastTime by EventCode ScriptBlockText  Computer UserID | rename Computer as dest, UserID as user |  `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `get_addefaultdomainpasswordpolicy_with_powershell_script_block_filter`'



<li><a href="#">NAME: Get ADUserResultantPasswordPolicy with Powershell

DESCRIPTION:  This analytic looks for the execution of `powershell.exe` executing the  Get ADUserResultantPasswordPolicy commandlet used to obtain the password policy  in a Windows domain. Red Teams and adversaries alike may use PowerShell to enumerate  domain policies for situational awareness and Active Directory Discovery.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where (Processes.process_name="cmd.exe"  OR Processes.process_name="powershell*") AND Processes.process = "*Get-ADUserResultantPasswordPolicy*"  by Processes.dest Processes.user Processes.parent_process Processes.process_name  Processes.process Processes.process_id Processes.parent_process_id Processes.parent_process_name  | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `get_aduserresultantpasswordpolicy_with_powershell_filter`'



<li><a href="#">NAME: Get ADUserResultantPasswordPolicy with Powershell Script Block

DESCRIPTION:  The following analytic utilizes PowerShell Script Block Logging (EventCode=4104)  to identify the execution of the `Get-ADUserResultantPasswordPolicy` commandlet  used to obtain the password policy in a Windows domain. Red Teams and adversaries  alike may use PowerShell to enumerate domain policies for situational awareness  and Active Directory Discovery.

SEARCH:  '`powershell` EventCode=4104 ScriptBlockText="*Get-ADUserResultantPasswordPolicy*"  | stats count min(_time) as firstTime max(_time) as lastTime by Opcode Computer  UserID EventCode ScriptBlockText | rename Computer as dest | rename UserID as user  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `get_aduserresultantpasswordpolicy_with_powershell_script_block_filter`'



<li><a href="#">NAME: Get ADUser with PowerShell

DESCRIPTION:  This analytic looks for the execution of `powershell.exe` with command-line  arguments utilized to enumerate domain users. The `Get-AdUser' commandlet returns  a list of all domain users. Red Teams and adversaries alike may use this commandlet  to identify remote systems for situational awareness and Active Directory Discovery.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where (Processes.process_name="cmd.exe"  OR Processes.process_name="powershell*") AND Processes.process = "*Get-ADUser*"  AND Processes.process = "*-filter*" by Processes.dest Processes.user Processes.parent_process  Processes.process_name Processes.process Processes.process_id Processes.parent_process_id  Processes.parent_process_name | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `get_aduser_with_powershell_filter`'



<li><a href="#">NAME: Get ADUser with PowerShell Script Block

DESCRIPTION:  The following analytic utilizes PowerShell Script Block Logging (EventCode=4104)  to identify the execution of the `Get-AdGUser` commandlet. The `Get-AdUser` commandlet  is used to return a list of all domain users. Red Teams and adversaries may leverage  this commandlet to enumerate domain groups for situational awareness and Active  Directory Discovery.

SEARCH:  '`powershell` EventCode=4104 ScriptBlockText = "*get-aduser*" ScriptBlockText  = "*-filter*" | stats count min(_time) as firstTime max(_time) as lastTime by EventCode  ScriptBlockText Computer UserID | rename Computer as dest, UserID as user| `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `get_aduser_with_powershell_script_block_filter`'



<li><a href="#">NAME: Get DomainPolicy with Powershell

DESCRIPTION:  This analytic looks for the execution of `powershell.exe` executing the  `Get-DomainPolicy` commandlet used to obtain the password policy in a Windows domain.  Red Teams and adversaries alike may use PowerShell to enumerate domain policies  for situational awareness and Active Directory Discovery.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where (Processes.process_name="cmd.exe"  OR Processes.process_name="powershell*") AND Processes.process = "*Get-DomainPolicy*"  by Processes.dest Processes.user Processes.parent_process Processes.process_name  Processes.process Processes.process_id Processes.parent_process_id Processes.parent_process_name  | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `get_domainpolicy_with_powershell_filter`'



<li><a href="#">NAME: Get DomainPolicy with Powershell Script Block

DESCRIPTION:  The following analytic utilizes PowerShell Script Block Logging (EventCode=4104)  to identify the execution of the `Get DomainPolicy` commandlet used to obtain the  password policy in a Windows domain. Red Teams and adversaries alike may use PowerShell  to enumerate domain policies for situational awareness and Active Directory Discovery.

SEARCH:  '`powershell` EventCode=4104 ScriptBlockText ="*Get-DomainPolicy*" | stats  count min(_time) as firstTime max(_time) as lastTime by Opcode Computer UserID EventCode  ScriptBlockText | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `get_domainpolicy_with_powershell_script_block_filter`'



<li><a href="#">NAME: Get-DomainTrust with PowerShell

DESCRIPTION:  This analytic identifies Get-DomainTrust from PowerView in order to gather  domain trust information. Typically, this is utilized within a script being executed  and used to enumerate the domain trust information. This grants the adversary an  understanding of how large or small the domain is. During triage, review parallel  processes using an EDR product or 4688 events. It will be important to understand  the timeline of events around this activity.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.process=*get-domaintrust*  by Processes.dest Processes.user Processes.parent_process_name Processes.process_name  Processes.process Processes.process_id Processes.parent_process_id | `drop_dm_object_name(Processes)`  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `get_domaintrust_with_powershell_filter`'



<li><a href="#">NAME: Get-DomainTrust with PowerShell Script Block

DESCRIPTION:  'The following analytic utilizes PowerShell Script Block Logging (EventCode=4104)  to identify suspicious PowerShell execution. Script Block Logging captures the command  sent to PowerShell, the full command to be executed. Upon enabling, logs will output  to Windows event logs. Dependent upon volume, enable on critical endpoints or all.  \  This analytic identifies Get-DomainTrust from PowerView in order to gather domain  trust information. \  During triage, review parallel processes using an EDR product or 4688 events. It  will be important to understand the timeline of events around this activity. Review  the entire logged PowerShell script block.'

SEARCH:  '`powershell` EventCode=4104 ScriptBlockText = "*get-domaintrust*" | stats  count min(_time) as firstTime max(_time) as lastTime by Opcode Computer UserID EventCode  ScriptBlockText | rename Computer as dest | rename UserID as user | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `get_domaintrust_with_powershell_script_block_filter`'



<li><a href="#">NAME: Get DomainUser with PowerShell

DESCRIPTION:  This analytic looks for the execution of `powershell.exe` with command-line  arguments utilized to enumerate domain users. `Get-DomainUser` is part of PowerView,  a PowerShell tool used to perform enumeration on Windows domains. Red Teams and  adversaries alike may leverage PowerView to enumerate domain users for situational  awareness and Active Directory Discovery.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where (Processes.process_name="cmd.exe"  OR Processes.process_name="powershell*") AND Processes.process = "*Get-DomainUser*"  by Processes.dest Processes.user Processes.parent_process Processes.process_name  Processes.process Processes.process_id Processes.parent_process_id Processes.parent_process_name  | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `get_domainuser_with_powershell_filter`'



<li><a href="#">NAME: Get DomainUser with PowerShell Script Block

DESCRIPTION:  The following analytic utilizes PowerShell Script Block Logging (EventCode=4104)  to identify the execution of the `Get-DomainUser` commandlet. `GetDomainUser` is  part of PowerView, a PowerShell tool used to perform enumeration on Windows domains.  Red Teams and adversaries alike may use PowerView to enumerate domain users for  situational awareness and Active Directory Discovery.

SEARCH:  '`powershell` EventCode=4104 ScriptBlockText = "*Get-DomainUser*" | stats  count min(_time) as firstTime max(_time) as lastTime by EventCode ScriptBlockText  Computer UserID | rename Computer as dest, UserID as user| `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `get_domainuser_with_powershell_script_block_filter`'



<li><a href="#">NAME: Get-ForestTrust with PowerShell

DESCRIPTION:  This analytic identifies Get-ForestTrust from PowerSploit in order to  gather domain trust information. Typically, this is utilized within a script being  executed and used to enumerate the domain trust information. This grants the adversary  an understanding of how large or small the domain is. During triage, review parallel  processes using an EDR product or 4688 events. It will be important to understand  the timeline of events around this activity.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.process_name=powershell.exe  OR Processes.process_name=cmd.exe Processes.process=*get-foresttrust* by Processes.dest  Processes.user Processes.parent_process_name Processes.process_name Processes.process  Processes.process_id Processes.parent_process_id | `drop_dm_object_name(Processes)`  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `get_foresttrust_with_powershell_filter`'



<li><a href="#">NAME: Get-ForestTrust with PowerShell Script Block

DESCRIPTION:  'The following analytic utilizes PowerShell Script Block Logging (EventCode=4104)  to identify suspicious PowerShell execution. Script Block Logging captures the command  sent to PowerShell, the full command to be executed. Upon enabling, logs will output  to Windows event logs. Dependent upon volume, enable on critical endpoints or all.  \  This analytic identifies Get-ForestTrust from PowerSploit in order to gather domain  trust information. \  During triage, review parallel processes using an EDR product or 4688 events. It  will be important to understand the timeline of events around this activity. Review  the entire logged PowerShell script block.'

SEARCH:  '`powershell` EventCode=4104 ScriptBlockText = "*get-foresttrust*" | stats  count min(_time) as firstTime max(_time) as lastTime by EventCode ScriptBlockText  Computer UserID | rename Computer as dest | rename UserID as user | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `get_foresttrust_with_powershell_script_block_filter`'



<li><a href="#">NAME: Get WMIObject Group Discovery

DESCRIPTION:  The following hunting analytic identifies the use of `Get-WMIObject Win32_Group`  being used with PowerShell to identify local groups on the endpoint. \ Typically,  by itself, is not malicious but may raise suspicion based on time of day, endpoint  and username. \ During triage, review parallel processes and identify any further  suspicious behavior.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where (Processes.process_name=powershell.exe  OR processes.process_name=cmd.exe) (Processes.process="*Get-WMIObject*" AND Processes.process="*Win32_Group*")  by Processes.dest Processes.user Processes.parent_process_name Processes.process_name  Processes.process Processes.original_file_name Processes.process_id Processes.parent_process_id  | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)`| `security_content_ctime(lastTime)`  |  `get_wmiobject_group_discovery_filter`'



<li><a href="#">NAME: Get WMIObject Group Discovery with Script Block Logging

DESCRIPTION:  'The following analytic utilizes PowerShell Script Block Logging (EventCode=4104)  to identify suspicious PowerShell execution. Script Block Logging captures the command  sent to PowerShell, the full command to be executed. Upon enabling, logs will output  to Windows event logs. Dependent upon volume, enable on critical endpoints or all.  \  This analytic identifies the usage of `Get-WMIObject Win32_Group`, which is typically  used as a way to identify groups on the endpoint.  Typically, by itself, is not  malicious but may raise suspicion based on time of day, endpoint and username. \  During triage, review parallel processes using an EDR product or 4688 events. It  will be important to understand the timeline of events around this activity. Review  the entire logged PowerShell script block.'

SEARCH:  '`powershell` EventCode=4104 ScriptBlockText = "*Get-WMIObject*" AND ScriptBlockText  = "*Win32_Group*" | stats count min(_time) as firstTime max(_time) as lastTime by  EventCode ScriptBlockText Computer UserID | rename Computer as dest, UserID as user | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `get_wmiobject_group_discovery_with_script_block_logging_filter`'



<li><a href="#">NAME: GPUpdate with no Command Line Arguments with Network

DESCRIPTION:  The following analytic identifies gpupdate.exe with no command line arguments  and with a network connection. It is unusual for gpupdate.exe to execute with no  command line arguments present. This particular behavior is common with malicious  software, including Cobalt Strike. During investigation, triage any network connections  and parallel processes. Identify any suspicious module loads related to credential  dumping or file writes. gpupdate.exe is natively found in C:\Windows\system32 and  C:\Windows\syswow64.

SEARCH:  '| tstats `security_content_summariesonly` count FROM datamodel=Endpoint.Processes  where Processes.process_name=gpupdate.exe by _time span=1h  Processes.process_id  Processes.process_name Processes.dest Processes.user Processes.process_path Processes.process Processes.parent_process_name  | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | regex process="(?i)(gpupdate\.exe.{0,4}$)"| join  process_id [| tstats `security_content_summariesonly`  count FROM datamodel=Network_Traffic.All_Traffic where All_Traffic.dest_port !=  0 by All_Traffic.process_id All_Traffic.dest All_Traffic.dest_port | `drop_dm_object_name(All_Traffic)`  | rename dest as C2 ] | table _time user dest parent_process_name process_name process_path  process process_id dest_port C2 | `gpupdate_with_no_command_line_arguments_with_network_filter`'



<li><a href="#">NAME: Headless Browser Mockbin or Mocky Request

DESCRIPTION:  The following analytic identifies headless browser activity accessing mockbin.org or mocky.io. Mockbin.org and mocky.io are web services that allow users to mock HTTP requests and responses. The detection is based on the presence of "--headless" and "--disable-gpu" command line arguments which are commonly used in headless browsing and the presence of mockbin.org or mocky.io in the process.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where   (Processes.process="*--headless*" AND Processes.process="*--disable-gpu*" AND (Processes.process="*mockbin.org/*" OR Processes.process="*mocky.io/*")) by Processes.dest Processes.user Processes.parent_process  Processes.process_name Processes.process Processes.process_id Processes.parent_process_id  | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `headless_browser_mockbin_or_mocky_request_filter`'



<li><a href="#">NAME: Headless Browser Usage

DESCRIPTION:  'The following hunting analytic is designed to detect the usage of headless browsers in an organization. Headless browsers are web browsers without a graphical user interface and are operated via a command line interface or network requests. They are often used for automating tasks but can also be utilized by adversaries for malicious activities such as web scraping, automated testing, and performing actions on web pages without detection. The detection is based on the presence of "--headless" and "--disable-gpu" command line arguments which are commonly used in headless browsing.'

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where   (Processes.process="*--headless*" AND Processes.process="*--disable-gpu*") by Processes.dest Processes.user Processes.parent_process  Processes.process_name Processes.process Processes.process_id Processes.parent_process_id  | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`| `headless_browser_usage_filter`'



<li><a href="#">NAME: Hide User Account From Sign-In Screen

DESCRIPTION:  This analytic identifies a suspicious registry modification to hide a  user account on the Windows Login screen. This technique was seen in some tradecraft  where the adversary will create a hidden user account with Admin privileges in login  screen to avoid noticing by the user that they already compromise and to persist  on that said machine.

SEARCH:  '| tstats `security_content_summariesonly` count FROM datamodel=Endpoint.Registry  WHERE (Registry.registry_path="*\\Windows NT\\CurrentVersion\\Winlogon\\SpecialAccounts\\Userlist*"  AND Registry.registry_value_data = "0x00000000") BY _time span=1h Registry.dest Registry.user Registry.registry_path  Registry.registry_key_name Registry.registry_value_name Registry.registry_value_data  Registry.process_guid | `drop_dm_object_name(Registry)` | where isnotnull(registry_value_data)  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `hide_user_account_from_sign_in_screen_filter`'



<li><a href="#">NAME: Hiding Files And Directories With Attrib exe

DESCRIPTION:  Attackers leverage an existing Windows binary, attrib.exe, to mark specific  as hidden by using specific flags so that the victim does not see the file.  The  search looks for specific command-line arguments to detect the use of attrib.exe  to hide files.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) values(Processes.process)  as process max(_time) as lastTime from datamodel=Endpoint.Processes where Processes.process_name=attrib.exe  (Processes.process=*+h*) by Processes.parent_process_name Processes.process_name Processes.user  Processes.dest | `drop_dm_object_name("Processes")` | `security_content_ctime(firstTime)`|`security_content_ctime(lastTime)`|  `hiding_files_and_directories_with_attrib_exe_filter` '



<li><a href="#">NAME: High Frequency Copy Of Files In Network Share

DESCRIPTION:  This analytic is to detect a suspicious high frequency copying/moving  of files in network share as part of information sabotage. This anomaly event can  be a good indicator of insider trying to sabotage data by transfering classified  or internal files within network share to exfitrate it after or to lure evidence  of insider attack to other user. This behavior may catch several noise if network  share is a common place for classified or internal document processing.

SEARCH:  '`wineventlog_security` EventCode=5145 Relative_Target_Name IN ("*.doc","*.docx","*.xls","*.xlsx","*.ppt","*.pptx","*.log","*.txt","*.db","*.7z","*.zip","*.rar","*.tar","*.gz","*.jpg","*.gif","*.png","*.bmp","*.pdf","*.rtf","*.key")  Object_Type=File Share_Name IN ("\\\\*\\C$","\\\\*\\IPC$","\\\\*\\admin$") Access_Mask=  "0x2" |  bucket _time span=5m | stats values(Relative_Target_Name) as valRelativeTargetName,  values(Share_Name) as valShareName, values(Object_Type) as valObjectType, values(Access_Mask)  as valAccessmask, values(src_port) as valSrcPort, values(Source_Address) as valSrcAddress  count as numShareName by dest, _time, EventCode, user | eventstats avg(numShareName)  as avgShareName, stdev(numShareName) as stdShareName, count as numSlots by dest,  _time, EventCode, user |  eval upperThreshold=(avgShareName + stdShareName *3) |  eval  isOutlier=if(avgShareName > 20 and avgShareName >= upperThreshold, 1, 0) |  search  isOutlier=1 | `high_frequency_copy_of_files_in_network_share_filter`'



<li><a href="#">NAME: High Process Termination Frequency

DESCRIPTION:  This analytic is designed to identify a high frequency of process termination  events on a computer in a short period of time, which is a common behavior of ransomware  malware before encrypting files. This technique is designed to avoid an exception  error while accessing (docs, images, database and etc..) in the infected machine  for encryption.

SEARCH:  '`sysmon` EventCode=5 |bin _time span=3s |stats values(Image) as proc_terminated  min(_time) as firstTime max(_time) as lastTime  count by _time dest EventCode  ProcessID | where count >= 15 | `security_content_ctime(firstTime)`| `security_content_ctime(lastTime)`  | `high_process_termination_frequency_filter`'



<li><a href="#">NAME: High Volume of Bytes Out to Url

DESCRIPTION:  The following analytic detects high volume of bytes out (greater than 1GB) to a URL within 2 mins of time window. This may be  indicative of an attacker attempting to exfiltrate data.  The search applies a fundamental threshold for detecting significant web uploads. This approach aims to identify potential data exfiltration activities by malware or malevolent insiders. View the alert for $dest$ to investigate further. 

SEARCH:  '| tstats  `security_content_summariesonly` count sum(Web.bytes_out) as sum_bytes_out values(Web.user) as user values(Web.app) as app values(Web.dest) as dest from datamodel=Web by _time span=2m Web.url Web.src sourcetype | search sum_bytes_out > 1070000000 | `drop_dm_object_name("Web")`| `high_volume_of_bytes_out_to_url_filter`'



<li><a href="#">NAME: Hosts receiving high volume of network traffic from email server

DESCRIPTION:  This search looks for an increase of data transfers from your email server  to your clients. This could be indicative of a malicious actor collecting data using  your email server.

SEARCH:  '| tstats `security_content_summariesonly` sum(All_Traffic.bytes_in) as bytes_in  from datamodel=Network_Traffic where All_Traffic.dest_category=email_server by All_Traffic.src_ip  _time span=1d | `drop_dm_object_name("All_Traffic")` | eventstats avg(bytes_in)  as avg_bytes_in stdev(bytes_in) as stdev_bytes_in | eventstats count as num_data_samples  avg(eval(if(_time < relative_time(now(), "@d"), bytes_in, null))) as per_source_avg_bytes_in  stdev(eval(if(_time < relative_time(now(), "@d"), bytes_in, null))) as per_source_stdev_bytes_in  by src_ip | eval minimum_data_samples = 4, deviation_threshold = 3 | where num_data_samples  >= minimum_data_samples AND bytes_in > (avg_bytes_in + (deviation_threshold * stdev_bytes_in))  AND bytes_in > (per_source_avg_bytes_in + (deviation_threshold * per_source_stdev_bytes_in))  AND _time >= relative_time(now(), "@d") | eval num_standard_deviations_away_from_server_average  = round(abs(bytes_in - avg_bytes_in) / stdev_bytes_in, 2), num_standard_deviations_away_from_client_average  = round(abs(bytes_in - per_source_avg_bytes_in) / per_source_stdev_bytes_in, 2)  | table src_ip, _time, bytes_in, avg_bytes_in, per_source_avg_bytes_in, num_standard_deviations_away_from_server_average,  num_standard_deviations_away_from_client_average | `hosts_receiving_high_volume_of_network_traffic_from_email_server_filter`'



<li><a href="#">NAME: Hunting 3CXDesktopApp Software

DESCRIPTION:  The hunting analytic outlined below is designed to detect any version  of the 3CXDesktopApp, also known as the 3CX Desktop App, operating on either Mac  or Windows systems. It is important to note that this particular analytic employs  the Endpoint datamodel Processes node, which means that the file version information  is not provided. Recently, 3CX has identified a vulnerability specifically in versions  18.12.407 and 18.12.416 of the desktop app.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.process_name=3CXDesktopApp.exe  OR Processes.process_name="3CX Desktop App" by Processes.dest Processes.user Processes.parent_process_name  Processes.process_name Processes.original_file_name Processes.process Processes.process_id  Processes.parent_process_id | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `hunting_3cxdesktopapp_software_filter`'



<li><a href="#">NAME: Icacls Deny Command

DESCRIPTION:  This analytic identifies instances where an adversary modifies the security  permissions of a particular file or directory. This technique is frequently observed  in the tradecraft of Advanced Persistent Threats (APTs) and coinminer scripts. The  purpose of this behavior is to actively evade detection and impede access to their  associated files. By identifying these security permission changes, we can enhance  our ability to detect and respond to potential threats, mitigating the impact of  malicious activities on the system.

SEARCH:  '| tstats `security_content_summariesonly` min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.process_name IN( "icacls.exe",  "cacls.exe", "xcacls.exe") AND Processes.process IN ("*/deny*", "*/D*") by Processes.parent_process_name  Processes.parent_process Processes.process_name Processes.process Processes.process_guid  Processes.dest Processes.user | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `icacls_deny_command_filter`'



<li><a href="#">NAME: ICACLS Grant Command

DESCRIPTION:  This analytic identifies adversaries who manipulate the security permissions  of specific files or directories by granting additional access. This technique is  frequently observed in the tradecraft of Advanced Persistent Threats (APTs) and  coinminer scripts. The objective behind this behavior is to actively evade detection  mechanisms and tightly control access to their associated files. By identifying  these security permission modifications, we can improve our ability to identify  and respond to potential threats, thereby minimizing the impact of malicious activities  on the system.

SEARCH:  '| tstats `security_content_summariesonly` min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.process_name IN( "icacls.exe",  "cacls.exe", "xcacls.exe") AND Processes.process IN ("*/grant*", "*/G*") by Processes.parent_process_name  Processes.parent_process Processes.process_name Processes.process Processes.process_guid  Processes.dest Processes.user | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `icacls_grant_command_filter`'



<li><a href="#">NAME: IcedID Exfiltrated Archived File Creation

DESCRIPTION:  This search is to detect a suspicious file creation namely passff.tar  and cookie.tar. This files are possible archived of stolen browser information like  history and cookies in a compromised machine with IcedID.

SEARCH:  '`sysmon` EventCode= 11  (TargetFilename = "*\\passff.tar" OR TargetFilename  = "*\\cookie.tar") |stats count min(_time) as firstTime max(_time) as lastTime by  TargetFilename EventCode process_id  process_name dest | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `icedid_exfiltrated_archived_file_creation_filter`'



<li><a href="#">NAME: Impacket Lateral Movement Commandline Parameters

DESCRIPTION:  This analytic looks for the presence of suspicious commandline parameters  typically present when using Impacket tools. Impacket is a collection of python  classes meant to be used with Microsoft network protocols. There are multiple scripts  that leverage impacket libraries like `wmiexec.py`, `smbexec.py`, `dcomexec.py`  and `atexec.py` used to execute commands on remote endpoints. By default, these  scripts leverage administrative shares and hardcoded parameters that can be used  as a signature to detect its use. Red Teams and adversaries alike may leverage Impackets  tools for lateral movement and remote code execution.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.process_name=cmd.exe  (Processes.process = "*/Q /c * \\\\127.0.0.1\\*$*" AND Processes.process IN ("*2>&1*","*2&gt;&amp;1*"))  by Processes.dest Processes.user Processes.parent_process_name Processes.process_name  Processes.process Processes.process_id Processes.parent_process_id | `drop_dm_object_name(Processes)`  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `impacket_lateral_movement_commandline_parameters_filter`'



<li><a href="#">NAME: Impacket Lateral Movement smbexec CommandLine Parameters

DESCRIPTION:  This analytic focuses on identifying suspicious command-line parameters  commonly associated with the use of Impacket wmiexec.py. Impacket is a set of Python  classes designed for working with Microsoft network protocols, and it includes several  scripts like wmiexec.py, smbexec.py, dcomexec.py, and atexec.py that enable command  execution on remote endpoints. These scripts typically utilize administrative shares  and hardcoded parameters, which can serve as signatures to detect their usage. Both  Red Teams and adversaries may employ Impacket tools for lateral movement and remote  code execution purposes. By monitoring for these specific command-line indicators,  the analytic aims to detect potentially malicious activities related to Impacket  tool usage.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.process_name=cmd.exe  by Processes.dest Processes.user Processes.parent_process_name Processes.process_name  Processes.process Processes.process_id Processes.parent_process_id | `drop_dm_object_name(Processes)`  | where match(process, "(?i)cmd\.exe\s+\/Q\s+\/c") AND match(process,"(?i)echo\s+cd")  AND match(process, "(?i)\\__output") AND  match(process, "(?i)C:\\\\Windows\\\\[a-zA-Z]{1,8}\\.bat")  AND  match(process, "\\\\127\.0\.0\.1\\.*") | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `impacket_lateral_movement_smbexec_commandline_parameters_filter`'



<li><a href="#">NAME: Impacket Lateral Movement WMIExec Commandline Parameters

DESCRIPTION:  This analytic looks for the presence of suspicious commandline parameters  typically present when using Impacket tools. Impacket is a collection of python  classes meant to be used with Microsoft network protocols. There are multiple scripts  that leverage impacket libraries like `wmiexec.py`, `smbexec.py`, `dcomexec.py`  and `atexec.py` used to execute commands on remote endpoints. By default, these  scripts leverage administrative shares and hardcoded parameters that can be used  as a signature to detect its use. Red Teams and adversaries alike may leverage Impackets  tools for lateral movement and remote code execution.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.parent_process_name=wmiprvse.exe  by Processes.dest Processes.user Processes.parent_process_name Processes.process_name  Processes.process Processes.process_id Processes.parent_process_id | `drop_dm_object_name(Processes)`  | where match(process, "(?i)cmd\.exe\s+\/Q\s+\/c") AND match(process, "\\\\127\.0\.0\.1\\.*")  AND match(process, "__\\d{1,10}\\.\\d{1,10}") | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)`| `impacket_lateral_movement_wmiexec_commandline_parameters_filter`'



<li><a href="#">NAME: Interactive Session on Remote Endpoint with PowerShell

DESCRIPTION:  The following analytic utilizes PowerShell Script Block Logging (EventCode=4104)  to identify the usage of the `Enter-PSSession`. This commandlet can be used to open  an interactive session on a remote endpoint leveraging the WinRM protocol. Red Teams  and adversaries alike may abuse WinRM and `Enter-PSSession` for lateral movement  and remote code execution.

SEARCH:  '`powershell` EventCode=4104 (ScriptBlockText="*Enter-PSSession*" AND ScriptBlockText="*-ComputerName*")  | stats count min(_time) as firstTime max(_time) as lastTime by EventCode ScriptBlockText  Computer UserID | rename Computer as dest | rename UserID as user| `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `interactive_session_on_remote_endpoint_with_powershell_filter`'



<li><a href="#">NAME: Java Class File download by Java User Agent

DESCRIPTION:  The following analytic identifies a Java user agent performing a GET  request for a .class file from the remote site. This is potentially indicative of  exploitation of the Java application and may be related to current event CVE-2021-44228  (Log4Shell).

SEARCH:  '| tstats count from datamodel=Web where Web.http_user_agent="*Java*" Web.http_method="GET"  Web.url="*.class*" by Web.http_user_agent Web.http_method, Web.url,Web.url_length  Web.src, Web.dest | `drop_dm_object_name("Web")` | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `java_class_file_download_by_java_user_agent_filter`'



<li><a href="#">NAME: Java Writing JSP File

DESCRIPTION:  The following analytic identifies the process java writing a .jsp to  disk. This is potentially indicative of a web shell being written to disk. Modify  and tune the analytic based on data ingested. For instance, it may be worth running  a broad query for jsp file writes first before performing a join.

SEARCH:  '| tstats `security_content_summariesonly` count FROM datamodel=Endpoint.Processes  where Processes.process_name IN ("java","java.exe", "javaw.exe") by _time Processes.process_id  Processes.process_name Processes.dest Processes.process_guid Processes.user | `drop_dm_object_name(Processes)`  | join process_guid [| tstats `security_content_summariesonly` count FROM datamodel=Endpoint.Filesystem  where Filesystem.file_name="*.jsp*" by _time Filesystem.dest Filesystem.file_create_time  Filesystem.file_name Filesystem.file_path Filesystem.process_guid Filesystem.user  | `drop_dm_object_name(Filesystem)` | fields _time process_guid file_path file_name  file_create_time user dest process_name] | stats count min(_time) as firstTime max(_time)  as lastTime by dest process_name process_guid file_name file_path file_create_time  user | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `java_writing_jsp_file_filter`'



<li><a href="#">NAME: Jscript Execution Using Cscript App

DESCRIPTION:  This search is to detect a execution of jscript using cscript process.  Commonly when a user run jscript file it was executed by wscript.exe application.  This technique was seen in FIN7 js implant to execute its malicious script using  cscript process. This behavior is uncommon and a good artifacts to check further  anomalies within the network

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where (Processes.parent_process_name  = "cscript.exe" AND Processes.parent_process = "*//e:jscript*") OR (Processes.process_name  = "cscript.exe" AND Processes.process = "*//e:jscript*") by Processes.parent_process_name  Processes.parent_process Processes.process_name Processes.process_id Processes.process  Processes.dest Processes.user | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `jscript_execution_using_cscript_app_filter`'



<li><a href="#">NAME: Kerberoasting spn request with RC4 encryption

DESCRIPTION:  The following analytic leverages Kerberos Event 4769, A Kerberos service  ticket was requested, to identify a potential kerberoasting attack against Active  Directory networks. Kerberoasting allows an adversary to request kerberos tickets  for domain accounts typically used as service accounts and attempt to crack them  offline allowing them to obtain privileged access to the domain. This analytic looks  for a specific combination of the Ticket_Options field based on common kerberoasting  tools. Defenders should be aware that it may be possible for a Kerberoast attack  to use different Ticket_Options.

SEARCH:  '`wineventlog_security` EventCode=4769 Service_Name!="*$" (Ticket_Options=0x40810000  OR Ticket_Options=0x40800000 OR Ticket_Options=0x40810010) Ticket_Encryption_Type=0x17  | stats count min(_time) as firstTime max(_time) as lastTime by dest, service, service_id,  Ticket_Encryption_Type, Ticket_Options | `security_content_ctime(lastTime)` | `security_content_ctime(firstTime)`  | `kerberoasting_spn_request_with_rc4_encryption_filter`'



<li><a href="#">NAME: Kerberos Pre-Authentication Flag Disabled in UserAccountControl

DESCRIPTION:  The following analytic leverages Windows Security Event 4738, `A user  account was changed`, to identify a change performed on a domain user object that  disables Kerberos Pre-Authentication. Disabling the Pre Authentication flag in the  UserAccountControl property allows an adversary to easily perform a brute force  attack against the user's password offline leveraging the ASP REP Roasting technique.  Red Teams and adversaries alike who have obtained privileges in an Active Directory  network may use this technique as a backdoor or a way to escalate privileges.

SEARCH:  ' `wineventlog_security` EventCode=4738 MSADChangedAttributes="*Don''t Require  Preauth'' - Enabled*" |rename Account_Name as user | table EventCode, user, dest, Security_ID, MSADChangedAttributes  | `kerberos_pre_authentication_flag_disabled_in_useraccountcontrol_filter`'



<li><a href="#">NAME: Kerberos Pre-Authentication Flag Disabled with PowerShell

DESCRIPTION:  The following analytic utilizes PowerShell Script Block Logging (EventCode=4104)  to identify the execution of the `Set-ADAccountControl` commandlet with specific  parameters. `Set-ADAccountControl` is part of the Active Directory PowerShell module  used to manage Windows Active Directory networks. As the name suggests, `Set-ADAccountControl`  is used to modify User Account Control values for an Active Directory domain account.  With the appropiate parameters, Set-ADAccountControl allows adversaries to disable  Kerberos Pre-Authentication for an account to to easily perform a brute force attack  against the user's password offline leveraging the ASP REP Roasting technique. Red  Teams and adversaries alike who have obtained privileges in an Active Directory  network may use this technique as a backdoor or a way to escalate privileges.

SEARCH:  '`powershell` EventCode=4104 (ScriptBlockText = "*Set-ADAccountControl*" AND  ScriptBlockText="*DoesNotRequirePreAuth:$true*") | stats count min(_time) as firstTime  max(_time) as lastTime by EventCode ScriptBlockText Computer user_id | rename Computer as dest | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `kerberos_pre_authentication_flag_disabled_with_powershell_filter`'



<li><a href="#">NAME: Kerberos Service Ticket Request Using RC4 Encryption

DESCRIPTION:  The following analytic leverages Kerberos Event 4769, A Kerberos service  ticket was requested, to identify a potential Kerberos Service Ticket request related  to a Golden Ticket attack. Adversaries who have obtained the Krbtgt account NTLM  password hash may forge a Kerberos Granting Ticket (TGT) to obtain unrestricted  access to an Active Directory environment. Armed with a Golden Ticket, attackers  can request service tickets to move laterally and execute code on remote systems.  Looking for Kerberos Service Ticket requests using the legacy RC4 encryption mechanism  could represent the second stage of a Golden Ticket attack. RC4 usage should be  rare on a modern network since Windows Vista & Windows Sever 2008 and newer support  AES Kerberos encryption.\ Defenders should note that if an attacker does not leverage  the NTLM password hash but rather the AES key to create a golden ticket, this detection  may be bypassed.

SEARCH:  ' `wineventlog_security` EventCode=4769 Service_Name="*$" (Ticket_Options=0x40810000  OR Ticket_Options=0x40800000 OR Ticket_Options=0x40810010) Ticket_Encryption_Type=0x17  | stats count min(_time) as firstTime max(_time) as lastTime by dest, service, service_id,  Ticket_Encryption_Type, Ticket_Options | `security_content_ctime(lastTime)` | `security_content_ctime(firstTime)`  | `kerberos_service_ticket_request_using_rc4_encryption_filter`'



<li><a href="#">NAME: Kerberos TGT Request Using RC4 Encryption

DESCRIPTION:  The following analytic leverages Event 4768, A Kerberos authentication  ticket (TGT) was requested, to identify a TGT request with encryption type 0x17,  or RC4-HMAC. This encryption type is no longer utilized by newer systems and could  represent evidence of an OverPass The Hash attack. Similar to Pass The Hash, OverPass  The Hash is a form of credential theft that allows adversaries to move laterally  or consume resources in a target network. Leveraging this attack, an adversary who  has stolen the NTLM hash of a valid domain account is able to authenticate to the  Kerberos Distribution Center(KDC) on behalf of the legitimate account and obtain  a Kerberos TGT ticket. Depending on the privileges of the compromised account, this  ticket may be used to obtain unauthorized access to systems and other network resources.

SEARCH:  ' `wineventlog_security` EventCode=4768 Ticket_Encryption_Type=0x17 Account_Name!=*$   | stats count min(_time) as firstTime max(_time) as lastTime by Account_Name Client_Address dest  | `security_content_ctime(firstTime)`   | `security_content_ctime(lastTime)`   | `kerberos_tgt_request_using_rc4_encryption_filter`'



<li><a href="#">NAME: Kerberos User Enumeration

DESCRIPTION:  The following analytic leverages Event Id 4768, A Kerberos authentication  ticket (TGT) was requested, to identify one source endpoint trying to obtain an  unusual number Kerberos TGT ticket for non existing users. This behavior could represent  an adversary abusing the Kerberos protocol to perform a user enumeration attack  against an Active Directory environment. When Kerberos is sent a TGT request with  no preauthentication for an invalid username, it responds with KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN  or 0x6. Red teams and adversaries alike may abuse the Kerberos protocol to validate  a list of users use them to perform further attacks.\ The detection calculates the  standard deviation for each host and leverages the 3-sigma statistical rule to identify  an unusual number requests. To customize this analytic, users can try different  combinations of the `bucket` span time and the calculation of the `upperBound` field.

SEARCH:  ' `wineventlog_security` EventCode=4768 Result_Code=0x6 Account_Name!="*$"  | bucket span=2m _time | stats dc(Account_Name) AS unique_accounts values(Account_Name)  as tried_accounts by _time, Client_Address | eventstats avg(unique_accounts) as  comp_avg , stdev(unique_accounts) as comp_std by Client_Address | eval upperBound=(comp_avg+comp_std*3)  | eval isOutlier=if(unique_accounts > 10 and unique_accounts >= upperBound, 1, 0)  | search isOutlier=1 | `kerberos_user_enumeration_filter`'



<li><a href="#">NAME: Known Services Killed by Ransomware

DESCRIPTION:  This search detects a suspicioous termination of known services killed  by ransomware before encrypting files in a compromised machine. This technique is  commonly seen in most of ransomware now a days to avoid exception error while accessing  the targetted files it wants to encrypts because of the open handle of those services  to the targetted file.

SEARCH:  '`wineventlog_system` EventCode=7036 Message IN ("*Volume Shadow Copy*","*VSS*",  "*backup*", "*sophos*", "*sql*", "*memtas*", "*mepocs*", "*veeam*", "*svc$*", "DefWatch",  "ccEvtMgr", "ccSetMgr", "SavRoam", "RTVscan", "QBFCService", "QBIDPService", "Intuit.QuickBooks.FCS",  "QBCFMonitorService" "YooBackup", "YooIT", "*Veeam*", "PDVFSService", "BackupExecVSSProvider",  "BackupExecAgentAccelerator", "BackupExec*", "WdBoot", "WdFilter", "WdNisDrv", "WdNisSvc",  "WinDefend", "wscsvc", "Sense", "sppsvc", "SecurityHealthService") Message="*service  entered the stopped state*" | stats count min(_time) as firstTime max(_time) as  lastTime by EventCode Message dest Type | `security_content_ctime(lastTime)` | `security_content_ctime(firstTime)`  | `known_services_killed_by_ransomware_filter`'



<li><a href="#">NAME: Large Volume of DNS ANY Queries

DESCRIPTION:  The search is used to identify attempts to use your DNS Infrastructure  for DDoS purposes via a DNS amplification attack leveraging ANY queries.

SEARCH:  '| tstats `security_content_summariesonly` count from datamodel=Network_Resolution  where nodename=DNS "DNS.message_type"="QUERY" "DNS.record_type"="ANY" by "DNS.dest"  | `drop_dm_object_name("DNS")` | where count>200 | `large_volume_of_dns_any_queries_filter`'



<li><a href="#">NAME: Living Off The Land

DESCRIPTION:  The following correlation identifies a distinct amount of analytics associated  with the Living Off The Land analytic story that identify potentially suspicious  behavior.

SEARCH:  '| tstats `security_content_summariesonly` min(_time) as firstTime max(_time)  as lastTime sum(All_Risk.calculated_risk_score) as risk_score, count(All_Risk.calculated_risk_score)  as risk_event_count, values(All_Risk.annotations.mitre_attack.mitre_tactic_id) as  annotations.mitre_attack.mitre_tactic_id, dc(All_Risk.annotations.mitre_attack.mitre_tactic_id)  as mitre_tactic_id_count, values(All_Risk.annotations.mitre_attack.mitre_technique_id)  as annotations.mitre_attack.mitre_technique_id, dc(All_Risk.annotations.mitre_attack.mitre_technique_id)  as mitre_technique_id_count, values(All_Risk.tag) as tag, values(source) as source,  dc(source) as source_count from datamodel=Risk.All_Risk where All_Risk.analyticstories="Living  Off The Land" All_Risk.risk_object_type="system" by All_Risk.risk_object All_Risk.risk_object_type  All_Risk.annotations.mitre_attack.mitre_tactic | `drop_dm_object_name(All_Risk)`  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | where  source_count >= 5 | `living_off_the_land_filter`'



<li><a href="#">NAME: Loading Of Dynwrapx Module

DESCRIPTION:  DynamicWrapperX is an ActiveX component that can be used in a script  to call Windows API functions, but it requires the dynwrapx.dll to be installed  and registered. With that, registering or loading dynwrapx.dll to a host is highly  suspicious. In most instances when it is used maliciously, the best way to triage  is to review parallel processes and pivot on the process_guid. Review the registry  for any suspicious modifications meant to load dynwrapx.dll. Identify any suspicious  module loads of dynwrapx.dll. This detection will return and identify the processes  that invoke vbs/wscript/cscript.

SEARCH:  '`sysmon` EventCode=7 (ImageLoaded = "*\\dynwrapx.dll" OR OriginalFileName  = "dynwrapx.dll" OR  Product = "DynamicWrapperX") | stats count min(_time) as firstTime  max(_time) as lastTime by Image ImageLoaded OriginalFileName Product process_name  dest EventCode Signed ProcessId | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `loading_of_dynwrapx_module_filter`'



<li><a href="#">NAME: Local Account Discovery with Net

DESCRIPTION:  This analytic looks for the execution of `net.exe` or `net1.exe` with  command-line arguments utilized to query for local users. The two arguments `user`  and 'users', return a list of all local users. Red Teams and adversaries alike use  net.exe to enumerate users for situational awareness and Active Directory Discovery.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where `process_net` (Processes.process=*user  OR Processes.process=*users) by Processes.dest Processes.user Processes.parent_process  Processes.process_name Processes.process Processes.process_id Processes.parent_process_id  | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `local_account_discovery_with_net_filter`'



<li><a href="#">NAME: Local Account Discovery With Wmic

DESCRIPTION:  This analytic looks for the execution of `wmic.exe` with command-line  arguments utilized to query for local users. The argument `useraccount` is used  to leverage WMI to return a list of all local users. Red Teams and adversaries alike  use net.exe to enumerate users for situational awareness and Active Directory Discovery.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where `process_wmic` (Processes.process=*useraccount*)  by Processes.dest Processes.user Processes.parent_process Processes.process_name  Processes.process Processes.process_id Processes.parent_process_id | `drop_dm_object_name(Processes)`  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `local_account_discovery_with_wmic_filter`'



<li><a href="#">NAME: Log4Shell CVE-2021-44228 Exploitation

DESCRIPTION:  This correlation find exploitation of Log4Shell CVE-2021-44228 against  systems using detections from Splunk Security Content Analytic Story. It does this  by calculating the distinct count of MITRE ATT&CK tactics from Log4Shell detections  fired. If the count is larger than 2 or more distinct MITRE ATT&CK tactics we assume  high problability of exploitation. The Analytic story breaks down into 3 major phases  of a Log4Shell exploitation, specifically> Initial Payload delivery eg. `${jndi:ldap://PAYLOAD_INJECTED}`  Call back to malicious LDAP server eg. Exploit.class Post Exploitation Activity/Lateral  Movement using Powershell or similar T1562.001 Each of these phases fall into different  MITRE ATT&CK Tactics (Initial Access, Execution, Command And Control), by looking  into 2 or more phases showing up in detections triggerd is how this correlation  search finds exploitation. If we get a notable from this correlation search the  best way to triage it is by investigating the affected systems against Log4Shell  exploitation using Splunk SOAR playbooks.

SEARCH:  '| tstats `security_content_summariesonly` min(_time) as firstTime max(_time)  as lastTime sum(All_Risk.calculated_risk_score) as risk_score, count(All_Risk.calculated_risk_score)  as risk_event_count, values(All_Risk.annotations.mitre_attack.mitre_tactic_id) as  annotations.mitre_attack.mitre_tactic_id, dc(All_Risk.annotations.mitre_attack.mitre_tactic_id)  as mitre_tactic_id_count, values(All_Risk.annotations.mitre_attack.mitre_technique_id)  as annotations.mitre_attack.mitre_technique_id, dc(All_Risk.annotations.mitre_attack.mitre_technique_id)  as mitre_technique_id_count, values(All_Risk.tag) as tag, values(source) as source,  dc(source) as source_count from datamodel=Risk.All_Risk where All_Risk.analyticstories="Log4Shell  CVE-2021-44228" All_Risk.risk_object_type="system" by All_Risk.risk_object All_Risk.risk_object_type  All_Risk.annotations.mitre_attack.mitre_tactic | `drop_dm_object_name(All_Risk)`  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | where  source_count >= 2 | `log4shell_cve_2021_44228_exploitation_filter`'



<li><a href="#">NAME: Logon Script Event Trigger Execution

DESCRIPTION:  This search is to detect a suspicious modification of registry entry  to persist and gain privilege escalation upon booting up of compromised host. This  technique was seen in several APT and malware where it modify UserInitMprLogonScript  registry entry to its malicious payload to be executed upon boot up of the machine.

SEARCH:  '| tstats `security_content_summariesonly` count  min(_time) as firstTime  max(_time) as lastTime FROM datamodel=Endpoint.Registry where Registry.registry_path  IN ("*\\Environment\\UserInitMprLogonScript") by Registry.dest  Registry.user Registry.registry_path  Registry.registry_key_name Registry.registry_value_name | `security_content_ctime(lastTime)`  | `security_content_ctime(firstTime)` | `drop_dm_object_name(Registry)` | `logon_script_event_trigger_execution_filter`'



<li><a href="#">NAME: LOLBAS With Network Traffic

DESCRIPTION:  The following analytic identifies LOLBAS with network traffic. When adversaries  abuse LOLBAS they are often used to download malicious code or executables. The  LOLBAS project documents Windows native binaries that can be abused by threat actors  to perform tasks like downloading malicious code. Looking for these process can  help defenders identify lateral movement, command-and-control, or exfiltration activies.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Network_Traffic.All_Traffic where (All_Traffic.app IN  ("*Regsvcs.exe", "*\\Ftp.exe", "*OfflineScannerShell.exe", "*Rasautou.exe", "*Schtasks.exe",  "*Xwizard.exe", "*Pnputil.exe", "*Atbroker.exe", "*Pcwrun.exe", "*Ttdinject.exe",  "*Mshta.exe", "*Bitsadmin.exe", "*Certoc.exe", "*Ieexec.exe", "*Microsoft.Workflow.Compiler.exe",  "*Runscripthelper.exe", "*Forfiles.exe", "*Msbuild.exe", "*Register-cimprovider.exe",  "*Tttracer.exe", "*Ie4uinit.exe", "*Bash.exe", "*Hh.exe", "*SettingSyncHost.exe",  "*Cmstp.exe", "*Stordiag.exe", "*Scriptrunner.exe", "*Odbcconf.exe", "*Extexport.exe",  "*Msdt.exe", "*WorkFolders.exe", "*Diskshadow.exe", "*Mavinject.exe", "*Regasm.exe",  "*Gpscript.exe", "*Regsvr32.exe", "*Msiexec.exe", "*Wuauclt.exe", "*Presentationhost.exe",  "*Wmic.exe", "*Runonce.exe", "*Syncappvpublishingserver.exe", "*Verclsid.exe", "*Infdefaultinstall.exe",  "*Installutil.exe", "*Netsh.exe", "*Wab.exe", "*Dnscmd.exe", "*\\At.exe", "*Pcalua.exe",  "*Msconfig.exe", "*makecab.exe", "*cscript.exe", "*notepad.exe", "*\\cmd.exe", "*certutil.exe",  "*\\powershell.exe", "*powershell_ise.exe")) by All_Traffic.app,All_Traffic.src,All_Traffic.src_ip,All_Traffic.user,All_Traffic.dest,All_Traffic.dest_ip  | `drop_dm_object_name(All_Traffic)` | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | rex field=app ".*\\\(?<process_name>.*)$" | rename app as process | `lolbas_with_network_traffic_filter`'



<li><a href="#">NAME: MacOS LOLbin

DESCRIPTION:  Detect multiple executions of Living off the Land (LOLbin) binaries in  a short period of time.

SEARCH:  '`osquery` name=es_process_events columns.cmdline IN ("find*", "crontab*",  "screencapture*", "openssl*", "curl*", "wget*", "killall*", "funzip*") | rename  columns.* as * | stats  min(_time) as firstTime max(_time) as lastTime values(cmdline)  as cmdline, values(pid) as pid, values(parent) as parent, values(path) as path,  values(signing_id) as signing_id,  dc(path) as dc_path by username host | rename  username as user, cmdline as process, path as process_path, host as dest | where dc_path > 3 |  `security_content_ctime(firstTime)`| `security_content_ctime(lastTime)` | `macos_lolbin_filter`'



<li><a href="#">NAME: MacOS plutil

DESCRIPTION:  Detect usage of plutil to modify plist files. Adversaries can modiy plist  files to executed binaries or add command line arguments. Plist files in auto-run  locations are executed upon user logon or system startup.

SEARCH:  '`osquery` name=es_process_events columns.path=/usr/bin/plutil | rename columns.*  as * | stats count  min(_time) as firstTime max(_time) as lastTime by username host  cmdline pid path parent signing_id | rename username as user, cmdline as process,  path as process_path, host as dest | `security_content_ctime(firstTime)`| `security_content_ctime(lastTime)`  | `macos_plutil_filter`'



<li><a href="#">NAME: MacOS - Re-opened Applications

DESCRIPTION:  This search looks for processes referencing the plist files that determine  which applications are re-opened when a user reboots their machine.

SEARCH:  '| tstats `security_content_summariesonly` count values(Processes.process)  as process values(Processes.parent_process) as parent_process min(_time) as firstTime  max(_time) as lastTime from datamodel=Endpoint.Processes where Processes.process="*com.apple.loginwindow*"  by Processes.user Processes.process_name Processes.parent_process_name Processes.dest  | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `macos___re_opened_applications_filter`'



<li><a href="#">NAME: Mailsniper Invoke functions

DESCRIPTION:  This search is to detect known mailsniper.ps1 functions executed in a  machine. This technique was seen in some attacker to harvest some sensitive e-mail  in a compromised exchange server.

SEARCH:  '`powershell` EventCode=4104 ScriptBlockText IN ("*Invoke-GlobalO365MailSearch*",  "*Invoke-GlobalMailSearch*", "*Invoke-SelfSearch*", "*Invoke-PasswordSprayOWA*",  "*Invoke-PasswordSprayEWS*","*Invoke-DomainHarvestOWA*", "*Invoke-UsernameHarvestOWA*","*Invoke-OpenInboxFinder*","*Invoke-InjectGEventAPI*","*Invoke-InjectGEvent*","*Invoke-SearchGmail*",  "*Invoke-MonitorCredSniper*", "*Invoke-AddGmailRule*","*Invoke-PasswordSprayEAS*","*Invoke-UsernameHarvestEAS*")  | stats count min(_time) as firstTime max(_time) as lastTime by Opcode Computer  UserID EventCode ScriptBlockText | rename Computer as dest | rename UserID as user | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `mailsniper_invoke_functions_filter`'



<li><a href="#">NAME: Malicious InProcServer32 Modification

DESCRIPTION:  The following analytic identifies a process modifying the registry with  a known malicious CLSID under InProcServer32. Most COM classes are registered with  the operating system and are identified by a GUID that represents the Class Identifier  (CLSID) within the registry (usually under HKLM\\Software\\Classes\\CLSID or HKCU\\Software\\Classes\\CLSID).  Behind  the implementation of a COM class is the server (some binary) that is referenced  within registry keys under the CLSID.  The LocalServer32 key represents a path to  an executable (exe) implementation, and the InprocServer32 key represents a path  to a dynamic link library (DLL) implementation (Bohops). During triage, review parallel  processes for suspicious activity. Pivot on the process GUID to see the full timeline  of events. Analyze the value and look for file modifications. Being this is looking  for inprocserver32, a DLL found in the value will most likely be loaded by a parallel  process.

SEARCH:  '| tstats `security_content_summariesonly` count FROM datamodel=Endpoint.Processes  by _time Processes.process_id Processes.process_name Processes.dest Processes.process_guid  Processes.user | `drop_dm_object_name(Processes)` | join process_guid [| tstats  `security_content_summariesonly` count FROM datamodel=Endpoint.Registry where Registry.registry_path=  "*\\CLSID\\{89565275-A714-4a43-912E-978B935EDCCC}\\InProcServer32\\(Default)" by  Registry.registry_path Registry.registry_key_name Registry.registry_value_name Registry.dest  Registry.process_guid Registry.user | `drop_dm_object_name(Registry)` | fields _time  dest registry_path registry_key_name registry_value_name process_name process_path  process process_guid user] | stats count min(_time) as firstTime max(_time) as lastTime  by dest, process_name registry_path registry_key_name registry_value_name user |  `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `malicious_inprocserver32_modification_filter`'



<li><a href="#">NAME: Malicious Powershell Executed As A Service

DESCRIPTION:  This detection is to identify the abuse the Windows SC.exe to execute  malicious commands or payloads via PowerShell.

SEARCH:  ' `wineventlog_system` EventCode=7045 | eval l_Service_File_Name=lower(Service_File_Name)  | regex l_Service_File_Name="powershell[.\s]|powershell_ise[.\s]|pwsh[.\s]|psexec[.\s]"  | regex l_Service_File_Name="-nop[rofile\s]+|-w[indowstyle]*\s+hid[den]*|-noe[xit\s]+|-enc[odedcommand\s]+"  | stats count min(_time) as firstTime max(_time) as lastTime by EventCode Service_File_Name  Service_Name Service_Start_Type Service_Type Service_Account user dest| `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `malicious_powershell_executed_as_a_service_filter`'



<li><a href="#">NAME: Malicious PowerShell Process With Obfuscation Techniques

DESCRIPTION:  This search looks for PowerShell processes launched with arguments that  have characters indicative of obfuscation on the command-line.

SEARCH:  '| tstats `security_content_summariesonly` count values(Processes.process)  as process values(Processes.parent_process) as parent_process min(_time) as firstTime  max(_time) as lastTime from datamodel=Endpoint.Processes where `process_powershell`  by Processes.user Processes.process_name Processes.original_file_name Processes.parent_process_name  Processes.dest Processes.process | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)`|  `security_content_ctime(lastTime)`| eval num_obfuscation = (mvcount(split(process,"`"))-1)  + (mvcount(split(process, "^"))-1) + (mvcount(split(process, "''"))-1) | `malicious_powershell_process_with_obfuscation_techniques_filter`  | search num_obfuscation > 10 '



<li><a href="#">NAME: Malicious PowerShell Process - Encoded Command

DESCRIPTION:  'The following analytic identifies the use of the EncodedCommand PowerShell  parameter. This is typically used by Administrators to run complex scripts, but  commonly used by adversaries to hide their code. \  The analytic identifies all variations of EncodedCommand, as PowerShell allows the  ability to shorten the parameter. For example enc, enco, encod and so forth. In  addition, through our research it was identified that PowerShell will interpret  different command switch types beyond the hyphen. We have added endash, emdash,  horizontal bar, and forward slash. \  During triage, review parallel events to determine legitimacy. Tune as needed based  on admin scripts in use. \  Alternatively, may use regex per matching here https://regexr.com/662ov.'

SEARCH:  "| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)\  \ as lastTime from datamodel=Endpoint.Processes where `process_powershell` by Processes.user\  \ Processes.process_name Processes.process Processes.parent_process_name Processes.original_file_name\  \ Processes.dest Processes.process_id | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)`\  \ | `security_content_ctime(lastTime)` | where match(process,\"(?i)[\\-|\\/|\u2013\  |\u2014|\u2015]e(nc*o*d*e*d*c*o*m*m*a*n*d*)*\\s+[^-]\") | `malicious_powershell_process___encoded_command_filter`"



<li><a href="#">NAME: Malicious PowerShell Process - Execution Policy Bypass

DESCRIPTION:  This search looks for PowerShell processes started with parameters used  to bypass the local execution policy for scripts. These parameters are often observed  in attacks leveraging PowerShell scripts as they override the default PowerShell  execution policy.

SEARCH:  '| tstats `security_content_summariesonly` values(Processes.process_id) as  process_id, values(Processes.parent_process_id) as parent_process_id values(Processes.process)  as process min(_time) as firstTime max(_time) as lastTime from datamodel=Endpoint.Processes  where `process_powershell` (Processes.process="* -ex*" OR Processes.process="* bypass  *") by Processes.process_id, Processes.user, Processes.dest | `drop_dm_object_name(Processes)`  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `malicious_powershell_process___execution_policy_bypass_filter`'



<li><a href="#">NAME: Mimikatz PassTheTicket CommandLine Parameters

DESCRIPTION:  The following analytic looks for the use of Mimikatz command line parameters  leveraged to execute pass the ticket attacks. Red teams and adversaries alike may  use the pass the ticket technique using stolen Kerberos tickets to move laterally  within an environment, bypassing normal system access controls. Defenders should  be aware that adversaries may customize the source code of Mimikatz and modify the  command line parameters. This would effectively bypass this analytic.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where (Processes.process = "*sekurlsa::tickets  /export*" OR Processes.process = "*kerberos::ptt*") by Processes.dest Processes.user  Processes.parent_process Processes.process_name Processes.process Processes.process_id  Processes.parent_process_id Processes.parent_process_name | `drop_dm_object_name(Processes)`  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `mimikatz_passtheticket_commandline_parameters_filter`'



<li><a href="#">NAME: Mmc LOLBAS Execution Process Spawn

DESCRIPTION:  The following analytic identifies `mmc.exe` spawning a LOLBAS execution  process. When adversaries execute code on remote endpoints abusing the DCOM protocol  and the MMC20 COM object, the executed command is spawned as a child processs of  `mmc.exe`. The LOLBAS project documents Windows native binaries that can be abused  by threat actors to perform tasks like executing malicious code. Looking for child  processes of mmc.exe that are part of the LOLBAS project can help defenders identify  lateral movement activity.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where (Processes.parent_process_name=mmc.exe)  (Processes.process_name IN ("Regsvcs.exe", "Ftp.exe", "OfflineScannerShell.exe",  "Rasautou.exe", "Schtasks.exe", "Xwizard.exe", "Dllhost.exe", "Pnputil.exe", "Atbroker.exe",  "Pcwrun.exe", "Ttdinject.exe","Mshta.exe", "Bitsadmin.exe", "Certoc.exe", "Ieexec.exe",  "Microsoft.Workflow.Compiler.exe", "Runscripthelper.exe", "Forfiles.exe", "Msbuild.exe",  "Register-cimprovider.exe", "Tttracer.exe", "Ie4uinit.exe", "Bash.exe", "Hh.exe",  "SettingSyncHost.exe", "Cmstp.exe", "Mmc.exe", "Stordiag.exe", "Scriptrunner.exe",  "Odbcconf.exe", "Extexport.exe", "Msdt.exe", "WorkFolders.exe", "Diskshadow.exe",  "Mavinject.exe", "Regasm.exe", "Gpscript.exe", "Rundll32.exe", "Regsvr32.exe", "Msiexec.exe",  "Wuauclt.exe", "Presentationhost.exe", "Wmic.exe", "Runonce.exe", "Syncappvpublishingserver.exe",  "Verclsid.exe", "Infdefaultinstall.exe", "Explorer.exe", "Installutil.exe", "Netsh.exe",  "Wab.exe", "Dnscmd.exe", "At.exe", "Pcalua.exe", "Msconfig.exe")) by Processes.dest  Processes.user Processes.parent_process Processes.process_name Processes.process  Processes.process_id Processes.parent_process_id | `drop_dm_object_name(Processes)`  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `mmc_lolbas_execution_process_spawn_filter`'



<li><a href="#">NAME: Modification Of Wallpaper

DESCRIPTION:  This analytic identifies suspicious modification of registry to deface  or change the wallpaper of a compromised machines as part of its payload. This technique  was commonly seen in ransomware like REVIL where it create a bitmap file contain  a note that the machine was compromised and make it as a wallpaper.

SEARCH:  '`sysmon` EventCode =13  (TargetObject IN ("*\\Control Panel\\Desktop\\Wallpaper","*\\Control Panel\\Desktop\\WallpaperStyle") AND Image != "*\\explorer.exe")   OR (TargetObject IN ("*\\Control Panel\\Desktop\\Wallpaper","*\\Control Panel\\Desktop\\WallpaperStyle") AND Details IN ("*\\temp\\*", "*\\users\\public\\*"))   | stats count min(_time) as firstTime max(_time) as lastTime by EventCode Image TargetObject Details Computer process_guid process_id user_id   | rename Computer as dest   | `security_content_ctime(firstTime)`   | `security_content_ctime(lastTime)`  | `modification_of_wallpaper_filter`'



<li><a href="#">NAME: Modify ACL permission To Files Or Folder

DESCRIPTION:  This analytic identifies suspicious modification of ACL permission to  a files or folder to make it available to everyone. This technique may be used by  the adversary to evade ACLs or protected files access. This changes is commonly  configured by the file or directory owner with appropriate permission. This behavior  is a good indicator if this command seen on a machine utilized by an account with  no permission to do so.

SEARCH:  '| tstats `security_content_summariesonly` values(Processes.process) as process  values(Processes.process_id) as process_id count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where (Processes.process_name = "cacls.exe"  OR Processes.process_name = "icacls.exe" OR Processes.process_name = "xcacls.exe")  AND Processes.process = "*/G*" AND (Processes.process = "* everyone:*"  OR Processes.process  = "* SYSTEM:*" OR Processes.process = "* S-1-1-0:*") by Processes.parent_process_name  Processes.process_name Processes.dest Processes.user | `drop_dm_object_name(Processes)`  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `modify_acl_permission_to_files_or_folder_filter`'



<li><a href="#">NAME: Monitor Registry Keys for Print Monitors

DESCRIPTION:  This search looks for registry activity associated with modifications  to the registry key `HKLM\SYSTEM\CurrentControlSet\Control\Print\Monitors`. In this  scenario, an attacker can load an arbitrary .dll into the print-monitor registry  by giving the full path name to the after.dll. The system will execute the .dll  with elevated (SYSTEM) permissions and will persist after reboot.

SEARCH:  '| tstats `security_content_summariesonly` count FROM datamodel=Endpoint.Registry  WHERE (Registry.action=modified AND Registry.registry_path="*CurrentControlSet\\Control\\Print\\Monitors*")  BY _time span=1h Registry.dest Registry.user Registry.registry_path Registry.registry_key_name Registry.registry_value_name  Registry.registry_value_data Registry.process_guid | `drop_dm_object_name(Registry)` | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `monitor_registry_keys_for_print_monitors_filter`'



<li><a href="#">NAME: MSBuild Suspicious Spawned By Script Process

DESCRIPTION:  This analytic is to detect a suspicious child process of MSBuild spawned  by Windows Script Host - cscript or wscript. This behavior or event are commonly  seen and used by malware or adversaries to execute malicious msbuild process using  malicious script in the compromised host. During triage, review parallel processes  and identify any file modifications. MSBuild may load a script from the same path  without having command-line arguments.

SEARCH:  '| tstats `security_content_summariesonly` count values(Processes.process_name)  as process_name values(Processes.process) as process min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.parent_process_name  IN ("wscript.exe", "cscript.exe") AND `process_msbuild` by Processes.dest Processes.parent_process  Processes.parent_process_name Processes.process_name Processes.original_file_name  Processes.user | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `msbuild_suspicious_spawned_by_script_process_filter`'



<li><a href="#">NAME: Mshta spawning Rundll32 OR Regsvr32 Process

DESCRIPTION:  This search is to detect a suspicious mshta.exe process that spawn rundll32  or regsvr32 child process. This technique was seen in several malware nowadays like  trickbot to load its initial .dll stage loader to execute and download the the actual  trickbot payload.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.parent_process_name  = "mshta.exe"  `process_rundll32` OR `process_regsvr32` by Processes.parent_process  Processes.process_name Processes.process Processes.process_id Processes.process_guid  Processes.user Processes.dest | `drop_dm_object_name("Processes")` | `security_content_ctime(firstTime)`  |`security_content_ctime(lastTime)` | `mshta_spawning_rundll32_or_regsvr32_process_filter`'



<li><a href="#">NAME: MSHTML Module Load in Office Product

DESCRIPTION:  The following detection identifies the module load of mshtml.dll into  an Office product. This behavior has been related to CVE-2021-40444, whereas the  malicious document will load ActiveX, which activates the MSHTML component. The  vulnerability resides in the MSHTML component. During triage, identify parallel  processes and capture any file modifications for analysis.

SEARCH:  '`sysmon` EventID=7  parent_process_name IN ("winword.exe","excel.exe","powerpnt.exe","mspub.exe","visio.exe","wordpad.exe","wordview.exe","onenote.exe","onenotem.exe","onenoteviewer.exe","onenoteim.exe",  "msaccess.exe","Graph.exe","winproj.exe") ImageLoaded IN ("*\\mshtml.dll", "*\\Microsoft.mshtml.dll","*\\IE.Interop.MSHTML.dll","*\\MshtmlDac.dll","*\\MshtmlDed.dll","*\\MshtmlDer.dll")  | stats count min(_time) as firstTime max(_time) as lastTime by dest, process_name,  ImageLoaded, OriginalFileName, ProcessGuid  | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `mshtml_module_load_in_office_product_filter`'



<li><a href="#">NAME: MSI Module Loaded by Non-System Binary

DESCRIPTION:  'The following hunting analytic identifies `msi.dll` being loaded by  a binary not located in `system32`, `syswow64`, `winsxs` or `windows` paths. This  behavior is most recently related to InstallerFileTakeOver, or CVE-2021-41379, and  DLL side-loading. CVE-2021-41379 requires a binary to be dropped and `msi.dll` to  be loaded by it. To Successful exploitation of this issue happens in four parts  \  1. Generation of an MSI that will trigger bad behavior. \  1. Preparing a directory for MSI installation. \  1. Inducing an error state. \  1. Racing to introduce a junction and a symlink to trick msiexec.exe to modify the  attacker specified file. \  In addition, `msi.dll` has been abused in DLL side-loading attacks by being loaded  by non-system binaries.'

SEARCH:  '`sysmon` EventCode=7 ImageLoaded="*\\msi.dll" NOT (Image IN ("*\\System32\\*","*\\syswow64\\*","*\\windows\\*",  "*\\winsxs\\*")) | stats count min(_time) as firstTime max(_time) as lastTime by  Image ImageLoaded process_name dest EventCode ProcessId | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `msi_module_loaded_by_non_system_binary_filter`'



<li><a href="#">NAME: Msmpeng Application DLL Side Loading

DESCRIPTION:  This search is to detect a suspicious creation of msmpeng.exe or mpsvc.dll  in non default windows defender folder. This technique was seen  with revil ransomware in Kaseya Supply chain. The approach is to drop an old version  of msmpeng.exe to load the actual payload name as mspvc.dll which will load the  revil ransomware to the compromise machine

SEARCH:  '|tstats `security_content_summariesonly` values(Filesystem.file_path) as  file_path count min(_time) as firstTime max(_time) as lastTime from datamodel=Endpoint.Filesystem  where (Filesystem.file_name = "msmpeng.exe" OR Filesystem.file_name = "mpsvc.dll")  AND NOT   (Filesystem.file_path IN ("*\\Program Files\\windows defender\\*","*\\WinSxS\\*defender-service*","*\\WinSxS\\Temp\\*defender-service*")) by Filesystem.file_create_time  Filesystem.process_id  Filesystem.file_name Filesystem.user Filesystem.dest | `drop_dm_object_name(Filesystem)`  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `msmpeng_application_dll_side_loading_filter`'



<li><a href="#">NAME: MS Exchange Mailbox Replication service writing Active Server Pages

DESCRIPTION:  'The following query identifies suspicious .aspx created in 3 paths identified  by Microsoft as known drop locations for Exchange exploitation related to HAFNIUM  group and recently disclosed vulnerablity named ProxyShell. Paths include: `\HttpProxy\owa\auth\`,  `\inetpub\wwwroot\aspnet_client\`, and `\HttpProxy\OAB\`. The analytic is limited  to process name MSExchangeMailboxReplication.exe, which typically does not write  .aspx files to disk. Upon triage, the suspicious .aspx file will likely look obvious  on the surface. inspect the contents for script code inside. Identify additional  log sources, IIS included, to review source and other potential exploitation. It  is often the case that a particular threat is only applicable to a specific subset  of systems in your environment. Typically analytics to detect those threats are  written without the benefit of being able to only target those systems as well.  Writing analytics against all systems when those behaviors are limited to identifiable  subsets of those systems is suboptimal. Consider the case ProxyShell vulnerability  on Microsoft Exchange Servers. With asset information, a hunter can limit their  analytics to systems that have been identified as Exchange servers. A hunter may  start with the theory that the exchange server is communicating with new systems  that it has not previously. If this theory is run against all publicly facing systems,  the amount of noise it will generate will likely render this theory untenable. However,  using the asset information to limit this analytic to just the Exchange servers  will reduce the noise allowing the hunter to focus only on the systems where this  behavioral change is relevant.'

SEARCH:  '| tstats `security_content_summariesonly` count FROM datamodel=Endpoint.Processes  where Processes.process_name=MSExchangeMailboxReplication.exe  by _time span=1h  Processes.process_id Processes.process_name Processes.process_guid Processes.dest  | `drop_dm_object_name(Processes)` | join process_guid, _time [| tstats `security_content_summariesonly`  count min(_time) as firstTime max(_time) as lastTime FROM datamodel=Endpoint.Filesystem  where Filesystem.file_path IN ("*\\HttpProxy\\owa\\auth\\*", "*\\inetpub\\wwwroot\\aspnet_client\\*",  "*\\HttpProxy\\OAB\\*") Filesystem.file_name="*.aspx" by _time span=1h Filesystem.dest  Filesystem.file_create_time Filesystem.file_name Filesystem.file_path | `drop_dm_object_name(Filesystem)`  | fields _time dest file_create_time file_name file_path process_name process_path  process process_guid] | dedup file_create_time | table dest file_create_time, file_name,  file_path, process_name | `ms_exchange_mailbox_replication_service_writing_active_server_pages_filter`'



<li><a href="#">NAME: MS Scripting Process Loading Ldap Module

DESCRIPTION:  This search is to detect a suspicious MS scripting process such as wscript.exe  or cscript.exe that loading ldap module to process ldap query. This behavior was  seen in FIN7 implant where it uses javascript to execute ldap query to parse host  information that will send to its C2 server. this anomaly detections is a good initial  step to hunt further a suspicious ldap query or ldap related events to the host  that may give you good information regarding ldap or AD information processing or  might be a attacker.

SEARCH:  '`sysmon` EventCode =7 Image IN ("*\\wscript.exe", "*\\cscript.exe") ImageLoaded  IN ("*\\Wldap32.dll", "*\\adsldp.dll", "*\\adsldpc.dll") | stats min(_time) as firstTime  max(_time) as lastTime count by Image EventCode process_name ProcessId ProcessGuid  Computer ImageLoaded | rename Computer as dest | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `ms_scripting_process_loading_ldap_module_filter`'



<li><a href="#">NAME: MS Scripting Process Loading WMI Module

DESCRIPTION:  This search is to detect a suspicious MS scripting process such as wscript.exe  or cscript.exe that loading wmi module to process wmi query. This behavior was seen  in FIN7 implant where it uses javascript to execute wmi query to parse host information  that will send to its C2 server. this anomaly detections is a good initial step  to hunt further a suspicious wmi query or wmi related events to the host that may  give you good information regarding process that are commonly using wmi query or  modules or might be an attacker using this technique.

SEARCH:  '`sysmon` EventCode =7 Image IN ("*\\wscript.exe", "*\\cscript.exe") ImageLoaded  IN ("*\\fastprox.dll", "*\\wbemdisp.dll", "*\\wbemprox.dll", "*\\wbemsvc.dll" ,  "*\\wmiutils.dll", "*\\wbemcomn.dll") | stats min(_time) as firstTime max(_time)  as lastTime count by Image EventCode process_name ProcessId ProcessGuid Computer  ImageLoaded | rename Computer as dest | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `ms_scripting_process_loading_wmi_module_filter`'



<li><a href="#">NAME: Multiple Archive Files Http Post Traffic

DESCRIPTION:  This search is designed to detect high frequency of archive files data  exfiltration through HTTP POST method protocol. This are one of the common techniques  used by APT or trojan spy after doing the data collection like screenshot, recording,  sensitive data to the infected machines. The attacker may execute archiving command  to the collected data, save it a temp folder with a hidden attribute then send it  to its C2 through HTTP POST. Sometimes adversaries will rename the archive files  or encode/encrypt to cover their tracks. This detection can detect a renamed archive  files transfer to HTTP POST since it checks the request body header. Unfortunately  this detection cannot support archive that was encrypted or encoded before doing  the exfiltration.

SEARCH:  '`stream_http` http_method=POST |eval archive_hdr1=substr(form_data,1,2) | eval archive_hdr2 = substr(form_data,1,4) |stats values(form_data) as http_request_body min(_time) as firstTime max(_time) as lastTime count by src_ip dest_ip http_method http_user_agent uri_path url bytes_in bytes_out archive_hdr1 archive_hdr2 |where count >20 AND (archive_hdr1 = "7z" OR archive_hdr1 = "PK" OR archive_hdr2="Rar!") | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `multiple_archive_files_http_post_traffic_filter`  '



<li><a href="#">NAME: Network Connection Discovery With Arp

DESCRIPTION:  This analytic looks for the execution of `arp.exe` utilized to get a  listing of network connections on a compromised system. Red Teams and adversaries  alike may use arp.exe for situational awareness and Active Directory Discovery.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where (Processes.process_name="arp.exe")  (Processes.process=*-a*) by Processes.dest Processes.user Processes.parent_process  Processes.process_name Processes.process Processes.process_id Processes.parent_process_id  | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `network_connection_discovery_with_arp_filter`'



<li><a href="#">NAME: Network Connection Discovery With Net

DESCRIPTION:  This analytic looks for the execution of `net.exe` with command-line  arguments utilized to get a listing of network connections on a compromised system.  Red Teams and adversaries alike may use net.exe for situational awareness and Active  Directory Discovery.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where (Processes.process_name="net.exe"  OR Processes.process_name="net1.exe") (Processes.process=*use*) by Processes.dest  Processes.user Processes.parent_process Processes.process_name Processes.process  Processes.process_id Processes.parent_process_id | `drop_dm_object_name(Processes)`  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `network_connection_discovery_with_net_filter`'



<li><a href="#">NAME: Network Connection Discovery With Netstat

DESCRIPTION:  This analytic looks for the execution of `netstat.exe` with command-line  arguments utilized to get a listing of network connections on a compromised system.  Red Teams and adversaries alike may use netstat.exe for situational awareness and  Active Directory Discovery.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where (Processes.process_name="netstat.exe")  (Processes.process=*-a*) by Processes.dest Processes.user Processes.parent_process  Processes.process_name Processes.process Processes.process_id Processes.parent_process_id  | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `network_connection_discovery_with_netstat_filter`'



<li><a href="#">NAME: Network Discovery Using Route Windows App

DESCRIPTION:  This analytic look for a spawned process of route.exe windows application.  Adversaries and red teams alike abuse this application the recon or do a network  discovery on a target host. but one possible false positive might be an automated  tool used by a system administator or a powershell script in amazon ec2 config services.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where `process_route` by Processes.dest  Processes.user Processes.parent_process_name Processes.parent_process Processes.process_name  Processes.process Processes.process_id Processes.parent_process_id | `drop_dm_object_name(Processes)`  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `network_discovery_using_route_windows_app_filter`'



<li><a href="#">NAME: Network Share Discovery Via Dir Command

DESCRIPTION:  The following analytic identifies object access on Windows administrative SMB shares (Admin$, IPC$, C$).   This represents suspicious behavior as its commonly used by tools like PsExec/PaExec and others  to stage service binaries before creating and starting a Windows service on remote  endpoints. Red Teams and adversaries alike may abuse administrative shares for lateral  movement and remote code execution. The IcedID malware family also implements  this behavior to try to infect other machines in the infected network.

SEARCH:  '`wineventlog_security` EventCode=5140 ShareName IN("\\\\*\\ADMIN$","\\\\*\\C$","*\\\\*\\IPC$") AccessMask= 0x1   | stats min(_time) as firstTime max(_time) as lastTime count by ShareName IpAddress ObjectType SubjectUserName SubjectDomainName IpPort AccessMask Computer  | rename Computer as dest  | `security_content_ctime(firstTime)`   | `security_content_ctime(lastTime)`   | `network_share_discovery_via_dir_command_filter`'



<li><a href="#">NAME: Network Traffic to Active Directory Web Services Protocol

DESCRIPTION:  The following analytic identifies network traffic to Active Directory  Web Services Protocol. This protocol is used to manage Active Directory. The analytic is meant to be tuned and filtered to the specific environment. It will assist defenders in identifying suspicious processes accessing port 9389. 

SEARCH:  '| tstats count from datamodel=Network_Traffic where All_Traffic.dest_port=9389 by All_Traffic.src_ip, All_Traffic.dest_ip, All_Traffic.app, All_Traffic.user, All_Traffic.dest_port  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `drop_dm_object_name("All_Traffic")` | `network_traffic_to_active_directory_web_services_protocol_filter`'



<li><a href="#">NAME: Net Localgroup Discovery

DESCRIPTION:  The following hunting analytic will identify the use of localgroup discovery  using `net localgroup`. During triage, review parallel processes and identify any  further suspicious behavior.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.process_name=net.exe  OR Processes.process_name=net1.exe (Processes.process="*localgroup*") by Processes.dest  Processes.user Processes.parent_process_name Processes.process_name Processes.process  Processes.original_file_name Processes.process_id Processes.parent_process_id |  `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)`| `security_content_ctime(lastTime)`  | `net_localgroup_discovery_filter`'



<li><a href="#">NAME: NET Profiler UAC bypass

DESCRIPTION:  This search is to detect modification of registry to bypass UAC windows  feature. This technique is to add a payload dll path on .NET COR file path that  will be loaded by mmc.exe as soon it was executed. This detection rely on monitoring  the registry key and values in the detection area. It may happened that windows  update some dll related to mmc.exe and add dll path in this registry. In this case  filtering is needed.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Registry where Registry.registry_path= "*\\Environment\\COR_PROFILER_PATH"  Registry.registry_value_data = "*.dll" by Registry.registry_path Registry.registry_key_name  Registry.registry_value_data Registry.dest | `drop_dm_object_name(Registry)` | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `net_profiler_uac_bypass_filter`'



<li><a href="#">NAME: Ngrok Reverse Proxy on Network

DESCRIPTION:  The following analytic identifies the 4 most common Ngrok used domains  based on DNS queries under the Network Resolution datamodel. It's possible these  domains may be ran against the Web datamodel or ran with a direct query across network/proxy  traffic. The sign of someone using Ngrok is not malicious, however, more recenctly  it has become an adversary tool.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime  from datamodel=Network_Resolution where DNS.query IN ("*.ngrok.com","*.ngrok.io",  "ngrok.*.tunnel.com", "korgn.*.lennut.com") by DNS.src DNS.query DNS.answer |  `drop_dm_object_name("DNS")`  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `ngrok_reverse_proxy_on_network_filter`'



<li><a href="#">NAME: Nishang PowershellTCPOneLine

DESCRIPTION:  This query detects the Nishang Invoke-PowerShellTCPOneLine utility that  spawns a call back to a remote Command And Control server. This is a powershell  oneliner. In addition, this will capture on the command-line additional utilities  used by Nishang. Triage the endpoint and identify any parallel processes that look  suspicious. Review the reputation of the remote IP or domain contacted by the powershell  process.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where `process_powershell` (Processes.process=*Net.Sockets.TCPClient*  AND Processes.process=*System.Text.ASCIIEncoding*) by Processes.dest Processes.user  Processes.parent_process Processes.original_file_name Processes.process_name Processes.process  Processes.process_id Processes.parent_process_id | `drop_dm_object_name(Processes)`  | `security_content_ctime(firstTime)`| `security_content_ctime(lastTime)`| `nishang_powershelltcponeline_filter`'



<li><a href="#">NAME: NLTest Domain Trust Discovery

DESCRIPTION:  This search looks for the execution of `nltest.exe` with command-line  arguments utilized to query for Domain Trust information. Two arguments `/domain  trusts`, returns a list of trusted domains, and `/all_trusts`, returns all trusted  domains. Red Teams and adversaries alike use NLTest.exe to enumerate the current  domain to assist with further understanding where to pivot next.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where `process_nltest` (Processes.process=*/domain_trusts*  OR Processes.process=*/all_trusts*) by Processes.dest Processes.user Processes.parent_process  Processes.process_name Processes.process Processes.process_id Processes.parent_process_id  | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `nltest_domain_trust_discovery_filter`'



<li><a href="#">NAME: Non Chrome Process Accessing Chrome Default Dir

DESCRIPTION:  This search is to detect an anomaly event of a non-chrome process accessing  the files in chrome user default folder. This folder contains all the sqlite database  of the chrome browser related to users login, history, cookies and etc. Most of  the RAT, trojan spy as well as FIN7 jssloader try to parse the those sqlite database  to collect information on the compromised host. This SACL Event (4663) need to be  enabled to tthe firefox profile directory to be eable to use this. Since you monitoring  this access to the folder,  we observed noise that needs to be filter out and hence  added sqlite db browser and explorer .exe to make this detection more stable.

SEARCH:  '`wineventlog_security` EventCode=4663 NOT (process_name IN ("*\\chrome.exe",  "*\\explorer.exe", "*sql*")) Object_Name="*\\Google\\Chrome\\User Data\\Default*"  | stats count min(_time) as firstTime max(_time) as lastTime by Object_Name Object_Type  process_name Access_Mask Accesses process_id EventCode dest user | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `non_chrome_process_accessing_chrome_default_dir_filter`'



<li><a href="#">NAME: Non Firefox Process Access Firefox Profile Dir

DESCRIPTION:  This search is to detect an anomaly event of a non-firefox process accessing  the files in the profile folder. This folder contains all the sqlite database of  the firefox browser related to users login, history, cookies and etc. Most of the  RAT, trojan spy as well as FIN7 jssloader try to parse the those sqlite database  to collect information on the compromised host. This SACL Event (4663) needs to  be enabled to the firefox profile directory to use this. Since this is monitoring  the access to the folder, we have obsevered noise and hence added `sqlite db browser`  and `explorer.exe` to make this detection more stable.

SEARCH:  '`wineventlog_security` EventCode=4663 NOT (process_name IN ("*\\firefox.exe",  "*\\explorer.exe", "*sql*")) Object_Name="*\\AppData\\Roaming\\Mozilla\\Firefox\\Profiles*"  | stats count min(_time) as firstTime max(_time) as lastTime by Object_Name Object_Type  process_name Access_Mask Accesses process_id EventCode dest user | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `non_firefox_process_access_firefox_profile_dir_filter`'



<li><a href="#">NAME: Notepad with no Command Line Arguments

DESCRIPTION:  The following analytic identifies behavior related to default SliverC2  framework where it will inject into Notepad.exe and spawn Notepad.exe with no command  line arguments. In testing, this is a common procedure for SliverC2 usage, however  may be modified or changed. From Microsoft, "The Sideload, SpawnDll, and Execute-Assembly  commands spawn and inject into notepad.exe by default. The following query finds  process creation events where the same process creates and injects into notepad.exe  within 10 seconds."

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime FROM datamodel=Endpoint.Processes where Processes.process_name=notepad.exe  AND Processes.action!="blocked" by host _time span=1h Processes.process_id Processes.process_name  Processes.dest Processes.process_path Processes.process Processes.parent_process_name  Processes.parent_process | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | regex process="(?i)(notepad\.exe.{0,4}$)"  | `notepad_with_no_command_line_arguments_filter`'



<li><a href="#">NAME: Ntdsutil Export NTDS

DESCRIPTION:  'Monitor for signs that Ntdsutil is being used to Extract Active Directory  database - NTDS.dit, typically used for offline password cracking. It may be used  in normal circumstances with no command line arguments or shorthand variations of  more common arguments. Ntdsutil.exe is typically seen run on a Windows Server. Typical  command used to dump ntds.dit \  ntdsutil "ac i ntds" "ifm" "create full C:\Temp" q q \  This technique uses "Install from Media" (IFM), which will extract a copy of the  Active Directory database. A successful export of the Active Directory database  will yield a file modification named ntds.dit to the destination.'

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where (Processes.process_name=ntdsutil.exe  Processes.process=*ntds* Processes.process=*create*) by Processes.dest Processes.user  Processes.parent_process Processes.process_name Processes.process Processes.process_id  Processes.parent_process_id | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)`|  `security_content_ctime(lastTime)` | `ntdsutil_export_ntds_filter`'



<li><a href="#">NAME: Office Application Drop Executable

DESCRIPTION:  This search is to detect a suspicious MS office application that drops  or creates executables or scripts in a Windows Operating System. This behavior is  commonly seen in spear phishing office attachment where it drop malicious files  or script to compromised the host. It might be some normal macro may drop script  or tools as part of automation but still this behavior is reallly suspicious and  not commonly seen in normal office application

SEARCH:  '| tstats `security_content_summariesonly` count FROM datamodel=Endpoint.Processes  where Processes.process_name IN ("winword.exe","excel.exe","powerpnt.exe","mspub.exe","visio.exe","wordpad.exe","wordview.exe","onenote.exe","onenotem.exe","onenoteviewer.exe","onenoteim.exe","msaccess.exe")  by _time span=1h Processes.process_id Processes.process_name Processes.process Processes.dest  Processes.process_guid | `drop_dm_object_name(Processes)` |join process_guid, _time  [| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime FROM datamodel=Endpoint.Filesystem where Filesystem.file_name IN ("*.exe","*.dll","*.pif","*.scr","*.js","*.vbs","*.vbe","*.ps1")  by _time span=1h Filesystem.dest Filesystem.file_create_time Filesystem.file_name  Filesystem.process_guid Filesystem.file_path | `drop_dm_object_name(Filesystem)`  | fields _time dest file_create_time file_name file_path process_name process_path  process process_guid] | dedup file_create_time | table dest, process_name, process,  file_create_time, file_name, file_path, process_guid | `office_application_drop_executable_filter`'



<li><a href="#">NAME: Office Application Spawn Regsvr32 process

DESCRIPTION:  this detection was designed to identifies suspicious spawned process  of known MS office application due to macro or malicious code. this technique can  be seen in so many malware like IcedID that used MS office as its weapon or attack  vector to initially infect the machines.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where (Processes.parent_process_name  = "winword.exe" OR Processes.parent_process_name = "excel.exe" OR Processes.parent_process_name  = "powerpnt.exe" OR Processes.parent_process_name = "outlook.exe" OR Processes.parent_process_name  = "onenote.exe" OR Processes.parent_process_name = "onenotem.exe" OR Processes.parent_process_name  = "onenoteviewer.exe" OR Processes.parent_process_name = "onenoteim.exe" OR Processes.parent_process_name="msaccess.exe")  `process_regsvr32` by Processes.parent_process_name Processes.parent_process Processes.process_name  Processes.original_file_name Processes.process Processes.process_id Processes.process_guid  Processes.user Processes.dest | `drop_dm_object_name("Processes")` | `security_content_ctime(firstTime)`  |`security_content_ctime(lastTime)` | `office_application_spawn_regsvr32_process_filter`'



<li><a href="#">NAME: Office Application Spawn rundll32 process

DESCRIPTION:  This detection was designed to identify suspicious spawned processes  of known MS office applications due to macro or malicious code. this technique can  be seen in so many malware like trickbot that used MS office as its weapon or attack  vector to initially infect the machines.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where (Processes.parent_process_name  = "winword.exe" OR Processes.parent_process_name = "excel.exe" OR Processes.parent_process_name  = "powerpnt.exe" OR Processes.parent_process_name= "onenote.exe" OR Processes.parent_process_name  = "onenotem.exe" OR Processes.parent_process_name = "onenoteviewer.exe" OR Processes.parent_process_name  = "onenoteim.exe" OR Processes.parent_process_name = "msaccess.exe") AND `process_rundll32`  by Processes.parent_process Processes.process_name Processes.process_id Processes.process_guid  Processes.process Processes.user Processes.dest | `drop_dm_object_name("Processes")`  | `security_content_ctime(firstTime)` |`security_content_ctime(lastTime)` | `office_application_spawn_rundll32_process_filter`'



<li><a href="#">NAME: Office Document Creating Schedule Task

DESCRIPTION:  this search detects a potential malicious office document that create  schedule task entry through macro VBA api or through loading taskschd.dll. This  technique was seen in so many malicious macro malware that create persistence ,  beaconing using task schedule malware entry The search will return the first time  and last time the task was registered, as well as the `Command` to be executed,  `Task Name`, `Author`, `Enabled`, and whether it is `Hidden` or not. schtasks.exe  is natively found in `C:\Windows\system32` and `C:\Windows\syswow64`. The following  DLL(s) are loaded when schtasks.exe or TaskService is launched -`taskschd.dll`.  If found loaded by another process, it's possible a scheduled task is being registered  within that process context in memory. Upon triage, identify the task scheduled  source. Was it schtasks.exe or via TaskService? Review the job created and the Command  to be executed. Capture any artifacts on disk and review. Identify any parallel  processes within the same timeframe to identify source.'

SEARCH:  '`sysmon` EventCode=7 parent_process_name IN ("WINWORD.EXE", "EXCEL.EXE",  "POWERPNT.EXE","onenote.exe","onenotem.exe","onenoteviewer.exe","onenoteim.exe",  "msaccess.exe") ImageLoaded = "*\\taskschd.dll" | stats min(_time) as firstTime  max(_time) as lastTime values(ImageLoaded) as AllImageLoaded count by Computer EventCode  Image parent_process_name ProcessId ProcessGuid | rename Computer as dest | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `office_document_creating_schedule_task_filter`'



<li><a href="#">NAME: Office Document Executing Macro Code

DESCRIPTION:  this detection was designed to identifies suspicious office documents  that using macro code. Macro code is known to be one of the prevalent weaponization  or attack vector of threat actor. This malicious macro code is embed to a office  document as an attachment that may execute malicious payload, download malware payload  or other malware component. It is really good practice to disable macro by default  to avoid automatically execute macro code while opening or closing a office document  files.

SEARCH:  '`sysmon` EventCode=7 parent_process_name IN ("WINWORD.EXE", "EXCEL.EXE",  "POWERPNT.EXE","onenote.exe","onenotem.exe","onenoteviewer.exe","onenoteim.exe","msaccess.exe")  ImageLoaded IN ("*\\VBE7INTL.DLL","*\\VBE7.DLL", "*\\VBEUI.DLL") | stats min(_time)  as firstTime max(_time) as lastTime values(ImageLoaded) as AllImageLoaded count  by Computer EventCode Image process_name ProcessId ProcessGuid | rename Computer as dest| `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `office_document_executing_macro_code_filter`'



<li><a href="#">NAME: Office Document Spawned Child Process To Download

DESCRIPTION:  This search is to detect potential malicious office document executing  lolbin child process to download payload or other malware. Since most of the attacker  abused the capability of office document to execute living on land application to  blend it to the normal noise in the infected machine to cover its track.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.parent_process_name  IN ("winword.exe","excel.exe","powerpnt.exe","mspub.exe","visio.exe","onenote.exe","onenotem.exe","onenoteviewer.exe","onenoteim.exe","msaccess.exe",  "Graph.exe","winproj.exe") Processes.process IN ("*http:*","*https:*") NOT (Processes.original_file_name  IN("firefox.exe", "chrome.exe","iexplore.exe","msedge.exe"))  by Processes.dest  Processes.user Processes.parent_process_name Processes.process_name Processes.process  Processes.process_id Processes.parent_process_id Processes.original_file_name |  `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `office_document_spawned_child_process_to_download_filter`'



<li><a href="#">NAME: Office Product Spawning BITSAdmin

DESCRIPTION:  The following detection identifies the latest behavior utilized by different  malware families (including TA551, IcedID). This detection identifies any Windows  Office Product spawning `bitsadmin.exe`. In malicious instances, the command-line  of `bitsadmin.exe` will contain a URL to a remote destination or similar command-line  arguments as transfer, Download, priority, Foreground. In addition, Threat Research  has released a detections identifying suspicious use of `bitsadmin.exe`. In this  instance, we narrow our detection down to the Office suite as a parent process.  During triage, review all file modifications. Capture and analyze any artifacts  on disk. The Office Product, or `bitsadmin.exe` will have reached out to a remote  destination, capture and block the IPs or domain. Review additional parallel processes  for further activity.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.parent_process_name  IN ("winword.exe","excel.exe","powerpnt.exe","mspub.exe","visio.exe","onenote.exe","onenotem.exe","onenoteviewer.exe","onenoteim.exe",  "msaccess.exe", "Graph.exe","winproj.exe") `process_bitsadmin` by Processes.dest  Processes.user Processes.parent_process Processes.process_name Processes.original_file_name  Processes.process Processes.process_id Processes.parent_process_id | `drop_dm_object_name(Processes)`  | `security_content_ctime(firstTime)`| `security_content_ctime(lastTime)` | `office_product_spawning_bitsadmin_filter`'



<li><a href="#">NAME: Office Product Spawning CertUtil

DESCRIPTION:  The following detection identifies the latest behavior utilized by different  malware families (including TA551, IcedID). This detection identifies any Windows  Office Product spawning `certutil.exe`. In malicious instances, the command-line  of `certutil.exe` will contain a URL to a remote destination. In addition, Threat  Research has released a detections identifying suspicious use of `certutil.exe`.  In this instance, we narrow our detection down to the Office suite as a parent process.  During triage, review all file modifications. Capture and analyze any artifacts  on disk. The Office Product, or `certutil.exe` will have reached out to a remote  destination, capture and block the IPs or domain. Review additional parallel processes  for further activity.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.parent_process_name  IN ("winword.exe","excel.exe","powerpnt.exe","mspub.exe","visio.exe","onenote.exe","onenotem.exe","onenoteviewer.exe","onenoteim.exe","msaccess.exe",  "Graph.exe","winproj.exe") `process_certutil` by Processes.dest Processes.user Processes.parent_process  Processes.process_name Processes.original_file_name Processes.process Processes.process_id  Processes.parent_process_id | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)`|  `security_content_ctime(lastTime)` | `office_product_spawning_certutil_filter`'



<li><a href="#">NAME: Office Product Spawning MSHTA

DESCRIPTION:  The following detection identifies the latest behavior utilized by different  malware families (including TA551, IcedID). This detection identifies any Windows  Office Product spawning `mshta.exe`. In malicious instances, the command-line of  `mshta.exe` will contain the `hta` file locally, or a URL to the remote destination.  In addition, Threat Research has released a detections identifying suspicious use  of `mshta.exe`. In this instance, we narrow our detection down to the Office suite  as a parent process. During triage, review all file modifications. Capture and analyze  any artifacts on disk. The Office Product, or `mshta.exe` will have reached out  to a remote destination, capture and block the IPs or domain. Review additional  parallel processes for further activity.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.parent_process_name  IN ("winword.exe","excel.exe","powerpnt.exe","mspub.exe","visio.exe", "onenote.exe","onenotem.exe",  "msaccess.exe","Graph.exe","winproj.exe") `process_mshta` by Processes.dest Processes.user  Processes.parent_process Processes.process_name Processes.original_file_name Processes.process  Processes.process_id Processes.parent_process_id | `drop_dm_object_name(Processes)`  | `security_content_ctime(firstTime)`| `security_content_ctime(lastTime)` | `office_product_spawning_mshta_filter`'



<li><a href="#">NAME: Office Product Spawning Rundll32 with no DLL

DESCRIPTION:  The following detection identifies the latest behavior utilized by IcedID  malware family. This detection identifies any Windows Office Product spawning `rundll32.exe`  without a `.dll` file extension. In malicious instances, the command-line of `rundll32.exe`  will look like `rundll32 ..\oepddl.igk2,DllRegisterServer`. In addition, Threat  Research has released a detection identifying the use of `DllRegisterServer` on  the command-line of `rundll32.exe`. In this instance, we narrow our detection down  to the Office suite as a parent process. During triage, review all file modifications.  Capture and analyze the `DLL` that was dropped to disk. The Office Product will  have reached out to a remote destination, capture and block the IPs or domain. Review  additional parallel processes for further activity.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.parent_process_name  IN ("winword.exe","excel.exe","powerpnt.exe","mspub.exe","visio.exe","onenote.exe","onenotem.exe","onenoteviewer.exe","onenoteim.exe",  "msaccess.exe", "Graph.exe","winproj.exe") `process_rundll32` (Processes.process!=*.dll*)  by Processes.dest Processes.user Processes.parent_process Processes.process_name  Processes.process Processes.process_id Processes.parent_process_id | `drop_dm_object_name(Processes)`  | `security_content_ctime(firstTime)`| `security_content_ctime(lastTime)` | `office_product_spawning_rundll32_with_no_dll_filter`'



<li><a href="#">NAME: Office Product Spawning Windows Script Host

DESCRIPTION:  The following analytic will identify a Windows Office Product spawning  WScript.exe or CScript.exe. Tuning may be required based on legitimate application  usage that may spawn scripts from an Office product.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.parent_process_name  IN ("winword.exe","excel.exe","powerpnt.exe","mspub.exe","visio.exe","onenote.exe","onenotem.exe","onenoteviewer.exe","onenoteim.exe",  "msaccess.exe","Graph.exe","winproj.exe") Processes.process_name IN ("wscript.exe",  "cscript.exe") by  Processes.dest Processes.user Processes.parent_process_name Processes.parent_process Processes.process_name  Processes.original_file_name Processes.process Processes.process_id Processes.parent_process_id  | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)`| `security_content_ctime(lastTime)`  | `office_product_spawning_windows_script_host_filter`'



<li><a href="#">NAME: Office Product Spawning Wmic

DESCRIPTION:  The following detection identifies the latest behavior utilized by Ursnif  malware family. This detection identifies any Windows Office Product spawning `wmic.exe`.  In malicious instances, the command-line of `wmic.exe` will contain `wmic process  call create`. In addition, Threat Research has released a detection identifying  the use of `wmic process call create` on the command-line of `wmic.exe`. In this  instance, we narrow our detection down to the Office suite as a parent process.  During triage, review all file modifications. Capture and analyze any artifacts  on disk. The Office Product, or `wmic.exe` will have reached out to a remote destination,  capture and block the IPs or domain. Review additional parallel processes for further  activity.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.parent_process_name  IN ("winword.exe","excel.exe","powerpnt.exe","mspub.exe","visio.exe","onenote.exe","onenotem.exe","onenoteviewer.exe","onenoteim.exe","msaccess.exe",  "Graph.exe","winproj.exe") `process_wmic` by Processes.dest Processes.user Processes.parent_process  Processes.process_name Processes.original_file_name Processes.process Processes.process_id  Processes.parent_process_id | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)`|  `security_content_ctime(lastTime)` | `office_product_spawning_wmic_filter`'



<li><a href="#">NAME: Office Product Spawn CMD Process

DESCRIPTION:  this search is to detect a suspicious office product process that spawn  cmd child process. This is commonly seen in a ms office product having macro to  execute shell command to download or execute malicious lolbin relative to its malicious  code. This is seen in trickbot spear phishing doc where it execute shell cmd to  run mshta payload.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where (Processes.parent_process_name  = "winword.exe" OR Processes.parent_process_name= "excel.exe" OR Processes.parent_process_name  = "powerpnt.exe" OR Processes.parent_process_name= "onenote.exe" OR Processes.parent_process_name  = "onenotem.exe" OR Processes.parent_process_name = "onenoteviewer.exe" OR Processes.parent_process_name  = "onenoteim.exe" OR Processes.parent_process_name = "msaccess.exe" OR  Processes.parent_process_name="Graph.exe"  OR Processes.parent_process_name="winproj.exe") `process_cmd` by Processes.parent_process  Processes.process_name Processes.process Processes.process_id Processes.process_guid  Processes.user Processes.dest Processes.original_file_name | `drop_dm_object_name("Processes")`  | `security_content_ctime(firstTime)` |`security_content_ctime(lastTime)` | `office_product_spawn_cmd_process_filter`'



<li><a href="#">NAME: Office Product Writing cab or inf

DESCRIPTION:  The following analytic identifies behavior related to CVE-2021-40444.  Whereas the malicious document will load ActiveX and download the remote payload  (.inf, .cab). During triage, review parallel processes and further activity on endpoint  to identify additional patterns. Retrieve the file modifications and analyze further.

SEARCH:  '| tstats `security_content_summariesonly` count FROM datamodel=Endpoint.Processes  where Processes.process_name IN ("winword.exe","excel.exe","powerpnt.exe","mspub.exe","visio.exe","wordpad.exe","wordview.exe","onenote.exe","onenotem.exe","onenoteviewer.exe","onenoteim.exe","msaccess.exe")  by _time span=1h Processes.process_id Processes.process_name Processes.process Processes.dest  Processes.process_guid | `drop_dm_object_name(Processes)` |rename process_guid as  proc_guid | join proc_guid, _time [ | tstats `security_content_summariesonly` count  min(_time) as firstTime max(_time) as lastTime FROM datamodel=Endpoint.Filesystem  where Filesystem.file_name IN ("*.inf","*.cab") by _time span=1h Filesystem.dest  Filesystem.file_create_time Filesystem.file_name Filesystem.file_path Filesystem.process_guid  | `drop_dm_object_name(Filesystem)` |rename process_guid as proc_guid | fields _time  dest file_create_time file_name file_path process_name process_path process proc_guid]  | dedup file_create_time | table dest, process_name, process, file_create_time,  file_name, file_path, proc_guid | `office_product_writing_cab_or_inf_filter`'



<li><a href="#">NAME: Office Spawning Control

DESCRIPTION:  The following detection identifies control.exe spawning from an office  product. This detection identifies any Windows Office Product spawning `control.exe`.  In malicious instances, the command-line of `control.exe` will contain a file path  to a .cpl or .inf, related to CVE-2021-40444. In this instance, we narrow our detection  down to the Office suite as a parent process. During triage, review all file modifications.  Capture and analyze any artifacts on disk. review parallel and child processes to  identify further suspicious behavior

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.parent_process_name  IN ("winword.exe","excel.exe","powerpnt.exe","mspub.exe","visio.exe","wordpad.exe","wordview.exe","onenote.exe","onenotem.exe","onenoteviewer.exe","onenoteim.exe","msaccess.exe")  Processes.process_name=control.exe by Processes.dest Processes.user Processes.parent_process_name Processes.parent_process   Processes.process_name Processes.process Processes.process_id Processes.parent_process_id  | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)`| `security_content_ctime(lastTime)`|  `office_spawning_control_filter`'



<li><a href="#">NAME: Outbound Network Connection from Java Using Default Ports

DESCRIPTION:  A required step while exploiting the CVE-2021-44228-Log4j vulnerability  is that the victim server will perform outbound connections to attacker-controlled  infrastructure. This is required as part of the JNDI lookup as well as for retrieving  the second stage .class payload. The following analytic identifies the Java process  reaching out to default ports used by the LDAP and RMI protocols. This behavior  could represent successfull exploitation. Note that adversaries can easily decide  to use arbitrary ports for these protocols and potentially bypass this detection.

SEARCH:  '| tstats `security_content_summariesonly` count FROM datamodel=Endpoint.Processes  where (Processes.process_name="java.exe" OR Processes.process_name=javaw.exe OR  Processes.process_name=javaw.exe) by _time Processes.process_id Processes.process_name  Processes.dest Processes.process_path Processes.process Processes.parent_process_name  | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | join process_id [| tstats `security_content_summariesonly` count FROM datamodel=Network_Traffic.All_Traffic  where (All_Traffic.dest_port= 389 OR All_Traffic.dest_port= 636 OR All_Traffic.dest_port  = 1389 OR All_Traffic.dest_port = 1099 ) by All_Traffic.process_id All_Traffic.dest  All_Traffic.dest_port | `drop_dm_object_name(All_Traffic)` | rename dest as connection_to_CNC]  | table _time dest parent_process_name process_name process_path process connection_to_CNC  dest_port| `outbound_network_connection_from_java_using_default_ports_filter`'



<li><a href="#">NAME: Overwriting Accessibility Binaries

DESCRIPTION:  Microsoft Windows contains accessibility features that can be launched  with a key combination before a user has logged in. An adversary can modify or replace  these programs so they can get a command prompt or backdoor without logging in to  the system. This search looks for modifications to these binaries.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime values(Filesystem.user) as user values(Filesystem.dest) as dest values(Filesystem.file_path)  as file_path from datamodel=Endpoint.Filesystem where (Filesystem.file_path=*\\Windows\\System32\\sethc.exe*  OR Filesystem.file_path=*\\Windows\\System32\\utilman.exe* OR Filesystem.file_path=*\\Windows\\System32\\osk.exe*  OR Filesystem.file_path=*\\Windows\\System32\\Magnify.exe* OR Filesystem.file_path=*\\Windows\\System32\\Narrator.exe*  OR Filesystem.file_path=*\\Windows\\System32\\DisplaySwitch.exe* OR Filesystem.file_path=*\\Windows\\System32\\AtBroker.exe*)  by Filesystem.file_name Filesystem.dest | `drop_dm_object_name(Filesystem)` | `security_content_ctime(lastTime)`  | `security_content_ctime(firstTime)` | `overwriting_accessibility_binaries_filter`'



<li><a href="#">NAME: PaperCut NG Suspicious Behavior Debug Log

DESCRIPTION:  The following hunting analytic is designed to monitor and detect potential exploitation attempts targeting a PaperCut NG server by analyzing its debug log data. By focusing on public IP addresses accessing the PaperCut NG instance, this analytic aims to identify unauthorized or suspicious access attempts. Furthermore, it searches for specific URIs that have been discovered in the proof of concept code, which are associated with known exploits or vulnerabilities. The analytic is focused on the user admin. Regex is used mainly because the log is not parsed by Splunk and there is no TA for this debug log.

SEARCH:  '`papercutng` (loginType=Admin OR userName=admin)   | eval uri_match=if(match(_raw, "(?i)(\/app\?service=page\/SetupCompleted|\/app|\/app\?service=page\/PrinterList|\/app\?service=direct\/1\/PrinterList\/selectPrinter&sp=l1001|\/app\?service=direct\/1\/PrinterDetails\/printerOptionsTab\.tab)"), "URI matches", null())  | eval ip_match=if(match(_raw, "(?i)((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?))") AND NOT match(_raw, "(?i)(10\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?))|(172\.(1[6-9]|2[0-9]|3[0-1])\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?))|(192\.168\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?))"), "IP matches", null())  | where  (isnotnull(uri_match) OR isnotnull(ip_match))  | stats sparkline, count, values(uri_match) AS uri_match, values(ip_match) AS ip_match latest(_raw)    BY host, index, sourcetype | `papercut_ng_suspicious_behavior_debug_log_filter`'



<li><a href="#">NAME: Password Policy Discovery with Net

DESCRIPTION:  This analytic looks for the execution of `net.exe` or `net1.exe` with  command line arguments used to obtain the domain password policy. Red Teams and  adversaries may leverage `net.exe` for situational awareness and Active Directory  Discovery.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where (Processes.process_name="net.exe"  OR Processes.process_name="net1.exe") AND Processes.process = "*accounts*" AND Processes.process  = "*/domain*" by Processes.dest Processes.user Processes.parent_process Processes.process_name  Processes.process Processes.process_id Processes.parent_process_id Processes.parent_process_name  | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `password_policy_discovery_with_net_filter`'



<li><a href="#">NAME: Permission Modification using Takeown App

DESCRIPTION:  This search is to detect a modification of file or directory permission  using takeown.exe windows app. This technique was seen in some ransomware that take  the ownership of a folder or files to encrypt or delete it.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.process_name = "takeown.exe"  Processes.process = "*/f*" by Processes.parent_process_name Processes.parent_process  Processes.process_name Processes.process Processes.dest Processes.user Processes.process_id  Processes.process_guid | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `permission_modification_using_takeown_app_filter`'



<li><a href="#">NAME: PetitPotam Network Share Access Request

DESCRIPTION:  'The following analytic utilizes Windows Event Code 5145, "A network  share object was checked to see whether client can be granted desired access". During  our research into PetitPotam, CVE-2021-36942, we identified the ocurrence of this  event on the target host with specific values. \  To enable 5145 events via Group Policy - Computer Configuration->Polices->Windows  Settings->Security Settings->Advanced Audit Policy Configuration. Expand this node,  go to Object Access (Audit Polices->Object Access), then select the Setting Audit  Detailed File Share Audit \  It is possible this is not enabled by default and may need to be reviewed and enabled.  \  During triage, review parallel security events to identify further suspicious activity.'

SEARCH:  '`wineventlog_security` Account_Name="ANONYMOUS LOGON" EventCode=5145 Relative_Target_Name=lsarpc  | stats count min(_time) as firstTime max(_time) as lastTime by dest, Security_ID,  Share_Name, Source_Address, Accesses, Message | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `petitpotam_network_share_access_request_filter`'



<li><a href="#">NAME: PetitPotam Suspicious Kerberos TGT Request

DESCRIPTION:  The following analytic identifes Event Code 4768, A `Kerberos authentication  ticket (TGT) was requested`, successfull occurs. This behavior has been identified  to assist with detecting PetitPotam, CVE-2021-36942. Once an attacer obtains a computer  certificate by abusing Active Directory Certificate Services in combination with  PetitPotam, the next step would be to leverage the certificate for malicious purposes.  One way of doing this is to request a Kerberos Ticket Granting Ticket using a tool  like Rubeus. This request will generate a 4768 event with some unusual fields depending  on the environment. This analytic will require tuning, we recommend filtering Account_Name  to Domain Controllers for your environment.

SEARCH:  '`wineventlog_security` EventCode=4768 Client_Address!="::1" Certificate_Thumbprint!=""  Account_Name=*$ | stats count min(_time) as firstTime max(_time) as lastTime by  dest, Account_Name, Client_Address, action, Message | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `petitpotam_suspicious_kerberos_tgt_request_filter`'



<li><a href="#">NAME: Ping Sleep Batch Command

DESCRIPTION:  This analytic will identify the possible execution of ping sleep batch  commands. This technique was seen in several malware samples and is used to trigger  sleep times without explicitly calling sleep functions or commandlets. The goal  is to delay the execution of malicious code and bypass detection or sandbox analysis.  This  detection can be a good indicator of a process delaying its execution for  malicious purposes.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where `process_ping` (Processes.parent_process  = "*ping*" Processes.parent_process = *-n* Processes.parent_process="* Nul*"Processes.parent_process="*&gt;*")  OR (Processes.process = "*ping*" Processes.process = *-n* Processes.process="* Nul*"Processes.process="*&gt;*")  by Processes.parent_process_name Processes.parent_process Processes.process_name  Processes.original_file_name Processes.process Processes.process_id Processes.process_guid  Processes.user Processes.dest | `drop_dm_object_name("Processes")` | `security_content_ctime(firstTime)`  |`security_content_ctime(lastTime)` | `ping_sleep_batch_command_filter`'



<li><a href="#">NAME: Plain HTTP POST Exfiltrated Data

DESCRIPTION:  This search is to detect potential plain HTTP POST method data exfiltration.  This network traffic is commonly used by trickbot, trojanspy, keylogger or APT adversary  where arguments or commands are sent in plain text to the remote C2 server using  HTTP POST method as part of data exfiltration.

SEARCH:  '`stream_http` http_method=POST form_data IN ("*wermgr.exe*","*svchost.exe*",  "*name=\"proclist\"*","*ipconfig*", "*name=\"sysinfo\"*", "*net view*") |stats values(form_data)  as http_request_body min(_time) as firstTime max(_time) as lastTime count by src_ip dest_ip http_method  http_user_agent uri_path url bytes_in bytes_out | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `plain_http_post_exfiltrated_data_filter`'



<li><a href="#">NAME: Possible Browser Pass View Parameter

DESCRIPTION:  This analytic will detect if a suspicious process contains a commandline  parameter related to a web browser credential dumper. This technique is used by  Remcos RAT malware which uses the Nirsoft webbrowserpassview.exe application to  dump web browser credentials. Remcos uses the "/stext" command line to dump the  credentials in text format. This Hunting query is a good indicator of hosts suffering  from possible Remcos RAT infection. Since the hunting query is based on the parameter  command and the possible path where it will save the text credential information,  it may catch normal tools that are using the same command and behavior.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.process  IN ("*/stext  *", "*/shtml *", "*/LoadPasswordsIE*", "*/LoadPasswordsFirefox*", "*/LoadPasswordsChrome*",  "*/LoadPasswordsOpera*", "*/LoadPasswordsSafari*" , "*/UseOperaPasswordFile*", "*/OperaPasswordFile*","*/stab*",  "*/scomma*", "*/stabular*", "*/shtml*", "*/sverhtml*", "*/sxml*", "*/skeepass*"  ) AND Processes.process IN ("*\\temp\\*", "*\\users\\public\\*", "*\\programdata\\*")  by Processes.dest Processes.user Processes.parent_process_name Processes.parent_process  Processes.process_name Processes.process Processes.process_id Processes.parent_process_id  Processes.original_file_name | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `possible_browser_pass_view_parameter_filter`'



<li><a href="#">NAME: Possible Lateral Movement PowerShell Spawn

DESCRIPTION:  'The following analytic is designed to identify possible lateral movement  attacks that involve the spawning of a PowerShell process as a child or grandchild  process of commonly abused processes. These processes include services.exe, wmiprsve.exe,  svchost.exe, wsmprovhost.exe, and mmc.exe.\  Such behavior is indicative of legitimate Windows features such as the Service Control  Manager, Windows Management Instrumentation, Task Scheduler, Windows Remote Management,  and the DCOM protocol being abused to start a process on a remote endpoint. This  behavior is often seen during lateral movement techniques where adversaries or red  teams abuse these services for lateral movement and remote code execution.'

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where (Processes.parent_process_name=wmiprvse.exe  OR Processes.parent_process_name=services.exe OR Processes.parent_process_name=svchost.exe  OR Processes.parent_process_name=wsmprovhost.exe OR Processes.parent_process_name=mmc.exe)  (Processes.process_name=powershell.exe OR (Processes.process_name=cmd.exe AND Processes.process=*powershell.exe*)  OR Processes.process_name=pwsh.exe OR (Processes.process_name=cmd.exe AND Processes.process=*pwsh.exe*))  by Processes.dest Processes.user Processes.parent_process_name Processes.process_name  Processes.process Processes.process_id Processes.parent_process_id | `drop_dm_object_name(Processes)`  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `possible_lateral_movement_powershell_spawn_filter`'



<li><a href="#">NAME: Potentially malicious code on commandline

DESCRIPTION:  The following analytic uses a pretrained machine learning text classifier  to detect potentially malicious commandlines.  The model identifies unusual combinations  of keywords found in samples of commandlines where adversaries executed powershell  code, primarily for C2 communication.  For example, adversaries will leverage IO  capabilities such as "streamreader" and "webclient", threading capabilties such  as "mutex" locks, programmatic constructs like "function" and "catch", and cryptographic  operations like "computehash".  Although observing one of these keywords in a commandline  script is possible, combinations of keywords observed in attack data are not typically  found in normal usage of the commandline.  The model will output a score where all  values above zero are suspicious, anything greater than one particularly so.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel="Endpoint.Processes" by Processes.parent_process_name  Processes.process_name Processes.process Processes.user Processes.dest  | `drop_dm_object_name(Processes)`  |  where len(process) > 200 | `potentially_malicious_code_on_cmdline_tokenize_score`  | apply unusual_commandline_detection | eval score=''predicted(unusual_cmdline_logits)'',  process=orig_process | fields - unusual_cmdline* predicted(unusual_cmdline_logits)  orig_process | where score > 0.5 | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `potentially_malicious_code_on_commandline_filter`'



<li><a href="#">NAME: Potential password in username

DESCRIPTION:  This search identifies users who have entered their passwords in username  fields. This is done by looking for failed authentication attempts using usernames  with a length longer than 7 characters and a high Shannon entropy, and looks for  the next successful authentication attempt from the same source system to the same  destination system as the failed attempt.

SEARCH:  '| tstats `security_content_summariesonly` earliest(_time) AS starttime latest(_time)  AS endtime latest(sourcetype) AS sourcetype values(Authentication.src) AS src values(Authentication.dest)  AS dest count FROM datamodel=Authentication WHERE nodename=Authentication.Failed_Authentication  BY "Authentication.user" | `drop_dm_object_name(Authentication)` | lookup ut_shannon_lookup  word AS user | where ut_shannon>3 AND len(user)>=8 AND mvcount(src) == 1 | sort  count, - ut_shannon | eval incorrect_cred=user | eval endtime=endtime+1000 | map  maxsearches=70 search="| tstats `security_content_summariesonly` earliest(_time)  AS starttime latest(_time) AS endtime latest(sourcetype) AS sourcetype values(Authentication.src)  AS src values(Authentication.dest) AS dest count FROM datamodel=Authentication WHERE  nodename=Authentication.Successful_Authentication Authentication.src=\"$src$\" Authentication.dest=\"$dest$\"  sourcetype IN (\"$sourcetype$\") earliest=\"$starttime$\" latest=\"$endtime$\" BY  \"Authentication.user\" | `drop_dm_object_name(\"Authentication\")` | `potential_password_in_username_false_positive_reduction`  | eval incorrect_cred=\"$incorrect_cred$\" | eval ut_shannon=\"$ut_shannon$\" |  sort count" | where user!=incorrect_cred | outlier action=RM count | `potential_password_in_username_filter`'



<li><a href="#">NAME: PowerShell 4104 Hunting

DESCRIPTION:  The following Hunting analytic assists with identifying suspicious PowerShell  execution using Script Block Logging, or EventCode 4104. This analytic is not meant  to be ran hourly, but occasionally to identify malicious or suspicious PowerShell.  This analytic is a combination of work completed by Alex Teixeira and Splunk Threat  Research Team.

SEARCH:  '`powershell` EventCode=4104 | eval DoIt = if(match(ScriptBlockText,"(?i)(\$doit)"),  "4", 0) | eval enccom=if(match(ScriptBlockText,"[A-Za-z0-9+\/]{44,}([A-Za-z0-9+\/]{4}|[A-Za-z0-9+\/]{3}=|[A-Za-z0-9+\/]{2}==)")  OR match(ScriptBlockText, "(?i)[-]e(nc*o*d*e*d*c*o*m*m*a*n*d*)*\s+[^-]"),4,0) |  eval suspcmdlet=if(match(ScriptBlockText, "(?i)Add-Exfiltration|Add-Persistence|Add-RegBackdoor|Add-ScrnSaveBackdoor|Check-VM|Do-Exfiltration|Enabled-DuplicateToken|Exploit-Jboss|Find-Fruit|Find-GPOLocation|Find-TrustedDocuments|Get-ApplicationHost|Get-ChromeDump|Get-ClipboardContents|Get-FoxDump|Get-GPPPassword|Get-IndexedItem|Get-Keystrokes|LSASecret|Get-PassHash|Get-RegAlwaysInstallElevated|Get-RegAutoLogon|Get-RickAstley|Get-Screenshot|Get-SecurityPackages|Get-ServiceFilePermission|Get-ServicePermission|Get-ServiceUnquoted|Get-SiteListPassword|Get-System|Get-TimedScreenshot|Get-UnattendedInstallFile|Get-Unconstrained|Get-VaultCredential|Get-VulnAutoRun|Get-VulnSchTask|Gupt-Backdoor|HTTP-Login|Install-SSP|Install-ServiceBinary|Invoke-ACLScanner|Invoke-ADSBackdoor|Invoke-ARPScan|Invoke-AllChecks|Invoke-BackdoorLNK|Invoke-BypassUAC|Invoke-CredentialInjection|Invoke-DCSync|Invoke-DllInjection|Invoke-DowngradeAccount|Invoke-EgressCheck|Invoke-Inveigh|Invoke-InveighRelay|Invoke-Mimikittenz|Invoke-NetRipper|Invoke-NinjaCopy|Invoke-PSInject|Invoke-Paranoia|Invoke-PortScan|Invoke-PoshRat|Invoke-PostExfil|Invoke-PowerDump|Invoke-PowerShellTCP|Invoke-PsExec|Invoke-PsUaCme|Invoke-ReflectivePEInjection|Invoke-ReverseDNSLookup|Invoke-RunAs|Invoke-SMBScanner|Invoke-SSHCommand|Invoke-Service|Invoke-Shellcode|Invoke-Tater|Invoke-ThunderStruck|Invoke-Token|Invoke-UserHunter|Invoke-VoiceTroll|Invoke-WScriptBypassUAC|Invoke-WinEnum|MailRaider|New-HoneyHash|Out-Minidump|Port-Scan|PowerBreach|PowerUp|PowerView|Remove-Update|Set-MacAttribute|Set-Wallpaper|Show-TargetScreen|Start-CaptureServer|VolumeShadowCopyTools|NEEEEWWW|(Computer|User)Property|CachedRDPConnection|get-net\S+|invoke-\S+hunter|Install-Service|get-\S+(credent|password)|remoteps|Kerberos.*(policy|ticket)|netfirewall|Uninstall-Windows|Verb\s+Runas|AmsiBypass|nishang|Invoke-Interceptor|EXEonRemote|NetworkRelay|PowerShelludp|PowerShellIcmp|CreateShortcut|copy-vss|invoke-dll|invoke-mass|out-shortcut|Invoke-ShellCommand"),1,0)  | eval base64 = if(match(lower(ScriptBlockText),"frombase64"), "4", 0) | eval empire=if(match(lower(ScriptBlockText),"system.net.webclient")  AND match(lower(ScriptBlockText), "frombase64string") ,5,0) | eval mimikatz=if(match(lower(ScriptBlockText),"mimikatz")  OR match(lower(ScriptBlockText), "-dumpcr") OR match(lower(ScriptBlockText), "SEKURLSA::Pth")  OR match(lower(ScriptBlockText), "kerberos::ptt") OR match(lower(ScriptBlockText),  "kerberos::golden") ,5,0) | eval iex=if(match(ScriptBlockText, "(?i)iex|invoke-expression"),2,0)  | eval webclient=if(match(lower(ScriptBlockText),"http") OR match(lower(ScriptBlockText),"web(client|request)")  OR match(lower(ScriptBlockText),"socket") OR match(lower(ScriptBlockText),"download(file|string)")  OR match(lower(ScriptBlockText),"bitstransfer") OR match(lower(ScriptBlockText),"internetexplorer.application")  OR match(lower(ScriptBlockText),"xmlhttp"),5,0) | eval get = if(match(lower(ScriptBlockText),"get-"),  "1", 0) | eval rundll32 = if(match(lower(ScriptBlockText),"rundll32"), "4", 0) |  eval suspkeywrd=if(match(ScriptBlockText, "(?i)(bitstransfer|mimik|metasp|AssemblyBuilderAccess|Reflection\.Assembly|shellcode|injection|cnvert|shell\.application|start-process|Rc4ByteStream|System\.Security\.Cryptography|lsass\.exe|localadmin|LastLoggedOn|hijack|BackupPrivilege|ngrok|comsvcs|backdoor|brute.?force|Port.?Scan|Exfiltration|exploit|DisableRealtimeMonitoring|beacon)"),1,0)  | eval syswow64 = if(match(lower(ScriptBlockText),"syswow64"), "3", 0) | eval httplocal  = if(match(lower(ScriptBlockText),"http://127.0.0.1"), "4", 0) | eval reflection  = if(match(lower(ScriptBlockText),"reflection"), "1", 0) | eval invokewmi=if(match(lower(ScriptBlockText),  "(?i)(wmiobject|WMIMethod|RemoteWMI|PowerShellWmi|wmicommand)"),5,0) | eval downgrade=if(match(ScriptBlockText,  "(?i)([-]ve*r*s*i*o*n*\s+2)") OR match(lower(ScriptBlockText),"powershell -version"),3,0)  | eval compressed=if(match(ScriptBlockText, "(?i)GZipStream|::Decompress|IO.Compression|write-zip|(expand|compress)-Archive"),5,0)  | eval invokecmd = if(match(lower(ScriptBlockText),"invoke-command"), "4", 0) |  addtotals fieldname=Score DoIt, enccom, suspcmdlet, suspkeywrd, compressed, downgrade,  mimikatz, iex, empire, rundll32, webclient, syswow64, httplocal, reflection, invokewmi,  invokecmd, base64, get | stats values(Score) by UserID, Computer, DoIt, enccom,  compressed, downgrade, iex, mimikatz, rundll32, empire, webclient, syswow64, httplocal,  reflection, invokewmi, invokecmd, base64, get, suspcmdlet, suspkeywrd | rename Computer  as dest, UserID as user | `powershell_4104_hunting_filter`'



<li><a href="#">NAME: Powershell COM Hijacking InprocServer32 Modification

DESCRIPTION:  The following analytic utilizes PowerShell ScriptBlock Logging to identify  a script that is attempting to modify or add a component object model to inprocserver32  path within the registry.

SEARCH:  '`powershell` EventCode=4104 ScriptBlockText = "*Software\\Classes\\CLSID\\*\\InProcServer32*"  | stats count min(_time) as firstTime max(_time) as lastTime by EventCode ScriptBlockText  Computer UserID | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `powershell_com_hijacking_inprocserver32_modification_filter`'



<li><a href="#">NAME: Powershell Creating Thread Mutex

DESCRIPTION:  The following analytic identifies suspicious PowerShell script execution  via EventCode 4104 that is using the `mutex` function. This function is commonly  seen in some obfuscated PowerShell scripts to make sure that only one instance of  there process is running on a compromise machine. During triage, review parallel  processes within the same timeframe. Review the full script block to identify other  related artifacts.

SEARCH:  '`powershell` EventCode=4104 ScriptBlockText = "*Threading.Mutex*" | stats  count min(_time) as firstTime max(_time) as lastTime by EventCode ScriptBlockText  Computer UserID | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `powershell_creating_thread_mutex_filter`'



<li><a href="#">NAME: Powershell Disable Security Monitoring

DESCRIPTION:  This search identifies a modification in registry to disable the windows  defender real time behavior monitoring. This event or technique is commonly seen  in RATs, bots, or Trojans to disable AV to evade detections.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where `process_powershell` Processes.process="*set-mppreference*"  AND Processes.process IN ("*disablerealtimemonitoring*","*disableioavprotection*","*disableintrusionpreventionsystem*","*disablescriptscanning*","*disableblockatfirstseen*","*DisableBehaviorMonitoring*","*drtm  *","*dioavp *","*dscrptsc *","*dbaf *","*dbm *") by Processes.dest Processes.user  Processes.parent_process Processes.original_file_name Processes.process_name Processes.process  Processes.process_id Processes.parent_process_id | `drop_dm_object_name(Processes)`  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `powershell_disable_security_monitoring_filter`'



<li><a href="#">NAME: PowerShell Domain Enumeration

DESCRIPTION:  'The following analytic utilizes PowerShell Script Block Logging (EventCode=4104)  to identify suspicious PowerShell execution. Script Block Logging captures the command  sent to PowerShell, the full command to be executed. Upon enabling, logs will output  to Windows event logs. Dependent upon volume, enable on critical endpoints or all.  \  This analytic identifies specific PowerShell modules typically used to enumerate  an organizations domain or users. \  During triage, review parallel processes using an EDR product or 4688 events. It  will be important to understand the timeline of events around this activity. Review  the entire logged PowerShell script block.'

SEARCH:  '`powershell` EventCode=4104 ScriptBlockText IN (*get-netdomaintrust*, *get-netforesttrust*,  *get-addomain*, *get-adgroupmember*, *get-domainuser*) | stats count min(_time)  as firstTime max(_time) as lastTime by Computer EventCode ScriptBlockText UserID  | rename Computer as dest | rename UserID as user | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `powershell_domain_enumeration_filter`'



<li><a href="#">NAME: PowerShell Enable PowerShell Remoting

DESCRIPTION:  This analytic utilizes PowerShell Script Block Logging (EventCode 4104) to identify the use of Enable-PSRemoting cmdlet. This cmdlet allows users to enable PowerShell remoting on a local or remote computer, which allows other computers to run commands on the target computer. The ability to remotely execute commands can be abused by attackers to take control of compromised systems and pivot to other systems on the network.  By detecting the use of Enable-PSRemoting cmdlet via script block logging, this analytic can help organizations identify potential malicious activity related to attackers attempting to gain remote control of compromised systems.

SEARCH:  '`powershell` EventCode=4104 ScriptBlockText="*Enable-PSRemoting*"  | stats count min(_time) as firstTime max(_time) as lastTime by Computer EventCode ScriptBlockText   | `security_content_ctime(firstTime)`   | `security_content_ctime(lastTime)`| `powershell_enable_powershell_remoting_filter`'



<li><a href="#">NAME: Powershell Enable SMB1Protocol Feature

DESCRIPTION:  This search is to detect a suspicious enabling of smb1protocol through  `powershell.exe`. This technique was seen in some ransomware (like reddot) where  it enable smb share to do the lateral movement and encrypt other files within the  compromise network system.

SEARCH:  '`powershell` EventCode=4104 ScriptBlockText = "*Enable-WindowsOptionalFeature*"  ScriptBlockText = "*SMB1Protocol*" | stats count min(_time) as firstTime max(_time)  as lastTime by EventCode ScriptBlockText Computer UserID | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `powershell_enable_smb1protocol_feature_filter`'



<li><a href="#">NAME: Powershell Execute COM Object

DESCRIPTION:  This search is to detect a COM CLSID execution through powershell. This  technique was seen in several adversaries and malware like ransomware conti where  it has a feature to execute command using COM Object. This technique may use by  network operator at some cases but a good indicator if some application want to  gain privilege escalation or bypass uac.

SEARCH:  '`powershell` EventCode=4104 ScriptBlockText = "*CreateInstance([type]::GetTypeFromCLSID*"  | stats count min(_time) as firstTime max(_time) as lastTime by EventCode ScriptBlockText  Computer user_id | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `powershell_execute_com_object_filter`'



<li><a href="#">NAME: Powershell Fileless Process Injection via GetProcAddress

DESCRIPTION:  'The following analytic utilizes PowerShell Script Block Logging (EventCode=4104)  to identify suspicious PowerShell execution. Script Block Logging captures the command  sent to PowerShell, the full command to be executed. Upon enabling, logs will output  to Windows event logs. Dependent upon volume, enable no critical endpoints or all.  \  This analytic identifies `GetProcAddress` in the script block. This is not normal  to be used by most PowerShell scripts and is typically unsafe/malicious. Many attack  toolkits use GetProcAddress to obtain code execution. \  In use, `$var_gpa = $var_unsafe_native_methods.GetMethod(GetProcAddress` and later  referenced/executed elsewhere. \  During triage, review parallel processes using an EDR product or 4688 events. It  will be important to understand the timeline of events around this activity. Review  the entire logged PowerShell script block.'

SEARCH:  '`powershell` EventCode=4104 ScriptBlockText=*getprocaddress* | stats count  min(_time) as firstTime max(_time) as lastTime by Opcode Computer UserID EventCode  ScriptBlockText | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `powershell_fileless_process_injection_via_getprocaddress_filter`'



<li><a href="#">NAME: Powershell Fileless Script Contains Base64 Encoded Content

DESCRIPTION:  'The following analytic utilizes PowerShell Script Block Logging (EventCode=4104)  to identify suspicious PowerShell execution. Script Block Logging captures the command  sent to PowerShell, the full command to be executed. Upon enabling, logs will output  to Windows event logs. Dependent upon volume, enable on critical endpoints or all.  \  This analytic identifies `FromBase64String` within the script block. A typical malicious  instance will include additional code. \  Command example - `[Byte[]]$var_code = [System.Convert]::FromBase64String(38uqIyMjQ6rG....`  \  During triage, review parallel processes using an EDR product or 4688 events. It  will be important to understand the timeline of events around this activity. Review  the entire logged PowerShell script block.'

SEARCH:  '`powershell` EventCode=4104 ScriptBlockText = "*frombase64string*" OR ScriptBlockText  = "*gnirtS46esaBmorF*" | stats count min(_time) as firstTime max(_time) as lastTime  by EventCode ScriptBlockText Computer UserID | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `powershell_fileless_script_contains_base64_encoded_content_filter`'



<li><a href="#">NAME: PowerShell Get LocalGroup Discovery

DESCRIPTION:  The following hunting analytic identifies the use of `get-localgroup`  being used with PowerShell to identify local groups on the endpoint. During triage,  review parallel processes and identify any further suspicious behavior.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where (Processes.process_name=powershell.exe  OR Processes.process_name=cmd.exe) (Processes.process="*get-localgroup*") by Processes.dest  Processes.user Processes.parent_process_name Processes.process_name Processes.process  Processes.process_id Processes.parent_process_id | `drop_dm_object_name(Processes)`  | `security_content_ctime(firstTime)`| `security_content_ctime(lastTime)` | `powershell_get_localgroup_discovery_filter`'



<li><a href="#">NAME: Powershell Get LocalGroup Discovery with Script Block Logging

DESCRIPTION:  'The following analytic utilizes PowerShell Script Block Logging (EventCode=4104)  to identify suspicious PowerShell execution. Script Block Logging captures the command  sent to PowerShell, the full command to be executed. Upon enabling, logs will output  to Windows event logs. Dependent upon volume, enable on critical endpoints or all.  \  This analytic identifies PowerShell cmdlet - `get-localgroup` being ran. Typically,  by itself, is not malicious but may raise suspicion based on time of day, endpoint  and username. \  During triage, review parallel processes using an EDR product or 4688 events. It  will be important to understand the timeline of events around this activity. Review  the entire logged PowerShell script block.'

SEARCH:  '`powershell` EventCode=4104 ScriptBlockText = "*get-localgroup*" | stats  count min(_time) as firstTime max(_time) as lastTime by Opcode Computer UserID EventCode  ScriptBlockText  | rename Computer as dest, UserID as user  | `security_content_ctime(firstTime)`  |`security_content_ctime(lastTime)`  | `powershell_get_localgroup_discovery_with_script_block_logging_filter`'



<li><a href="#">NAME: PowerShell Invoke CIMMethod CIMSession

DESCRIPTION:  This analytic identifies the use of the New-CIMSession cmdlet being created along with the Invoke-CIMMethod cmdlet being used within PowerShell. This particular behavior is similar to the usage of the Invoke-WMIMethod cmdlet, which is known for executing WMI commands on targets using NTLMv2 pass-the-hash authentication. The New-CIMSession cmdlet allows users to create a new CIM session object for a specified computer system, which can then be used to execute CIM operations remotely. Similarly, the Invoke-CIMMethod cmdlet is used to invoke a specified method on one or more CIM objects. Therefore, the combination of New-CIMSession and Invoke-CIMMethod cmdlets in PowerShell can potentially indicate malicious behavior, and this analytic can help detect such activity.

SEARCH:  '`powershell` EventCode=4104 ScriptBlockText IN ("*invoke-CIMMethod*", "*New-CimSession*")  | stats count min(_time) as firstTime max(_time) as lastTime by Computer EventCode ScriptBlockText   | `security_content_ctime(firstTime)`   | `security_content_ctime(lastTime)` | `powershell_invoke_cimmethod_cimsession_filter`'



<li><a href="#">NAME: PowerShell Invoke WmiExec Usage

DESCRIPTION:  The following analytic detects the usage of the Invoke-WMIExec utility within PowerShell Script Block Logging (EventCode 4104). The utility is used for executing WMI commands on targets using NTLMv2 pass-the-hash authentication.

SEARCH:  '`powershell` EventCode=4104 ScriptBlockText IN ("*invoke-wmiexec*")   | stats count min(_time) as firstTime max(_time) as lastTime by Computer EventCode ScriptBlockText   | `security_content_ctime(firstTime)`   | `security_content_ctime(lastTime)`  | `powershell_invoke_wmiexec_usage_filter`'



<li><a href="#">NAME: PowerShell Loading DotNET into Memory via Reflection

DESCRIPTION:  'The following analytic utilizes PowerShell Script Block Logging (EventCode=4104)  to identify suspicious PowerShell execution. Script Block Logging captures the command  sent to PowerShell, the full command to be executed. Upon enabling, logs will output  to Windows event logs. Dependent upon volume, enable no critical endpoints or all.  \  This analytic identifies the use of PowerShell loading .net assembly via reflection.  This is commonly found in malicious PowerShell usage, including Empire and Cobalt  Strike. In addition, the `load(` value may be modifed by removing `(` and it will  identify more events to review. \  During triage, review parallel processes using an EDR product or 4688 events. It  will be important to understand the timeline of events around this activity. Review  the entire logged PowerShell script block.'

SEARCH:  '`powershell` EventCode=4104 ScriptBlockText IN ("*[system.reflection.assembly]::load(*","*[reflection.assembly]*",  "*reflection.assembly*") | stats count min(_time) as firstTime max(_time) as lastTime  by Opcode Computer UserID EventCode ScriptBlockText | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `powershell_loading_dotnet_into_memory_via_reflection_filter`'



<li><a href="#">NAME: Powershell Load Module in Meterpreter

DESCRIPTION:  'The following analytic utilizes PowerShell Script Block Logging (EventCode=4104)  to identify suspicious PowerShell execution. Script Block Logging captures the command  sent to PowerShell, the full command to be executed. Upon enabling, logs will output  to Windows event logs. Dependent upon volume, enable on critical endpoints or all.  \  This analytic identifies "MSF.Powershell","MSF.Powershell.Meterpreter","MSF.Powershell.Meterpreter.Kiwi","MSF.Powershell.Meterpreter.Transport"  being used. This behavior is related to when a Meterpreter session is started and  the operator runs load_kiwi. \  During triage, review parallel processes using an EDR product or 4688 events. It  will be important to understand the timeline of events around this activity. Review  the entire logged PowerShell script block.'

SEARCH:  '`powershell` EventCode=4104 ScriptBlockText IN ("*MSF.Powershell*","*MSF.Powershell.Meterpreter*","*MSF.Powershell.Meterpreter.Kiwi*","*MSF.Powershell.Meterpreter.Transport*")  | stats count min(_time) as firstTime max(_time) as lastTime by EventCode ScriptBlockText  Computer user_id | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `powershell_load_module_in_meterpreter_filter`'



<li><a href="#">NAME: Powershell Processing Stream Of Data

DESCRIPTION:  The following analytic identifies suspicious PowerShell script execution  via EventCode 4104 that is processing compressed stream data. This is typically  found in obfuscated PowerShell or PowerShell executing embedded .NET or binary files  that are stream flattened and will be deflated durnig execution. During triage,  review parallel processes within the same timeframe. Review the full script block  to identify other related artifacts.

SEARCH:  '`powershell` EventCode=4104 ScriptBlockText = "*IO.Compression.*" OR ScriptBlockText  = "*IO.StreamReader*" OR ScriptBlockText = "*]::Decompress*" | stats count min(_time)  as firstTime max(_time) as lastTime by EventCode ScriptBlockText Computer UserID  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `powershell_processing_stream_of_data_filter`'



<li><a href="#">NAME: Powershell Remote Services Add TrustedHost

DESCRIPTION:  The following analytic identifies a suspicious PowerShell script execution via EventCode 4104   that contains command to add or modify the trustedhost configuration in Windows OS.   This behavior raises concerns due to the nature of modifications made to the 'TrustedHost' configuration,   which typically involves adjusting settings crucial for remote connections and security protocols.   Alterations in this area could potentially indicate attempts to manipulate trusted hosts or systems   for unauthorized remote access, a tactic commonly observed in various unauthorized access or compromise attempts.

SEARCH:  '`powershell` EventCode=4104  ScriptBlockText = "*WSMan:\\localhost\\Client\\TrustedHosts*" ScriptBlockText IN ("* -Value *", "* -Concatenate *")  | rename Computer as dest, UserID as user  | stats count min(_time) as firstTime max(_time) as lastTime by EventCode ScriptBlockText dest user  | `security_content_ctime(firstTime)`   | `security_content_ctime(lastTime)`   | `powershell_remote_services_add_trustedhost_filter`'



<li><a href="#">NAME: Powershell Remote Thread To Known Windows Process

DESCRIPTION:  this search is designed to detect suspicious powershell process that  tries to inject code and to known/critical windows process and execute it using  CreateRemoteThread. This technique is seen in several malware like trickbot and  offensive tooling like cobaltstrike where it load a shellcode to svchost.exe to  execute reverse shell to c2 and download another payload

SEARCH:  '`sysmon` EventCode = 8 parent_process_name IN ("powershell_ise.exe", "powershell.exe")  TargetImage IN ("*\\svchost.exe","*\\csrss.exe" "*\\gpupdate.exe", "*\\explorer.exe","*\\services.exe","*\\winlogon.exe","*\\smss.exe","*\\wininit.exe","*\\userinit.exe","*\\spoolsv.exe","*\\taskhost.exe")  | stats  min(_time) as firstTime max(_time) as lastTime count by SourceImage process_name  SourceProcessId SourceProcessGuid TargetImage TargetProcessId NewThreadId StartAddress  dest EventCode | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `powershell_remote_thread_to_known_windows_process_filter`'



<li><a href="#">NAME: Powershell Remove Windows Defender Directory

DESCRIPTION:  This analytic will identify a suspicious PowerShell command used to delete  the Windows Defender folder. This technique was seen used by the WhisperGate malware  campaign where it used Nirsofts advancedrun.exe to gain administrative privileges  to then execute a PowerShell command to delete the Windows Defender folder. This  is a good indicator the offending process is trying corrupt a Windows Defender installation.

SEARCH:  '`powershell` EventCode=4104 ScriptBlockText = "*rmdir *" AND ScriptBlockText  = "*\\Microsoft\\Windows Defender*" | stats count min(_time) as firstTime max(_time)  as lastTime by Opcode Computer UserID EventCode ScriptBlockText | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `powershell_remove_windows_defender_directory_filter` '



<li><a href="#">NAME: PowerShell Script Block With URL Chain

DESCRIPTION:  The following analytic identifies a suspicious PowerShell script execution via EventCode 4104 that contains multiple URLs within a function or array. This is typically found in obfuscated PowerShell or PowerShell executing embedded .NET or binary files that are attempting to download 2nd stage payloads.  During triage, review parallel processes within the same timeframe. Review the full script block to identify other related artifacts.

SEARCH:  '`powershell` EventCode=4104 ScriptBlockText IN ("*http:*","*https:*")| regex ScriptBlockText="(\"?(https?:\/\/(?:www\.)?[-a-zA-Z0-9@:%._\+~#=]{1,256}\.[a-zA-Z0-9()]{1,6}\b(?:[-a-zA-Z0-9()@:%_\+.~#?&\/=]*))\"?(?:,|\))?){2,}"| rex max_match=20 field=ScriptBlockText "(?<url>https?:\/\/(?:www\.)?[-a-zA-Z0-9@:%._\+~#=]{1,256}\.[a-zA-Z0-9()]{1,6}\b(?:[-a-zA-Z0-9()@:%_\+.~#?&\/=]*))"| eval Path = case(isnotnull(Path),Path,true(),"unknown")| stats count min(_time) as firstTime max(_time) as lastTime list(ScriptBlockText) as command values(Path) as file_name values(UserID) as user values(url) as url dc(url) as url_count by ActivityID, Computer, EventCode| rename Computer as dest, EventCode as signature_id| `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`| `powershell_script_block_with_url_chain_filter`'



<li><a href="#">NAME: PowerShell Start-BitsTransfer

DESCRIPTION:  Start-BitsTransfer is the PowerShell "version" of BitsAdmin.exe. Similar  functionality is present. This technique variation is not as commonly used by adversaries,  but has been abused in the past. Lesser known uses include the ability to set the  `-TransferType` to `Upload` for exfiltration of files. In an instance where `Upload`  is used, it is highly possible files will be archived. During triage, review parallel  processes and process lineage. Capture any files on disk and review. For the remote  domain or IP, what is the reputation?

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where `process_powershell` Processes.process=*start-bitstransfer*  by Processes.dest Processes.user Processes.parent_process Processes.process_name  Processes.process Processes.process_id Processes.original_file_name Processes.parent_process_id  | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `powershell_start_bitstransfer_filter`'



<li><a href="#">NAME: PowerShell Start or Stop Service

DESCRIPTION:  This analytic identifies the use of PowerShell's Start-Service or Stop-Service cmdlets on an endpoint. These cmdlets allow users to start or stop a specified Windows service. The ability to manipulate services can be leveraged by attackers to disable or stop critical services, which can cause system instability or disrupt business operations.  By detecting the use of Start-Service or Stop-Service cmdlets via PowerShell, this analytic can help organizations identify potential malicious activity related to attackers attempting to manipulate services on compromised systems. However, note that this behavior may be noisy, as these cmdlets are commonly used by system administrators or other legitimate users to manage services. Therefore, it is recommended not to enable this analytic as a direct notable or TTP. Instead, it should be used as part of a broader set of security controls to detect and investigate potential threats.

SEARCH:  '`powershell` EventCode=4104 ScriptBlockText IN ("*start-service*", "*stop-service*")   | stats count min(_time) as firstTime max(_time) as lastTime by Computer EventCode ScriptBlockText   | `security_content_ctime(firstTime)`   | `security_content_ctime(lastTime)`  | `powershell_start_or_stop_service_filter`'



<li><a href="#">NAME: Powershell Using memory As Backing Store

DESCRIPTION:  The following analytic identifies suspicious PowerShell script execution  via EventCode 4104 that is using memory stream as new object backstore. The malicious  PowerShell script will contain stream flate data and will be decompressed in memory  to run or drop the actual payload. During triage, review parallel processes within  the same timeframe. Review the full script block to identify other related artifacts.

SEARCH:  '`powershell` EventCode=4104 ScriptBlockText = *New-Object* ScriptBlockText  = *IO.MemoryStream* | stats count min(_time) as firstTime max(_time) as lastTime  by EventCode ScriptBlockText Computer UserID | rename Computer as dest | rename UserID as user | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `powershell_using_memory_as_backing_store_filter`'



<li><a href="#">NAME: PowerShell WebRequest Using Memory Stream

DESCRIPTION:  This analytic identifies a common fileless malware staging technique of using .NET classes to directly download a URL payload into memory. The analytic utilizes PowerShell Script Block Logging  (EventCode=4104) to identify suspicious PowerShell execution.

SEARCH:  '`powershell` EventCode=4104  ScriptBlockText IN ("*system.net.webclient*","*system.net.webrequest*") AND ScriptBlockText="*IO.MemoryStream*" | eval Path = case(isnotnull(Path),Path,true(),"unknown")| stats count min(_time) as firstTime max(_time) as lastTime list(ScriptBlockText) as command values(Path) as file_name values(UserID) as user by ActivityID, Computer, EventCode | rename Computer as dest, EventCode as signature_id| `security_content_ctime(firstTime)`| `security_content_ctime(lastTime)`| `powershell_webrequest_using_memory_stream_filter`'



<li><a href="#">NAME: Powershell Windows Defender Exclusion Commands

DESCRIPTION:  This analytic will detect a suspicious process commandline related to  windows defender exclusion feature. This command is abused by adversaries, malware  author and red teams to bypassed Windows Defender Anti-Virus product by excluding  folder  path, file path, process, extensions and etc. from its real time or schedule scan  to execute their malicious code. This is a good indicator for defense evasion and  to look further for events after this behavior.

SEARCH:  '`powershell` EventCode=4104 (Message = "*Add-MpPreference *" OR Message =  "*Set-MpPreference *") AND Message = "*-exclusion*" | stats count min(_time) as  firstTime max(_time) as lastTime by EventCode Message ComputerName User | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `powershell_windows_defender_exclusion_commands_filter`'



<li><a href="#">NAME: PowerShell - Connect To Internet With Hidden Window

DESCRIPTION:  The following hunting analytic identifies PowerShell commands utilizing  the WindowStyle parameter to hide the window on the compromised endpoint. This combination  of command-line options is suspicious because it is overriding the default PowerShell  execution policy, attempts to hide its activity from the user, and connects to the  Internet. Removed in this version of the query is New-Object. The analytic identifies  all variations of WindowStyle, as PowerShell allows the ability to shorten the parameter.  For example w, win, windowsty and so forth. In addition, through our research it  was identified that PowerShell will interpret different command switch types beyond  the hyphen. We have added endash, emdash, horizontal bar, and forward slash.

SEARCH:  "| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)\  \ as lastTime from datamodel=Endpoint.Processes where `process_powershell` by Processes.user\  \ Processes.process_name Processes.process Processes.parent_process_name Processes.original_file_name\  \ Processes.dest Processes.process_id | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)`\  \ | `security_content_ctime(lastTime)` | where match(process,\"(?i)[\\-|\\/|\u2013\  |\u2014|\u2015]w(in*d*o*w*s*t*y*l*e*)*\\s+[^-]\") | `powershell___connect_to_internet_with_hidden_window_filter`"



<li><a href="#">NAME: Prevent Automatic Repair Mode using Bcdedit

DESCRIPTION:  This search is to detect a suspicious bcdedit.exe execution to ignore  all failures. This technique was used by ransomware to prevent the compromise machine  automatically boot in repair mode.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.process_name = "bcdedit.exe"  Processes.process = "*bootstatuspolicy*"  Processes.process = "*ignoreallfailures*"  by Processes.parent_process_name Processes.parent_process Processes.process_name  Processes.process Processes.dest Processes.user Processes.process_id Processes.process_guid  | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`|  `prevent_automatic_repair_mode_using_bcdedit_filter`'



<li><a href="#">NAME: Print Processor Registry Autostart

DESCRIPTION:  This analytic is to detect a suspicious modification or new registry  entry regarding print processor. This registry is known to be abuse by turla or  other APT to gain persistence and privilege escalation to the compromised machine.  This is done by adding the malicious dll payload on the new created key in this  registry that will be executed as it restarted the spoolsv.exe process and services.

SEARCH:  '| tstats `security_content_summariesonly` count  min(_time) as firstTime  max(_time) as lastTime FROM datamodel=Endpoint.Registry where Registry.registry_path  ="*\\Control\\Print\\Environments\\Windows x64\\Print Processors*" by Registry.dest  Registry.user  Registry.registry_path Registry.registry_key_name Registry.registry_value_name |  `security_content_ctime(lastTime)` | `security_content_ctime(firstTime)` | `drop_dm_object_name(Registry)`  | `print_processor_registry_autostart_filter`'



<li><a href="#">NAME: Print Spooler Adding A Printer Driver

DESCRIPTION:  'The following analytic identifies new printer drivers being load by  utilizing the Windows PrintService operational logs, EventCode 316. This was identified  during our testing of CVE-2021-34527 previously (CVE-2021-1675) or PrintNightmare.  \  Within the proof of concept code, the following event will occur - "Printer driver  1234 for Windows x64 Version-3 was added or updated. Files:- UNIDRV.DLL, kernelbase.dll,  evil.dll. No user action is required." \  During triage, isolate the endpoint and review for source of exploitation. Capture  any additional file modification events and review the source of where the exploitation  began.'

SEARCH:  '`printservice` EventCode=316 category = "Adding a printer driver" Message  = "*kernelbase.dll,*" Message = "*UNIDRV.DLL,*" Message = "*.DLL.*" | stats  count  min(_time) as firstTime max(_time) as lastTime by OpCode EventCode ComputerName  Message | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `print_spooler_adding_a_printer_driver_filter`'



<li><a href="#">NAME: Print Spooler Failed to Load a Plug-in

DESCRIPTION:  'The following analytic identifies driver load errors utilizing the Windows  PrintService Admin logs. This was identified during our testing of CVE-2021-34527  previously (CVE-2021-1675) or PrintNightmare. \  Within the proof of concept code, the following error will occur - "The print spooler  failed to load a plug-in module C:\Windows\system32\spool\DRIVERS\x64\3\meterpreter.dll,  error code 0x45A. See the event user data for context information." \  The analytic is based on file path and failure to load the plug-in. \  During triage, isolate the endpoint and review for source of exploitation. Capture  any additional file modification events.'

SEARCH:  '`printservice` ((ErrorCode="0x45A" (EventCode="808" OR EventCode="4909"))  OR ("The print spooler failed to load a plug-in module" OR "\\drivers\\x64\\"))  | stats count min(_time) as firstTime max(_time) as lastTime by OpCode EventCode  ComputerName Message | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `print_spooler_failed_to_load_a_plug_in_filter`'



<li><a href="#">NAME: Processes launching netsh

DESCRIPTION:  This search looks for processes launching netsh.exe. Netsh is a command-line  scripting utility that allows you to, either locally or remotely, display or modify  the network configuration of a computer that is currently running. Netsh can be  used as a persistence proxy technique to execute a helper DLL when netsh.exe is  executed. In this search, we are looking for processes spawned by netsh.exe and  executing commands via the command line.

SEARCH:  '| tstats `security_content_summariesonly` count values(Processes.process)  AS Processes.process min(_time) as firstTime max(_time) as lastTime from datamodel=Endpoint.Processes  where `process_netsh` by Processes.parent_process_name Processes.parent_process  Processes.original_file_name Processes.process_name Processes.user Processes.dest  |`drop_dm_object_name("Processes")` |`security_content_ctime(firstTime)` |`security_content_ctime(lastTime)`  |`processes_launching_netsh_filter`'



<li><a href="#">NAME: Processes Tapping Keyboard Events

DESCRIPTION:  This search looks for processes in an MacOS system that is tapping keyboard  events in MacOS, and essentially monitoring all keystrokes made by a user. This  is a common technique used by RATs to log keystrokes from a victim, although it  can also be used by legitimate processes like Siri to react on human input

SEARCH:  '| from datamodel Alerts.Alerts | search app=osquery:results name=pack_osx-attacks_Keyboard_Event_Taps  | rename columns.cmdline as cmd, columns.name as process_name, columns.pid as process_id|  dedup host,process_name | table host,process_name, cmd, process_id | `processes_tapping_keyboard_events_filter`'



<li><a href="#">NAME: Process Creating LNK file in Suspicious Location

DESCRIPTION:  This search looks for a process launching an `*.lnk` file under `C:\User*`  or `*\Local\Temp\*`. This is common behavior used by various spear phishing tools.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime FROM datamodel=Endpoint.Filesystem where Filesystem.file_name="*.lnk"  AND (Filesystem.file_path="C:\\User\\*" OR Filesystem.file_path="*\\Temp\\*") by  _time span=1h Filesystem.process_guid Filesystem.file_name Filesystem.file_path  Filesystem.file_hash Filesystem.user | `drop_dm_object_name(Filesystem)` | rename  process_guid as lnk_guid | join lnk_guid, _time [| tstats `security_content_summariesonly`  count FROM datamodel=Endpoint.Processes where Processes.process_name=* by _time  span=1h Processes.parent_process_guid Processes.process_id Processes.process_name  Processes.dest Processes.process_path Processes.process | `drop_dm_object_name(Processes)`  | rename parent_process_guid as lnk_guid | fields _time lnk_guid process_id dest  process_name process_path process] | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | table firstTime, lastTime, lnk_guid, process_id, user, dest, file_name, file_path,  process_name, process, process_path, file_hash | `process_creating_lnk_file_in_suspicious_location_filter`'



<li><a href="#">NAME: Process Deleting Its Process File Path

DESCRIPTION:  This detection is to identify a suspicious process that tries to delete  the process file path related to its process. This technique is known to be defense  evasion once a certain condition of malware is satisfied or not. Clop ransomware  use this technique where it will try to delete its process file path using a .bat  command if the keyboard layout is not the layout it tries to infect.

SEARCH:  '`sysmon` EventCode=1 CommandLine = "* /c *" CommandLine = "* del*" Image  = "*\\cmd.exe" | eval result = if(like(process,"%".parent_process."%"), "Found",  "Not Found") | stats min(_time) as firstTime max(_time) as lastTime count by dest  user ParentImage ParentCommandLine Image CommandLine EventCode ProcessID result  | where result = "Found" | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `process_deleting_its_process_file_path_filter`'



<li><a href="#">NAME: Process Execution via WMI

DESCRIPTION:  The following analytic identifies `WmiPrvSE.exe` spawning a process.  This typically occurs when a process is instantiated from a local or remote process  using `wmic.exe`. During triage, review parallel processes for suspicious behavior  or commands executed. Review the process and command-line spawning from `wmiprvse.exe`.  Contain and remediate the endpoint as necessary.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.parent_process_name=WmiPrvSE.exe  by Processes.dest Processes.user Processes.parent_process Processes.process_name  Processes.process Processes.process_id Processes.parent_process_id | `drop_dm_object_name(Processes)`  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `process_execution_via_wmi_filter` '



<li><a href="#">NAME: Process Kill Base On File Path

DESCRIPTION:  The following analytic identifies the use of `wmic.exe` using `delete`  to remove a executable path. This is typically ran via a batch file during beginning  stages of an adversary setting up for mining on an endpoint.

SEARCH:  '| tstats `security_content_summariesonly` values(Processes.process) as process  values(Processes.process_id) as process_id count min(_time) as firstTime max(_time)  as lastTime  from datamodel=Endpoint.Processes where `process_wmic` AND Processes.process="*process*"  AND Processes.process="*executablepath*" AND Processes.process="*delete*" by  Processes.parent_process_name  Processes.process_name Processes.original_file_name Processes.dest Processes.user  | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `process_kill_base_on_file_path_filter`'



<li><a href="#">NAME: Process Writing DynamicWrapperX

DESCRIPTION:  DynamicWrapperX is an ActiveX component that can be used in a script  to call Windows API functions, but it requires the dynwrapx.dll to be installed  and registered. With that, a binary writing dynwrapx.dll to disk and registering  it into the registry is highly suspect. Why is it needed? In most malicious instances,  it will be written to disk at a non-standard location. During triage, review parallel  processes and pivot on the process_guid. Review the registry for any suspicious  modifications meant to load dynwrapx.dll. Identify any suspicious module loads of  dynwrapx.dll. This will identify the process that will invoke vbs/wscript/cscript.

SEARCH:  '| tstats `security_content_summariesonly` count FROM datamodel=Endpoint.Processes  by _time Processes.process_id Processes.process_name Processes.dest Processes.process_guid  Processes.user | `drop_dm_object_name(Processes)` | join process_guid [| tstats  `security_content_summariesonly` count FROM datamodel=Endpoint.Filesystem where  Filesystem.file_name="dynwrapx.dll" by _time Filesystem.dest Filesystem.file_create_time  Filesystem.file_name Filesystem.file_path Filesystem.process_guid Filesystem.user  | `drop_dm_object_name(Filesystem)` | fields _time process_guid file_path file_name  file_create_time user dest process_name] | stats count min(_time) as firstTime max(_time)  as lastTime by dest process_name process_guid file_name file_path file_create_time  user | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `process_writing_dynamicwrapperx_filter`'



<li><a href="#">NAME: Prohibited Network Traffic Allowed

DESCRIPTION:  This search looks for network traffic defined by port and transport layer  protocol in the Enterprise Security lookup table "lookup_interesting_ports", that  is marked as prohibited, and has an associated 'allow' action in the Network_Traffic  data model. This could be indicative of a misconfigured network device.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Network_Traffic where All_Traffic.action = allowed by  All_Traffic.src_ip All_Traffic.dest_ip All_Traffic.dest_port All_Traffic.action  | lookup update=true interesting_ports_lookup dest_port as All_Traffic.dest_port  OUTPUT app is_prohibited note transport | search is_prohibited=true | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `drop_dm_object_name("All_Traffic")` | `prohibited_network_traffic_allowed_filter`'



<li><a href="#">NAME: Protocols passing authentication in cleartext

DESCRIPTION:  The following analytic identifies cleartext protocols at risk of leaking  sensitive information. Currently, this consists of legacy protocols such as telnet  (port 23), POP3 (port 110), IMAP (port 143), and non-anonymous FTP (port 21) sessions.  While some of these protocols may be used over SSL, they typically are found on  different assigned ports in those instances.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Network_Traffic where All_Traffic.action!=blocked AND  All_Traffic.transport="tcp" AND (All_Traffic.dest_port="23" OR All_Traffic.dest_port="143"  OR All_Traffic.dest_port="110" OR (All_Traffic.dest_port="21" AND All_Traffic.user  != "anonymous")) by All_Traffic.user All_Traffic.src All_Traffic.dest All_Traffic.dest_port  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `drop_dm_object_name("All_Traffic")`  | `protocols_passing_authentication_in_cleartext_filter`'



<li><a href="#">NAME: Protocol or Port Mismatch

DESCRIPTION:  This search looks for network traffic on common ports where a higher  layer protocol does not match the port that is being used. For example, this search  should identify cases where protocols other than HTTP are running on TCP port 80.  This can be used by attackers to circumvent firewall restrictions, or as an attempt  to hide malicious communications over ports and protocols that are typically allowed  and not well inspected.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Network_Traffic where (All_Traffic.app=dns NOT All_Traffic.dest_port=53)  OR ((All_Traffic.app=web-browsing OR All_Traffic.app=http) NOT (All_Traffic.dest_port=80  OR All_Traffic.dest_port=8080 OR All_Traffic.dest_port=8000)) OR (All_Traffic.app=ssl  NOT (All_Traffic.dest_port=443 OR All_Traffic.dest_port=8443)) OR (All_Traffic.app=smtp  NOT All_Traffic.dest_port=25) by All_Traffic.src_ip, All_Traffic.dest_ip, All_Traffic.app,  All_Traffic.dest_port |`security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `drop_dm_object_name("All_Traffic")` | `protocol_or_port_mismatch_filter`'



<li><a href="#">NAME: Randomly Generated Scheduled Task Name

DESCRIPTION:  The following hunting analytic leverages Event ID 4698, `A scheduled  task was created`, to identify the creation of a Scheduled Task with a suspicious,  high entropy, Task Name. To achieve this, this analytic also leverages the `ut_shannon`  function from the URL ToolBox Splunk application. Red teams and adversaries alike  may abuse the Task Scheduler to create and start a remote Scheduled Task and obtain  remote code execution. To achieve this goal, tools like Impacket or Crapmapexec,  typically create a Scheduled Task with a random task name on the victim host. This  hunting analytic may help defenders identify Scheduled Tasks created as part of  a lateral movement attack. The entropy threshold `ut_shannon > 3` should be customized  by users. The Command field can be used to determine if the task has malicious intent  or not.

SEARCH:  ' `wineventlog_security` EventCode=4698 | xmlkv Message | lookup ut_shannon_lookup  word as Task_Name | where ut_shannon > 3 | table  _time, dest, Task_Name, ut_shannon,  Command, Author, Enabled, Hidden | `randomly_generated_scheduled_task_name_filter`'



<li><a href="#">NAME: Randomly Generated Windows Service Name

DESCRIPTION:  The following hunting analytic leverages Event ID 7045, `A new service  was installed in the system`, to identify the installation of a Windows Service  with a suspicious, high entropy, Service Name. To achieve this, this analytic also  leverages the `ut_shannon` function from the URL ToolBox Splunk application. Red  teams and adversaries alike may abuse the Service Control Manager to create and  start a remote Windows Service and obtain remote code execution. To achieve this  goal, some tools like Metasploit, Cobalt Strike and Impacket, typically create a  Windows Service with a random service name on the victim host. This hunting analytic  may help defenders identify Windows Services installed as part of a lateral movement  attack. The entropy threshold `ut_shannon > 3` should be customized by users. The  Service_File_Name field can be used to determine if the Windows Service has malicious  intent or not.

SEARCH:  ' `wineventlog_system` EventCode=7045 | lookup ut_shannon_lookup word as Service_Name  | where ut_shannon > 3 | table EventCode ComputerName Service_Name ut_shannon Service_Start_Type  Service_Type Service_File_Name | `randomly_generated_windows_service_name_filter` '



<li><a href="#">NAME: Ransomware Notes bulk creation

DESCRIPTION:  The following analytics identifies a big number of instance of ransomware  notes (filetype e.g .txt, .html, .hta) file creation to the infected machine. This  behavior is a good sensor if the ransomware note filename is quite new for security  industry or the ransomware note filename is not in your ransomware lookup table  list for monitoring.

SEARCH:  '`sysmon` EventCode=11 file_name IN ("*\.txt","*\.html","*\.hta") |bin _time  span=10s | stats min(_time) as firstTime max(_time) as lastTime dc(TargetFilename)  as unique_readme_path_count values(TargetFilename) as list_of_readme_path by Computer  Image file_name | rename Computer as dest | where unique_readme_path_count >= 15 | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `ransomware_notes_bulk_creation_filter`'



<li><a href="#">NAME: Recon AVProduct Through Pwh or WMI

DESCRIPTION:  The following analytic identifies suspicious PowerShell script execution  via EventCode 4104 performing checks to identify anti-virus products installed on  the endpoint. This technique is commonly found in malware and APT events where the  adversary will map all running security applications or services. During triage,  review parallel processes within the same timeframe. Review the full script block  to identify other related artifacts.

SEARCH:  '`powershell` EventCode=4104 (ScriptBlockText = "*SELECT*" OR ScriptBlockText  = "*WMIC*") AND (ScriptBlockText = "*AntiVirusProduct*" OR ScriptBlockText = "*AntiSpywareProduct*")  | stats count min(_time) as firstTime max(_time) as lastTime by EventCode ScriptBlockText  Computer UserID | rename Computer as dest | rename UserID as user | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `recon_avproduct_through_pwh_or_wmi_filter`'



<li><a href="#">NAME: Recon Using WMI Class

DESCRIPTION:  The following analytic identifies suspicious PowerShell via EventCode  4104, where WMI is performing an event query looking for running processes or running  services. This technique is commonly found where the adversary will identify services  and system information on the compromised machine. During triage, review parallel  processes within the same timeframe. Review the full script block to identify other  related artifacts.

SEARCH:  '`powershell` EventCode=4104 (ScriptBlockText= "*SELECT*" OR ScriptBlockText=  "*Get-WmiObject*") AND (ScriptBlockText= "*Win32_Bios*" OR ScriptBlockText= "*Win32_OperatingSystem*"  OR ScriptBlockText= "*Win32_Processor*" OR ScriptBlockText= "*Win32_ComputerSystem*"  OR ScriptBlockText= "*Win32_PnPEntity*" OR ScriptBlockText= "*Win32_ShadowCopy*"  OR ScriptBlockText= "*Win32_DiskDrive*" OR ScriptBlockText= "*Win32_PhysicalMemory*")  | stats count min(_time) as firstTime max(_time) as lastTime by EventCode ScriptBlockText  Computer UserID | rename Computer as dest | rename UserID as user| `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `recon_using_wmi_class_filter`'



<li><a href="#">NAME: Recursive Delete of Directory In Batch CMD

DESCRIPTION:  This search is to detect a suspicious commandline designed to delete  files or directory recursive using batch command. This technique was seen in ransomware  (reddot) where it it tries to delete the files in recycle bin to impaire user from  recovering deleted files.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where `process_cmd` Processes.process=*/c*  Processes.process="*  rd *"  Processes.process="*/s*" Processes.process="*/q*" by Processes.user Processes.process_name  Processes.parent_process_name Processes.parent_process Processes.process Processes.process_id  Processes.dest |`drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `recursive_delete_of_directory_in_batch_cmd_filter`'



<li><a href="#">NAME: Registry Keys for Creating SHIM Databases

DESCRIPTION:  This search looks for registry activity associated with application compatibility  shims, which can be leveraged by attackers for various nefarious purposes.

SEARCH:  '| tstats `security_content_summariesonly` count FROM datamodel=Endpoint.Registry  WHERE (Registry.registry_path=*CurrentVersion\\AppCompatFlags\\Custom* OR Registry.registry_path=*CurrentVersion\\AppCompatFlags\\InstalledSDB*)  BY _time span=1h Registry.dest Registry.user Registry.registry_path Registry.registry_key_name Registry.registry_value_name  Registry.registry_value_data Registry.process_guid | `drop_dm_object_name(Registry)` | where isnotnull(registry_value_data) | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `registry_keys_for_creating_shim_databases_filter`'



<li><a href="#">NAME: Registry Keys Used For Persistence

DESCRIPTION:  The search looks for modifications or alterations made to registry keys  that have the potential to initiate the launch of an application or service during  system startup. By monitoring and detecting modifications in these registry keys,  we can identify suspicious or unauthorized changes that could be indicative of malicious  activity. This proactive approach helps in safeguarding the system's integrity and  security by promptly identifying and mitigating potential threats that aim to gain  persistence or execute malicious actions during the startup process.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime FROM datamodel=Endpoint.Registry where (Registry.registry_path=*\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RunOnce  OR Registry.registry_path=*\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\StartupApproved\\Run  OR Registry.registry_path= "*\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\User  Shell Folders\\*" OR Registry.registry_path= "*\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell  Folders\\*" OR Registry.registry_path=*\\currentversion\\run* OR Registry.registry_path=*\\currentVersion\\Windows\\Appinit_Dlls*  OR Registry.registry_path=*\\CurrentVersion\\Winlogon\\Shell* OR Registry.registry_path=*\\CurrentVersion\\Winlogon\\Notify*  OR Registry.registry_path=*\\CurrentVersion\\Winlogon\\Userinit* OR Registry.registry_path=*\\CurrentVersion\\Winlogon\\VmApplet*  OR Registry.registry_path=*\\currentversion\\policies\\explorer\\run* OR Registry.registry_path=*\\currentversion\\runservices*  OR Registry.registry_path=HKLM\\SOFTWARE\\Microsoft\\Netsh\\* OR Registry.registry_path=  "*\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders\\Common  Startup" OR Registry.registry_path= *\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\SharedTaskScheduler  OR Registry.registry_path= *\\Classes\\htmlfile\\shell\\open\\command OR (Registry.registry_path="*Microsoft\\Windows  NT\\CurrentVersion\\Image File Execution Options*" AND Registry.registry_key_name=Debugger)  OR (Registry.registry_path="*\\CurrentControlSet\\Control\\Lsa" AND Registry.registry_key_name="Security  Packages") OR (Registry.registry_path="*\\CurrentControlSet\\Control\\Lsa\\OSConfig"  AND Registry.registry_key_name="Security Packages") OR (Registry.registry_path="*\\Microsoft\\Windows  NT\\CurrentVersion\\SilentProcessExit\\*") OR (Registry.registry_path="*currentVersion\\Windows"  AND Registry.registry_key_name="Load") OR (Registry.registry_path="*\\CurrentVersion"  AND Registry.registry_key_name="Svchost") OR (Registry.registry_path="*\\CurrentControlSet\Control\Session  Manager"AND Registry.registry_key_name="BootExecute") OR (Registry.registry_path="*\\Software\\Run"  AND Registry.registry_key_name="auto_update")) by Registry.dest Registry.user Registry.registry_path  Registry.registry_value_name Registry.registry_value_data Registry.process_guid  Registry.registry_key_name | `drop_dm_object_name(Registry)` | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `registry_keys_used_for_persistence_filter`'



<li><a href="#">NAME: Registry Keys Used For Privilege Escalation

DESCRIPTION:  This search looks for modifications to registry keys that can be used  to elevate privileges. The registry keys under "Image File Execution Options" are  used to intercept calls to an executable and can be used to attach malicious binaries  to benign system binaries.

SEARCH:  '| tstats `security_content_summariesonly` count FROM datamodel=Endpoint.Registry  WHERE ((Registry.registry_path="*Microsoft\\Windows NT\\CurrentVersion\\Image File  Execution Options*") AND (Registry.registry_value_name=GlobalFlag OR Registry.registry_value_name=Debugger))  BY _time span=1h Registry.dest Registry.user Registry.registry_path Registry.registry_key_name Registry.registry_value_name  Registry.registry_value_data Registry.process_guid | `drop_dm_object_name(Registry)` | where isnotnull(registry_value_data) | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `registry_keys_used_for_privilege_escalation_filter`'



<li><a href="#">NAME: Regsvr32 Silent and Install Param Dll Loading

DESCRIPTION:  This analytic is to detect a loading of dll using regsvr32 application  with silent parameter and dllinstall execution. This technique was seen in several  RAT malware similar to remcos, njrat and adversaries to load their malicious DLL  on the compromised machine. This TTP may executed by normal 3rd party application  so it is better to pivot by the parent process, parent command-line and command-line  of the file that execute this regsvr32.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where `process_regsvr32` AND Processes.process="*/i*"  by Processes.dest Processes.parent_process Processes.process Processes.parent_process_name  Processes.process_name Processes.original_file_name Processes.user | `drop_dm_object_name(Processes)`  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | where  match(process,"(?i)[\-|\/][Ss]{1}") | `regsvr32_silent_and_install_param_dll_loading_filter`'



<li><a href="#">NAME: Regsvr32 with Known Silent Switch Cmdline

DESCRIPTION:  The following analytic identifies Regsvr32.exe utilizing the silent switch  to load DLLs. This technique has most recently been seen in IcedID campaigns to  load its initial dll that will download the 2nd stage loader that will download  and decrypt the config payload. The switch type may be either a hyphen `-` or forward  slash `/`. This behavior is typically found with `-s`, and it is possible there  are more switch types that may be used. \ During triage, review parallel processes  and capture any artifacts that may have landed on disk. Isolate and contain the  endpoint as necessary.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where `process_regsvr32` by Processes.user  Processes.process_name Processes.process Processes.parent_process_name Processes.original_file_name  Processes.dest Processes.process_id | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | where match(process,"(?i)[\-|\/][Ss]{1}")  | `regsvr32_with_known_silent_switch_cmdline_filter`'



<li><a href="#">NAME: Reg exe Manipulating Windows Services Registry Keys

DESCRIPTION:  The search looks for reg.exe modifying registry keys that define Windows  services and their configurations.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime values(Processes.process_name) as process_name values(Processes.parent_process_name)  as parent_process_name values(Processes.user) as user FROM datamodel=Endpoint.Processes  where Processes.process_name=reg.exe Processes.process=*reg* Processes.process=*add*  Processes.process=*Services* by Processes.process_id Processes.dest Processes.process  | `drop_dm_object_name("Processes")` | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `reg_exe_manipulating_windows_services_registry_keys_filter`'



<li><a href="#">NAME: Remcos client registry install entry

DESCRIPTION:  |-  The following analytic detects the presence of a registry key related to the Remcos RAT agent on a host. This detection is made by a Splunk query to search for instances where the registry key "license" is found in the "Software\Remcos" path. This analytic combines information from two data models: Endpoint.Processes and Endpoint.Registry and retrieves process information such as user, process ID, process name, process path, destination, parent process name, parent process, and process GUID. This analytic also retrieves registry information such as registry path, registry key name, registry value name, registry value data, and process GUID. By joining the process GUID from the Endpoint.Processes data model with the process GUID from the Endpoint.Registry data model, the analytic identifies instances where the "license" registry key is found in the "Software\Remcos" path. This detection is important because it suggests that the host has been compromised by the Remcos RAT agent. Remcos is a well-known remote access Trojan that can be used by attackers to gain unauthorized access to systems and exfiltrate sensitive data. Identifying this behavior allows the SOC to take immediate action to remove the RAT agent and prevent further compromise. The impact of this attack can be severe, as the attacker can gain unauthorized access to the system, steal sensitive information, or use the compromised system as a launching point for further attacks. Next steps include using this analytic in conjunction with other security measures and threat intelligence to ensure accurate detection and response.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) AS firstTime max(_time)  AS lastTime FROM datamodel=Endpoint.Processes BY _time span=1h Processes.user Processes.process_id  Processes.process_name Processes.process Processes.process_path Processes.dest Processes.parent_process_name  Processes.parent_process Processes.process_guid | `drop_dm_object_name(Processes)`  | join process_guid [ | tstats `security_content_summariesonly` count FROM datamodel=Endpoint.Registry  WHERE (Registry.registry_key_name=*\\Software\\Remcos*) BY _time span=1h Registry.registry_path  Registry.registry_key_name Registry.registry_value_name Registry.registry_value_data  Registry.process_guid | `drop_dm_object_name(Registry)`] | fields firstTime lastTime  dest user parent_process_name parent_process process_name process_path process registry_key_name  registry_path registry_value_name registry_value_data process_guid | where isnotnull(registry_value_data)  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` |`remcos_client_registry_install_entry_filter`'



<li><a href="#">NAME: Remcos RAT File Creation in Remcos Folder

DESCRIPTION:  This search is to detect file creation in remcos folder in appdata which  is the keylog and clipboard logs that will be send to its c2 server. This is really  a good TTP indicator that there is a remcos rat in the system that do keylogging,  clipboard grabbing and audio recording.

SEARCH:  '|tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime FROM datamodel=Endpoint.Filesystem where Filesystem.file_name IN ("*.dat")  Filesystem.file_path = "*\\remcos\\*" by _time Filesystem.file_name Filesystem.file_path  Filesystem.dest Filesystem.file_create_time | `drop_dm_object_name(Filesystem)`  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `remcos_rat_file_creation_in_remcos_folder_filter`'



<li><a href="#">NAME: Remote Desktop Network Bruteforce

DESCRIPTION:  This search looks for RDP application network traffic and filters any  source/destination pair generating more than twice the standard deviation of the  average traffic.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Network_Traffic where All_Traffic.app=rdp by All_Traffic.src  All_Traffic.dest All_Traffic.dest_port | eventstats stdev(count) AS stdev avg(count)  AS avg p50(count) AS p50 | where count>(avg + stdev*2) | rename All_Traffic.src  AS src All_Traffic.dest AS dest | table firstTime lastTime src dest count avg p50  stdev | `remote_desktop_network_bruteforce_filter`'



<li><a href="#">NAME: Remote Desktop Network Traffic

DESCRIPTION:  This search looks for network traffic on TCP/3389, the default port used  by remote desktop. While remote desktop traffic is not uncommon on a network, it  is usually associated with known hosts. This search will ignore common RDP sources  and common RDP destinations so you can focus on the uncommon uses of remote desktop  on your network.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Network_Traffic where All_Traffic.dest_port=3389 AND  All_Traffic.dest_category!=common_rdp_destination AND All_Traffic.src_category!=common_rdp_source  AND all_Traffic.action="allowed" by All_Traffic.src All_Traffic.dest All_Traffic.dest_port  | `drop_dm_object_name("All_Traffic")` | `security_content_ctime(firstTime)`| `security_content_ctime(lastTime)`  | `remote_desktop_network_traffic_filter` '



<li><a href="#">NAME: Remote Desktop Process Running On System

DESCRIPTION:  This search looks for the remote desktop process mstsc.exe running on  systems upon which it doesn't typically run. This is accomplished by filtering out  all systems that are noted in the `common_rdp_source category` in the Assets and  Identity framework.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.process=*mstsc.exe  AND Processes.dest_category!=common_rdp_source by Processes.dest Processes.user  Processes.process | `security_content_ctime(firstTime)`| `security_content_ctime(lastTime)`  | `drop_dm_object_name(Processes)` | `remote_desktop_process_running_on_system_filter` '



<li><a href="#">NAME: Remote Process Instantiation via DCOM and PowerShell

DESCRIPTION:  This analytic looks for the execution of `powershell.exe` with arguments  utilized to start a process on a remote endpoint by abusing the DCOM protocol. Specifically,  this search looks for the abuse of ShellExecute and ExecuteShellCommand. Red Teams  and adversaries alike may abuse DCOM and `powershell.exe` for lateral movement and  remote code execution.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where `process_powershell` (Processes.process="*Document.ActiveView.ExecuteShellCommand*"  OR Processes.process="*Document.Application.ShellExecute*") by Processes.dest Processes.user  Processes.parent_process_name Processes.process_name Processes.process Processes.process_id  Processes.parent_process_id | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)`|  `security_content_ctime(lastTime)` | `remote_process_instantiation_via_dcom_and_powershell_filter`'



<li><a href="#">NAME: Remote Process Instantiation via DCOM and PowerShell Script Block

DESCRIPTION:  The following analytic utilizes PowerShell Script Block Logging (EventCode=4104)  to identify the execution of PowerShell with arguments utilized to start a process  on a remote endpoint by abusing the DCOM protocol. Specifically, this search looks  for the abuse of ShellExecute and ExecuteShellCommand. Red Teams and adversaries  alike may abuse DCOM for lateral movement and remote code execution.

SEARCH:  '`powershell` EventCode=4104 (ScriptBlockText="*Document.Application.ShellExecute*"  OR ScriptBlockText="*Document.ActiveView.ExecuteShellCommand*") | stats count min(_time)  as firstTime max(_time) as lastTime by EventCode ScriptBlockText Computer user_id  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `remote_process_instantiation_via_dcom_and_powershell_script_block_filter`'



<li><a href="#">NAME: Remote Process Instantiation via WinRM and PowerShell

DESCRIPTION:  This analytic looks for the execution of `powershell.exe` with arguments  utilized to start a process on a remote endpoint by abusing the WinRM protocol.  Specifically, this search looks for the abuse of the `Invoke-Command` commandlet.  Red Teams and adversaries alike may abuse WinRM and `powershell.exe` for lateral  movement and remote code execution.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where `process_powershell` (Processes.process="*Invoke-Command*"  AND Processes.process="*-ComputerName*") by Processes.dest Processes.user Processes.parent_process_name  Processes.process_name Processes.process Processes.process_id Processes.parent_process_id  | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)`| `security_content_ctime(lastTime)`  | `remote_process_instantiation_via_winrm_and_powershell_filter`'



<li><a href="#">NAME: Remote Process Instantiation via WinRM and PowerShell Script Block

DESCRIPTION:  The following analytic utilizes PowerShell Script Block Logging (EventCode=4104)  to identify the execution of PowerShell with arguments utilized to start a process  on a remote endpoint by abusing the WinRM protocol. Specifically, this search looks  for the abuse of the `Invoke-Command` commandlet. Red Teams and adversaries alike  may abuse WinRM for lateral movement and remote code execution.

SEARCH:  '`powershell` EventCode=4104 (ScriptBlockText="*Invoke-Command*" AND ScriptBlockText="*-ComputerName*")  | stats count min(_time) as firstTime max(_time) as lastTime by EventCode ScriptBlockText  Computer user_id | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `remote_process_instantiation_via_winrm_and_powershell_script_block_filter`'



<li><a href="#">NAME: Remote Process Instantiation via WinRM and Winrs

DESCRIPTION:  This analytic looks for the execution of `winrs.exe` with command-line  arguments utilized to start a process on a remote endpoint. Red Teams and adversaries  alike may abuse the WinRM protocol and this binary for lateral movement and remote  code execution.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where (Processes.process_name=winrs.exe  OR Processes.original_file_name=winrs.exe) (Processes.process="*-r:*" OR Processes.process="*-remote:*")  by Processes.dest Processes.user Processes.parent_process_name Processes.process_name  Processes.process Processes.process_id Processes.parent_process_id | `drop_dm_object_name(Processes)`  | `security_content_ctime(firstTime)`| `security_content_ctime(lastTime)` | `remote_process_instantiation_via_winrm_and_winrs_filter`'



<li><a href="#">NAME: Remote Process Instantiation via WMI

DESCRIPTION:  This analytic identifies wmic.exe being launched with parameters to spawn  a process on a remote system. Red Teams and adversaries alike may abuse WMI and  this binary for lateral movement and remote code execution.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where `process_wmic` (Processes.process="*/node:*"  AND Processes.process="*process*" AND Processes.process="*call*" AND  Processes.process="*create*")  by Processes.dest Processes.user Processes.parent_process_name Processes.process_name  Processes.process Processes.process_id Processes.parent_process_id | `drop_dm_object_name(Processes)`  | `security_content_ctime(firstTime)`| `security_content_ctime(lastTime)` | `remote_process_instantiation_via_wmi_filter`'



<li><a href="#">NAME: Remote Process Instantiation via WMI and PowerShell

DESCRIPTION:  This analytic looks for the execution of `powershell.exe` leveraging  the `Invoke-WmiMethod` commandlet complemented with arguments utilized to start  a process on a remote endpoint by abusing WMI. Red Teams and adversaries alike may  abuse WMI and `powershell.exe` for lateral movement and remote code execution.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where `process_powershell` (Processes.process="*Invoke-WmiMethod*"  AND Processes.process="*-CN*" AND Processes.process="*-Class Win32_Process*" AND  Processes.process="*-Name  create*") by Processes.dest Processes.user Processes.parent_process_name Processes.process_name  Processes.process Processes.process_id Processes.parent_process_id | `drop_dm_object_name(Processes)`  | `security_content_ctime(firstTime)`| `security_content_ctime(lastTime)` | `remote_process_instantiation_via_wmi_and_powershell_filter`'



<li><a href="#">NAME: Remote Process Instantiation via WMI and PowerShell Script Block

DESCRIPTION:  The following analytic utilizes PowerShell Script Block Logging (EventCode=4104)  to identify the execution of the `Invoke-WmiMethod` commandlet with arguments utilized  to start a process on a remote endpoint by abusing WMI. Red Teams and adversaries  alike may abuse WMI and this commandlet for lateral movement and remote code execution.

SEARCH:  '`powershell` EventCode=4104 ScriptBlockText="*Invoke-WmiMethod*" AND (ScriptBlockText="*-CN*"  OR ScriptBlockText="*-ComputerName*") AND ScriptBlockText="*-Class Win32_Process*"  AND ScriptBlockText="*-Name create*" | stats count min(_time) as firstTime max(_time)  as lastTime by EventCode ScriptBlockText Computer UserID|  `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `remote_process_instantiation_via_wmi_and_powershell_script_block_filter`'



<li><a href="#">NAME: Remote System Discovery with Adsisearcher

DESCRIPTION:  The following analytic utilizes PowerShell Script Block Logging (EventCode=4104)  to identify the `[Adsisearcher]` type accelerator being used to query Active Directory  for domain computers. Red Teams and adversaries may leverage `[Adsisearcher]` to  enumerate domain computers for situational awareness and Active Directory Discovery.

SEARCH:  '`powershell` EventCode=4104 ScriptBlockText = "*adsisearcher*" AND ScriptBlockText  = "*objectcategory=computer*" AND ScriptBlockText IN ("*findAll()*","*findOne()*")  | stats count min(_time) as firstTime max(_time) as lastTime by EventCode ScriptBlockText  Computer UserID | `security_content_ctime(firstTime)` | `remote_system_discovery_with_adsisearcher_filter`'



<li><a href="#">NAME: Remote System Discovery with Dsquery

DESCRIPTION:  This analytic looks for the execution of `dsquery.exe` with command-line  arguments utilized to discover remote systems. The `computer` argument returns a  list of all computers registered in the domain. Red Teams and adversaries alike  engage in remote system discovery for situational awareness and Active Directory  Discovery.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where (Processes.process_name="dsquery.exe")  (Processes.process="*computer*") by Processes.dest Processes.user Processes.parent_process  Processes.process_name Processes.process Processes.process_id Processes.parent_process_id  | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `remote_system_discovery_with_dsquery_filter`'



<li><a href="#">NAME: Remote System Discovery with Net

DESCRIPTION:  This analytic looks for the execution of `net.exe` or `net1.exe` with  command-line arguments utilized to discover remote systems. The argument `domain  computers /domain` returns a list of all domain computers. Red Teams and adversaries  alike use net.exe to identify remote systems for situational awareness and Active  Directory Discovery.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where (Processes.process_name="net.exe"  OR Processes.process_name="net1.exe") (Processes.process="*domain computers*" AND  Processes.process=*/do*) OR (Processes.process="*view*" AND Processes.process=*/do*)  by Processes.dest Processes.user Processes.parent_process Processes.process_name  Processes.process Processes.process_id Processes.parent_process_id | `drop_dm_object_name(Processes)`  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `remote_system_discovery_with_net_filter`'



<li><a href="#">NAME: Remote System Discovery with Wmic

DESCRIPTION:  This analytic looks for the execution of `wmic.exe` with command-line  arguments utilized to discover remote systems. The arguments utilized in this command  return a list of all the systems registered in the domain. Red Teams and adversaries  alike may leverage WMI and wmic.exe to identify remote systems for situational awareness  and Active Directory Discovery.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where (Processes.process_name="wmic.exe")  (Processes.process=*/NAMESPACE:\\\\root\\directory\\ldap* AND Processes.process=*ds_computer*  AND Processes.process="*GET ds_samaccountname*") by Processes.dest Processes.user  Processes.parent_process Processes.process_name Processes.process Processes.process_id  Processes.parent_process_id | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `remote_system_discovery_with_wmic_filter`'



<li><a href="#">NAME: Remote WMI Command Attempt

DESCRIPTION:  The following analytic identifies usage of `wmic.exe` spawning a local  or remote process, identified by the `node` switch. During triage, review parallel  processes for additional commands executed. Look for any file modifications before  and after `wmic.exe` execution. In addition, identify the remote endpoint and confirm  execution or file modifications. Contain and isolate the endpoint as needed.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where `process_wmic` Processes.process=*node*  by Processes.dest Processes.user Processes.parent_process Processes.process_name  Processes.process Processes.process_id Processes.parent_process_id | `drop_dm_object_name(Processes)`  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `remote_wmi_command_attempt_filter`'



<li><a href="#">NAME: Resize ShadowStorage volume

DESCRIPTION:  The following analytics identifies the resizing of shadowstorage by ransomware  malware to avoid the shadow volumes being made again. this technique is an alternative  by ransomware attacker than deleting the shadowstorage which is known alert in defensive  team. one example of ransomware that use this technique is CLOP ransomware where  it drops a .bat file that will resize the shadowstorage to minimum size as much  as possible

SEARCH:  '| tstats `security_content_summariesonly` values(Processes.process) as cmdline  values(Processes.parent_process_name) as parent_process values(Processes.process_name)  as process_name min(_time) as firstTime max(_time) as lastTime from datamodel=Endpoint.Processes  where Processes.parent_process_name = "cmd.exe" OR Processes.parent_process_name  = "powershell.exe" OR Processes.parent_process_name = "powershell_ise.exe" OR Processes.parent_process_name  =  "wmic.exe" Processes.process_name = "vssadmin.exe" Processes.process="*resize*"  Processes.process="*shadowstorage*" Processes.process="*/maxsize*" by Processes.parent_process_name  Processes.parent_process Processes.process_name Processes.process Processes.dest  Processes.user Processes.process_id Processes.process_guid | `drop_dm_object_name(Processes)`  | `security_content_ctime(firstTime)` |`security_content_ctime(lastTime)` | `resize_shadowstorage_volume_filter`'



<li><a href="#">NAME: Revil Common Exec Parameter

DESCRIPTION:  This analytic identifies suspicious commandline parameter that are commonly  used by REVIL ransomware to encrypts the compromise machine.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.process = "* -nolan  *" OR Processes.process = "* -nolocal *" OR Processes.process = "* -fast *" OR Processes.process  = "* -full *" by Processes.process_name Processes.process Processes.parent_process_name  Processes.parent_process Processes.dest Processes.user Processes.process_id Processes.process_guid  | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `revil_common_exec_parameter_filter`'



<li><a href="#">NAME: Revil Registry Entry

DESCRIPTION:  This analytic identifies suspicious modification in registry entry to  keep some malware data during its infection. This technique seen in several apt  implant, malware and ransomware like REVIL where it keep some information like the  random generated file extension it uses for all the encrypted files and ransomware  notes file name in the compromised host.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) AS firstTime max(_time)  AS lastTime FROM datamodel=Endpoint.Processes BY _time span=1h Processes.user Processes.process_id  Processes.process_name Processes.process Processes.process_path Processes.dest Processes.parent_process_name  Processes.parent_process Processes.process_guid | `drop_dm_object_name(Processes)`  | join process_guid [ | tstats `security_content_summariesonly` count FROM datamodel=Endpoint.Registry  WHERE (Registry.registry_path="*\\SOFTWARE\\WOW6432Node\\Facebook_Assistant\\*"  OR Registry.registry_path="*\\SOFTWARE\\WOW6432Node\\BlackLivesMatter*") BY _time  span=1h Registry.registry_path Registry.registry_key_name Registry.registry_value_name  Registry.registry_value_data Registry.process_guid | `drop_dm_object_name(Registry)`]  | fields firstTime lastTime dest user parent_process_name parent_process process_name  process_path process registry_key_name registry_path registry_value_name registry_value_data  process_guid | where isnotnull(registry_value_data) | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `revil_registry_entry_filter`'



<li><a href="#">NAME: Rubeus Command Line Parameters

DESCRIPTION:  Rubeus is a C# toolset for raw Kerberos interaction and abuses. It is  heavily adapted from Benjamin Delpys Kekeo project and Vincent LE TOUXs MakeMeEnterpriseAdmin  project. This analytic looks for the use of Rubeus command line arguments utilized  in common Kerberos attacks like exporting and importing tickets, forging silver  and golden tickets, requesting a TGT or TGS, kerberoasting, password spraying, etc.  Red teams and adversaries alike use Rubeus for Kerberos attacks within Active Directory  networks. Defenders should be aware that adversaries may customize the source code  of Rubeus and modify the command line parameters. This would effectively bypass  this analytic.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where (Processes.process = "*ptt /ticket*"  OR Processes.process = "* monitor /interval*" OR Processes.process ="* asktgt* /user:*"  OR Processes.process ="* asktgs* /service:*" OR Processes.process ="* golden* /user:*"  OR Processes.process ="* silver* /service:*" OR Processes.process ="* kerberoast*"  OR Processes.process ="* asreproast*" OR Processes.process = "* renew* /ticket:*"  OR Processes.process = "* brute* /password:*" OR Processes.process = "* brute* /passwords:*"  OR Processes.process ="* harvest*") by Processes.dest Processes.user Processes.parent_process  Processes.process_name Processes.process Processes.process_id Processes.parent_process_id  Processes.parent_process_name | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `rubeus_command_line_parameters_filter`'



<li><a href="#">NAME: Rubeus Kerberos Ticket Exports Through Winlogon Access

DESCRIPTION:  The following analytic looks for a process accessing the winlogon.exe  system process. The Splunk Threat Research team identified this behavior when using  the Rubeus tool to monitor for and export kerberos tickets from memory. Before being  able to export tickets. Rubeus will try to escalate privileges to SYSTEM by obtaining  a handle to winlogon.exe before trying to monitor for kerberos tickets. Exporting  tickets from memory is typically the first step for pass the ticket attacks. Red  teams and adversaries alike may use the pass the ticket technique using stolen Kerberos  tickets to move laterally within an environment, bypassing normal system access  controls. Defenders should be aware that adversaries may customize the source code  of Rubeus to potentially bypass this analytic.

SEARCH:  ' `sysmon` EventCode=10 TargetImage=C:\\Windows\\system32\\winlogon.exe (GrantedAccess=0x1f3fff)  (SourceImage!=C:\\Windows\\system32\\svchost.exe AND SourceImage!=C:\\Windows\\system32\\lsass.exe  AND SourceImage!=C:\\Windows\\system32\\LogonUI.exe AND SourceImage!=C:\\Windows\\system32\\smss.exe  AND SourceImage!=C:\\Windows\\system32\\wbem\\wmiprvse.exe) | stats count min(_time)  as firstTime max(_time) as lastTime by dest, SourceImage, SourceProcessId, TargetImage,  TargetProcessId, EventCode, GrantedAccess  | `security_content_ctime(firstTime)`|  `security_content_ctime(lastTime)` | `rubeus_kerberos_ticket_exports_through_winlogon_access_filter`'



<li><a href="#">NAME: Runas Execution in CommandLine

DESCRIPTION:  This analytic look for a spawned runas.exe process with a administrator  user option parameter. This parameter was abused by adversaries, malware author  or even red teams to gain elevated privileges in target host. This is a good hunting  query to figure out privilege escalation tactics that may used for different stages  like lateral movement but take note that administrator may use this command in purpose  so its better to see other event context before and after this analytic.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where `process_runas` AND Processes.process  = "*/user:*" AND Processes.process = "*admin*" by Processes.dest Processes.user  Processes.parent_process_name Processes.parent_process Processes.process_name Processes.process  Processes.process_id Processes.parent_process_id | `drop_dm_object_name(Processes)`  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `runas_execution_in_commandline_filter`'



<li><a href="#">NAME: Rundll32 Control RunDLL Hunt

DESCRIPTION:  The following hunting detection identifies rundll32.exe with `control_rundll`  within the command-line, loading a .cpl or another file type. Developed in relation  to CVE-2021-40444. Rundll32.exe can also be used to execute Control Panel Item files  (.cpl) through the undocumented shell32.dll functions Control_RunDLL and Control_RunDLLAsUser.  Double-clicking a .cpl file also causes rundll32.exe to execute. \ This is written  to be a bit more broad by not including .cpl. \ During triage, review parallel processes  to identify any further suspicious behavior.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where `process_rundll32` Processes.process=*Control_RunDLL*  by  Processes.dest Processes.user Processes.parent_process_name Processes.process_name  Processes.process Processes.process_id Processes.parent_process_id Processes.original_file_name  | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `rundll32_control_rundll_hunt_filter`'



<li><a href="#">NAME: Rundll32 Control RunDLL World Writable Directory

DESCRIPTION:  The following detection identifies rundll32.exe with `control_rundll`  within the command-line, loading a .cpl or another file type from windows\temp,  programdata, or appdata. Developed in relation to CVE-2021-40444. Rundll32.exe can  also be used to execute Control Panel Item files (.cpl) through the undocumented  shell32.dll functions Control_RunDLL and Control_RunDLLAsUser. Double-clicking a  .cpl file also causes rundll32.exe to execute. This is written to be a bit more  broad by not including .cpl. The paths are specified, add more as needed. During  triage, review parallel processes to identify any further suspicious behavior.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where `process_rundll32` Processes.process=*Control_RunDLL*  AND Processes.process IN ("*\\appdata\\*", "*\\windows\\temp\\*", "*\\programdata\\*")  by  Processes.dest Processes.user Processes.parent_process_name Processes.process_name  Processes.process Processes.process_id Processes.parent_process_id Processes.original_file_name  | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `rundll32_control_rundll_world_writable_directory_filter`'



<li><a href="#">NAME: Rundll32 CreateRemoteThread In Browser

DESCRIPTION:  This analytic identifies the suspicious Remote Thread execution of rundll32.exe  process to "firefox.exe" and "chrome.exe" browser. This technique was seen in IcedID  malware where it hooks the browser to parse banking information as user used the  targetted browser process.

SEARCH:  '`sysmon` EventCode=8 SourceImage = "*\\rundll32.exe" TargetImage IN ("*\\firefox.exe",  "*\\chrome.exe", "*\\iexplore.exe","*\\microsoftedgecp.exe") | stats count min(_time)  as firstTime max(_time) as lastTime by SourceImage TargetImage TargetProcessId SourceProcessId  StartAddress EventCode dest | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `rundll32_createremotethread_in_browser_filter`'



<li><a href="#">NAME: Rundll32 Create Remote Thread To A Process

DESCRIPTION:  This analytic identifies the suspicious Remote Thread execution of rundll32.exe  to any process. This technique was seen in IcedID malware to execute its malicious  code in normal process for defense evasion and to steal sensitive information in  the compromised host.

SEARCH:  '`sysmon` EventCode=8 SourceImage = "*\\rundll32.exe" TargetImage = "*.exe"  | stats count min(_time) as firstTime max(_time) as lastTime by SourceImage TargetImage  TargetProcessId SourceProcessId StartAddress EventCode dest | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `rundll32_create_remote_thread_to_a_process_filter`'



<li><a href="#">NAME: Rundll32 DNSQuery

DESCRIPTION:  This search is to detect a suspicious rundll32.exe process having a http  connection and do a dns query in some web domain. This technique was seen in IcedID  malware where the rundll32 that execute its payload will contact amazon.com to check  internet connect and to communicate to its C&C server to download config and other  file component.

SEARCH:  '`sysmon` EventCode=22 process_name="rundll32.exe" | stats count min(_time)  as firstTime max(_time) as lastTime values(query) as query values(answer) as answer values(QueryResults) as query_results values(QueryStatus) as query_status by process_name process_guid Computer | rename Computer as dest  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `rundll32_dnsquery_filter`'



<li><a href="#">NAME: Rundll32 LockWorkStation

DESCRIPTION:  This search is to detect a suspicious rundll32 commandline to lock the  workstation through command line. This technique was seen in CONTI leak tooling  and script as part of its defense evasion. This technique is not a common practice  to lock a screen and maybe a good indicator of compromise.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.process_name=rundll32.exe  Processes.process= "*user32.dll,LockWorkStation*" by Processes.dest Processes.user  Processes.parent_process Processes.process_name Processes.process Processes.process_id  Processes.parent_process_id Processes.parent_process_name | `drop_dm_object_name(Processes)`  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `rundll32_lockworkstation_filter`'



<li><a href="#">NAME: Rundll32 Process Creating Exe Dll Files

DESCRIPTION:  This search is to detect a suspicious rundll32 process that drops executable  (.exe or .dll) files. This behavior seen in rundll32 process of IcedID that tries  to drop copy of itself in temp folder or download executable drop it either appdata  or programdata as part of its execution.

SEARCH:  '`sysmon` EventCode=11 Image="*rundll32.exe" TargetFilename IN ("*.exe", "*.dll") | stats count min(_time) as firstTime max(_time) as lastTime by Image TargetFilename Computer | rename Computer as dest | rename TargetFilename as file_name| `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `rundll32_process_creating_exe_dll_files_filter`'



<li><a href="#">NAME: Rundll32 Shimcache Flush

DESCRIPTION:  This analytic is to detect a suspicious rundll32 commandline to clear  shim cache. This technique is a anti-forensic technique to clear the cache taht  are one important artifacts in terms of digital forensic during attacks or incident.  This TTP is a good indicator that someone tries to evade some tools and clear foothold  on the machine.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where  `process_rundll32` AND Processes.process  = "*apphelp.dll,ShimFlushCache*" by Processes.dest Processes.user Processes.parent_process_name  Processes.process_name Processes.process Processes.process_id Processes.parent_process_id  Processes.original_file_name | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `rundll32_shimcache_flush_filter`'



<li><a href="#">NAME: Rundll32 with no Command Line Arguments with Network

DESCRIPTION:  The following analytic identifies rundll32.exe with no command line arguments  and performing a network connection. It is unusual for rundll32.exe to execute with  no command line arguments present. This particular behavior is common with malicious  software, including Cobalt Strike. During investigation, triage any network connections  and parallel processes. Identify any suspicious module loads related to credential  dumping or file writes. Rundll32.exe is natively found in C:\Windows\system32 and  C:\Windows\syswow64.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime FROM datamodel=Endpoint.Processes where `process_rundll32` AND Processes.action!="blocked"  by host _time span=1h Processes.process_id Processes.process_name Processes.dest  Processes.process_path Processes.process Processes.parent_process_name Processes.parent_process  | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | regex process="(?i)(rundll32\.exe.{0,4}$)" | rename dest as src | join host process_id  [| tstats `security_content_summariesonly` count latest(All_Traffic.dest) as dest  latest(All_Traffic.dest_ip) as dest_ip latest(All_Traffic.dest_port) as dest_port  FROM datamodel=Network_Traffic.All_Traffic where All_Traffic.dest_port != 0 by host  All_Traffic.process_id | `drop_dm_object_name(All_Traffic)`] | `rundll32_with_no_command_line_arguments_with_network_filter`'



<li><a href="#">NAME: RunDLL Loading DLL By Ordinal

DESCRIPTION:  The following analytic identifies rundll32.exe loading an export function  by ordinal value. Adversaries may abuse rundll32.exe to proxy execution of malicious  code. Using rundll32.exe, vice executing directly, may avoid triggering security  tools that may not monitor execution of the rundll32.exe process because of allowlists  or false positives from normal operations. Utilizing ordinal values makes it a bit  more complicated for analysts to understand the behavior until the DLL is reviewed.

SEARCH:  '| tstats `security_content_summariesonly` values(Processes.process) as process  min(_time) as firstTime max(_time) as lastTime from datamodel=Endpoint.Processes  where `process_rundll32` by Processes.dest Processes.user Processes.parent_process_name  Processes.process_name Processes.original_file_name Processes.process Processes.process_id  Processes.parent_process_id | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | where match(process,"rundll32.+\#\d+") |  `rundll_loading_dll_by_ordinal_filter`'



<li><a href="#">NAME: Ryuk Test Files Detected

DESCRIPTION:  The search looks for files that contain the key word *Ryuk* under any  folder in the C drive, which is consistent with Ryuk propagation.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime FROM datamodel=Endpoint.Filesystem WHERE "Filesystem.file_path"=C:\\*Ryuk*  BY "Filesystem.dest", "Filesystem.user", "Filesystem.file_path" | `drop_dm_object_name(Filesystem)`  | `security_content_ctime(lastTime)` | `security_content_ctime(firstTime)` | `ryuk_test_files_detected_filter`'



<li><a href="#">NAME: Ryuk Wake on LAN Command

DESCRIPTION:  This Splunk query identifies the use of Wake-on-LAN utilized by Ryuk  ransomware. The Ryuk Ransomware uses the Wake-on-Lan feature to turn on powered  off devices on a compromised network to have greater success encrypting them. This  is a high fidelity indicator of Ryuk ransomware executing on an endpoint. Upon triage,  isolate the endpoint. Additional file modification events will be within the users  profile (\appdata\roaming) and in public directories (users\public\). Review all  Scheduled Tasks on the isolated endpoint and across the fleet. Suspicious Scheduled  Tasks will include a path to a unknown binary and those endpoints should be isolated  until triaged.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where (Processes.process="*8 LAN*"  OR Processes.process="*9 REP*") by Processes.dest Processes.user Processes.parent_process  Processes.process_name Processes.process Processes.process_id Processes.parent_process_id  | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)`| `security_content_ctime(lastTime)`  | `ryuk_wake_on_lan_command_filter`'



<li><a href="#">NAME: Samsam Test File Write

DESCRIPTION:  The search looks for a file named "test.txt" written to the windows system  directory tree, which is consistent with Samsam propagation.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime values(Filesystem.user) as user values(Filesystem.dest) as dest values(Filesystem.file_name)  as file_name from datamodel=Endpoint.Filesystem where Filesystem.file_path=*\\windows\\system32\\test.txt  by Filesystem.file_path | `drop_dm_object_name(Filesystem)` | `security_content_ctime(lastTime)`  | `security_content_ctime(firstTime)` | `samsam_test_file_write_filter`'



<li><a href="#">NAME: SAM Database File Access Attempt

DESCRIPTION:  The following analytic identifies access to SAM, SYSTEM or SECURITY databases'  within the file path of `windows\system32\config` using Windows Security EventCode  4663. This particular behavior is related to credential access, an attempt to either  use a Shadow Copy or recent CVE-2021-36934 to access the SAM database. The Security  Account Manager (SAM) is a database file in Windows XP, Windows Vista, Windows 7,  8.1 and 10 that stores users' passwords.

SEARCH:  '`wineventlog_security` (EventCode=4663)  process_name!=*\\dllhost.exe Object_Name  IN ("*\\Windows\\System32\\config\\SAM*","*\\Windows\\System32\\config\\SYSTEM*","*\\Windows\\System32\\config\\SECURITY*")  | stats values(Accesses) count by process_name Object_Name  dest user | `sam_database_file_access_attempt_filter`'



<li><a href="#">NAME: SchCache Change By App Connect And Create ADSI Object

DESCRIPTION:  This analytic is to detect an application try to connect and create ADSI  Object to do LDAP query. Every time an application connects to the directory and  attempts to create an ADSI object, the Active Directory Schema is checked for changes.  If it has changed since the last connection, the schema is downloaded and stored  in a cache on the local computer either in %LOCALAPPDATA%\Microsoft\Windows\SchCache  or %systemroot%\SchCache. We found this a good anomaly use case to detect suspicious  application like blackmatter ransomware that use ADS object api to execute ldap  query. having a good list of ldap or normal AD query tool used within the network  is a good start to reduce the noise.

SEARCH:  '`sysmon` EventCode=11  TargetFilename = "*\\Windows\\SchCache\\*" TargetFilename  = "*.sch*" NOT (Image IN ("*\\Windows\\system32\\mmc.exe")) |stats count min(_time)  as firstTime max(_time) as lastTime by Image TargetFilename EventCode process_id  process_name  dest | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `schcache_change_by_app_connect_and_create_adsi_object_filter`'



<li><a href="#">NAME: Scheduled Task Creation on Remote Endpoint using At

DESCRIPTION:  'The following analytic detects the creation of suspicious tasks on a  remote Windows endpoint using the at.exe command with command-line arguments. This  technique is commonly used by red teams and adversaries for lateral movement and  remote code execution. The at.exe binary leverages the deprecated AT protocol, which  may still work on previous versions of Windows. Attackers can enable this protocol  on demand by modifying a system registry key. It is important to consider potential  false positives. While administrators may create scheduled tasks on remote systems,  this activity is typically limited to a small set of hosts or users.\  Identifying the creation of scheduled tasks on remote endpoints is crucial for a  Security Operations Center (SOC) because it indicates potential unauthorized activity  or an attacker attempting to establish persistence or execute malicious code. The  impact of a true positive can be significant, leading to unauthorized access, data  theft, or other damaging outcomes. During triage, investigate the source and purpose  of the scheduled task, inspect relevant on-disk artifacts, and analyze concurrent  processes to identify the extent of the attack and take appropriate response actions.'

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where (Processes.process_name=at.exe  OR Processes.original_file_name=at.exe) (Processes.process=*\\\\*) by Processes.dest  Processes.user Processes.parent_process_name Processes.process_name Processes.process  Processes.process_id Processes.parent_process_id | `drop_dm_object_name(Processes)`  | `security_content_ctime(firstTime)`| `security_content_ctime(lastTime)` | `scheduled_task_creation_on_remote_endpoint_using_at_filter`'



<li><a href="#">NAME: Scheduled Task Deleted Or Created via CMD

DESCRIPTION:  This analytic focuses on identifying the creation or deletion of scheduled  tasks using the schtasks.exe utility with the corresponding command-line flags (-create  or -delete). This technique has been notably associated with threat actors like  Dragonfly and the SUNBURST attack against SolarWinds. The purpose of this analytic  is to detect suspicious activity related to scheduled tasks that could indicate  malicious intent or unauthorized system manipulation. By monitoring for these specific  command-line flags, we can enhance our ability to identify potential threats and  prevent attacks similar to the use of scheduled tasks in the BadRabbit Ransomware  incident.

SEARCH:  '| tstats `security_content_summariesonly` count values(Processes.process)  as process values(Processes.parent_process) as parent_process min(_time) as firstTime  max(_time) as lastTime from datamodel=Endpoint.Processes where Processes.process_name=schtasks.exe  (Processes.process=*delete* OR Processes.process=*create*) by Processes.user Processes.process_name  Processes.parent_process_name Processes.dest | `drop_dm_object_name(Processes)`  | `security_content_ctime(firstTime)`| `security_content_ctime(lastTime)` | `scheduled_task_deleted_or_created_via_cmd_filter` '



<li><a href="#">NAME: Scheduled Task Initiation on Remote Endpoint

DESCRIPTION:  The following analytic detects instances of 'schtasks.exe' being used to start  a Scheduled Task on a remote endpoint. Adversaries often abuse the Task Scheduler  for lateral movement and remote code execution. The search parameters include process  details such as the process  name, parent process, and command-line executions.  Although legitimate administrators may start scheduled tasks on remote systems,  this activity is usually limited to a small set of hosts or users. The findings  from this analytic provide valuable insight into potentially malicious activities  on an endpoint.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where (Processes.process_name=schtasks.exe  OR Processes.original_file_name=schtasks.exe) (Processes.process=*/s* AND Processes.process=*/run*)  by Processes.dest Processes.user Processes.parent_process_name Processes.process_name  Processes.process Processes.process_id Processes.parent_process_id | `drop_dm_object_name(Processes)`  | `security_content_ctime(firstTime)`| `security_content_ctime(lastTime)` | `scheduled_task_initiation_on_remote_endpoint_filter`'



<li><a href="#">NAME: Schedule Task with HTTP Command Arguments

DESCRIPTION:  The following analytic detects the registration of suspicious tasks on Windows using the Windows Security EventCode 4698, "A scheduled task was created." It specifically looks for tasks registered through schtasks.exe or TaskService that have command arguments containing the string "HTTP." This behavior is often associated with malware or attacks that utilize Living off the Land binaries (lolbins) to download additional files or payloads to the compromised machine.\  The search returns information about the task, such as the task name, command, author, enabled status, hidden status, and arguments. Upon triage, it is important to identify the source of the scheduled task, whether it was registered through schtasks.exe or TaskService. Review the details of the created task and the command to be executed. Capture relevant artifacts on disk and examine them. Additionally, identify any parallel processes occurring within the same timeframe to determine the source of the attack.\  Implementing this analytic requires ingesting logs with information about task schedules, specifically Windows Security Log EventCode 4698, from your endpoints. It is recommended to tune and filter known instances of task schedules used in your environment to minimize false positives.\  Detecting the registration of suspicious tasks with HTTP command arguments is valuable for a SOC as it indicates potential malicious activity or an attempt to establish persistence on the system. If a true positive is found, further investigation is warranted to analyze the nature and purpose of the scheduled task, identify any downloaded files or payloads, and mitigate the associated risks. The impact of a true positive can vary but may include data exfiltration, malware propagation, or unauthorized access to sensitive information.

SEARCH:  '`wineventlog_security` EventCode=4698 | xmlkv Message| search Arguments IN  ("*http*") | stats count min(_time) as firstTime max(_time) as lastTime by dest,  Task_Name, Command, Author, Enabled, Hidden, Arguments | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `schedule_task_with_http_command_arguments_filter`'



<li><a href="#">NAME: Schedule Task with Rundll32 Command Trigger

DESCRIPTION:  The following analytic detects the creation of suspicious tasks in Windows, specifically tasks using the rundll32 command. It's implemented using Windows Security EventCode 4698 for A scheduled task was created, and looks for tasks executed either via schtasks.exe or TaskService. This behavior is worth identifying as it is commonly used by malware, such as TrickBot, that leverages rundll32 to execute its downloader.\  If a true positive is found, it suggests an attacker is trying to persist within the environment or potentially deliver additional malicious payloads, leading to data theft, ransomware, or other damaging outcomes.\  To implement this analytic, ensure you are ingesting logs with task schedule information from your endpoints. Be aware of potential false positives - legitimate uses of Task Scheduler in your environment may cause benign activities to be flagged.\  Upon triage, review the scheduled task's source and the command to be executed. Capture and inspect any relevant on-disk artifacts, and look for concurrent processes to identify the attack source. This approach helps analysts detect potential threats earlier and mitigate the risks.

SEARCH:  '`wineventlog_security` EventCode=4698 | xmlkv Message | search Command IN  ("*rundll32*") | stats count min(_time) as firstTime max(_time) as lastTime by dest,  Task_Name, Command, Author, Enabled, Hidden, Arguments | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `schedule_task_with_rundll32_command_trigger_filter`'



<li><a href="#">NAME: Schtasks Run Task On Demand

DESCRIPTION:  The following analytic is designed to detect when a Windows Scheduled  Task is executed on demand via shell or command line. Adversaries often force the  execution of their created Scheduled Tasks for persistent access or lateral movement  within a compromised machine. This analytic is driven by process-related data, specifically  process name, parent process, and command-line executions, sourced from endpoint  logs. The search criteria focus on 'schtasks.exe' with an associated 'run' command.

SEARCH:  '| tstats `security_content_summariesonly` values(Processes.process) as process  values(Processes.process_id) as process_id count min(_time) as firstTime max(_time)  as lastTime  from datamodel=Endpoint.Processes where Processes.process_name = "schtasks.exe"  Processes.process = "*/run*" by Processes.process_name Processes.parent_process_name  Processes.dest Processes.user | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `schtasks_run_task_on_demand_filter`'



<li><a href="#">NAME: Schtasks scheduling job on remote system

DESCRIPTION:  The following analytic is designed to detect suspicious command-line  arguments executed through 'schtasks.exe' to create a scheduled task on a remote  endpoint. The analytic scans process data, checking for instances where 'schtasks.exe'  has been used with specific command-line flags that suggest an attempt at lateral  movement or remote code execution, common techniques employed by adversaries and  red teams. Key data points include the process name, the specific command line used,  the parent process name, the target destination, and the user involved. Also, timestamp  data gives context to when these activities occurred.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where (Processes.process_name = schtasks.exe  OR Processes.original_file_name=schtasks.exe) (Processes.process="*/create*" AND  Processes.process="*/s*") by Processes.process_name Processes.process Processes.parent_process_name  Processes.dest Processes.user | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `schtasks_scheduling_job_on_remote_system_filter`'



<li><a href="#">NAME: Schtasks used for forcing a reboot

DESCRIPTION:  The following analytic utilizes a Splunk query to pinpoint potential  threats by monitoring the 'schtasks.exe' command-line usage. This particular command,  especially when used in tandem with 'shutdown' and '/create' flags, can suggest  an adversarial force intending to schedule unwarranted system reboots. The query  focuses on endpoint process data and retrieves details such as the process name,  the parent process name, the destination, and the user involved. Essential to the  investigation are the earliest and latest timestamps of these events, providing  an activity timeline. Data such as the targeted host and initiating user offer valuable  context for analyst.

SEARCH:  '| tstats `security_content_summariesonly` values(Processes.process) as process  min(_time) as firstTime max(_time) as lastTime from datamodel=Endpoint.Processes  where Processes.process_name=schtasks.exe Processes.process="*shutdown*" Processes.process="*/create  *" by Processes.process_name Processes.parent_process_name Processes.dest Processes.user  | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `schtasks_used_for_forcing_a_reboot_filter`'



<li><a href="#">NAME: Screensaver Event Trigger Execution

DESCRIPTION:  This analytic is developed to detect possible event trigger execution  through screensaver registry entry modification for persistence or privilege escalation.  This technique was seen in several APT and malware where they put the malicious  payload path to the SCRNSAVE.EXE registry key to redirect the execution to their  malicious payload path. This TTP is a good indicator that some attacker may modify  this entry for their persistence and privilege escalation.

SEARCH:  '| tstats `security_content_summariesonly` count  min(_time) as firstTime  max(_time) as lastTime FROM datamodel=Endpoint.Registry where (Registry.registry_path="*\\Control  Panel\\Desktop\\SCRNSAVE.EXE*") by Registry.dest Registry.user Registry.registry_path  Registry.registry_key_name Registry.registry_value_name | `security_content_ctime(lastTime)`  | `security_content_ctime(firstTime)` | `drop_dm_object_name(Registry)` | `screensaver_event_trigger_execution_filter`'



<li><a href="#">NAME: Script Execution via WMI

DESCRIPTION:  |-  The following analytic detects any potential misuse of Windows Management Instrumentation (WMI) for malicious purposes since adversaries often use WMI to run scripts which allows them to carry out malicious activities without raising suspicion. The detection is made by monitoring the process 'scrcons.exe', which is essential to run WMI scripts. The detection is important because it proactively identifies and responds to potential threats that leverage WMI for malicious purposes that can lead to system compromise, data exfiltration, or the establishment of persistence within the environment. False positives might occur since administrators might occasionally use WMI to launch scripts for legitimate purposes. Therefore, you must distinguish between malicious and benign activities.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.process_name=scrcons.exe  by Processes.dest Processes.user Processes.parent_process Processes.process_name  Processes.process Processes.process_id Processes.parent_process_id | `drop_dm_object_name(Processes)`  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `script_execution_via_wmi_filter` '



<li><a href="#">NAME: Sc exe Manipulating Windows Services

DESCRIPTION:  This search looks for arguments to sc.exe indicating the creation or  modification of a Windows service.

SEARCH:  '| tstats `security_content_summariesonly` values(Processes.process) as process  min(_time) as firstTime max(_time) as lastTime from datamodel=Endpoint.Processes  where Processes.process_name = sc.exe (Processes.process="* create *" OR Processes.process="*  config *") by Processes.process_name Processes.parent_process_name Processes.dest  Processes.user | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `sc_exe_manipulating_windows_services_filter`'



<li><a href="#">NAME: Sdclt UAC Bypass

DESCRIPTION:  This search is to detect a suspicious sdclt.exe registry modification.  This technique is commonly seen when attacker try to bypassed UAC by using sdclt.exe  application by modifying some registry that sdclt.exe tries to open or query with  payload file path on it to be executed.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) AS firstTime max(_time)  AS lastTime FROM datamodel=Endpoint.Processes BY _time span=1h Processes.user Processes.process_id  Processes.process_name Processes.process Processes.process_path Processes.dest Processes.parent_process_name  Processes.parent_process Processes.process_guid | `drop_dm_object_name(Processes)`  | join process_guid [ | tstats `security_content_summariesonly` count FROM datamodel=Endpoint.Registry  WHERE ((Registry.registry_path= "*\\Windows\\CurrentVersion\\App Paths\\control.exe*"  OR Registry.registry_path= "*\\exefile\\shell\\runas\\command\\*") (Registry.registry_value_name  = "(Default)" OR Registry.registry_value_name = "IsolatedCommand")) BY _time span=1h  Registry.registry_path Registry.registry_key_name Registry.registry_value_name Registry.registry_value_data  Registry.process_guid | `drop_dm_object_name(Registry)`] | fields firstTime lastTime  dest user parent_process_name parent_process process_name process_path process registry_key_name  registry_path registry_value_name registry_value_data process_guid | where isnotnull(registry_value_data)  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `sdclt_uac_bypass_filter`'



<li><a href="#">NAME: Sdelete Application Execution

DESCRIPTION:  This analytic is to detect the execution of sdelete.exe application sysinternal  tools. This tool is one of the most use tool of malware and adversaries to remove  or clear their tracks and artifact in the targetted host. This tool is designed  to delete securely a file in file system that remove the forensic evidence on the  machine. A good TTP query to check why user execute this application which is not  a common practice.

SEARCH:  '| tstats `security_content_summariesonly` values(Processes.process) as process  values(Processes.parent_process) as parent_process values(Processes.process_id)  as process_id count min(_time) as firstTime max(_time) as lastTime from datamodel=Endpoint.Processes  where `process_sdelete` by  Processes.process_name Processes.original_file_name  Processes.dest Processes.user Processes.parent_process_name Processes.parent_process  | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `sdelete_application_execution_filter`'



<li><a href="#">NAME: SearchProtocolHost with no Command Line with Network

DESCRIPTION:  The following analytic identifies searchprotocolhost.exe with no command  line arguments and with a network connection. It is unusual for searchprotocolhost.exe  to execute with no command line arguments present. This particular behavior is common  with malicious software, including Cobalt Strike. During investigation, identify  any network connections and parallel processes. Identify any suspicious module loads  related to credential dumping or file writes. searchprotocolhost.exe is natively  found in C:\Windows\system32 and C:\Windows\syswow64.

SEARCH:  '| tstats `security_content_summariesonly` count FROM datamodel=Endpoint.Processes  where Processes.process_name=searchprotocolhost.exe by _time span=1h  Processes.process_id  Processes.process_name Processes.dest Processes.process_path Processes.process Processes.parent_process_name  | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | regex process="(?i)(searchprotocolhost\.exe.{0,4}$)" | join  process_id [| tstats  `security_content_summariesonly` count FROM datamodel=Network_Traffic.All_Traffic  where All_Traffic.dest_port != 0 by All_Traffic.process_id All_Traffic.dest All_Traffic.dest_port  | `drop_dm_object_name(All_Traffic)` | rename dest as C2 ] | table _time dest parent_process_name  process_name process_path process process_id dest_port C2 | `searchprotocolhost_with_no_command_line_with_network_filter`'



<li><a href="#">NAME: SecretDumps Offline NTDS Dumping Tool

DESCRIPTION:  The following analytic detects a potential usage of secretsdump.py tool for dumping  credentials (ntlm hash) from a copy of ntds.dit and SAM.Security,SYSTEM registrry  hive. This technique was seen in some attacker that dump ntlm hashes offline after  having a copy of ntds.dit and SAM/SYSTEM/SECURITY registry hive.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.process_name = "python*.exe"  Processes.process = "*.py*" Processes.process = "*-ntds*" (Processes.process = "*-system*"  OR Processes.process = "*-sam*" OR Processes.process = "*-security*" OR Processes.process  = "*-bootkey*") by Processes.process_name Processes.process Processes.parent_process_name  Processes.parent_process Processes.dest Processes.user Processes.process_id Processes.process_guid  | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `secretdumps_offline_ntds_dumping_tool_filter`'



<li><a href="#">NAME: ServicePrincipalNames Discovery with PowerShell

DESCRIPTION:  'The following analytic identifies `powershell.exe` usage, using Script  Block Logging EventCode 4104, related to querying the domain for Service Principle  Names. typically, this is a precursor activity related to kerberoasting or the silver  ticket attack. \  What is a ServicePrincipleName? \  A service principal name (SPN) is a unique identifier of a service instance. SPNs  are used by Kerberos authentication to associate a service instance with a service  logon account. This allows a client application to request that the service authenticate  an account even if the client does not have the account name.\  The following analytic identifies the use of KerberosRequestorSecurityToken class  within the script block. Using .NET System.IdentityModel.Tokens.KerberosRequestorSecurityToken  class in PowerShell is the equivelant of using setspn.exe. \  During triage, review parallel processes for further suspicious activity.'

SEARCH:  '`powershell` EventCode=4104 ScriptBlockText="*KerberosRequestorSecurityToken*"  | stats count min(_time) as firstTime max(_time) as lastTime by ScriptBlockText  Opcode Computer UserID EventCode | rename Computer as dest | rename UserID as user | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `serviceprincipalnames_discovery_with_powershell_filter`'



<li><a href="#">NAME: ServicePrincipalNames Discovery with SetSPN

DESCRIPTION:  'The following analytic identifies `setspn.exe` usage related to querying  the domain for Service Principle Names. typically, this is a precursor activity  related to kerberoasting or the silver ticket attack. \  What is a ServicePrincipleName? \  A service principal name (SPN) is a unique identifier of a service instance. SPNs  are used by Kerberos authentication to associate a service instance with a service  logon account. This allows a client application to request that the service authenticate  an account even if the client does not have the account name.\  Example usage includes the following \  1. setspn -T offense -Q */* 1. setspn -T attackrange.local -F -Q MSSQLSvc/* 1. setspn  -Q */* > allspns.txt 1. setspn -q \  Values \  1. -F = perform queries at the forest, rather than domain level 1. -T = perform  query on the specified domain or forest (when -F is also used) 1. -Q = query for  existence of SPN \  During triage, review parallel processes for further suspicious activity.'

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where `process_setspn` (Processes.process="*-t*"  AND Processes.process="*-f*") OR (Processes.process="*-q*" AND Processes.process="**/**")  OR (Processes.process="*-q*") OR (Processes.process="*-s*") by Processes.dest Processes.user  Processes.parent_process_name Processes.process_name Processes.original_file_name  Processes.process Processes.process_id Processes.parent_process_id | `drop_dm_object_name(Processes)`  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`| `serviceprincipalnames_discovery_with_setspn_filter`'



<li><a href="#">NAME: Services Escalate Exe

DESCRIPTION:  The following analytic identifies the use of `svc-exe` with Cobalt Strike.  The behavior typically follows after an adversary has already gained initial access  and is escalating privileges. Using `svc-exe`, a randomly named binary will be downloaded  from the remote Teamserver and placed on disk within `C:\Windows\400619a.exe`. Following,  the binary will be added to the registry under key `HKLM\System\CurrentControlSet\Services\400619a\`  with multiple keys and values added to look like a legitimate service. Upon loading,  `services.exe` will spawn the randomly named binary from `\\127.0.0.1\ADMIN$\400619a.exe`.  The process lineage is completed with `400619a.exe` spawning rundll32.exe, which  is the default `spawnto_` value for Cobalt Strike. The `spawnto_` value is arbitrary  and may be any process on disk (typically system32/syswow64 binary). The `spawnto_`  process will also contain a network connection. During triage, review parallel procesess  and identify any additional file modifications.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.parent_process_name=services.exe  Processes.process_path=*admin$* by Processes.process_path Processes.dest Processes.user  Processes.parent_process_name Processes.parent_process Processes.process_name Processes.process  Processes.process_id Processes.parent_process_id | `drop_dm_object_name(Processes)`  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `services_escalate_exe_filter`'



<li><a href="#">NAME: Services LOLBAS Execution Process Spawn

DESCRIPTION:  The following analytic identifies `services.exe` spawning a LOLBAS execution  process. When adversaries execute code on remote endpoints abusing the Service Control  Manager and creating a remote malicious service, the executed command is spawned  as a child process of `services.exe`. The LOLBAS project documents Windows native  binaries that can be abused by threat actors to perform tasks like executing malicious  code. Looking for child processes of services.exe that are part of the LOLBAS project  can help defenders identify lateral movement activity.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where (Processes.parent_process_name=services.exe)  (Processes.process_name IN ("Regsvcs.exe", "Ftp.exe", "OfflineScannerShell.exe",  "Rasautou.exe", "Schtasks.exe", "Xwizard.exe", "Dllhost.exe", "Pnputil.exe", "Atbroker.exe",  "Pcwrun.exe", "Ttdinject.exe","Mshta.exe", "Bitsadmin.exe", "Certoc.exe", "Ieexec.exe",  "Microsoft.Workflow.Compiler.exe", "Runscripthelper.exe", "Forfiles.exe", "Msbuild.exe",  "Register-cimprovider.exe", "Tttracer.exe", "Ie4uinit.exe", "Bash.exe", "Hh.exe",  "SettingSyncHost.exe", "Cmstp.exe", "Mmc.exe", "Stordiag.exe", "Scriptrunner.exe",  "Odbcconf.exe", "Extexport.exe", "Msdt.exe", "WorkFolders.exe", "Diskshadow.exe",  "Mavinject.exe", "Regasm.exe", "Gpscript.exe", "Rundll32.exe", "Regsvr32.exe", "Msiexec.exe",  "Wuauclt.exe", "Presentationhost.exe", "Wmic.exe", "Runonce.exe", "Syncappvpublishingserver.exe",  "Verclsid.exe", "Infdefaultinstall.exe", "Explorer.exe", "Installutil.exe", "Netsh.exe",  "Wab.exe", "Dnscmd.exe", "At.exe", "Pcalua.exe", "Msconfig.exe")) by Processes.dest  Processes.user Processes.parent_process Processes.process_name Processes.process  Processes.process_id Processes.parent_process_id | `drop_dm_object_name(Processes)`  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `services_lolbas_execution_process_spawn_filter`'



<li><a href="#">NAME: Set Default PowerShell Execution Policy To Unrestricted or Bypass

DESCRIPTION:  Monitor for changes of the ExecutionPolicy in the registry to the values  "unrestricted" or "bypass," which allows the execution of malicious scripts.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) AS firstTime max(_time)  AS lastTime FROM datamodel=Endpoint.Processes BY _time span=1h Processes.user Processes.process_id  Processes.process_name Processes.process Processes.process_path Processes.dest Processes.parent_process_name  Processes.parent_process Processes.process_guid | `drop_dm_object_name(Processes)`  | join process_guid [ | tstats `security_content_summariesonly` count FROM datamodel=Endpoint.Registry  WHERE (Registry.registry_path=*Software\\Microsoft\\Powershell\\1\\ShellIds\\Microsoft.PowerShell*  Registry.registry_value_name=ExecutionPolicy (Registry.registry_value_data=Unrestricted  OR Registry.registry_value_data=Bypass)) BY _time span=1h Registry.registry_path  Registry.registry_key_name Registry.registry_value_name Registry.registry_value_data  Registry.process_guid | `drop_dm_object_name(Registry)`] | fields firstTime lastTime  dest user parent_process_name parent_process process_name process_path process registry_key_name  registry_path registry_value_name registry_value_data process_guid | where isnotnull(registry_value_data)  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `set_default_powershell_execution_policy_to_unrestricted_or_bypass_filter`'



<li><a href="#">NAME: Shim Database File Creation

DESCRIPTION:  This search looks for shim database files being written to default directories.  The sdbinst.exe application is used to install shim database files (.sdb). According  to Microsoft, a shim is a small library that transparently intercepts an API, changes  the parameters passed, handles the operation itself, or redirects the operation  elsewhere.

SEARCH:  '| tstats `security_content_summariesonly` count values(Filesystem.action)  values(Filesystem.file_hash) as file_hash values(Filesystem.file_path) as file_path  min(_time)  as firstTime max(_time) as lastTime FROM datamodel=Endpoint.Filesystem where Filesystem.file_path=*Windows\\AppPatch\\Custom*  by Filesystem.file_name Filesystem.dest | `security_content_ctime(lastTime)` | `security_content_ctime(firstTime)`  |`drop_dm_object_name(Filesystem)` | `shim_database_file_creation_filter`'



<li><a href="#">NAME: Shim Database Installation With Suspicious Parameters

DESCRIPTION:  This search detects the process execution and arguments required to silently  create a shim database.  The sdbinst.exe application is used to install shim database  files (.sdb). A shim is a small library which transparently intercepts an API, changes  the parameters passed, handles the operation itself, or redirects the operation  elsewhere.

SEARCH:  '| tstats `security_content_summariesonly` values(Processes.process) as process  min(_time) as firstTime max(_time) as lastTime from datamodel=Endpoint.Processes  where Processes.process_name = sdbinst.exe by Processes.process_name Processes.parent_process_name  Processes.dest Processes.user | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `shim_database_installation_with_suspicious_parameters_filter`'



<li><a href="#">NAME: Short Lived Scheduled Task

DESCRIPTION:  'The following analytic utilizes Windows Security EventCode 4698, "A  scheduled task was created," and EventCode 4699, "A scheduled task was deleted,"  to identify scheduled tasks that are created and deleted within a short time frame  of less than 30 seconds. This behavior is indicative of a potential lateral movement  attack where the Task Scheduler is abused to achieve code execution. Both red teams  and adversaries may exploit the Task Scheduler for lateral movement and remote code  execution.\  To implement this analytic, ensure that you are ingesting Windows Security Event  Logs with EventCode 4698 enabled. Additionally, the Windows TA (Technology Add-on)  is required to parse and extract the necessary information from the logs.\  It''s important to note that while uncommon, legitimate applications may create  and delete scheduled tasks within a short duration. Analysts should filter the results  based on the specific context and environment to reduce false positives.\  Identifying short-lived scheduled tasks is valuable for a SOC as it can indicate  malicious activities attempting to move laterally or execute unauthorized code on  Windows systems. By detecting and investigating these events, security analysts  can respond promptly to prevent further compromise and mitigate potential risks.  The impact of a true positive could range from unauthorized access to data exfiltration  or the execution of malicious payloads.'

SEARCH:  ' `wineventlog_security` EventCode=4698 OR EventCode=4699 | xmlkv Message  | transaction Task_Name  startswith=(EventCode=4698) endswith=(EventCode=4699) |  eval short_lived=case((duration<30),"TRUE") | search  short_lived = TRUE | rename  ComputerName as dest| table _time, dest, Account_Name, Command, Task_Name, short_lived  | `short_lived_scheduled_task_filter` '



<li><a href="#">NAME: Short Lived Windows Accounts

DESCRIPTION:  |-  The following analytic detects the creation and deletion of accounts in a short time period to identify potential threats earlier and take appropriate actions to mitigate the risks. Helps prevent or minimize the potential damage caused by unauthorized access or malicious activities within the environment. This detection is made by a Splunk query that searches for events with the result IDs 4720 and 4726 in the "Change" data model. The query then groups the results by time, user, and destination. The result is filtered to only include events with the specified result IDs. The "transaction" command is used to group events that occur within a specified time span and have the same user but are not connected. Finally, the relevant information such as the first and last time of the event, the count, user, destination, and result ID are displayed in a table. This detection is important because it suggests that an attacker is attempting to create and delete accounts rapidly, potentially to cover their tracks or gain unauthorized access. The impact of such an attack can include unauthorized access to sensitive data, privilege escalation, or the ability to carry out further malicious activities within the environment. Next steps include investigating the events flagged by the analytic, review the account creation and deletion activities, and analyze any associated logs or artifacts to determine the intent and impact of the attack.

SEARCH:  '| tstats `security_content_summariesonly` values(All_Changes.result_id) as  result_id count min(_time) as firstTime max(_time) as lastTime from datamodel=Change  where All_Changes.result_id=4720 OR All_Changes.result_id=4726 by _time span=4h  All_Changes.user All_Changes.dest | `security_content_ctime(lastTime)` | `security_content_ctime(firstTime)`  | `drop_dm_object_name("All_Changes")` | search result_id = 4720 result_id=4726  | transaction user connected=false maxspan=240m | table firstTime lastTime count  user dest result_id | `short_lived_windows_accounts_filter`'



<li><a href="#">NAME: SilentCleanup UAC Bypass

DESCRIPTION:  This search is to detect a suspicious modification of registry that may  related to UAC bypassed. This registry will be trigger once the attacker abuse the  silentcleanup task schedule to gain high privilege execution that will bypass User  control account.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) AS firstTime max(_time)  AS lastTime FROM datamodel=Endpoint.Processes BY _time span=1h Processes.user Processes.process_id  Processes.process_name Processes.process Processes.process_path Processes.dest Processes.parent_process_name  Processes.parent_process Processes.process_guid | `drop_dm_object_name(Processes)`  | join process_guid [ | tstats `security_content_summariesonly` count FROM datamodel=Endpoint.Registry  WHERE (Registry.registry_path= "*\\Environment\\windir" Registry.registry_value_data  = "*.exe*") BY _time span=1h Registry.registry_path Registry.registry_key_name Registry.registry_value_name  Registry.registry_value_data Registry.process_guid | `drop_dm_object_name(Registry)`]  | fields firstTime lastTime dest user parent_process_name parent_process process_name  process_path process registry_key_name registry_path registry_value_name registry_value_data  process_guid | where isnotnull(registry_value_data) | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `silentcleanup_uac_bypass_filter`'



<li><a href="#">NAME: Single Letter Process On Endpoint

DESCRIPTION:  |-  The following analytic detects a behavior where a process name consists only of a single letter that helps to detect potential threats earlier and mitigate the risks. This detection is important because it indicates the presence of malware or an attacker attempting to evade detection by using a process name that is difficult to identify or track so that he can carry out malicious activities such as data theft or ransomware attacks. False positives might occur since there might be legitimate uses of single-letter process names in your environment. Next steps include reviewing the process details and investigating any suspicious activity upon triage.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes by Processes.dest, Processes.user,  Processes.process, Processes.process_name | `drop_dm_object_name(Processes)` | `security_content_ctime(lastTime)`  | `security_content_ctime(firstTime)` | eval process_name_length = len(process_name),  endExe = if(substr(process_name, -4) == ".exe", 1, 0) | search process_name_length=5  AND endExe=1 | table count, firstTime, lastTime, dest, user, process, process_name  | `single_letter_process_on_endpoint_filter`'



<li><a href="#">NAME: SLUI RunAs Elevated

DESCRIPTION:  The following analytic identifies the Microsoft Software Licensing User  Interface Tool, `slui.exe`, elevating access using the `-verb runas` function. This  particular bypass utilizes a registry key/value. Identified by two sources, the  registry keys are `HKCU\Software\Classes\exefile\shell` and `HKCU\Software\Classes\launcher.Systemsettings\Shell\open\command`.  To simulate this behavior, multiple POC are available. The analytic identifies the  use of `runas` by `slui.exe`.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.process_name=slui.exe  (Processes.process=*-verb* Processes.process=*runas*) by Processes.dest Processes.user  Processes.parent_process Processes.process_name Processes.process Processes.process_id  Processes.parent_process_id | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `slui_runas_elevated_filter`'



<li><a href="#">NAME: SLUI Spawning a Process

DESCRIPTION:  The following analytic identifies the Microsoft Software Licensing User  Interface Tool, `slui.exe`, spawning a child process. This behavior is associated  with publicly known UAC bypass. `slui.exe` is commonly associated with software  updates and is most often spawned by `svchost.exe`. The `slui.exe` process should  not have child processes, and any processes spawning from it will be running with  elevated privileges. During triage, review the child process and additional parallel  processes. Identify any file modifications that may have lead to the bypass.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.parent_process_name=slui.exe  by Processes.dest Processes.user Processes.parent_process Processes.process_name  Processes.process Processes.process_id Processes.parent_process_id | `drop_dm_object_name(Processes)`  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `slui_spawning_a_process_filter`'



<li><a href="#">NAME: SMB Traffic Spike

DESCRIPTION:  |-  The following analytic detects spikes in the number of Server Message Block (SMB) traffic connections. SMB is a network protocol used for sharing files, printers, and other resources between computers. This detection is made by a Splunk query that looks for SMB traffic connections on ports 139 and 445, as well as connections using the SMB application. The query calculates the average and standard deviation of the number of SMB connections over the past 70 minutes, and identifies any sources that exceed two standard deviations from the average. This helps to filter out false positives caused by normal fluctuations in SMB traffic. This detection is important because it identifies potential SMB-based attacks, such as ransomware or data theft, which often involve a large number of SMB connections. This  suggests that an attacker is attempting to exfiltrate data or spread malware within the network. Next steps include investigating the source of the traffic and determining if it is malicious. This can involve reviewing network logs, capturing and analyzing any relevant network packets, and correlating with other security events to identify the attack source and mitigate the risk.

SEARCH:  '| tstats `security_content_summariesonly` count from datamodel=Network_Traffic  where All_Traffic.dest_port=139 OR All_Traffic.dest_port=445 OR All_Traffic.app=smb  by _time span=1h, All_Traffic.src | `drop_dm_object_name("All_Traffic")` | eventstats  max(_time) as maxtime | stats count as num_data_samples max(eval(if(_time >= relative_time(maxtime,  "-70m@m"), count, null))) as count avg(eval(if(_time<relative_time(maxtime, "-70m@m"),  count, null))) as avg stdev(eval(if(_time<relative_time(maxtime, "-70m@m"), count,  null))) as stdev by src | eval upperBound=(avg+stdev*2), isOutlier=if(count > upperBound  AND num_data_samples >=50, 1, 0) | where isOutlier=1 | table src count | `smb_traffic_spike_filter` '



<li><a href="#">NAME: SMB Traffic Spike - MLTK

DESCRIPTION:  This search uses the Machine Learning Toolkit (MLTK) to identify spikes  in the number of Server Message Block (SMB) connections.

SEARCH:  '| tstats `security_content_summariesonly` count values(All_Traffic.dest_ip)  as dest values(All_Traffic.dest_port) as port from datamodel=Network_Traffic where  All_Traffic.dest_port=139 OR All_Traffic.dest_port=445 OR All_Traffic.app=smb by  _time span=1h, All_Traffic.src | eval HourOfDay=strftime(_time, "%H") | eval DayOfWeek=strftime(_time,  "%A") | `drop_dm_object_name(All_Traffic)` | apply smb_pdfmodel threshold=0.001  | rename "IsOutlier(count)" as isOutlier | search isOutlier > 0 | sort -count |  table _time src dest port count | `smb_traffic_spike___mltk_filter` '



<li><a href="#">NAME: Spike in File Writes

DESCRIPTION:  The search looks for a sharp increase in the number of files written  to a particular host

SEARCH:  '| tstats `security_content_summariesonly` count FROM datamodel=Endpoint.Filesystem  where Filesystem.action=created by _time span=1h, Filesystem.dest | `drop_dm_object_name(Filesystem)`  | eventstats max(_time) as maxtime | stats count as num_data_samples max(eval(if(_time  >= relative_time(maxtime, "-1d@d"), count, null))) as "count" avg(eval(if(_time<relative_time(maxtime,  "-1d@d"), count,null))) as avg stdev(eval(if(_time<relative_time(maxtime, "-1d@d"),  count, null))) as stdev by "dest" | eval upperBound=(avg+stdev*4), isOutlier=if((count  > upperBound) AND num_data_samples >=20, 1, 0) | search isOutlier=1 | `spike_in_file_writes_filter` '



<li><a href="#">NAME: Splunk Identified SSL TLS Certificates

DESCRIPTION:  The following analytic uses tags of SSL, TLS and certificate to identify  the usage of the Splunk default certificates being utilized in the environment.  Recommended guidance is to utilize valid TLS certificates which documentation may  be found in Splunk Docs - https://docs.splunk.com/Documentation/Splunk/8.2.6/Security/AboutsecuringyourSplunkconfigurationwithSSL.

SEARCH:  tag IN (ssl, tls, certificate) ssl_issuer_common_name=*splunk* | stats values(src)  AS "Host(s) with Default Cert" count by ssl_issuer ssl_subject_common_name ssl_subject_organization  ssl_subject host sourcetype | `splunk_identified_ssl_tls_certificates_filter`



<li><a href="#">NAME: Spoolsv Spawning Rundll32

DESCRIPTION:  The following analytic identifies a suspicious child process, `rundll32.exe`,  with no command-line arguments being spawned from `spoolsv.exe`. This was identified  during our testing of CVE-2021-34527 previously (CVE-2021-1675) or PrintNightmare.  Typically, this is not normal behavior for `spoolsv.exe` to spawn a process. During  triage, isolate the endpoint and review for source of exploitation. Capture any  additional file modification events.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.parent_process_name=spoolsv.exe  `process_rundll32` by Processes.dest Processes.user Processes.parent_process_name Processes.original_file_name  Processes.process_name Processes.process Processes.process_id Processes.parent_process_id  | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `spoolsv_spawning_rundll32_filter`'



<li><a href="#">NAME: Spoolsv Suspicious Loaded Modules

DESCRIPTION:  This search is to detect suspicious loading of dll in specific path relative  to printnightmare exploitation. In this search we try to detect the loaded modules  made by spoolsv.exe after the exploitation.

SEARCH:  '`sysmon` EventCode=7 Image ="*\\spoolsv.exe" ImageLoaded="*\\Windows\\System32\\spool\\drivers\\x64\\*"  ImageLoaded = "*.dll" | stats dc(ImageLoaded) as countImgloaded values(ImageLoaded)  as ImgLoaded count min(_time) as firstTime max(_time) as lastTime by Image Computer  ProcessId EventCode | rename Computer as dest | where countImgloaded >= 3 | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `spoolsv_suspicious_loaded_modules_filter`'



<li><a href="#">NAME: Spoolsv Suspicious Process Access

DESCRIPTION:  This analytic identifies a suspicious behavior related to PrintNightmare,  or CVE-2021-34527 previously (CVE-2021-1675),  to gain privilege escalation on the  vulnerable machine. This exploit attacks a critical Windows Print Spooler Vulnerability  to elevate privilege. This detection is to look for suspicious process access made  by the spoolsv.exe that may related to the attack.

SEARCH:  '`sysmon` EventCode=10 SourceImage = "*\\spoolsv.exe" CallTrace = "*\\Windows\\system32\\spool\\DRIVERS\\x64\\*"  TargetImage IN ("*\\rundll32.exe", "*\\spoolsv.exe") GrantedAccess = 0x1fffff |  stats  count min(_time) as firstTime max(_time) as lastTime by dest SourceImage  TargetImage GrantedAccess CallTrace  EventCode ProcessID| `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `spoolsv_suspicious_process_access_filter`'



<li><a href="#">NAME: Spoolsv Writing a DLL

DESCRIPTION:  The following analytic identifies a `.dll` being written by `spoolsv.exe`.  This was identified during our testing of CVE-2021-34527 previously (CVE-2021-1675)  or PrintNightmare. Typically, this is not normal behavior for `spoolsv.exe` to write  a `.dll`. Current POC code used will write the suspicious DLL to disk within a path  of `\spool\drivers\x64\`. During triage, isolate the endpoint and review for source  of exploitation. Capture any additional file modification events.

SEARCH:  '| tstats `security_content_summariesonly` count FROM datamodel=Endpoint.Processes  where Processes.process_name=spoolsv.exe by _time Processes.process_guid Processes.process_name  Processes.dest | `drop_dm_object_name(Processes)` | join process_guid, _time [|  tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime FROM datamodel=Endpoint.Filesystem where Filesystem.file_path="*\\spool\\drivers\\x64\\*"  Filesystem.file_name="*.dll" by _time Filesystem.dest Filesystem.process_guid Filesystem.file_create_time  Filesystem.file_name Filesystem.file_path | `drop_dm_object_name(Filesystem)` |  fields _time dest file_create_time file_name file_path process_name process_path process_guid  process] | dedup file_create_time | table  dest file_create_time, file_name, file_path,  process_name process_guid | `spoolsv_writing_a_dll_filter`'



<li><a href="#">NAME: Spoolsv Writing a DLL - Sysmon

DESCRIPTION:  The following analytic identifies a `.dll` being written by `spoolsv.exe`.  This was identified during our testing of CVE-2021-34527 previously(CVE-2021-1675)  or PrintNightmare. Typically, this is not normal behavior for `spoolsv.exe` to write  a `.dll`. Current POC code used will write the suspicious DLL to disk within a path  of `\spool\drivers\x64\`. During triage, isolate the endpoint and review for source  of exploitation. Capture any additional file modification events.

SEARCH:  '`sysmon` EventID=11 process_name=spoolsv.exe file_path="*\\spool\\drivers\\x64\\*"  file_name=*.dll | stats count min(_time) as firstTime max(_time) as lastTime by  dest, UserID, process_name, file_path, file_name, TargetFilename, process_id | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `spoolsv_writing_a_dll___sysmon_filter`'



<li><a href="#">NAME: Sqlite Module In Temp Folder

DESCRIPTION:  This search is to detect a suspicious file creation of sqlite3.dll in  %temp% folder. This behavior was seen in IcedID malware where it download sqlite  module to parse browser database like for chrome or firefox to stole browser information  related to bank, credit card or credentials.

SEARCH:  '`sysmon` EventCode=11 (TargetFilename = "*\\sqlite32.dll" OR TargetFilename    = "*\\sqlite64.dll") (TargetFilename = "*\\temp\\*") | stats count min(_time) as    firstTime max(_time) as lastTime by dest signature signature_id process_name file_name file_path action process_guid| `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `sqlite_module_in_temp_folder_filter`'



<li><a href="#">NAME: SSL Certificates with Punycode

DESCRIPTION:  The following analytic utilizes the Certificates Datamodel to look for  punycode domains, starting with xn--, found in the SSL issuer email domain. The  presence of punycode here does not equate to evil, therefore we need to decode the  punycode to determine what it translates to. Remove the CyberChef recipe as needed  and decode manually. Note that this is not the exact location of the malicious punycode  to trip CVE-2022-3602, but a method to at least identify fuzzing occurring on these  email paths. What does evil look like? it will start with

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Certificates.All_Certificates by All_Certificates.SSL.ssl_issuer_email_domain  All_Certificates.SSL.ssl_issuer All_Certificates.SSL.ssl_subject_email All_Certificates.SSL.dest  All_Certificates.SSL.src All_Certificates.SSL.sourcetype All_Certificates.SSL.ssl_subject_email_domain  | `drop_dm_object_name("All_Certificates.SSL")` | eval punycode=if(like(ssl_issuer_email_domain,"%xn--%"),1,0)  | where punycode=1 | cyberchef infield="ssl_issuer_email_domain" outfield="convertedPuny"  jsonrecipe="[{"op":"From Punycode","args":[true]}]" | table ssl_issuer_email_domain  convertedPuny ssl_issuer ssl_subject_email dest src sourcetype ssl_subject_email_domain  | `ssl_certificates_with_punycode_filter`'



<li><a href="#">NAME: Steal or Forge Authentication Certificates Behavior Identified

DESCRIPTION:  This correlation rule focuses on detecting potential threats associated with MITRE ATT&CK T1649 (Steal or Forge Authentication Certificates). The rule is designed to identify instances where 5 or more analytics related to Windows Certificate Services analytic story that are triggered within a specified time frame, which may indicate a potential attack in progress. By aggregating these analytics, security teams can swiftly respond to and investigate any suspicious activities, enhancing their ability to protect critical assets and prevent unauthorized access to sensitive information.

SEARCH:  '| tstats `security_content_summariesonly` min(_time) as firstTime max(_time) as lastTime sum(All_Risk.calculated_risk_score) as risk_score, count(All_Risk.calculated_risk_score) as risk_event_count, values(All_Risk.annotations.mitre_attack.mitre_tactic_id) as annotations.mitre_attack.mitre_tactic_id, dc(All_Risk.annotations.mitre_attack.mitre_tactic_id) as mitre_tactic_id_count, values(All_Risk.annotations.mitre_attack.mitre_technique_id) as annotations.mitre_attack.mitre_technique_id, dc(All_Risk.annotations.mitre_attack.mitre_technique_id) as mitre_technique_id_count, values(All_Risk.tag) as tag, values(source) as source, dc(source) as source_count from datamodel=Risk.All_Risk where All_Risk.analyticstories="Windows Certificate Services" All_Risk.risk_object_type="system" by All_Risk.risk_object All_Risk.risk_object_type All_Risk.annotations.mitre_attack.mitre_tactic   | `drop_dm_object_name(All_Risk)`   | `security_content_ctime(firstTime)`   | `security_content_ctime(lastTime)`   | where source_count >= 5 | `steal_or_forge_authentication_certificates_behavior_identified_filter`'



<li><a href="#">NAME: Sunburst Correlation DLL and Network Event

DESCRIPTION:  The malware sunburst will load the malicious dll by SolarWinds.BusinessLayerHost.exe.  After a period of 12-14 days, the malware will attempt to resolve a subdomain of  avsvmcloud.com. This detections will correlate both events.

SEARCH:  '(`sysmon` EventCode=7 ImageLoaded=*SolarWinds.Orion.Core.BusinessLayer.dll)  OR (`sysmon` EventCode=22 QueryName=*avsvmcloud.com) | eventstats dc(EventCode)  AS dc_events | where dc_events=2 | stats min(_time) as firstTime max(_time) as lastTime  values(ImageLoaded) AS ImageLoaded values(QueryName) AS QueryName by host | rename  host as dest | `security_content_ctime(firstTime)`| `security_content_ctime(lastTime)`  | `sunburst_correlation_dll_and_network_event_filter` '



<li><a href="#">NAME: Suspicious Computer Account Name Change

DESCRIPTION:  As part of the sAMAccountName Spoofing (CVE-2021-42278) and Domain Controller  Impersonation (CVE-2021-42287) exploitation chain, adversaries need to create a  new computer account name and rename it to match the name of a domain controller  account without the ending '$'. In Windows Active Directory environments, computer  account names always end with `$`. This analytic leverages Event Id 4781, `The name  of an account was changed`, to identify a computer account rename event with a suspicious  name that does not terminate with `$`. This behavior could represent an exploitation  attempt of CVE-2021-42278 and CVE-2021-42287 for privilege escalation.

SEARCH:  '`wineventlog_security` EventCode=4781 Old_Account_Name="*$" New_Account_Name!="*$"  | table _time, ComputerName, Account_Name, Old_Account_Name, New_Account_Name |  `suspicious_computer_account_name_change_filter`'



<li><a href="#">NAME: Suspicious Copy on System32

DESCRIPTION:  This analytic is to detect a suspicious copy of file from systemroot  folder of the windows OS. This technique is commonly used by APT or other malware  as part of execution (LOLBIN) to run its malicious code using the available legitimate  tool in OS. this type of event may seen or may execute of normal user in some instance  but this is really a anomaly that needs to be check within the network.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.parent_process_name  IN("cmd.exe", "powershell*","pwsh.exe", "sqlps.exe", "sqltoolsps.exe", "powershell_ise.exe")  AND `process_copy` AND Processes.process IN("*\\Windows\\System32\\*", "*\\Windows\\SysWow64\\*")  AND Processes.process = "*copy*" by Processes.dest Processes.user Processes.parent_process_name  Processes.process_name Processes.process Processes.process_id Processes.parent_process_id  temp | `drop_dm_object_name(Processes)` | eval splitted_commandline=split(process,"  ") | eval first_cmdline=lower(mvindex(splitted_commandline,0)) | where NOT LIKE(first_cmdline,"%\\windows\\system32\\%")  AND NOT LIKE(first_cmdline,"%\\windows\\syswow64\\%") | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` |`suspicious_copy_on_system32_filter`'



<li><a href="#">NAME: Suspicious Curl Network Connection

DESCRIPTION:  The following analytic identifies the use of a curl contacting suspicious  remote domains to checkin to Command And Control servers or download further implants.  In the context of Silver Sparrow, curl is identified contacting s3.amazonaws.com.  This particular behavior is common with MacOS adware-malicious software.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.process_name=curl  Processes.process=s3.amazonaws.com by Processes.dest Processes.user Processes.parent_process  Processes.process_name Processes.process Processes.process_id Processes.parent_process_id  | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)`| `security_content_ctime(lastTime)`  | `suspicious_curl_network_connection_filter`'



<li><a href="#">NAME: Suspicious DLLHost no Command Line Arguments

DESCRIPTION:  The following analytic identifies DLLHost.exe with no command line arguments.  It is unusual for DLLHost.exe to execute with no command line arguments present.  This particular behavior is common with malicious software, including Cobalt Strike.  During investigation, identify any network connections and parallel processes. Identify  any suspicious module loads related to credential dumping or file writes. DLLHost.exe  is natively found in C:\Windows\system32 and C:\Windows\syswow64.

SEARCH:  '| tstats `security_content_summariesonly` count FROM datamodel=Endpoint.Processes  where `process_dllhost` by _time span=1h  Processes.process_id Processes.process_name  Processes.dest Processes.user Processes.process_path Processes.process Processes.parent_process_name  | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | regex process="(?i)(dllhost\.exe.{0,4}$)" | `suspicious_dllhost_no_command_line_arguments_filter`'



<li><a href="#">NAME: Suspicious Driver Loaded Path

DESCRIPTION:  This analytic will detect suspicious driver loaded paths. This technique  is commonly used by malicious software like coin miners (xmrig) to register its  malicious driver from notable directories where executable or drivers do not commonly  exist. During triage, validate this driver is for legitimate business use. Review  the metadata and certificate information. Unsigned drivers from non-standard paths  is not normal, but occurs. In addition, review driver loads into `ntoskrnl.exe`  for possible other drivers of interest. Long tail analyze drivers by path (outside  of default, and in default) for further review.

SEARCH:  '`sysmon` EventCode=6 ImageLoaded = "*.sys" NOT (ImageLoaded IN("*\\WINDOWS\\inf","*\\WINDOWS\\System32\\drivers\\*",  "*\\WINDOWS\\System32\\DriverStore\\FileRepository\\*")) |  stats  min(_time) as  firstTime max(_time) as lastTime count by dest ImageLoaded Hashes IMPHASH Signature  Signed| rename ImageLoaded as file_name | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `suspicious_driver_loaded_path_filter`'



<li><a href="#">NAME: Suspicious Event Log Service Behavior

DESCRIPTION:  The following analytic utilizes Windows Event ID 1100 to identify when  Windows event log service is shutdown. Note that this is a voluminous analytic that  will require tuning or restricted to specific endpoints based on criticality. This  event generates every time Windows Event Log service has shut down. It also generates  during normal system shutdown. During triage, based on time of day and user, determine  if this was planned. If not planned, follow through with reviewing parallel alerts  and other data sources to determine what else may have occurred.

SEARCH:  (`wineventlog_security` EventCode=1100) | stats count min(_time) as firstTime  max(_time) as lastTime by dest Message EventCode | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `suspicious_event_log_service_behavior_filter`



<li><a href="#">NAME: Suspicious GPUpdate no Command Line Arguments

DESCRIPTION:  The following analytic identifies gpupdate.exe with no command line arguments.  It is unusual for gpupdate.exe to execute with no command line arguments present.  This particular behavior is common with malicious software, including Cobalt Strike.  During investigation, identify any network connections and parallel processes. Identify  any suspicious module loads related to credential dumping or file writes. gpupdate.exe  is natively found in C:\Windows\system32 and C:\Windows\syswow64.

SEARCH:  '| tstats `security_content_summariesonly` count FROM datamodel=Endpoint.Processes  where `process_gpupdate` by _time span=1h  Processes.process_id Processes.process_name  Processes.dest Processes.user Processes.process_path Processes.process Processes.parent_process_name  | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | regex process="(?i)(gpupdate\.exe.{0,4}$)" | `suspicious_gpupdate_no_command_line_arguments_filter`'



<li><a href="#">NAME: Suspicious IcedID Rundll32 Cmdline

DESCRIPTION:  This search is to detect a suspicious rundll32.exe commandline to execute  dll file. This technique was seen in IcedID malware to load its payload dll with  the following parameter to load encrypted dll payload which is the license.dat.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where `process_rundll32` Processes.process=*/i:*  by  Processes.process_name Processes.process Processes.parent_process_name Processes.parent_process  Processes.process_id Processes.parent_process_id Processes.dest Processes.user |  `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `suspicious_icedid_rundll32_cmdline_filter`'



<li><a href="#">NAME: Suspicious Image Creation In Appdata Folder

DESCRIPTION:  This search is to detect a suspicious creation of image in appdata folder  made by process that also has a file reference in appdata folder. This technique  was seen in remcos rat that capture screenshot of the compromised machine and place  it in the appdata and will be send to its C2 server. This TTP is really a good indicator  to check that process because it is in suspicious folder path and image files are  not commonly created by user in this folder path.

SEARCH:  '| tstats `security_content_summariesonly` count FROM datamodel=Endpoint.Processes  where Processes.process_name=*.exe Processes.process_path="*\\appdata\\Roaming\\*"  by _time span=1h Processes.process_id Processes.process_name Processes.process Processes.dest  Processes.process_guid | `drop_dm_object_name(Processes)` |rename process_guid as  proc_guid |join proc_guid, _time [| tstats `security_content_summariesonly` count  min(_time) as firstTime max(_time) as lastTime FROM datamodel=Endpoint.Filesystem  where Filesystem.file_name IN ("*.png","*.jpg","*.bmp","*.gif","*.tiff") Filesystem.file_path=  "*\\appdata\\Roaming\\*" by _time span=1h Filesystem.dest Filesystem.file_create_time  Filesystem.file_name Filesystem.file_path Filesystem.process_guid | `drop_dm_object_name(Filesystem)`  |rename process_guid as proc_guid | fields _time dest file_create_time file_name  file_path process_name process_path process proc_guid] | `suspicious_image_creation_in_appdata_folder_filter`'



<li><a href="#">NAME: Suspicious Kerberos Service Ticket Request

DESCRIPTION:  As part of the sAMAccountName Spoofing (CVE-2021-42278) and Domain Controller  Impersonation (CVE-2021-42287) exploitation chain, adversaries will request and  obtain a Kerberos Service Ticket (TGS) with a domain controller computer account  as the Service Name. This Service Ticket can be then used to take control of the  domain controller on the final part of the attack. This analytic leverages Event  Id 4769, `A Kerberos service ticket was requested`, to identify an unusual TGS request  where the Account_Name requesting the ticket matches the Service_Name field. This  behavior could represent an exploitation attempt of CVE-2021-42278 and CVE-2021-42287  for privilege escalation.

SEARCH:  ' `wineventlog_security` EventCode=4769 | eval isSuspicious = if(lower(Service_Name)  = lower(mvindex(split(Account_Name,"@"),0)+"$"),1,0) | where isSuspicious = 1 | rename ComputerName as dest| rename Account_Name as user  |  table _time, dest, Client_Address, Account_Name, Service_Name, Failure_Code, isSuspicious  | `suspicious_kerberos_service_ticket_request_filter`'



<li><a href="#">NAME: Suspicious microsoft workflow compiler rename

DESCRIPTION:  The following analytic identifies a renamed instance of microsoft.workflow.compiler.exe.  Microsoft.workflow.compiler.exe is natively found in C:\Windows\Microsoft.NET\Framework64\v4.0.30319  and is rarely utilized. When investigating, identify the executed code on disk and  review. A spawned child process from microsoft.workflow.compiler.exe is uncommon.  In any instance, microsoft.workflow.compiler.exe spawning from an Office product  or any living off the land binary is highly suspect.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.process_name!=microsoft.workflow.compiler.exe  AND Processes.original_file_name=Microsoft.Workflow.Compiler.exe by Processes.dest  Processes.user Processes.parent_process_name Processes.process_name Processes.process  Processes.process_id Processes.parent_process_id Processes.original_file_name |  `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `suspicious_microsoft_workflow_compiler_rename_filter`'



<li><a href="#">NAME: Suspicious microsoft workflow compiler usage

DESCRIPTION:  The following analytic identifies microsoft.workflow.compiler.exe usage.  microsoft.workflow.compiler.exe is natively found in C:\Windows\Microsoft.NET\Framework64\v4.0.30319  and is rarely utilized. When investigating, identify the executed code on disk and  review. It is not a commonly used process by many applications.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where `process_microsoftworkflowcompiler`  by Processes.dest Processes.parent_process Processes.process_name Processes.original_file_name  Processes.process Processes.user | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `suspicious_microsoft_workflow_compiler_usage_filter`'



<li><a href="#">NAME: Suspicious msbuild path

DESCRIPTION:  The following analytic identifies msbuild.exe executing from a non-standard  path. Msbuild.exe is natively found in C:\Windows\Microsoft.NET\Framework\v4.0.30319  and C:\Windows\Microsoft.NET\Framework64\v4.0.30319. Instances of Visual Studio  will run a copy of msbuild.exe. A moved instance of MSBuild is suspicious, however  there are instances of build applications that will move or use a copy of MSBuild.

SEARCH:  '| tstats `security_content_summariesonly` count values(Processes.process_name)  as process_name values(Processes.process) as process min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where `process_msbuild` AND (Processes.process_path!=*\\framework*\\v*\\*)  by Processes.dest Processes.original_file_name Processes.parent_process Processes.user  | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`|  `suspicious_msbuild_path_filter`'



<li><a href="#">NAME: Suspicious MSBuild Rename

DESCRIPTION:  The following analytic identifies renamed instances of msbuild.exe executing.  Msbuild.exe is natively found in C:\Windows\Microsoft.NET\Framework\v4.0.30319 and  C:\Windows\Microsoft.NET\Framework64\v4.0.30319. During investigation, identify  the code executed and what is executing a renamed instance of MSBuild.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.process_name!=msbuild.exe  AND Processes.original_file_name=MSBuild.exe by Processes.dest Processes.user Processes.parent_process_name  Processes.process_name Processes.process Processes.process_id Processes.parent_process_id  Processes.original_file_name | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `suspicious_msbuild_rename_filter`'



<li><a href="#">NAME: Suspicious MSBuild Spawn

DESCRIPTION:  The following analytic identifies wmiprvse.exe spawning msbuild.exe.  This behavior is indicative of a COM object being utilized to spawn msbuild from  wmiprvse.exe. It is common for MSBuild.exe to be spawned from devenv.exe while using  Visual Studio. In this instance, there will be command line arguments and file paths.  In a malicious instance, MSBuild.exe will spawn from non-standard processes and  have no command line arguments. For example, MSBuild.exe spawning from explorer.exe,  powershell.exe is far less common and should be investigated.

SEARCH:  '| tstats `security_content_summariesonly` count values(Processes.process_name)  as process_name values(Processes.process) as process min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.parent_process_name=wmiprvse.exe  AND `process_msbuild` by Processes.dest Processes.parent_process Processes.original_file_name  Processes.user | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `suspicious_msbuild_spawn_filter`'



<li><a href="#">NAME: Suspicious mshta child process

DESCRIPTION:  The following analytic identifies child processes spawning from  "mshta.exe".  The search will return the first time and last time these command-line arguments  were used for these executions, as well as the target system, the user, parent process  "mshta.exe" and its child process.

SEARCH:  '| tstats `security_content_summariesonly` count values(Processes.process_name)  as process_name values(Processes.process) as process min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.parent_process_name=mshta.exe  AND (Processes.process_name=powershell.exe OR Processes.process_name=colorcpl.exe  OR Processes.process_name=msbuild.exe OR Processes.process_name=microsoft.workflow.compiler.exe  OR Processes.process_name=searchprotocolhost.exe OR Processes.process_name=scrcons.exe  OR Processes.process_name=cscript.exe OR Processes.process_name=wscript.exe OR Processes.process_name=powershell.exe  OR Processes.process_name=cmd.exe) by Processes.dest Processes.parent_process Processes.user  | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `suspicious_mshta_child_process_filter`'



<li><a href="#">NAME: Suspicious mshta spawn

DESCRIPTION:  The following analytic identifies wmiprvse.exe spawning mshta.exe. This  behavior is indicative of a DCOM object being utilized to spawn mshta from wmiprvse.exe  or svchost.exe. In this instance, adversaries may use LethalHTA that will spawn  mshta.exe from svchost.exe.

SEARCH:  '| tstats `security_content_summariesonly` count values(Processes.process_name)  as process_name values(Processes.process) as process min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where (Processes.parent_process_name=svchost.exe  OR Processes.parent_process_name=wmiprvse.exe) AND `process_mshta` by Processes.dest  Processes.parent_process Processes.user Processes.original_file_name| `drop_dm_object_name(Processes)`  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `suspicious_mshta_spawn_filter`'



<li><a href="#">NAME: Suspicious PlistBuddy Usage

DESCRIPTION:  'The following analytic identifies the use of a native MacOS utility,  PlistBuddy, creating or modifying a properly list (.plist) file. In the instance  of Silver Sparrow, the following commands were executed:\  - PlistBuddy -c "Add :Label string init_verx" ~/Library/Launchagents/init_verx.plist  \  - PlistBuddy -c "Add :RunAtLoad bool true" ~/Library/Launchagents/init_verx.plist  \  - PlistBuddy -c "Add :StartInterval integer 3600" ~/Library/Launchagents/init_verx.plist  \  - PlistBuddy -c "Add :ProgramArguments array" ~/Library/Launchagents/init_verx.plist  \  - PlistBuddy -c "Add :ProgramArguments:0 string /bin/sh" ~/Library/Launchagents/init_verx.plist  \  - PlistBuddy -c "Add :ProgramArguments:1 string -c" ~/Library/Launchagents/init_verx.plist  \  Upon triage, capture the property list file being written to disk and review for  further indicators. Contain the endpoint and triage further.'

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.process_name=PlistBuddy  (Processes.process=*LaunchAgents* OR Processes.process=*RunAtLoad* OR Processes.process=*true*)  by Processes.dest Processes.user Processes.parent_process Processes.process_name  Processes.process Processes.process_id Processes.parent_process_id | `drop_dm_object_name(Processes)`  | `security_content_ctime(firstTime)`| `security_content_ctime(lastTime)` |  `suspicious_plistbuddy_usage_filter`'



<li><a href="#">NAME: Suspicious PlistBuddy Usage via OSquery

DESCRIPTION:  'The following analytic identifies the use of a native MacOS utility,  PlistBuddy, creating or modifying a properly list (.plist) file. In the instance  of Silver Sparrow, the following commands were executed:\  - PlistBuddy -c "Add :Label string init_verx" ~/Library/Launchagents/init_verx.plist  \  - PlistBuddy -c "Add :RunAtLoad bool true" ~/Library/Launchagents/init_verx.plist  \  - PlistBuddy -c "Add :StartInterval integer 3600" ~/Library/Launchagents/init_verx.plist  \  - PlistBuddy -c "Add :ProgramArguments array" ~/Library/Launchagents/init_verx.plist  \  - PlistBuddy -c "Add :ProgramArguments:0 string /bin/sh" ~/Library/Launchagents/init_verx.plist  \  - PlistBuddy -c "Add :ProgramArguments:1 string -c" ~/Library/Launchagents/init_verx.plist  \  Upon triage, capture the property list file being written to disk and review for  further indicators. Contain the endpoint and triage further.'

SEARCH:  '`osquery_process` "columns.cmdline"="*LaunchAgents*" OR "columns.cmdline"="*RunAtLoad*"  OR "columns.cmdline"="*true*" |  `suspicious_plistbuddy_usage_via_osquery_filter`'



<li><a href="#">NAME: Suspicious Process DNS Query Known Abuse Web Services

DESCRIPTION:  The following analytic detects a suspicious process making a DNS query via known,  abused text-paste web services, VoIP, instant messaging, and digital distribution  platforms used to download external files. This technique is abused by adversaries,  malware actors, and red teams to download a malicious file on the target host. This  is a good TTP indicator for possible initial access techniques. A user will experience  false positives if the following instant messaging is allowed or common applications  like telegram or discord are allowed in the corporate network.

SEARCH:  '`sysmon` EventCode=22 QueryName IN ("*pastebin*", "*discord*", "*api.telegram*","*t.me*")   process_name IN ("cmd.exe", "*powershell*", "pwsh.exe", "wscript.exe","cscript.exe") OR Image IN ("*\\users\\public\\*", "*\\programdata\\*", "*\\temp\\*", "*\\Windows\\Tasks\\*", "*\\appdata\\*", "*\\perflogs\\*")  | stats count min(_time) as firstTime max(_time) as lastTime by Image QueryName QueryStatus process_name QueryResults Computer   | rename Computer as dest   | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)`  | `suspicious_process_dns_query_known_abuse_web_services_filter`'



<li><a href="#">NAME: Suspicious Process Executed From Container File

DESCRIPTION:  This analytic identifies a suspicious process spawned by another process  from within common container/archive file types. This technique was a common technique  used by adversaries and malware to execute scripts or evade defenses. This TTP may  detect some normal software installation or user behaviors where opening archive  files is common.

SEARCH:  '| tstats `security_content_summariesonly` count values(Processes.process_name)  as process_name min(_time) as firstTime max(_time) as lastTime from datamodel=Endpoint.Processes  where Processes.process IN ("*.ZIP\\*","*.ISO\\*","*.IMG\\*","*.CAB\\*","*.TAR\\*","*.GZ\\*","*.RAR\\*","*.7Z\\*")  AND Processes.action="allowed" by Processes.dest Processes.parent_process Processes.process  Processes.user| `drop_dm_object_name(Processes)`| regex process="(?i).*(ZIP|ISO|IMG|CAB|TAR|GZ|RAR|7Z)\\\\.+\.(BAT|BIN|CAB|CMD|COM|CPL|EX_|EXE|GADGET|INF1|INS|INX||HTM|HTML|ISU|JAR|JOB|JS|JSE|LNK|MSC|MSI|MSP|MST|PAF|PIF|PS1|REG|RGS|SCR|SCT|SHB|SHS|U3P|VB|VBE|VBS|VBSCRIPT|WS|WSF|WSH)\"?$"  | rex field=process "(?i).+\\\\(?<file_name>[^\\\]+\.(ZIP|ISO|IMG|CAB|TAR|GZ|RAR|7Z))\\\\((.+\\\\)+)?(?<process_name>.+\.(BAT|BIN|CAB|CMD|COM|CPL|EX_|EXE|GADGET|INF1|INS|INX||HTM|HTML|ISU|JAR|JOB|JS|JSE|LNK|MSC|MSI|MSP|MST|PAF|PIF|PS1|REG|RGS|SCR|SCT|SHB|SHS|U3P|VB|VBE|VBS|VBSCRIPT|WS|WSF|WSH))\"?$"|  `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `suspicious_process_executed_from_container_file_filter`'



<li><a href="#">NAME: Suspicious Process File Path

DESCRIPTION:  This analytic identifies a suspicious processes running in file paths  that are not typically associated with legitimate software. Adversaries often employ  this technique to drop and execute malicious executables in accessible locations  that do not require administrative privileges. By monitoring for processes running  in such unconventional file paths, we can identify potential indicators of compromise  and proactively respond to malicious activity. This analytic plays a crucial role  in enhancing system security by pinpointing suspicious behaviors commonly associated  with malware and unauthorized software execution.

SEARCH:  '| tstats `security_content_summariesonly` count values(Processes.process_name)  as process_name values(Processes.process) as process min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.process_path = "*\\windows\\fonts\\*"  OR Processes.process_path = "*\\windows\\temp\\*" OR Processes.process_path = "*\\users\\public\\*"  OR Processes.process_path = "*\\windows\\debug\\*" OR Processes.process_path = "*\\Users\\Administrator\\Music\\*"  OR Processes.process_path = "*\\Windows\\servicing\\*" OR Processes.process_path  = "*\\Users\\Default\\*" OR Processes.process_path = "*Recycle.bin*" OR Processes.process_path  = "*\\Windows\\Media\\*" OR Processes.process_path = "\\Windows\\repair\\*" OR Processes.process_path  = "*\\temp\\*" OR Processes.process_path = "*\\PerfLogs\\*" by Processes.parent_process_name  Processes.parent_process Processes.process_path Processes.dest Processes.user |  `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `suspicious_process_file_path_filter`'



<li><a href="#">NAME: Suspicious Process With Discord DNS Query

DESCRIPTION:  This analytic identifies a process making a DNS query to Discord, a well  known instant messaging and digital distribution platform. Discord can be abused  by adversaries, as seen in the WhisperGate campaign, to host and download malicious.  external files. A process resolving a Discord DNS name could be an indicator of  malware trying to download files from Discord for further execution.

SEARCH:  '`sysmon` EventCode=22 QueryName IN ("*discord*") Image != "*\\AppData\\Local\\Discord\\*"  AND Image != "*\\Program Files*" AND Image != "discord.exe" | stats count min(_time)  as firstTime max(_time) as lastTime by Image QueryName QueryStatus process_name  QueryResults Computer | rename Computer as dest | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `suspicious_process_with_discord_dns_query_filter`'



<li><a href="#">NAME: Suspicious Regsvr32 Register Suspicious Path

DESCRIPTION:  Adversaries may abuse Regsvr32.exe to proxy execution of malicious code  by using non-standard file extensions to load DLLs. Upon investigating, look for  network connections to remote destinations (internal or external). Review additional  parrallel processes and child processes for additional activity.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where `process_regsvr32` Processes.process  IN ("*\\appdata\\*", "*\\programdata\\*","*\\windows\\temp\\*") NOT (Processes.process  IN ("*.dll*", "*.ax*", "*.ocx*")) by Processes.dest Processes.user  Processes.parent_process_name Processes.parent_process  Processes.process_name Processes.process Processes.original_file_name Processes.process_id  Processes.parent_process_id | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)`|  `security_content_ctime(lastTime)` | `suspicious_regsvr32_register_suspicious_path_filter`'



<li><a href="#">NAME: Suspicious Reg exe Process

DESCRIPTION:  This search looks for reg.exe being launched from a command prompt not  started by the user. When a user launches cmd.exe, the parent process is usually  explorer.exe. This search filters out those instances.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime FROM datamodel=Endpoint.Processes where Processes.parent_process_name  != explorer.exe Processes.process_name =cmd.exe by Processes.user Processes.process_name  Processes.parent_process_name Processes.dest Processes.process_id Processes.parent_process_id  | `drop_dm_object_name("Processes")` | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | search [| tstats `security_content_summariesonly` count FROM datamodel=Endpoint.Processes  where Processes.parent_process_name=cmd.exe Processes.process_name= reg.exe by Processes.parent_process_id  Processes.dest Processes.process_name | `drop_dm_object_name("Processes")` | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | rename parent_process_id as process_id |dedup  process_id| table process_id dest] | `suspicious_reg_exe_process_filter` '



<li><a href="#">NAME: Suspicious Rundll32 dllregisterserver

DESCRIPTION:  The following analytic identifies rundll32.exe using dllregisterserver  on the command line to load a DLL. When a DLL is registered, the DllRegisterServer  method entry point in the DLL is invoked. This is typically seen when a DLL is being  registered on the system. Not every instance is considered malicious, but it will  capture malicious use of it. During investigation, review the parent process and  parrellel processes executing. Capture the DLL being loaded and inspect further.  Rundll32.exe is natively found in C:\Windows\system32 and C:\Windows\syswow64.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where `process_rundll32` Processes.process=*dllregisterserver*  by Processes.dest Processes.user Processes.parent_process_name Processes.parent_process Processes.original_file_name  Processes.process_name Processes.process Processes.process_id Processes.parent_process_id  | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `suspicious_rundll32_dllregisterserver_filter`'



<li><a href="#">NAME: Suspicious Rundll32 no Command Line Arguments

DESCRIPTION:  The following analytic identifies rundll32.exe with no command line arguments.  It is unusual for rundll32.exe to execute with no command line arguments present.  This particular behavior is common with malicious software, including Cobalt Strike.  During investigation, identify any network connections and parallel processes. Identify  any suspicious module loads related to credential dumping or file writes. Rundll32.exe  is natively found in C:\Windows\system32 and C:\Windows\syswow64.

SEARCH:  '| tstats `security_content_summariesonly` count FROM datamodel=Endpoint.Processes  where `process_rundll32` by _time span=1h  Processes.process_id Processes.process_name  Processes.dest Processes.user Processes.process_path Processes.process Processes.parent_process_name  | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | regex process="(?i)(rundll32\.exe.{0,4}$)" | `suspicious_rundll32_no_command_line_arguments_filter`'



<li><a href="#">NAME: Suspicious Rundll32 PluginInit

DESCRIPTION:  This search is to detect a suspicious rundll32.exe process with plugininit  parameter. This technique is commonly seen in IcedID malware to execute its initial  dll stager to download another payload to the compromised machine.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where `process_rundll32` Processes.process=*PluginInit*  by  Processes.process_name Processes.process Processes.parent_process_name Processes.original_file_name  Processes.parent_process Processes.process_id Processes.parent_process_id Processes.dest  Processes.user | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `suspicious_rundll32_plugininit_filter`'



<li><a href="#">NAME: Suspicious Rundll32 StartW

DESCRIPTION:  The following analytic identifies rundll32.exe executing a DLL function  name, Start and StartW, on the command line that is commonly observed with Cobalt  Strike x86 and x64 DLL payloads. Rundll32.exe is natively found in C:\Windows\system32  and C:\Windows\syswow64. Typically, the DLL will be written and loaded from a world  writeable path or user location. In most instances it will not have a valid certificate  (Unsigned). During investigation, review the parent process and other parallel application  execution. Capture and triage the DLL in question. In the instance of Cobalt Strike,  rundll32.exe is the default process it opens and injects shellcode into. This default  process can be changed, but typically is not.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where `process_rundll32` Processes.process=*start*  by Processes.dest Processes.user Processes.parent_process Processes.process_name  Processes.process Processes.original_file_name Processes.process_id Processes.parent_process_id  | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `suspicious_rundll32_startw_filter`'



<li><a href="#">NAME: Suspicious Scheduled Task from Public Directory

DESCRIPTION:  'The following analytic, "Suspicious Scheduled Task from Public Directory",  detects the registration of scheduled tasks aimed to execute a binary or script  from public directories, a behavior often associated with malware deployment. It  utilizes the Sysmon Event ID 1 data source, searching for instances where schtasks.exe  is connected with the directories users\public, \programdata\, or \windows\temp  and involves the /create command.\  The registration of such scheduled tasks in public directories could suggest that  an attacker is trying to maintain persistence or execute malicious scripts. If confirmed  as a true positive, this could lead to data compromise, unauthorized access, and  potential lateral movement within the network.'

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.process_name=schtasks.exe  (Processes.process=*\\users\\public\\* OR Processes.process=*\\programdata\\* OR  Processes.process=*windows\\temp*)  Processes.process=*/create* by Processes.dest  Processes.user Processes.parent_process Processes.process_name Processes.process  Processes.process_id Processes.parent_process_id | `drop_dm_object_name(Processes)`  | `security_content_ctime(firstTime)`| `security_content_ctime(lastTime)`| `suspicious_scheduled_task_from_public_directory_filter`'



<li><a href="#">NAME: Suspicious SearchProtocolHost no Command Line Arguments

DESCRIPTION:  The following analytic identifies searchprotocolhost.exe with no command  line arguments. It is unusual for searchprotocolhost.exe to execute with no command  line arguments present. This particular behavior is common with malicious software,  including Cobalt Strike. During investigation, identify any network connections  and parallel processes. Identify any suspicious module loads related to credential  dumping or file writes. searchprotocolhost.exe is natively found in C:\Windows\system32  and C:\Windows\syswow64.

SEARCH:  '| tstats `security_content_summariesonly` count FROM datamodel=Endpoint.Processes  where Processes.process_name=searchprotocolhost.exe by _time span=1h  Processes.process_id  Processes.process_name Processes.dest Processes.user Processes.process_path Processes.process Processes.parent_process_name  | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | regex process="(?i)(searchprotocolhost\.exe.{0,4}$)" | `suspicious_searchprotocolhost_no_command_line_arguments_filter`'



<li><a href="#">NAME: Suspicious SQLite3 LSQuarantine Behavior

DESCRIPTION:  The following analytic identifies the use of a SQLite3 querying the MacOS  preferences to identify the original URL the pkg was downloaded from. This particular  behavior is common with MacOS adware-malicious software. Upon triage, review other  processes in parallel for suspicious activity. Identify any recent package installations.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.process_name=sqlite3  Processes.process=*LSQuarantine* by Processes.dest Processes.user Processes.parent_process  Processes.process_name Processes.process Processes.process_id Processes.parent_process_id  | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)`| `security_content_ctime(lastTime)`  | `suspicious_sqlite3_lsquarantine_behavior_filter`'



<li><a href="#">NAME: Suspicious Ticket Granting Ticket Request

DESCRIPTION:  As part of the sAMAccountName Spoofing (CVE-2021-42278) and Domain Controller  Impersonation (CVE-2021-42287) exploitation chain, adversaries will need to request  a Kerberos Ticket Granting Ticket (TGT) on behalf of the newly created and renamed  computer account. The TGT request will be preceded by a computer account name event.  This analytic leverages Event Id 4781, `The name of an account was changed` and  event Id 4768 `A Kerberos authentication ticket (TGT) was requested` to correlate  a sequence of events where the new computer account on event id 4781 matches the  request account on event id 4768. This behavior could represent an exploitation  attempt of CVE-2021-42278 and CVE-2021-42287 for privilege escalation.

SEARCH:  ' `wineventlog_security` (EventCode=4781 Old_Account_Name="*$" New_Account_Name!="*$")  OR (EventCode=4768 Account_Name!="*$") | eval RenamedComputerAccount = coalesce(New_Account_Name,  mvindex(Account_Name,0)) | transaction RenamedComputerAccount startswith=(EventCode=4781)  endswith=(EventCode=4768) | eval short_lived=case((duration<2),"TRUE") | search  short_lived = TRUE | table _time, ComputerName, EventCode, Account_Name,RenamedComputerAccount,  short_lived |`suspicious_ticket_granting_ticket_request_filter`'



<li><a href="#">NAME: Suspicious WAV file in Appdata Folder

DESCRIPTION:  This analytic is to detect a suspicious creation of .wav file in appdata  folder. This behavior was seen in Remcos RAT malware where it put the audio recording  in the appdata\audio folde as part of data collection. this recording can be send  to its C2 server as part of its exfiltration to the compromised machine. creation  of wav files in this folder path is not a ussual disk place used by user to save  audio format file.

SEARCH:  '| tstats `security_content_summariesonly` count FROM datamodel=Endpoint.Processes  where Processes.process_name=*.exe Processes.process_path="*\\appdata\\Roaming\\*"  by _time span=1h Processes.process_id Processes.process_name Processes.process Processes.dest  Processes.process_guid | `drop_dm_object_name(Processes)` |rename process_guid as  proc_guid | join proc_guid, _time [ | tstats `security_content_summariesonly` count  min(_time) as firstTime max(_time) as lastTime FROM datamodel=Endpoint.Filesystem  where Filesystem.file_name IN ("*.wav") Filesystem.file_path = "*\\appdata\\Roaming\\*"  by _time span=1h Filesystem.dest Filesystem.file_create_time Filesystem.file_name  Filesystem.file_path Filesystem.process_guid | `drop_dm_object_name(Filesystem)`  |rename process_guid as proc_guid | fields file_name file_path process_name process_path  process dest file_create_time _time proc_guid] | `suspicious_wav_file_in_appdata_folder_filter`'



<li><a href="#">NAME: Suspicious wevtutil Usage

DESCRIPTION:  The wevtutil.exe application is the windows event log utility. This searches  for wevtutil.exe with parameters for clearing the application, security, setup,  trace or system event logs.

SEARCH:  '| tstats `security_content_summariesonly` values(Processes.process) as process  min(_time) as firstTime max(_time) as lastTime from datamodel=Endpoint.Processes  where Processes.process_name=wevtutil.exe Processes.process IN ("* cl *", "*clear-log*")  (Processes.process="*System*" OR Processes.process="*Security*" OR Processes.process="*Setup*"  OR Processes.process="*Application*" OR Processes.process="*trace*") by Processes.process_name  Processes.parent_process_name Processes.dest Processes.user| `drop_dm_object_name(Processes)`  | `security_content_ctime(firstTime)` |`security_content_ctime(lastTime)` | `suspicious_wevtutil_usage_filter`'



<li><a href="#">NAME: Suspicious writes to windows Recycle Bin

DESCRIPTION:  |-  The following analytic detects when a process other than explorer.exe writes to the Windows Recycle Bin to detect potential threats earlier and mitigate the risks. This detection is made by a Splunk query that utilizes the Endpoint.Filesystem data model and the Endpoint.Processes data model. The query looks for any process writing to the "*$Recycle.Bin*" file path, excluding explorer.exe. This detection is important because it suggests that an attacker is attempting to hide their activities by using the Recycle Bin, which can lead to data theft, ransomware, or other damaging outcomes. Detecting writes to the Recycle Bin by a process other than explorer.exe can help to investigate and determine if the activity is malicious or benign. False positives might occur since there might be legitimate uses of the Recycle Bin by processes other than explorer.exe. Next steps include reviewing the process writing to the Recycle Bin and any relevant on-disk artifacts upon triage.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time) as lastTime values(Filesystem.file_path) as file_path values(Filesystem.file_name) as file_name FROM datamodel=Endpoint.Filesystem where Filesystem.file_path = "*$Recycle.Bin*" by Filesystem.process_name Filesystem.process_id Filesystem.dest | `drop_dm_object_name("Filesystem")` | join  process_id    [| tstats `security_content_summariesonly` values(Processes.user) as user values(Processes.process_name) as process_name values(Processes.parent_process_name) as parent_process_name FROM datamodel=Endpoint.Processes where Processes.process_name != "explorer.exe" by Processes.process_id Processes.dest     | `drop_dm_object_name("Processes")`     | table user process_name process_id dest] | `suspicious_writes_to_windows_recycle_bin_filter`'



<li><a href="#">NAME: Svchost LOLBAS Execution Process Spawn

DESCRIPTION:  The following analytic is designed to spot instances of 'svchost.exe'  initiating a Living Off The Land Binaries and Scripts (LOLBAS) execution process.  Often, adversaries manipulate Task Scheduler to execute code on remote endpoints,  resulting in the spawning of a malicious command as a child process of 'svchost.exe'.  By tracking child processes of 'svchost.exe' that align with the LOLBAS project,  potential lateral movement activity can be detected. The analytic examines process  details, including the process name, parent process, and command-line executions.  A comprehensive list of LOLBAS processes is included in the search parameters. Although  the analytic might catch legitimate applications exhibiting this behavior, these  instances should be filtered accordingly. The findings from this analytic offer  valuable insight into potentially malicious activities on an endpoint.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where (Processes.parent_process_name=svchost.exe)  (Processes.process_name IN ("Regsvcs.exe", "Ftp.exe", "OfflineScannerShell.exe",  "Rasautou.exe", "Schtasks.exe", "Xwizard.exe", "Pnputil.exe", "Atbroker.exe", "Pcwrun.exe",  "Ttdinject.exe","Mshta.exe", "Bitsadmin.exe", "Certoc.exe", "Ieexec.exe", "Microsoft.Workflow.Compiler.exe",  "Runscripthelper.exe", "Forfiles.exe", "Msbuild.exe", "Register-cimprovider.exe",  "Tttracer.exe", "Ie4uinit.exe", "Bash.exe", "Hh.exe", "SettingSyncHost.exe", "Cmstp.exe",  "Stordiag.exe", "Scriptrunner.exe", "Odbcconf.exe", "Extexport.exe", "Msdt.exe",  "WorkFolders.exe", "Diskshadow.exe", "Mavinject.exe", "Regasm.exe", "Gpscript.exe",  "Regsvr32.exe", "Msiexec.exe", "Wuauclt.exe", "Presentationhost.exe", "Wmic.exe",  "Runonce.exe", "Syncappvpublishingserver.exe", "Verclsid.exe", "Infdefaultinstall.exe",  "Installutil.exe", "Netsh.exe", "Wab.exe", "Dnscmd.exe", "At.exe", "Pcalua.exe",  "Msconfig.exe")) by Processes.dest Processes.user Processes.parent_process Processes.process_name  Processes.process Processes.process_id Processes.parent_process_id | `drop_dm_object_name(Processes)`  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `svchost_lolbas_execution_process_spawn_filter`'



<li><a href="#">NAME: System Information Discovery Detection

DESCRIPTION:  Detect system information discovery techniques used by attackers to understand  configurations of the system to further exploit it.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where (Processes.process="*wmic* qfe*"  OR Processes.process=*systeminfo* OR Processes.process=*hostname*) by Processes.user  Processes.process_name Processes.process Processes.dest Processes.parent_process_name  | `drop_dm_object_name(Processes)` | eventstats dc(process) as dc_processes_by_dest  by dest | where dc_processes_by_dest > 2 | stats values(process) as process min(firstTime)  as firstTime max(lastTime) as lastTime by user, dest parent_process_name | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `system_information_discovery_detection_filter`'



<li><a href="#">NAME: System Info Gathering Using Dxdiag Application

DESCRIPTION:  This analytic is to detect a suspicious dxdiag.exe process command-line  execution. Dxdiag is used to collect the system info of the target host. This technique  has been used by Remcos RATS, various actors, and other malware to collect information  as part of the recon or collection phase of an attack. This behavior should rarely  be seen in a corporate network, but this command line can be used by a network administrator  to audit host machine specifications. Thus in some rare cases, this detection will  contain false positives in its results. To triage further, analyze what commands  were passed after it pipes out the result to a file for further processing.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where `process_dxdiag` AND Processes.process  = "* /t *" by Processes.dest Processes.user Processes.parent_process_name Processes.parent_process  Processes.process_name Processes.process Processes.process_id Processes.parent_process_id  | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `system_info_gathering_using_dxdiag_application_filter`'



<li><a href="#">NAME: System Processes Run From Unexpected Locations

DESCRIPTION:  'This search looks for system processes that typically execute from `C:\Windows\System32\`  or `C:\Windows\SysWOW64`.  This may indicate a malicious process that is trying  to hide as a legitimate process.\  This detection utilizes a lookup that is deduped `system32` and `syswow64` directories  from Server 2016 and Windows 10.\  During triage, review the parallel processes - what process moved the native Windows  binary? identify any artifacts on disk and review. If a remote destination is contacted,  what is the reputation?'

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime FROM datamodel=Endpoint.Processes where Processes.process_path !="C:\\Windows\\System32*"  Processes.process_path !="C:\\Windows\\SysWOW64*" by Processes.dest Processes.user  Processes.parent_process Processes.process_path Processes.process_name Processes.process Processes.process_id  Processes.parent_process_id Processes.process_hash | `drop_dm_object_name("Processes")`  | `security_content_ctime(firstTime)`| `security_content_ctime(lastTime)`| `is_windows_system_file`  | `system_processes_run_from_unexpected_locations_filter`'



<li><a href="#">NAME: System User Discovery With Query

DESCRIPTION:  This analytic looks for the execution of `query.exe` with command-line  arguments utilized to discover the logged user. Red Teams and adversaries alike  may leverage `query.exe` to identify system users on a compromised endpoint for  situational awareness and Active Directory Discovery.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where (Processes.process_name="query.exe")  (Processes.process=*user*) by Processes.dest Processes.user Processes.parent_process  Processes.process_name Processes.process Processes.process_id Processes.parent_process_id  | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `system_user_discovery_with_query_filter`'



<li><a href="#">NAME: System User Discovery With Whoami

DESCRIPTION:  This analytic looks for the execution of `whoami.exe` without any arguments.  This windows native binary prints out the current logged user. Red Teams and adversaries  alike may leverage `whoami.exe` to identify system users on a compromised endpoint  for situational awareness and Active Directory Discovery.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where (Processes.process_name="whoami.exe")  by Processes.dest Processes.user Processes.parent_process Processes.process_name  Processes.process Processes.process_id Processes.parent_process_id | `drop_dm_object_name(Processes)`  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `system_user_discovery_with_whoami_filter`'



<li><a href="#">NAME: Time Provider Persistence Registry

DESCRIPTION:  This analytic is to detect a suspicious modification of time provider  registry for persistence and autostart. This technique can allow the attacker to  persist on the compromised host and autostart as soon as the machine boot up. This  TTP can be a good indicator of suspicious behavior since this registry is not commonly  modified by normal user or even an admin.

SEARCH:  '| tstats `security_content_summariesonly` count FROM datamodel=Endpoint.Registry  WHERE (Registry.registry_path="*\\CurrentControlSet\\Services\\W32Time\\TimeProviders*")  BY _time span=1h Registry.dest Registry.user Registry.registry_path Registry.registry_key_name Registry.registry_value_name  Registry.registry_value_data Registry.process_guid | `drop_dm_object_name(Registry)` | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `time_provider_persistence_registry_filter`'



<li><a href="#">NAME: TOR Traffic

DESCRIPTION:  The following analytic looks for allowed network traffic to The Onion Router(TOR), a benign anonymity network which can be abused for a variety of nefarious purposes. Detecting Tor traffic is paramount for upholding network security and mitigating potential threats. Tor's capacity to provide users with anonymity has been exploited by cybercriminals for activities like hacking, data breaches, and illicit content dissemination. Additionally, organizations must monitor Tor usage within their networks to ensure compliance with policies and regulations, as it can bypass conventional monitoring and filtering measures. Lastly, the ability to identify Tor traffic empowers security teams to promptly investigate and address potential security incidents, fortifying the protection of sensitive data and preserving the integrity of the network environment.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Network_Traffic where All_Traffic.app=tor AND All_Traffic.action=allowed  by All_Traffic.src_ip All_Traffic.dest_ip All_Traffic.dest_port All_Traffic.action  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `drop_dm_object_name("All_Traffic")`  | `tor_traffic_filter`'



<li><a href="#">NAME: Trickbot Named Pipe

DESCRIPTION:  this search is to detect potential trickbot infection through the create/connected  named pipe to the system. This technique is used by trickbot to communicate to its  c2 to post or get command during infection.

SEARCH:  '`sysmon` EventCode IN (17,18) PipeName="\\pipe\\*lacesomepipe" | stats  min(_time)  as firstTime max(_time) as lastTime count by dest user_id EventCode PipeName  signature Image process_id | rename Image as process_name | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `trickbot_named_pipe_filter`'



<li><a href="#">NAME: UAC Bypass MMC Load Unsigned Dll

DESCRIPTION:  This search is to detect a suspicious loaded unsigned dll by MMC.exe  application. This technique is commonly seen in attacker that tries to bypassed  UAC feature or gain privilege escalation. This is done by modifying some CLSID registry  that will trigger the mmc.exe to load the dll path

SEARCH:  '`sysmon` EventCode=7  ImageLoaded = "*.dll" Image = "*\\mmc.exe" Signed=false  Company != "Microsoft Corporation" | stats count min(_time) as firstTime max(_time)  as lastTime by Image ImageLoaded Signed ProcessId OriginalFileName dest EventCode  Company | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `uac_bypass_mmc_load_unsigned_dll_filter`'



<li><a href="#">NAME: UAC Bypass With Colorui COM Object

DESCRIPTION:  This search is to detect a possible uac bypass using the colorui.dll  COM Object. this technique was seen in so many malware and ransomware like lockbit  where it make use of the colorui.dll COM CLSID to bypass UAC.

SEARCH:  '`sysmon` EventCode=7 ImageLoaded="*\\colorui.dll" process_name != "colorcpl.exe"  NOT(Image IN("*\\windows\\*", "*\\program files*")) | stats count min(_time) as  firstTime max(_time) as lastTime by Image ImageLoaded process_name dest user_id EventCode Signed ProcessId | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `uac_bypass_with_colorui_com_object_filter`'



<li><a href="#">NAME: Uninstall App Using MsiExec

DESCRIPTION:  This search is to detect a suspicious un-installation of application  using msiexec. This technique was seen in conti leak tool and script where it tries  to uninstall AV product using this commandline. This commandline to uninstall product  is not a common practice in enterprise network.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.process_name=msiexec.exe  Processes.process= "* /qn *" Processes.process= "*/X*" Processes.process= "*REBOOT=*"  by Processes.dest Processes.user Processes.parent_process Processes.process_name  Processes.process Processes.process_id Processes.parent_process_id | `drop_dm_object_name(Processes)`  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `uninstall_app_using_msiexec_filter`'



<li><a href="#">NAME: Unknown Process Using The Kerberos Protocol

DESCRIPTION:  The following analytic identifies a process performing an outbound connection  on port 88 used by default by the network authentication protocol Kerberos. Typically,  on a regular Windows endpoint, only the lsass.exe process is the one tasked with  connecting to the Kerberos Distribution Center to obtain Kerberos tickets. Identifying  an unknown process using this protocol may be evidence of an adversary abusing the  Kerberos protocol.

SEARCH:  '| tstats `security_content_summariesonly` count FROM datamodel=Endpoint.Processes where Processes.process_name!=lsass.exe by _time Processes.process_id Processes.process_name Processes.dest Processes.process_path Processes.process Processes.parent_process_name | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | join  process_id dest [| tstats `security_content_summariesonly` count FROM datamodel=Network_Traffic.All_Traffic where All_Traffic.dest_port = 88 by All_Traffic.src All_Traffic.process_id  All_Traffic.dest_port | `drop_dm_object_name(All_Traffic)` | rename src as dest ] |  table _time dest parent_process_name process_name process_path process process_id dest_port | `unknown_process_using_the_kerberos_protocol_filter`'



<li><a href="#">NAME: Unloading AMSI via Reflection

DESCRIPTION:  'The following analytic utilizes PowerShell Script Block Logging (EventCode=4104)  to identify suspicious PowerShell execution. Script Block Logging captures the command  sent to PowerShell, the full command to be executed. Upon enabling, logs will output  to Windows event logs. Dependent upon volume, enable on critical endpoints or all.  \  This analytic identifies the behavior of AMSI being tampered with. Implemented natively  in many frameworks, the command will look similar to `SEtValuE($Null,(New-OBJEct  COLlECtionS.GenerIC.HAshSEt{[StrINg]))}$ReF=[ReF].AsSeMbLY.GeTTyPe("System.Management.Automation.Amsi"+"Utils")`  taken from Powershell-Empire. \  During triage, review parallel processes using an EDR product or 4688 events. It  will be important to understand the timeline of events around this activity. Review  the entire logged PowerShell script block.'

SEARCH:  '`powershell` EventCode=4104 ScriptBlockText = *system.management.automation.amsi*  | stats count min(_time) as firstTime max(_time) as lastTime by EventCode ScriptBlockText  Computer user_id | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `unloading_amsi_via_reflection_filter`'



<li><a href="#">NAME: Unload Sysmon Filter Driver

DESCRIPTION:  Attackers often disable security tools to avoid detection. This search  looks for the usage of process `fltMC.exe` to unload a Sysmon Driver that will stop  sysmon from collecting the data.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime values(Processes.process)  as process max(_time) as lastTime from datamodel=Endpoint.Processes where Processes.process_name=fltMC.exe  AND Processes.process=*unload* AND Processes.process=*SysmonDrv*  by Processes.process_name  Processes.process_id Processes.parent_process_name Processes.process Processes.dest  Processes.user | `drop_dm_object_name("Processes")` | `security_content_ctime(firstTime)`|`security_content_ctime(lastTime)`  |`unload_sysmon_filter_driver_filter`| table firstTime lastTime dest user count  process_name process_id parent_process_name process'



<li><a href="#">NAME: Unusually Long Command Line

DESCRIPTION:  |-  The following analytic detects command lines that are extremely long, which might be indicative of malicious activity on your hosts because attackers often use obfuscated or complex command lines to hide their actions and evade detection. This helps to mitigate the risks associated with long command lines to enhance your overall security posture and reduce the impact of attacks. This detection is important because it suggests that an attacker might be attempting to execute a malicious command or payload on the host, which can lead to various damaging outcomes such as data theft, ransomware, or further compromise of the system. False positives might occur since legitimate processes or commands can sometimes result in long command lines. Next steps include conducting extensive triage and investigation to differentiate between legitimate and malicious activities. Review the source of the command line and the command itself during the triage. Additionally, capture and inspect any relevant on-disk artifacts and review concurrent processes to identify the source of the attack.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime FROM datamodel=Endpoint.Processes by Processes.user Processes.dest Processes.process_name  Processes.process | `drop_dm_object_name("Processes")` | `security_content_ctime(firstTime)`|  `security_content_ctime(lastTime)`|  eval processlen=len(process) | eventstats stdev(processlen)  as stdev, avg(processlen) as avg by dest | stats max(processlen) as maxlen, values(stdev)  as stdevperhost, values(avg) as avgperhost by dest, user, process_name, process  | `unusually_long_command_line_filter` |eval threshold = 3 | where maxlen > ((threshold*stdevperhost)  + avgperhost)'



<li><a href="#">NAME: Unusually Long Command Line - MLTK

DESCRIPTION:  Command lines that are extremely long may be indicative of malicious  activity on your hosts. This search leverages the Machine Learning Toolkit (MLTK)  to help identify command lines with lengths that are unusual for a given user.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime FROM datamodel=Endpoint.Processes by Processes.user Processes.dest Processes.process_name  Processes.process | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)`|  `security_content_ctime(lastTime)`| eval processlen=len(process) | search user!=unknown  | apply cmdline_pdfmodel threshold=0.01 | rename "IsOutlier(processlen)" as isOutlier  | search isOutlier > 0 | table firstTime lastTime user dest process_name process  processlen count | `unusually_long_command_line___mltk_filter`'



<li><a href="#">NAME: Unusually Long Content-Type Length

DESCRIPTION:  This search looks for unusually long strings in the Content-Type http  header that the client sends the server.

SEARCH:  '`stream_http` | eval cs_content_type_length = len(cs_content_type) | where  cs_content_type_length > 100 | table endtime src_ip dest_ip cs_content_type_length  cs_content_type url | `unusually_long_content_type_length_filter`'



<li><a href="#">NAME: Unusual Number of Computer Service Tickets Requested

DESCRIPTION:  'The following hunting analytic leverages Event ID 4769, `A Kerberos  service ticket was requested`, to identify an unusual number of computer service  ticket requests from one source. When a domain joined endpoint connects to a remote  endpoint, it first will request a Kerberos Ticket with the computer name as the  Service Name. An endpoint requesting a large number of computer service tickets  for different endpoints could represent malicious behavior like lateral movement, malware staging, reconnaissance, etc. The detection calculates the standard deviation for each host and leverages the 3-sigma statistical rule to identify an unusual number of service requests. To customize this analytic, users can try different combinations of the `bucket` span time,  the calculation of the `upperBound` field as well as the Outlier calculation. This logic can be used for real time security monitoring as well as threat hunting exercises.'

SEARCH:  ' `wineventlog_security` EventCode=4769 Service_Name="*$" Account_Name!="*$*"  | bucket span=2m _time | stats dc(Service_Name) AS unique_targets values(Service_Name)  as host_targets by _time, Client_Address, Account_Name | eventstats avg(unique_targets)  as comp_avg , stdev(unique_targets) as comp_std by Client_Address, Account_Name  | eval upperBound=(comp_avg+comp_std*3) | eval isOutlier=if(unique_targets >10 and  unique_targets >= upperBound, 1, 0) | `unusual_number_of_computer_service_tickets_requested_filter`'



<li><a href="#">NAME: Unusual Number of Kerberos Service Tickets Requested

DESCRIPTION:  'The following hunting analytic leverages Kerberos Event 4769, A Kerberos  service ticket was requested, to identify a potential kerberoasting attack against  Active Directory networks. Kerberoasting allows an adversary to request kerberos  tickets for domain accounts typically used as service accounts and attempt to crack  them offline allowing them to obtain privileged access to the domain.\  The detection calculates the standard deviation for each host and leverages the  3-sigma statistical rule to identify an unusual number service ticket requests.  To customize this analytic, users can try different combinations of the `bucket`  span time and the calculation of the `upperBound` field.'

SEARCH:  ' `wineventlog_security` EventCode=4769 Service_Name!="*$" Ticket_Encryption_Type=0x17  | bucket span=2m _time | stats dc(Service_Name) AS unique_services values(Service_Name)  as requested_services by _time, Client_Address | eventstats avg(unique_services)  as comp_avg , stdev(unique_services) as comp_std by Client_Address | eval upperBound=(comp_avg+comp_std*3)  | eval isOutlier=if(unique_services > 2 and unique_services >= upperBound, 1, 0)  | search isOutlier=1 | `unusual_number_of_kerberos_service_tickets_requested_filter`'



<li><a href="#">NAME: Unusual Number of Remote Endpoint Authentication Events

DESCRIPTION:  'The following hunting analytic leverages Event ID 4624, `An account  was successfully logged on`, to identify an unusual number of remote authentication  attempts coming from one source. An endpoint authenticating to a large number of  remote endpoints could represent malicious behavior like lateral movement, malware  staging, reconnaissance, etc. The detection calculates the standard deviation for each host and leverages the 3-sigma statistical rule to identify an unusual high number of authentication events.To customize this analytic, users can try different combinations of the `bucket` span time,  the calculation of the `upperBound` field as well as the Outlier calculation.This logic can be used for real time security monitoring as well as threat hunting exercises.'

SEARCH:  ' `wineventlog_security` EventCode=4624 Logon_Type=3 Account_Name!="*$" |  eval Source_Account = mvindex(Account_Name, 1) | bucket span=2m _time | stats dc(ComputerName)  AS unique_targets values(ComputerName) as target_hosts by _time, Source_Network_Address,  Source_Account | eventstats avg(unique_targets) as comp_avg , stdev(unique_targets)  as comp_std by Source_Network_Address, Source_Account | eval upperBound=(comp_avg+comp_std*3)  | eval isOutlier=if(unique_targets >10 and unique_targets >= upperBound, 1, 0) |  `unusual_number_of_remote_endpoint_authentication_events_filter`'



<li><a href="#">NAME: User Discovery With Env Vars PowerShell

DESCRIPTION:  This analytic looks for the execution of `powershell.exe` with command-line  arguments that leverage PowerShell environment variables to identify the current  logged user. Red Teams and adversaries may leverage this method to identify the  logged user on a compromised endpoint for situational awareness and Active Directory  Discovery.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where (Processes.process_name="powershell.exe")  (Processes.process="*$env:UserName*" OR Processes.process="*[System.Environment]::UserName*")  by Processes.dest Processes.user Processes.parent_process Processes.process_name  Processes.process Processes.process_id Processes.parent_process_id | `drop_dm_object_name(Processes)`  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `user_discovery_with_env_vars_powershell_filter`'



<li><a href="#">NAME: User Discovery With Env Vars PowerShell Script Block

DESCRIPTION:  The following analytic utilizes PowerShell Script Block Logging (EventCode=4104)  to identify the use of PowerShell environment variables to identify the current  logged user. Red Teams and adversaries may leverage this method to identify the  logged user on a compromised endpoint for situational awareness and Active Directory  Discovery.

SEARCH:  '`powershell` EventCode=4104 (ScriptBlockText = "*$env:UserName*" OR ScriptBlockText  = "*[System.Environment]::UserName*") | stats count min(_time) as firstTime max(_time)  as lastTime by EventCode ScriptBlockText Computer user_id   | rename Computer as dest, user_id as user  | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)`   | `user_discovery_with_env_vars_powershell_script_block_filter`'



<li><a href="#">NAME: USN Journal Deletion

DESCRIPTION:  The fsutil.exe application is a legitimate Windows utility used to perform  tasks related to the file allocation table (FAT) and NTFS file systems. The update  sequence number (USN) change journal provides a log of all changes made to the files  on the disk. This search looks for fsutil.exe deleting the USN journal.

SEARCH:  '| tstats `security_content_summariesonly` count values(Processes.process)  as process values(Processes.parent_process) as parent_process min(_time) as firstTime  max(_time) as lastTime from datamodel=Endpoint.Processes where Processes.process_name=fsutil.exe  by Processes.user Processes.process_name Processes.parent_process_name Processes.dest  |  `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)`| `security_content_ctime(lastTime)`  | search process="*deletejournal*" AND process="*usn*" | `usn_journal_deletion_filter`'



<li><a href="#">NAME: Vbscript Execution Using Wscript App

DESCRIPTION:  This analytic is to detect a suspicious wscript commandline to execute  vbscript. This technique was seen in several malware to execute malicious vbs file  using wscript application. commonly vbs script is associated to cscript process  and this can be a technique to evade process parent child detections or even some  av script emulation system.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where (Processes.parent_process_name  = "wscript.exe" AND Processes.parent_process = "*//e:vbscript*") OR (Processes.process_name  = "wscript.exe" AND Processes.process = "*//e:vbscript*") by Processes.parent_process_name  Processes.parent_process Processes.process_name Processes.process_id Processes.process  Processes.dest Processes.user | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `vbscript_execution_using_wscript_app_filter`'



<li><a href="#">NAME: Verclsid CLSID Execution

DESCRIPTION:  This analytic is to detect a possible abuse of verclsid to execute malicious  file through generate CLSID. This process is a normal application of windows to  verify the CLSID COM object before it is instantiated by Windows Explorer. This  hunting query can be a good pivot point to analyze what is he CLSID or COM object  pointing too to check if it is a valid application or not.

SEARCH:  '| tstats `security_content_summariesonly` values(Processes.process) as process  values(Processes.parent_process) as parent_process values(Processes.process_id)  as process_id count min(_time) as firstTime max(_time) as lastTime from datamodel=Endpoint.Processes  where `process_verclsid` AND Processes.process="*/S*" Processes.process="*/C*" AND  Processes.process="*{*"  AND Processes.process="*}*" by  Processes.process_name Processes.original_file_name  Processes.dest Processes.user Processes.parent_process_name Processes.parent_process  | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `verclsid_clsid_execution_filter`'



<li><a href="#">NAME: W3WP Spawning Shell

DESCRIPTION:  This query identifies a shell, PowerShell.exe or Cmd.exe, spawning fromW3WP.exe, or IIS. In addition to IIS logs, this behavior with an EDR product willcapture potential webshell activity, similar to the HAFNIUM Group abusing CVEs,on publicly available Exchange mail servers. During triage, review the parent processand child process of the shell being spawned. Review the command-line argumentsand any file modifications that may occur. Identify additional parallel process,child processes, that may highlight further commands executed. After triaging, workto contain the threat and patch the system that is vulnerable.

SEARCH:  '| tstats `security_content_summariesonly` count values(Processes.process_name)as process_name values(Processes.process) as process min(_time) as firstTime max(_time)as lastTime from datamodel=Endpoint.Processes where Processes.parent_process_name=w3wp.exeAND `process_cmd` OR `process_powershell` by Processes.dest Processes.parent_processProcesses.original_file_name Processes.user | `drop_dm_object_name(Processes)` |`security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`| `w3wp_spawning_shell_filter`'



<li><a href="#">NAME: WBAdmin Delete System Backups

DESCRIPTION:  This search looks for flags passed to wbadmin.exe (Windows Backup Administrator  Tool) that delete backup files. This is typically used by ransomware to prevent  recovery.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.process_name=wbadmin.exe  Processes.process="*delete*" AND (Processes.process="*catalog*" OR Processes.process="*systemstatebackup*")  by Processes.process_name Processes.process Processes.parent_process_name Processes.dest  Processes.user | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)`| `wbadmin_delete_system_backups_filter`'



<li><a href="#">NAME: Wbemprox COM Object Execution

DESCRIPTION:  The following analytic identifies a potential suspicious process loading  a COM object from wbemprox.dll or faskprox.dll. The Microsoft Component Object Model  (COM) is a platform-independent, distributed, object-oriented system for creating  binary software components that can interact. This feature is being abused by several  threat actors, adversaries or even red teamers to gain privilege escalation or even  to evade detections. This TTP is a good indicator that a process is loading possible  known .dll modules that were known for its COM object.

SEARCH:  '`sysmon` EventCode=7  ImageLoaded IN ("*\\fastprox.dll", "*\\wbemprox.dll",  "*\\wbemcomn.dll") NOT (process_name IN ("wmiprvse.exe", "WmiApSrv.exe", "unsecapp.exe"))  NOT(Image IN("*\\windows\\*","*\\program files*", "*\\wbem\\*")) | stats count min(_time)  as firstTime max(_time) as lastTime by Image ImageLoaded process_name dest EventCode  Signed ProcessId Hashes IMPHASH | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `wbemprox_com_object_execution_filter`'



<li><a href="#">NAME: Wermgr Process Connecting To IP Check Web Services

DESCRIPTION:  This search is designed to detect suspicious wermgr.exe process that  tries to connect to known IP web services. This technique is know for trickbot and  other trojan spy malware to recon the infected machine and look for its ip address  without so much finger print on the commandline process. Since wermgr.exe is designed  for error handling process of windows it is really suspicious that this process  is trying to connect to this IP web services cause that maybe cause of some malicious  code injection.

SEARCH:  '`sysmon` EventCode =22 process_name = wermgr.exe QueryName IN ("*wtfismyip.com",  "*checkip.amazonaws.com", "*ipecho.net", "*ipinfo.io", "*api.ipify.org", "*icanhazip.com",  "*ip.anysrc.com","*api.ip.sb", "ident.me", "www.myexternalip.com", "*zen.spamhaus.org",  "*cbl.abuseat.org", "*b.barracudacentral.org","*dnsbl-1.uceprotect.net", "*spam.dnsbl.sorbs.net")  |  stats  min(_time) as firstTime max(_time) as lastTime count by Image process_name  ProcessId QueryName QueryStatus QueryResults EventCode Computer | rename Computer as dest | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `wermgr_process_connecting_to_ip_check_web_services_filter`'



<li><a href="#">NAME: Wermgr Process Create Executable File

DESCRIPTION:  this search is designed to detect potential malicious wermgr.exe process  that drops or create executable file. Since wermgr.exe is an application trigger  when error encountered in a process, it is really un ussual to this process to drop  executable file. This technique is commonly seen in trickbot malware where it injects  it code to this process to execute it malicious behavior like downloading other  payload

SEARCH:  '`sysmon` EventCode=11 process_name = "wermgr.exe" TargetFilename = "*.exe"  | stats  min(_time) as firstTime max(_time) as lastTime count by  Image TargetFilename  process_name dest EventCode ProcessId | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `wermgr_process_create_executable_file_filter`'



<li><a href="#">NAME: Wermgr Process Spawned CMD Or Powershell Process

DESCRIPTION:  This search is designed to detect suspicious cmd and powershell process  spawned by wermgr.exe process. This suspicious behavior are commonly seen in code  injection technique technique like trickbot to execute a shellcode, dll modules  to run malicious behavior.

SEARCH:  '| tstats `security_content_summariesonly` values(Processes.process) as cmdline  min(_time) as firstTime max(_time) as lastTime from datamodel=Endpoint.Processes  where Processes.parent_process_name = "wermgr.exe" `process_cmd` OR `process_powershell`  by Processes.parent_process_name  Processes.original_file_name Processes.parent_process_id  Processes.process_name  Processes.process Processes.process_id Processes.process_guid Processes.dest Processes.user  | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `wermgr_process_spawned_cmd_or_powershell_process_filter`'



<li><a href="#">NAME: Wget Download and Bash Execution

DESCRIPTION:  The following analytic identifies the use of wget on Linux or MacOS attempting  to download a file from a remote source and pipe it to bash. This is typically found  with coinminers and most recently with CVE-2021-44228, a vulnerability in Log4j.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.process_name=wget  (Processes.process="*-q *" OR Processes.process="*--quiet*"  AND Processes.process="*-O-  *") OR (Processes.process="*|*" AND Processes.process="*bash*") by Processes.dest  Processes.user Processes.parent_process_name Processes.process_name Processes.process  Processes.process_id Processes.parent_process_id | `drop_dm_object_name(Processes)`  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `wget_download_and_bash_execution_filter`'



<li><a href="#">NAME: Windows Abused Web Services

DESCRIPTION:  The following analytic detects a suspicious process making a DNS query via known,  abused text-paste web services, VoIP, internet via secure tunneling,instant messaging, and digital distribution  platforms used to download external files. This technique is abused by adversaries,  malware actors, and red teams to download a malicious file on the target host. This  is a good TTP indicator for possible initial access techniques. A user will experience  false positives if the following instant messaging is allowed or common applications  like telegram or discord are allowed in the corporate network.

SEARCH:  '`sysmon` EventCode=22 QueryName IN ("*pastebin*",""*textbin*"", "*ngrok.io*", "*discord*", "*duckdns.org*", "*pasteio.com*")   | stats count min(_time) as firstTime max(_time) as lastTime by Image QueryName QueryStatus process_name QueryResults Computer  | rename Computer as dest   | `security_content_ctime(firstTime)`   | `security_content_ctime(lastTime)`   | `windows_abused_web_services_filter`'



<li><a href="#">NAME: Windows Access Token Manipulation SeDebugPrivilege

DESCRIPTION:  The following analytic identifies a suspicious process enabling the "SeDebugPrivilege"  privilege token. SeDebugPrivilege allows a process to inspect and adjust the memory  of other processes, and has long been a security concern. SeDebugPrivilege allows  the token bearer to access any process or thread, regardless of security descriptors,  per Palantir. This technique is abused by adversaries to gain debug privileges with  their malicious software to be able to access or debug a process to dump credentials  or to inject malicious code.

SEARCH:  '`wineventlog_security` EventCode=4703 EnabledPrivilegeList = "*SeDebugPrivilege*"  AND NOT(ProcessName IN ("*\\Program File*", "*\\System32\\lsass.exe*", "*\\SysWOW64\\lsass.exe*",  "*\\SysWOW64\\svchost.exe*", "*\\System32\\svchost.exe*")) | stats count min(_time)  as firstTime max(_time) as lastTime by Computer ProcessName ProcessId SubjectDomainName  SubjectUserName SubjectUserSid TargetUserName TargetLogonId TargetDomainName EnabledPrivilegeList  action | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `windows_access_token_manipulation_sedebugprivilege_filter`'



<li><a href="#">NAME: Windows Access Token Manipulation Winlogon Duplicate Token Handle

DESCRIPTION:  The following analytic identifies a process requesting access to winlogon.exe  attempting to duplicate its handle. This technique was seen in several adversaries  to gain privileges for their process. Winlogon.exe is the common targeted process  of this technique because it contains high privileges and security tokens.

SEARCH:  '`sysmon` EventCode=10 TargetImage IN("*\\system32\\winlogon.exe*", "*\\SysWOW64\\winlogon.exe*")  GrantedAccess = 0x1040 | stats count min(_time) as firstTime max(_time) as lastTime  by SourceImage TargetImage SourceProcessGUID TargetProcessGUID SourceProcessId TargetProcessId  GrantedAccess CallTrace dest user_id | `security_content_ctime(firstTime)` |  `security_content_ctime(lastTime)` | `windows_access_token_manipulation_winlogon_duplicate_token_handle_filter`'



<li><a href="#">NAME: Windows Access Token Winlogon Duplicate Handle In Uncommon Path

DESCRIPTION:  The following analytic identifies a process requesting access in winlogon.exe  to duplicate its handle with a non-common or public process source path. This technique  was seen where adversaries attempt to gain privileges to their process. This duplicate  handle access technique, may refer to a malicious process duplicating the process  token of winlogon.exe and using it to a new process instance. Winlogon.exe is the  common targeted process of this technique because it contains high privileges and  security tokens.

SEARCH:  '`sysmon` EventCode=10  TargetImage IN("*\\system32\\winlogon.exe*", "*\\SysWOW64\\winlogon.exe*")  AND GrantedAccess = 0x1040 AND NOT (SourceImage IN("C:\\Windows\\*", "C:\\Program  File*", "%systemroot%\\*")) | stats count min(_time) as firstTime max(_time) as  lastTime by Computer SourceImage TargetImage SourceProcessGUID TargetProcessGUID SourceProcessId  TargetProcessId GrantedAccess CallTrace | rename Computer as dest| `security_content_ctime(firstTime)` |  `security_content_ctime(lastTime)` | `windows_access_token_winlogon_duplicate_handle_in_uncommon_path_filter`'



<li><a href="#">NAME: Windows Account Discovery for None Disable User Account

DESCRIPTION:  The following analytic utilizes PowerShell Script Block Logging to identify  the execution of the PowerView PowerShell commandlet Get-NetUser. In the context  of PowerView's Get-NetUser cmdlet as a filter or parameter to query Active Directory  user accounts that are not disabled. The full script block text based on the CISA-23-347A advisory is "Get-NetUser -UACFilter NOT_ACCOUNTDISABLE". Utilize this query to identify potential suspicious activity of user account enumeration.

SEARCH:  '`powershell` EventCode=4104  ScriptBlockText = "*Get-NetUser*" ScriptBlockText = "*NOT_ACCOUNTDISABLE*" ScriptBlockText = "*-UACFilter*"   | rename Computer as dest, UserID as user  | stats count min(_time) as firstTime max(_time) as lastTime by EventCode ScriptBlockText dest user  | `security_content_ctime(firstTime)`   | `security_content_ctime(lastTime)`   | `windows_account_discovery_for_none_disable_user_account_filter`'



<li><a href="#">NAME: Windows Account Discovery for Sam Account Name

DESCRIPTION:  The following analytic leverages Event ID 4104 to identify the execution of the PowerView powershell commandlets Get-NetUser.  In the context of PowerView's Get-NetUser cmdlet as a filter or parameter   to query Active Directory user account's "samccountname". This hunting query is a good pivot to look for suspicious process   or malware that gather user account information in a host or within network system. 

SEARCH:  '`powershell` EventCode=4104  ScriptBlockText = "*Get-NetUser*" ScriptBlockText IN ("*samaccountname*", "*pwdlastset*")  | rename Computer as dest, UserID as user  | stats count min(_time) as firstTime max(_time) as lastTime by EventCode ScriptBlockText dest user  | `security_content_ctime(firstTime)`   | `security_content_ctime(lastTime)`   | `windows_account_discovery_for_sam_account_name_filter`'



<li><a href="#">NAME: Windows Account Discovery With NetUser PreauthNotRequire

DESCRIPTION:  The following analytic leverages Event ID 4104 to identify the execution of the PowerView powershell commandlets Get-NetUser.   This technique was observed in the context of PowerView's Get-NetUser cmdlet as a filter or parameter  to query Active Directory user accounts that do not require preauthentication for Kerberos. This hunting query is a good pivot to look for suspicious process   or malware that gather user account information in a host or within network system. 

SEARCH:  '`powershell` EventCode=4104  ScriptBlockText = "*Get-NetUser*" ScriptBlockText = "*-PreauthNotRequire*"  | rename Computer as dest, UserID as user  | stats count min(_time) as firstTime max(_time) as lastTime by EventCode ScriptBlockText dest user  | `security_content_ctime(firstTime)`   | `security_content_ctime(lastTime)`   | `windows_account_discovery_with_netuser_preauthnotrequire_filter`'



<li><a href="#">NAME: Windows AdFind Exe

DESCRIPTION:  'This search looks for the execution of `adfind.exe` with command-line  arguments that it uses by default specifically the filter or search functions. It  also considers the arguments necessary like objectcategory, see readme for more  details: https://www.joeware.net/freetools/tools/adfind/usage.htm. AdFind.exe is  a powerful tool that is commonly used for querying and retrieving information from  Active Directory (AD). While it is primarily designed for AD administration and  management, it has been seen used before by Wizard Spider, FIN6 and actors whom  also launched SUNBURST.'

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where (Processes.process="* -f *"  OR Processes.process="* -b *") AND (Processes.process=*objectcategory* OR Processes.process="*  -gcb *" OR Processes.process="* -sc *") by Processes.dest Processes.user Processes.process_name  Processes.process Processes.parent_process Processes.process_id Processes.parent_process_id  | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `windows_adfind_exe_filter`'



<li><a href="#">NAME: Windows Administrative Shares Accessed On Multiple Hosts

DESCRIPTION:  The following analytic leverages Event IDs 5140 or 5145 to identify a  source computer accessing windows administrative shares (C$, Admin$ and IPC$ ) across  a large number remote endpoints. Specifically, the logic will trigger when a source  endpoint accesses administrative shares across 30 or more target computers within  a 5 minute timespan. This behavior could represent an adversary who is enumerating  network shares across an Active Directory environment in the search for sensitive  files, a common technique leveraged by red teamers and threat actors. As environments  differ across organizations, security teams should customize the thresholds of this  detection as needed.

SEARCH:  ' `wineventlog_security` EventCode=5140 OR EventCode=5145 (ShareName="\\\\*\\ADMIN$"  OR ShareName="\\\\*\\IPC$" OR ShareName="\\\\*\\C$") | bucket span=5m _time | stats  dc(Computer) AS unique_targets values(Computer) as host_targets values(ShareName)  as shares by _time, IpAddress, SubjectUserName, EventCode | where unique_targets  > 30 | `windows_administrative_shares_accessed_on_multiple_hosts_filter`'



<li><a href="#">NAME: Windows Admin Permission Discovery

DESCRIPTION:  This analytic is developed to identify suspicious file creation in the root drive (C:\).   This tactic was observed in NjRAT as a means to ascertain whether its malware instance running on   the compromised host possesses administrative privileges.  The methodology involves an attempt to create a 'win.dat' file in the C:\ directory.   If this file is successfully created, it serves as an indicator that the process indeed holds administrative privileges.  This anomaly detection mechanism serves as a valuable pivot point for detecting NjRAT and other malware strains employing   similar techniques to assess the privileges of their running malware instances, without using token privilege API calls or PowerShell commandlets.

SEARCH:  '|tstats `security_content_summariesonly` count min(_time) as firstTime max(_time) as lastTime from datamodel=Endpoint.Filesystem   where Filesystem.file_name IN ("*.exe", "*.dll", "*.sys", "*.com", "*.vbs", "*.vbe", "*.js", "*.bat", "*.cmd", "*.pif", "*.lnk", "*.dat")   by Filesystem.dest Filesystem.file_create_time Filesystem.process_id Filesystem.process_guid Filesystem.file_name Filesystem.file_path Filesystem.user   | `drop_dm_object_name(Filesystem)`   | eval dropped_file_path = split(file_path, "\\")   | eval dropped_file_path_split_count = mvcount(dropped_file_path)   | eval root_drive = mvindex(dropped_file_path,0) | where LIKE(root_drive, "C:") AND dropped_file_path_split_count = 2    | `security_content_ctime(firstTime)`   | `security_content_ctime(lastTime)`   | `windows_admin_permission_discovery_filter`'



<li><a href="#">NAME: Windows Admon Default Group Policy Object Modifieddata_source : []

DESCRIPTION:  The following analytic leverages Splunks Admon to identify the modification of a default Group Policy Object. A fresh installation of an Active Directory network will typically contain  two default group policy objects `Default Domain Controllers Policy` and `Default Domain Policy`. The default domain controllers policy is used to enforce and set policies to all the domain controllers within the domain environment.  The default domain policy is linked to all users and computers by default. An adversary who has obtained privileged access to an Active Directory network may modify the default group   policy objects to obtain further access, deploy persistence or execute malware across a large number of hosts. Security teams should monitor the modification of the default GPOs.

SEARCH:  ' `admon` admonEventType=Update objectCategory="CN=Group-Policy-Container,CN=Schema,CN=Configuration,DC=*" (displayName="Default Domain Policy" OR displayName="Default Domain Controllers Policy")  | stats min(_time) as firstTime max(_time) as lastTime values(gPCFileSysPath) by dcName, displayName  | `security_content_ctime(firstTime)`   | `security_content_ctime(lastTime)`  | `windows_admon_default_group_policy_object_modified_filter`'



<li><a href="#">NAME: Windows Admon Group Policy Object Createddata_source : []

DESCRIPTION:  The following analytic leverages Splunks Admon to identify the creation of a new Group Policy Object. With GPOs, system administrators can manage and configure   applications, software operations, and user settings throughout an entire organization. GPOs can be abused and leveraged by adversaries to escalate privileges or   deploy malware across an Active Directory network. As an example, the Lockbit ransomware malware will create new group policies on the domain controller that are then pushed out to every device on the network.  Security teams should monitor the creation of new Group Policy Objects.

SEARCH:  ' `admon` admonEventType=Update objectCategory="CN=Group-Policy-Container,CN=Schema,CN=Configuration,DC=*" versionNumber=0 displayName!="New Group Policy Object"  | stats min(_time) as firstTime max(_time) as lastTime values(gPCFileSysPath) by dcName, displayName  | `security_content_ctime(firstTime)`   | `security_content_ctime(lastTime)`  | `windows_admon_group_policy_object_created_filter`'



<li><a href="#">NAME: Windows AD Abnormal Object Access Activity

DESCRIPTION:  Windows Active Directory contains numerous objects. A statistically significant increase in access to these objects may be evidence of attacker enumeration of Active Directory.

SEARCH:  '`wineventlog_security` EventCode=4662  | stats min(_time) AS firstTime, max(_time) AS lastTime, dc(ObjectName) AS ObjectName_count, values(ObjectType) AS ObjectType, latest(Computer) AS dest count BY SubjectUserName| eventstats avg(ObjectName_count) AS average stdev(ObjectName_count) AS standarddev| eval limit = round((average+(standarddev*3)),0), user = SubjectUserName | where ObjectName_count > limit| `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`| `windows_ad_abnormal_object_access_activity_filter`'



<li><a href="#">NAME: Windows AD AdminSDHolder ACL Modified

DESCRIPTION:  The following analytic identifies the modification of the Access Control List for the AdminSDHolder object within a Windows domain. Specifically, the   detection triggers on the addition of a new rule to the existing ACL. AdminSDHolder is an object located in the System Partition in Active Directory and is used as a   security template for objects that are members of certain privileged groups. Objects in these groups are enumerated and any objects with security descriptors that dont   match the AdminSDHolder ACL are flagged for updating. The Security Descriptor propagator (SDProp) process runs every 60 minutes on the PDC Emulator and re-stamps the object  Access Control List (ACL) with the security permissions set on the AdminSDHolder. An adversary who has obtained privileged access to a Windows Domain may modify the AdminSDHolder  ACL to establish persistence and allow an unprivileged user to take control of a domain.

SEARCH:  ' `wineventlog_security` EventCode=5136 AttributeLDAPDisplayName=nTSecurityDescriptor OperationType="%%14674" ObjectDN="CN=AdminSDHolder,CN=System*"  | rex field=AttributeValue max_match=10000 "A;;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;(?P<added_user_sid>S-1-[0-59]-\d{2}-\d{8,10}-\d{8,10}-\d{8,10}-[1-9]\d{3})\)"  | stats values(added_user_sid) by _time, Computer, SubjectUserName, ObjectDN  | `windows_ad_adminsdholder_acl_modified_filter`'



<li><a href="#">NAME: Windows AD Cross Domain SID History Addition

DESCRIPTION:  The following analytic looks for changes to the sIDHistory AD attribute of user or computer objects within different domains.  The SID history AD attribute allows users to inherit permissions from a separate AD account without group changes. Initially developed for access continuity when migrating user accounts to different domains, this attribute can also be abused by adversaries for inter-domain privilege escalation and persistence. 

SEARCH:  '`wineventlog_security` (EventCode=4742 OR EventCode=4738) NOT SidHistory IN ("%%1793", -) | rex field=SidHistory "(^%{|^)(?P<SidHistoryMatch>.*)(\-|\\\)" | rex field=TargetSid "^(?P<TargetSidmatch>.*)(\-|\\\)" | where SidHistoryMatch!=TargetSidmatch AND SidHistoryMatch!=TargetDomainName | rename TargetSid as userSid | table _time action status host user userSid SidHistory Logon_ID src_user | `windows_ad_cross_domain_sid_history_addition_filter`'



<li><a href="#">NAME: Windows AD Domain Controller Audit Policy Disabled

DESCRIPTION:  The following analytic detects the disabling of audit policies on a domain controller. The detection is made by identifying changes made to audit policies and checks for the removal of success or failure auditing, which are common indicators of policy tampering. The detection is important because it indicates that an attacker has gained access to the domain controller and is attempting to evade detection and cover up malicious activity. The impact of such an attack can be severe, including data theft, privilege escalation, and compromise of the entire network. False positives might occur since legitimate changes to audit policies might also trigger the analytic. Upon triage, review the audit policy change event and investigate the source of the change. Additionally, you must capture and inspect any relevant on-disk artifacts and review concurrent processes to identify the attack source."

SEARCH:  '`wineventlog_security` EventCode=4719 (AuditPolicyChanges IN ("%%8448","%%8450","%%8448,  %%8450") OR Changes IN ("Failure removed","Success removed","Success removed, Failure  removed")) dest_category="domain_controller"| replace "%%8448" with "Success removed",  "%%8450" with "Failure removed", "%%8448, %%8450" with "Success removed, Failure  removed" in AuditPolicyChanges | eval AuditPolicyChanges=coalesce(AuditPolicyChanges,Changes),  SubcategoryGuid=coalesce(SubcategoryGuid,Subcategory_GUID) | stats min(_time) as  _time values(host) as dest by AuditPolicyChanges SubcategoryGuid | lookup advanced_audit_policy_guids  GUID as SubcategoryGuid OUTPUT Category SubCategory | `windows_ad_domain_controller_audit_policy_disabled_filter`'



<li><a href="#">NAME: Windows AD Domain Controller Promotion

DESCRIPTION:  This analytic identifies a genuine DC promotion event. Identifying when a computer assigns itself the   necessary SPNs to function as a domain controller. Note these events are triggered on the existing domain controllers, not the newly   joined domain controller. This detection will serve to identify rogue DCs added to the network. There are 2x detections within this analytic story   which identify DCShadow attacks, if you do not currently possess the logging for these detections, remove the where clause within this   detection to identify DCShadow activity.  

SEARCH:  "`wineventlog_security` EventCode=4742 ServicePrincipalNames IN (\"*E3514235-4B06-11D1-AB04-00C04FC2DCD2/*\",\"*GC/*\")| stats min(_time) as _time latest(ServicePrincipalNames) as ServicePrincipalNames,values(signature) as signature, values(src_user) as src_user, values(user) as user by Logon_ID, dvc| where src_user=user| rename Logon_ID as TargetLogonId, user as dest | appendpipe [| map search=\"search `wineventlog_security` EventCode=4624 TargetLogonId=$TargetLogonId$\" | fields - dest, dvc, signature]| stats min(_time) as _time, values(TargetUserSid) as TargetUserSid, values(Target_Domain) as Target_Domain, values(user) as user, values(status) as status, values(src_category) as src_category, values(src_ip) as src_ip values(ServicePrincipalNames) as ServicePrincipalNames values(signature) as signature values(dest) as dest values(dvc) as dvc by TargetLogonId | eval dest=trim(dest,\"$\") | `windows_ad_domain_controller_promotion_filter`"



<li><a href="#">NAME: Windows AD Domain Replication ACL Addition

DESCRIPTION:   The following analytic detects the addition of the permissions necessary to perform a DCSync attack.  In order to replicate AD objects, the initiating user or computer must have the following permissions on the domain.  - DS-Replication-Get-Changes  - DS-Replication-Get-Changes-All  Certain Sync operations may require the additional permission of DS-Replication-Get-Changes-In-Filtered-Set.  By default, adding DCSync permissions via the Powerview Add-ObjectACL operation adds all 3. This alert identifies where this trifecta has been met, and also where just the base level requirements have been met.

SEARCH:  '`wineventlog_security`  | rex field=AttributeValue max_match=10000 \"OA;;CR;89e95b76-444d-4c62-991a-0facbeda640c;;(?P<DSRGetChangesFiltered_user_sid>S-1-[0-59]-\d{2}-\d{8,10}-\d{8,10}-\d{8,10}-[1-9]\d{3})\)\"| table _time dest src_user DSRGetChanges_user_sid DSRGetChangesAll_user_sid DSRGetChangesFiltered_user_sid| mvexpand DSRGetChanges_user_sid| eval minDCSyncPermissions=if(DSRGetChanges_user_sid=DSRGetChangesAll_user_sid,\"true\",\"false\"), fullSet=if(DSRGetChanges_user_sid=DSRGetChangesAll_user_sid AND DSRGetChanges_user_sid=DSRGetChangesFiltered_user_sid,\"true\",\"false\")| where minDCSyncPermissions=\"true\" | lookup identity_lookup_expanded  objectSid as DSRGetChanges_user_sid OUTPUT sAMAccountName as user | rename DSRGetChanges_user_sid as userSid | stats min(_time) as _time values(user) as user by dest src_user userSid minDCSyncPermissions fullSet| `windows_ad_domain_replication_acl_addition_filter`'



<li><a href="#">NAME: Windows AD DSRM Account Changes

DESCRIPTION:  Aside from being used to promote genuine domain controllers, the DSRM  (Directory Services Restore Mode) account can be used to persist within a Domain.  A DC can be configured to allow the DSRM account to logon & be used in the same  way as a local administrator account. This detection is looking for alterations  to the behaviour of the account via registry.

SEARCH:  '| tstats `security_content_summariesonly` min(_time) as _time from datamodel=Endpoint.Registry  where Registry.registry_path= "*\\System\\CurrentControlSet\\Control\\Lsa\\DSRMAdminLogonBehavior"  Registry.registry_value_data IN ("*1","*2") by Registry.action Registry.registry_path  Registry.registry_value_data Registry.registry_value_type Registry.process_guid Registry.dest Registry.user  | `drop_dm_object_name(Registry)` | join type=outer process_guid [| tstats `security_content_summariesonly`  count FROM datamodel=Endpoint.Processes by Processes.user Processes.process_name  Processes.process Processes.dest Processes.parent_process_name Processes.parent_process  Processes.process_guid | `drop_dm_object_name(Processes)`] | table _time action  dest user parent_process_name parent_process process_name process process_guid registry_path  registry_value_data registry_value_type | `windows_ad_dsrm_account_changes_filter`'



<li><a href="#">NAME: Windows AD DSRM Password Reset

DESCRIPTION:  Aside from being used to promote genuine domain controllers, the DSRM (Directory Services Restore Mode)  account can be used to persist within a Domain. A DC can be configured to allow the DSRM account to logon & be used in the same way as a local administrator account. This detection is looking for any password reset attempts against that account. 

SEARCH:  '| tstats `security_content_summariesonly` min(_time) as _time from datamodel=Change  where All_Changes.result_id="4794" AND All_Changes.result="An attempt was made to  set the Directory Services Restore Mode administrator password" by All_Changes.action,   All_Changes.dest, All_Changes.src, All_Changes.user  | `drop_dm_object_name(All_Changes)` | `windows_ad_dsrm_password_reset_filter`'



<li><a href="#">NAME: Windows AD Privileged Account SID History Addition

DESCRIPTION:   This detection identifies when the SID of a privileged user is added to  the SID History attribute of another user. Useful for tracking SID history abuse  across multiple domains. This detection leverages the Asset and Identities  framework. See the implementation section for further details on configuration.

SEARCH:   '`wineventlog_security` (EventCode=4742 OR EventCode=4738) NOT SidHistory IN ("%%1793", -)  | rex field=SidHistory "(^%{|^)(?P<SidHistory>.*?)(}$|$)"  | eval category="privileged"  | lookup identity_lookup_expanded category, identity as SidHistory OUTPUT identity_tag as match  | where isnotnull(match)  | rename TargetSid as userSid  | table _time action status host user userSid SidHistory Logon_ID src_user  | `windows_ad_privileged_account_sid_history_addition_filter`'



<li><a href="#">NAME: Windows AD Privileged Object Access Activity

DESCRIPTION:  Windows Active Directory contains numerous objects that grant elevated access to the domain they reside in. These objects should be rarely accessed by normal users or processes. Access attempts to one or more of these objects may be evidence of attacker enumeration of Active Directory.

SEARCH:  '`wineventlog_security` EventCode=4662 ObjectName IN ("CN=Account Operators,*","CN=Administrators,*","CN=Backup Operators,*","CN=Cert Publishers,*","CN=Certificate Service DCOM Access,*","CN=Domain Admins,*","CN=Domain Controllers,*","CN=Enterprise Admins,*","CN=Enterprise Read-only Domain Controllers,*","CN=Group Policy Creator Owners,*","CN=Incoming Forest Trust Builders,*","CN=Microsoft Exchange Servers,*","CN=Network Configuration Operators,*","CN=Power Users,*","CN=Print Operators,*","CN=Read-only Domain Controllers,*","CN=Replicators,*","CN=Schema Admins,*","CN=Server Operators,*","CN=Exchange Trusted Subsystem,*","CN=Exchange Windows Permission,*","CN=Organization Management,*")| rex field=ObjectName "CN\=(?<object_name>[^,]+)" | stats values(Computer) as dest, values(object_name) as object_name, dc(ObjectName) as object_count, min(_time) as firstTime, max(_time) as lastTime, count by SubjectUserName| rename SubjectUserName as user| `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`| `windows_ad_privileged_object_access_activity_filter`'



<li><a href="#">NAME: Windows AD Replication Request Initiated by User Account

DESCRIPTION:  This alert was written to detect activity associated with the DCSync attack.  When a domain controller receives a replication request, the user account permissions are validated, however no checks are performed to validate the request was initiated by a Domain Controller. Once an attacker gains control of an account with the necessary privileges, they can request password hashes for any or all users within the domain. This alert detects when a user account creates a handle to domainDNS with the necessary replication permissions. 

SEARCH:  '`wineventlog_security` EventCode=4662 ObjectType IN ("%{19195a5b-6da0-11d0-afd3-00c04fd930c9}", "domainDNS") AND Properties IN ("*Replicating Directory Changes All*", "*{1131f6ad-9c07-11d1-f79f-00c04fc2dcd2}*", "*{9923a32a-3607-11d2-b9be-0000f87a36b2}*","*{1131f6ac-9c07-11d1-f79f-00c04fc2dcd2}*") AND AccessMask="0x100" AND NOT (SubjectUserSid="NT AUT*" OR SubjectUserSid="S-1-5-18" OR SubjectDomainName="Window Manager" OR SubjectUserName="*$") | stats min(_time) as _time, count by SubjectDomainName, SubjectUserName, Computer, Logon_ID, ObjectName, ObjectServer, ObjectType, OperationType, status | rename SubjectDomainName as Target_Domain, SubjectUserName as user, Logon_ID as TargetLogonId, _time as attack_time | appendpipe [| map search="search `wineventlog_security` EventCode=4624 TargetLogonId=$TargetLogonId$"] | table attack_time, AuthenticationPackageName, LogonProcessName, LogonType, TargetUserSid, Target_Domain, user, Computer, TargetLogonId, status, src_ip, src_category, ObjectName, ObjectServer, ObjectType, OperationType | stats min(attack_time) as _time values(TargetUserSid) as TargetUserSid, values(Target_Domain) as Target_Domain, values(user) as user, values(Computer) as Computer, values(status) as status, values(src_category) as src_category, values(src_ip) as src_ip by TargetLogonId | `windows_ad_replication_request_initiated_by_user_account_filter`'



<li><a href="#">NAME: Windows AD Replication Request Initiated from Unsanctioned Location

DESCRIPTION:  This alert was written to detect activity associated with the DCSync attack performed by computer accounts. When a domain controller receives a replication request, the account permissions are validated, however no checks are performed to validate the request was initiated by a Domain Controller. Once an attacker gains control of an account with the necessary privileges, they can request password hashes for any or all users within the domain. This alert detects when a computer account account creates a handle to domainDNS with the necessary replication permissions. These requests are then filtered to exclude where the events originate  from a known domain controller IP address.   

SEARCH:  '`wineventlog_security` EventCode=4662 ObjectType IN ("%{19195a5b-6da0-11d0-afd3-00c04fd930c9}",    "domainDNS") AND Properties IN ("*Replicating Directory Changes All*", "*{1131f6ad-9c07-11d1-f79f-00c04fc2dcd2}*",    "*{9923a32a-3607-11d2-b9be-0000f87a36b2}*","*{1131f6ac-9c07-11d1-f79f-00c04fc2dcd2}*")    AND AccessMask="0x100" AND (SubjectUserSid="NT AUT*" OR SubjectUserSid="S-1-5-18" OR SubjectDomainName="Window Manager" OR SubjectUserName="*$") | stats min(_time) as attack_time, count by SubjectDomainName, SubjectUserName, Computer, Logon_ID, ObjectName, ObjectServer, ObjectType, OperationType, status | rename SubjectDomainName as Target_Domain, SubjectUserName as user, Logon_ID as    TargetLogonId | appendpipe     [| map search="search `wineventlog_security` EventCode=4624 TargetLogonId=$TargetLogonId$"] | table attack_time, AuthenticationPackageName, LogonProcessName, LogonType, TargetUserSid,    Target_Domain, user, Computer, TargetLogonId, status, src_ip, src_category, ObjectName,    ObjectServer, ObjectType, OperationType | stats min(attack_time) as _time, values(TargetUserSid) as TargetUserSid, values(Target_Domain)    as Target_Domain, values(user) as user, values(Computer) as Computer, values(status)    as status, values(src_category) as src_category, values(src_ip) as src_ip by TargetLogonId | search NOT src_category="domain_controller" | `windows_ad_replication_request_initiated_from_unsanctioned_location_filter`'



<li><a href="#">NAME: Windows AD Replication Service Traffic

DESCRIPTION:   This search looks for evidence of Active Directory replication traffic [MS-DRSR] from unexpected sources.  This traffic is often seen exclusively between Domain Controllers for AD database replication.  Any detections from non-domain controller source to a domain controller may indicate the usage of DCSync or DCShadow credential dumping techniques.

SEARCH:   '| tstats `security_content_summariesonly` count values(All_Traffic.transport) as transport values(All_Traffic.user) as user  values(All_Traffic.src_category) as src_category values(All_Traffic.dest_category) as dest_category min(_time) as firstTime max(_time) as lastTime  from datamodel=Network_Traffic where All_Traffic.app IN ("ms-dc-replication","*drsr*","ad drs") by All_Traffic.src All_Traffic.dest All_Traffic.app  | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)`  | `drop_dm_object_name("All_Traffic")`  | `windows_ad_replication_service_traffic_filter`'



<li><a href="#">NAME: Windows AD Rogue Domain Controller Network Activity

DESCRIPTION:   This detection is looking at zeek wiredata for specific replication RPC calls being performed from a device which is not a domain controller.  

SEARCH:  '`zeek_rpc` DrsReplicaAdd OR DRSGetNCChanges  | where NOT (dest_category="Domain Controller") OR NOT (src_category="Domain Controller")  | fillnull value="Unknown" src_category, dest_category  | table _time endpoint operation src src_category dest dest_category | `windows_ad_rogue_domain_controller_network_activity_filter`'



<li><a href="#">NAME: Windows AD Same Domain SID History Addition

DESCRIPTION:  The following analytic looks for changes to the sIDHistory AD attribute of user or computer objects which exist within the same domain.  The SID history AD attribute allows users to inherit permissions from a separate AD account without group changes. Initially developed for access continuity when migrating user accounts to different domains, this attribute can also be abused by adversaries to stealthily grant access to a backdoor account within the same domain.  This analytic was written to pick up on activity via Mimikatz sid::patch. Please note there are additional avenues to abuse SID history such as DCShadow & Golden / Diamond tickets which won't be detected using these event codes.

SEARCH:  '`wineventlog_security` (EventCode=4742 OR EventCode=4738) NOT SidHistory  IN ("%%1793", -)  | rex field=SidHistory "(^%{|^)(?P<SidHistoryMatch>.*)(\-|\\\)"  | rex field=TargetSid "^(?P<TargetSidmatch>.*)(\-|\\\)"  | where SidHistoryMatch=TargetSidmatch OR SidHistoryMatch=TargetDomainName  | rename TargetSid as userSid, TargetDomainName as userDomainName  | table _time action status host user userSid userDomainName SidHistory Logon_ID src_user   | `windows_ad_same_domain_sid_history_addition_filter`'



<li><a href="#">NAME: Windows AD ServicePrincipalName Added To Domain Account

DESCRIPTION:  The following analytic identifies the addition of a Service Principal Name to a domain account. While this event may be part of a legitimate action part of certain administrative operations,  it may also be evidence of a persistence attack. Domain accounts with Servce Principal Names are vulnerable to a technique called Kerberoasting that enables attackers to potentially obtain the cleartext password   of the account by performing offline cracking. An adversary who has obtained privileged access to a domain environment may add an SPN to a privileged account to then leverage the Kerberoasting technique and attempt  to obtain its clertext password. 

SEARCH:  ' `wineventlog_security` EventCode=5136 AttributeLDAPDisplayName=servicePrincipalName OperationType="%%14674"  | stats values(ObjectDN) as ObjectDN by _time, Computer, SubjectUserName, AttributeValue | rename Computer as dest SubjectUserName as user  | `windows_ad_serviceprincipalname_added_to_domain_account_filter`'



<li><a href="#">NAME: Windows AD Short Lived Domain Account ServicePrincipalName

DESCRIPTION:  The following analytic identifies the addition of a Service Principal Name to a domain account that is quickly deleted within 5 minutes or less. While this event may be part of a legitimate action part of certain administrative operations,  it may also be evidence of a persistence attack. Domain accounts with Service Principal Names are vulnerable to a technique called Kerberoasting that enables attackers to potentially obtain the cleartext password   of the account by performing offline cracking. An adversary who has obtained privileged access to a domain environment may add an SPN to a privileged account to then leverage the Kerberoasting technique and attempt  to obtain its clertext password. To clean things up, the adversary may delete the SPN which will trigger this detection.

SEARCH:  ' `wineventlog_security` EventCode=5136 AttributeLDAPDisplayName=servicePrincipalName  | transaction ObjectDN AttributeValue startswith=(EventCode=5136 OperationType="%%14674") endswith=(EventCode=5136 OperationType="%%14675")  | eval short_lived=case((duration<300),"TRUE")   | search short_lived = TRUE | rename ObjectDN as user  | `windows_ad_short_lived_domain_account_serviceprincipalname_filter`'



<li><a href="#">NAME: Windows AD Short Lived Domain Controller SPN Attribute

DESCRIPTION:  The following analytic identifies when either a global catalog SPN or a DRS RPC SPN are temporarily added to an Active Directory computer object, both of which can be evidence of a DCShadow attack.    DCShadow allows an attacker who has obtained privileged access to register a rogue Domain Controller (DC). Once registered, the rogue DC may be able to inject  and replicate changes into the AD infrastructure for any domain object, including credentials and keys. This technique was initially released in 2018 by security researchers Benjamin Delpy and Vincent Le Toux.  No event logs are written for changes to AD attributes, allowing for stealthy backdoors to be implanted in the domain, or metadata such as timestamps overwritten to cover tracks. 

SEARCH:  '`wineventlog_security` EventCode=5136 AttributeLDAPDisplayName=servicePrincipalName (AttributeValue="GC/*" OR AttributeValue="E3514235-4B06-11D1-AB04-00C04FC2DCD2/*") | stats min(_time) as _time range(_time) as duration values(OperationType) as OperationType values(user) as user values(src_ip) as src_ip values(src_nt_domain) as src_nt_domain values(src_user) as src_user values(Computer) as dest, values(ObjectDN) as ObjectDN by Logon_ID | eval short_lived=case((duration<30),"TRUE") | where short_lived="TRUE" AND mvcount(OperationType)>1 | replace "%%14674" with "Value Added", "%%14675" with "Value Deleted" in OperationType | rename Logon_ID as TargetLogonId | appendpipe [| map search="search `wineventlog_security` EventCode=4624 TargetLogonId=$TargetLogonId$"] | stats min(_time) as _time, values(ObjectDN) as ObjectDN values(OperationType) as OperationType by TargetLogonId src_user dest | `windows_ad_short_lived_domain_controller_spn_attribute_filter`' 



<li><a href="#">NAME: Windows AD Short Lived Server Object

DESCRIPTION:  'The following analytic identifies a change in an Active Directory environment that could represent evidence of the DCShadow attack.    DCShadow allows an attacker who has obtained privileged access to register a rogue Domain Controller (DC). Once registered, the rogue DC may be able to inject  and replicate changes in the AD infrastructure for any domain object, including credentials and keys. This technique was initially released in 2018 by security   researchers Benjamin Delpy and Vincent Le Toux. Specifically, the detection will trigger when a possible rogue Domain Controller  computer object is created and quickly deleted within 30 seconds or less in an Active Directory domain. This behavior was identfied by simulating the DCShadow attack with  Mimikatz.'

SEARCH:  ' `wineventlog_security` EventCode=5137 OR EventCode=5141 ObjectDN="*CN=Servers,CN=Default-First-Site-Name,CN=Sites,CN=Configuration*"  | transaction ObjectDN startswith=(EventCode=5137) endswith=(EventCode=5141)   | eval short_lived=case((duration<30),"TRUE")   | search short_lived = TRUE  | stats values(ObjectDN) values(signature) values(EventCode) by _time, Computer, SubjectUserName  | `windows_ad_short_lived_server_object_filter`'



<li><a href="#">NAME: Windows AD SID History Attribute Modified

DESCRIPTION:  The following analytic leverages event code `5136` to identify a modification of the SID History AD attribute.   The SID history AD attribute allows users to inherit permissions from a separate AD account without group changes. Initially developed for access  continuity when migrating user accounts to different domains, this attribute can also be abused by adversaries to stealthily grant access to a backdoor account within the same domain. 

SEARCH:  ' `wineventlog_security` EventCode=5136 AttributeLDAPDisplayName=sIDHistory OperationType="%%14674"  | stats values(ObjectDN) by _time, Computer, SubjectUserName, AttributeValue  | `windows_ad_sid_history_attribute_modified_filter`'



<li><a href="#">NAME: Windows Alternate DataStream - Base64 Content

DESCRIPTION:  This analytic leverages Sysmon Event ID 15, a critical file creation event, to detect the creation of Alternate Data Streams (ADS) on Windows systems. ADS is a feature of the NTFS file system that allows the storage of data in hidden streams attached to files. These streams are not visible in standard file listings, making them a popular technique for concealing malicious activity. Event ID 15 captures both the hash of the primary file content (unnamed stream) and the content of any additional named streams, which can include executables, scripts, or configuration data. Malware often exploits ADS to hide payloads, leveraging browser downloads to attach a Zone.Identifier stream, marking the file as originating from the Internet (Mark Of The Web, MOTW). This analytic is designed to identify such misuse by analyzing the content and creation patterns of named streams, including those under 1KB which may contain MOTW information. It is essential for detecting sophisticated threats that utilize non-executable file types or conceal malicious scripts within ADS, beyond the traditional focus on PE executables. The detection process involves monitoring for the creation of named streams, which are part of the NTFS structure and can be examined using tools like PowerShell for the presence of additional data streams or MOTW information. This approach helps in uncovering hidden payloads and tracking the origin of suspicious files downloaded via browsers or email clients, providing a comprehensive defense against ADS abuse.

SEARCH:  '`sysmon` EventCode=15 NOT Contents IN ("-","[ZoneTransfer]*")  | regex TargetFilename="(?<!\/)\b\w+(\.\w+)?:\w+(\.\w+)?$"  | regex Contents="(?:[A-Za-z0-9+/]{128,})(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$"  | eval file_name = replace(TargetFilename,"(.*\\\)",""), process = Image , file_path = TargetFilename , base64 = Contents, file_hash = coalesce(SHA256,SHA1,MD5,Hash)  | stats count min(_time) as firstTime max(_time) as lastTime values(user) as user by dest, process, process_guid, file_name, file_path, file_hash, base64  | `base64decode(base64)`   | fields - base64   | rename base64_decode as command   | `security_content_ctime(firstTime)`   | `security_content_ctime(lastTime)`  | `windows_alternate_datastream___base64_content_filter`'



<li><a href="#">NAME: Windows Alternate DataStream - Executable Content

DESCRIPTION:  This analytic is designed to detect when data, possessing an IMPHASH value, is written to an Alternate Data Stream (ADS) in the NTFS file system. The presence of an IMPHASH value suggests that the written data has a Portable Executable (PE) structure, indicating its potential to be executed. Such behavior could be a sign of a threat actor staging malicious code within hard-to-detect areas of the file system for future use or persistence. It's important to note that for this analytic to function correctly, import hashing/imphash must be enabled within Sysmon. This allows the capture of the IMPHASH value, a unique identifier for the imported functions of a PE, providing a robust mechanism for detecting hidden malicious activity leveraging ADS.

SEARCH:  '`sysmon` EventCode=15 IMPHASH!=00000000000000000000000000000000   | regex TargetFilename="(?<!\/)\b\w+(\.\w+)?:\w+(\.\w+)?$"  | eval file_name = replace(TargetFilename,"(.*\\\)",""), process = Image , file_path = TargetFilename, file_hash = coalesce(SHA256,SHA1,MD5,Hash)  | stats count min(_time) as firstTime max(_time) as lastTime values(user) as user by dest, process, process_guid, file_name, file_path, file_hash, IMPHASH  | `security_content_ctime(firstTime)`   | `security_content_ctime(lastTime)`  | `windows_alternate_datastream___executable_content_filter`'



<li><a href="#">NAME: Windows Alternate DataStream - Process Execution

DESCRIPTION:  This following analytic detects when a process attempts to execute a file from within an NTFS file system alternate data stream. This behavior could indicate that a threat actor staged malicious code within a difficult to detect area of the file system and is now attempting to execute it.

SEARCH:  '| tstats count min(_time) as firstTime max(_time) as lastTime values(Processes.process_current_directory) as directory from datamodel=Endpoint.Processes where Processes.parent_process_name != "unknown" Processes.process_name IN ("appvlp.exe","bitsadmin.exe","control.exe","cscript.exe","forfiles.exe","ftp.exe","mavinject.exe","mshta.exe","powershell.exe","powershell_ise.exe","pwsh.exe","regini.exe","regscr32.exe","rundll32.exe","sc.exe","wmic.exe","wscript.exe") by Processes.dest Processes.user Processes.parent_process_name Processes.process_name Processes.process Processes.process_id Processes.parent_process_id | `drop_dm_object_name(Processes)` | regex process="(\b)\w+(\.\w+)?:\w+(\.\w{2,4})(?!\.)(\b|\s|&)"| `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`| `windows_alternate_datastream___process_execution_filter`'



<li><a href="#">NAME: Windows Apache Benchmark Binary

DESCRIPTION:  The following analytic identifies a default behavior of a MetaSploit  payload. MetaSploit uses Apache Benchmark to generate payloads. The payloads contain  standard artifacts including "Apache Benchmark" and the original file name is always  ab.exe. During triage, review the process and it's path. It is possible network  connections spawned from it. Review parallel processes for further behaviors.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.original_file_name=ab.exe  by Processes.dest Processes.user Processes.parent_process_name Processes.process_name  Processes.original_file_name Processes.process Processes.process_id Processes.parent_process_id  | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `windows_apache_benchmark_binary_filter`'



<li><a href="#">NAME: Windows Application Layer Protocol RMS Radmin Tool Namedpipe

DESCRIPTION:  The following analytic identifies the use of default or publicly known  named pipes used by RMX remote admin tool. A named pipe is a named, one-way or duplex  pipe for communication between the pipe server and one or more pipe clients. RMX  Tool uses named pipes in many way as part of its communication for its server and  client component. This tool was abuse by several adversaries and malware like Azorult  to collect data to the targeted host. This TTP is a good indicator that this tool  was install in production premise and need to check if the user has a valid reason  why it need to install this legitimate application.

SEARCH:  '`sysmon` EventCode IN (17, 18) EventType IN ( "CreatePipe", "ConnectPipe")  PipeName IN ("\\RManFUSServerNotify32", "\\RManFUSCallbackNotify32", "\\RMSPrint*")  | stats  min(_time) as firstTime max(_time) as lastTime count by Image EventType ProcessId PipeName dest UserID   | rename UserID as user   | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `windows_application_layer_protocol_rms_radmin_tool_namedpipe_filter`'



<li><a href="#">NAME: Windows App Layer Protocol Qakbot NamedPipe

DESCRIPTION:  The following analytic identifies a suspicious process creating or connecting  to a possible Qakbot named pipe . This technique was seen in Qakbot malware that  creates named pipe after injecting its code in legitimate process to communicate  on other process that also has an injected code to steal information on the compromised  host. This Anomaly detection can be a good pivot for possible Qakbot infection.  This detection looks for possible random generated named pipe (in GUID form) created  by known process being abused by Qakbot.

SEARCH:  '`sysmon` EventCode IN (17, 18) EventType IN ( "CreatePipe", "ConnectPipe")  Image IN ("*\\calc.exe", "*\\notepad.exe", "*\\rdpclip.exe", "*\\explorer.exe",  "*\\wermgr.exe", "*\\ping.exe", "*\\OneDriveSetup.exe", "*\\dxdiag.exe", "*\\mobsync.exe",  "*\\msra.exe", "*\\xwizard.exe") | regex PipeName="^\\\{[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{8}"  | stats  min(_time) as firstTime max(_time) as lastTime count by Image EventType  ProcessGuid ProcessId PipeName SecurityID EventCode dest UserID | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `windows_app_layer_protocol_qakbot_namedpipe_filter`'



<li><a href="#">NAME: Windows App Layer Protocol Wermgr Connect To NamedPipe

DESCRIPTION:  The following analytic identifies a suspicious wermgr.exe process creating  or connecting to a named pipe. Wermgr.exe is part of Windows OS Problem reporting  application responsible for reporting problems, fault or error happen on the Windows  OS. This file is being abused by several Threat actors and malware such as Trickbot  and Qakbot to execute their malicious code. This anomaly detection can be a good  pivot on possible wermgr.exe processes having injected malicious code that might  be related to qakbot infection that communicates via named pipe.

SEARCH:  '`sysmon` EventCode IN (17, 18) Image= "*\\wermgr.exe" EventType IN ( "CreatePipe",  "ConnectPipe") | stats  min(_time) as firstTime max(_time) as lastTime count by  Image EventType ProcessGuid ProcessId PipeName SecurityID EventCode dest UserID  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `windows_app_layer_protocol_wermgr_connect_to_namedpipe_filter`'



<li><a href="#">NAME: Windows Archive Collected Data via Powershell

DESCRIPTION:  The following analytic identifies suspicious PowerShell script that archive files to a temp folder.   This anomaly detection serves as a valuable indicator to uncover threats from adversaries utilizing PowerShell scripts   for data archiving purposes. Identifying this method becomes pivotal in flagging and investigating potential threats,   enabling proactive measures threat actors leveraging similar PowerShell-based data collection and archiving techniques.

SEARCH:  '`powershell` EventCode=4104 ScriptBlockText = "*Compress-Archive*"  ScriptBlockText = "*\\Temp\\*"  | stats count min(_time) as firstTime max(_time) as lastTime by EventCode ScriptBlockText Computer UserID   | rename Computer as dest   | rename UserID as user   | `security_content_ctime(firstTime)`   | `security_content_ctime(lastTime)`   | `windows_archive_collected_data_via_powershell_filter`'



<li><a href="#">NAME: Windows Archive Collected Data via Rar

DESCRIPTION:  The following analytic identifies a process execute a rar utilities to archive files.   This method has been exploited by various threat actors, including red-teamers and malware like DarkGate,   to gather and compress collected data on compromised hosts. Subsequently, these archives are transmitted to   command and control servers as part of their data exfiltration techniques.  These adversaries leverage RAR archiving to consolidate and compress collected data on compromised hosts.   Once the data is compiled into these archives, it serves as a means for these entities to effectively exfiltrate sensitive information.   This process involves transferring the archived data to command and control servers,   facilitating the extraction and retrieval of critical information from compromised systems.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time) as lastTime from datamodel=Endpoint.Processes   where Processes.process_name="Rar.exe" OR Processes.original_file_name = "Rar.exe" AND Processes.process = "*a*" Processes.process = "* -ep1*" Processes.process = "* -r*" Processes.process = "* -y*"   Processes.process = "* -v5m*" Processes.process = "* -m1*"   by Processes.process_name Processes.original_file_name Processes.process Processes.process_id  Processes.process_guid Processes.parent_process_name Processes.parent_process Processes.parent_process_guid Processes.dest Processes.user   | `drop_dm_object_name(Processes)`   | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)`   | `windows_archive_collected_data_via_rar_filter`'



<li><a href="#">NAME: Windows AutoIt3 Execution

DESCRIPTION:  The following analytic is designed to detect any execution of AutoIt3, a scripting language designed for automating the Windows GUI and general scripting. This includes instances where AutoIt3 has been renamed or otherwise altered in an attempt to evade detection. The analytic works by searching for process names or original file names that match 'autoit3.exe', which is the default executable for AutoIt scripts. This detection is important as AutoIt3 is often used by attackers to automate malicious activities, such as the execution of malware or other unwanted software. False positives may occur with legitimate uses of AutoIt3.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.process_name IN ("autoit3.exe", "autoit*.exe") OR Processes.original_file_name IN ("autoit3.exe", "autoit*.exe")  by Processes.dest Processes.user Processes.parent_process_name Processes.process_name Processes.original_file_name Processes.process Processes.process_id Processes.parent_process_id  | `drop_dm_object_name(Processes)`   | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `windows_autoit3_execution_filter`'



<li><a href="#">NAME: Windows Autostart Execution LSASS Driver Registry Modification

DESCRIPTION:  The following analytic identifies the abuse of two undocumented registry  keys that allow for a DLL to load into lsass.exe to potentially capture credentials.  Upon successful modification of \CurrentControlSet\Services\NTDS\DirectoryServiceExtPt  or \CurrentControlSet\Services\NTDS\LsaDbExtPt, a DLL either remote or local will  be set as the value and load up into lsass.exe. Based on POC code a text file may  be written to disk with credentials.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime FROM datamodel=Endpoint.Registry where Registry.registry_path IN ("*\\CurrentControlSet\\Services\\NTDS\\DirectoryServiceExtPt","*\\CurrentControlSet\\Services\\NTDS\\LsaDbExtPt")  by Registry.registry_key_name Registry.user Registry.registry_path Registry.registry_value_data  Registry.action Registry.dest Registry.process_guid | `drop_dm_object_name(Registry)`  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `windows_autostart_execution_lsass_driver_registry_modification_filter`'



<li><a href="#">NAME: Windows Binary Proxy Execution Mavinject DLL Injection

DESCRIPTION:  Adversaries may abuse mavinject.exe to inject malicious DLLs into running  processes (i.e. Dynamic-link Library Injection), allowing for arbitrary code execution  (ex. C:\Windows\system32\mavinject.exe PID /INJECTRUNNING PATH_DLL). In addition  to Dynamic-link Library Injection, Mavinject.exe can also be abused to perform import  descriptor injection via its /HMODULE command-line parameter (ex. mavinject.exe  PID /HMODULE=BASE_ADDRESS PATH_DLL ORDINAL_NUMBER). This command would inject an  import table entry consisting of the specified DLL into the module at the given  base address. During triage, review file modifcations and parallel processes.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.process_name=mavinject.exe  Processes.process IN ("*injectrunning*", "*hmodule=0x*") by Processes.dest Processes.user  Processes.parent_process_name Processes.process_name Processes.process Processes.process_id  Processes.parent_process_id | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `windows_binary_proxy_execution_mavinject_dll_injection_filter`'



<li><a href="#">NAME: Windows BootLoader Inventory

DESCRIPTION:  The following hunting query utilizes a PowerShell Scripted input that captures the bootloader paths for each Windows endpoint it is deployed to. The template inputs.conf is located in the references link.  By default, it only captures the path, but may be modified to capture everything that BCDedit provides. It can be verbose, but may be worth it.

SEARCH:  '`bootloader_inventory` | stats count min(_time) as firstTime max(_time)  as lastTime values(_raw) by host | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `windows_bootloader_inventory_filter`'



<li><a href="#">NAME: Windows Boot or Logon Autostart Execution In Startup Folder

DESCRIPTION:  This analytic will identify suspicious files dropped or created in the Windows %startup% folder.   This technique is a common way to gain persistence on a targeted host. Threat actor, adversaries and red teamer   abuse this folder path to automatically execute their malicious sample upon boot or restart of the infected host.   This TTP detection is a good indicator that a suspicious process wants to gain persistence on the targeted host. We suggest to   verify the process name by using the process guid field, the file created and also the user and the computer name for further investigation.

SEARCH:  '|tstats `security_content_summariesonly` count min(_time) as firstTime max(_time) as lastTime from datamodel=Endpoint.Filesystem  where Filesystem.file_path = "*\\Microsoft\\Windows\\Start Menu\\Programs\\Startup\\*"   by Filesystem.file_create_time Filesystem.process_id Filesystem.file_name Filesystem.user Filesystem.file_path Filesystem.process_guid Filesystem.dest  | `drop_dm_object_name(Filesystem)`   | `security_content_ctime(firstTime)`   | `security_content_ctime(lastTime)`   | `windows_boot_or_logon_autostart_execution_in_startup_folder_filter`'



<li><a href="#">NAME: Windows Bypass UAC via Pkgmgr Tool

DESCRIPTION:  The following analytic identifies a potentially suspicious execution  of the 'pkgmgr' process involving the use of an XML input file for package management.  The 'pkgmgr' process, though deprecated in modern Windows systems, was historically  used for managing packages. The presence of an XML input file raises concerns about  the nature of the executed command and its potential impact on the system. Due to  the deprecated status of 'pkgmgr' and the involvement of an XML file, this activity  warrants careful investigation. XML files are commonly used for configuration and  data exchange, making it crucial to ascertain the intentions and legitimacy of the  command. To ensure system security, it is recommended to use up-to-date package  management utilities, such as DISM or PowerShell's PackageManagement module, and  exercise caution when executing commands involving potentially sensitive operations  or files.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where  Processes.process_name = pkgmgr.exe  Processes.process = "*.xml*" NOT(Processes.parent_process_path IN("*:\\windows\\system32\\*",  "*:\\windows\\syswow64\\*", "*:\\Program Files*")) by Processes.dest Processes.user  Processes.parent_process_name Processes.parent_process_path Processes.process_name  Processes.process Processes.process_id Processes.parent_process_id Processes.original_file_name  | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `windows_bypass_uac_via_pkgmgr_tool_filter`'



<li><a href="#">NAME: Windows CAB File on Disk

DESCRIPTION:  The following analytic identifies .cab files being written to disk. Utilize this analytic as a way to hunt for suspect .cab files being written to non-standard paths and tune as needed. Cab files were recently being utilized to deliver .url files embedded. The .url files were then used to deliver malicious payloads. The search specifically looks for instances where the file name is '*.cab' and the action is 'write'. During the triage process, it is recommended to review the file path for additional artifacts that may provide further insights into the event.

SEARCH:  '| tstats `security_content_summariesonly` count values(Filesystem.file_path)  as file_path min(_time) as firstTime max(_time) as lastTime from datamodel=Endpoint.Filesystem where (Filesystem.file_name=*.cab) by Filesystem.dest Filesystem.action Filesystem.process_id Filesystem.file_name   | `drop_dm_object_name("Filesystem")` | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `windows_cab_file_on_disk_filter`'



<li><a href="#">NAME: Windows Cached Domain Credentials Reg Query

DESCRIPTION:  The following analytic identifies a process command line related to the  discovery of cache domain credential logon count in the registry. This Technique  was being abused by several post exploitation tool like Winpeas where it query CachedLogonsCount  registry value in Winlogon registry. This value can be good information about the  login caching setting on the Windows OS target host. A value of 0 means login caching  is disable and values > 50 caches only 50 login attempts. By default all versions  of Windows 10 save cached logins except Windows Server 2008.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where  `process_reg` AND Processes.process  = "* query *" AND Processes.process = "*\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon*"  AND Processes.process = "*CACHEDLOGONSCOUNT*" by Processes.process_name Processes.original_file_name  Processes.process Processes.process_id Processes.process_guid Processes.parent_process_name  Processes.parent_process Processes.parent_process_guid Processes.dest Processes.user  | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `windows_cached_domain_credentials_reg_query_filter`'



<li><a href="#">NAME: Windows Change Default File Association For No File Ext

DESCRIPTION:  This analytic is developed to detect suspicious process commandline to  change or set the default file association of a file without file extension with  notepad.exe. This technique was seen in some APT and ransomware Prestige where it  set/modify the default process to run file association, like .txt to notepad.exe.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime  from datamodel=Endpoint.Processes where `process_reg` AND Processes.process="*  add *" AND Processes.process="* HKCR\\*" AND Processes.process="*\\shell\\open\\command*"  AND  Processes.process= *Notepad.exe* by  Processes.process_name Processes.original_file_name  Processes.process Processes.process_id Processes.process_guid Processes.parent_process_name  Processes.parent_process Processes.parent_process_guid Processes.dest Processes.user  | `drop_dm_object_name(Processes)` | rex field=process "Notepad\.exe (?<file_name_association>.*$)"  | rex field=file_name_association "\.(?<extension>[^\.]*$)" | where isnull(extension)  and isnotnull(file_name_association) | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `windows_change_default_file_association_for_no_file_ext_filter`'



<li><a href="#">NAME: Windows ClipBoard Data via Get-ClipBoard

DESCRIPTION:  The following analytic identifies a powershell script command to retrieve  clipboard data. This technique was seen in several post exploitation tools like  WINPEAS to steal sensitive information that was saved in clipboard. Using the Get-Clipboard  powershell commandlet, adversaries can be able collect data stored in clipboard  that might be a copied user name, password or other sensitive information.

SEARCH:  '`powershell` EventCode=4104 ScriptBlockText = "*Get-Clipboard*" | stats count  min(_time) as firstTime max(_time) as lastTime by EventCode ScriptBlockText Computer  UserID | rename Computer as dest | rename UserID as user| `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `windows_clipboard_data_via_get_clipboard_filter`'



<li><a href="#">NAME: Windows Command and Scripting Interpreter Hunting Path Traversal

DESCRIPTION:  The following analytic identifies path traversal command-line execution  and should be used to tune and driver other more higher fidelity analytics. This  technique was seen in malicious document that execute malicious code using msdt.exe  and path traversal technique that serve as defense evasion. This Hunting query is  a good pivot to look for possible suspicious process and command-line that runs  execute path traversal technique to run malicious code. This may help you to find  possible downloaded malware or other lolbin execution.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime FROM datamodel=Endpoint.Processes  by Processes.original_file_name Processes.process_id  Processes.parent_process_id Processes.process_hash Processes.dest Processes.user  Processes.parent_process_name Processes.process_name Processes.process | `drop_dm_object_name("Processes")`  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | eval  count_of_pattern1 = (mvcount(split(process,"/.."))-1) | eval count_of_pattern2 =  (mvcount(split(process,"\.."))-1) | eval count_of_pattern3 = (mvcount(split(process,"\\.."))-1)  | eval count_of_pattern4 = (mvcount(split(process,"//.."))-1) | search count_of_pattern1  > 1 OR count_of_pattern2 > 1 OR count_of_pattern3 > 1 OR count_of_pattern4 > 1 |  `windows_command_and_scripting_interpreter_hunting_path_traversal_filter`'



<li><a href="#">NAME: Windows Command and Scripting Interpreter Path Traversal Exec

DESCRIPTION:  The following analytic identifies path traversal command-line execution.  This technique was seen in malicious document that execute malicious code using  msdt.exe and path traversal technique that serve as defense evasion. This TTP is  a good pivot to look for more suspicious process and command-line that runs before  and after this execution. This may help you to find possible downloaded malware  or other lolbin execution.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime FROM datamodel=Endpoint.Processes where  Processes.process="*\/..\/..\/..\/*"  OR Processes.process="*\\..\\..\\..\\*" OR Processes.process="*\/\/..\/\/..\/\/..\/\/*"  by Processes.dest Processes.user Processes.parent_process_name Processes.process_name  Processes.process Processes.original_file_name Processes.process_id Processes.parent_process_id  Processes.process_hash | `drop_dm_object_name("Processes")` | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `windows_command_and_scripting_interpreter_path_traversal_exec_filter`'



<li><a href="#">NAME: Windows Command Shell DCRat ForkBomb Payload

DESCRIPTION:  The following analytic identifies DCRat "forkbomb" payload feature. This  technique was seen in dark crystal RAT backdoor capabilities where it will execute  several cmd child process executing "notepad.exe & pause". The following analytic detects  the multiple cmd.exe and child process notepad.exe  execution using batch script  in the targeted host within 30s timeframe. this TTP can be a good pivot to check  DCRat infection.

SEARCH:  '| tstats `security_content_summariesonly` values(Processes.process) as process  values(Processes.parent_process) as parent_process values(Processes.parent_process_id)  as parent_process_id values(Processes.process_id) as process_id dc(Processes.parent_process_id)  as parent_process_id_count dc(Processes.process_id) as process_id_count min(_time)  as firstTime max(_time) as lastTime from datamodel=Endpoint.Processes where Processes.parent_process_name=  "cmd.exe" (Processes.process_name = "notepad.exe" OR Processes.original_file_name=  "notepad.exe") Processes.parent_process = "*.bat*" by  Processes.parent_process_name  Processes.process_name Processes.original_file_name Processes.parent_process Processes.dest  Processes.user  _time span=30s | where parent_process_id_count>= 10 AND process_id_count  >=10 | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)` |  `security_content_ctime(lastTime)` | `windows_command_shell_dcrat_forkbomb_payload_filter`'



<li><a href="#">NAME: Windows Command Shell Fetch Env Variables

DESCRIPTION:  The following analytic identifies a suspicious process command line fetching  the environment variables with a non-shell parent process. This technique was seen  in qakbot malware where it fetches the environment variable in the target or compromised  host. This TTP detection is a good pivot of possible malicious behavior since the  command line is executed by a common non-shell process like cmd.exe , powershell.exe  and many more. This can also be a good sign that the parent process has a malicious  code injected to it to execute this command.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.process = "*cmd /c  set" OR Processes.process = "*cmd.exe /c set" AND NOT (Processes.parent_process_name  = "cmd.exe" OR Processes.parent_process_name = "powershell*" OR Processes.parent_process_name="pwsh.exe"  OR Processes.parent_process_name = "explorer.exe") by Processes.dest Processes.user  Processes.parent_process_name Processes.process_name Processes.process Processes.process_id  Processes.parent_process_id Processes.original_file_name | `drop_dm_object_name(Processes)`  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `windows_command_shell_fetch_env_variables_filter`'



<li><a href="#">NAME: Windows Common Abused Cmd Shell Risk Behavior

DESCRIPTION:  The following correlation identifies instances where four or more distinct  detection analytics are associated with malicious command line behavior that is  known to be exploited by multiple threat actors, adversaries, or red teamers on  a specific host. By leveraging the Command Line Interface (CLI), attackers can execute  malicious commands, gain access to sensitive data, install backdoors, and engage  in various nefarious activities. The impact of such compromise can be severe, as  attackers may gain unauthorized control over the compromised system, enabling them  to exfiltrate valuable information, escalate privileges, or launch further attacks  within the network. If this detection is triggered, there is a high level of confidence  in the occurrence of suspicious command line activities on the host.

SEARCH:  '| tstats `security_content_summariesonly` min(_time) as firstTime max(_time)  as lastTime sum(All_Risk.calculated_risk_score) as risk_score, count(All_Risk.calculated_risk_score)  as risk_event_count, values(All_Risk.annotations.mitre_attack.mitre_tactic_id) as  annotations.mitre_attack.mitre_tactic_id, dc(All_Risk.annotations.mitre_attack.mitre_tactic_id)  as mitre_tactic_id_count, values(All_Risk.annotations.mitre_attack.mitre_technique_id)  as annotations.mitre_attack.mitre_technique_id, dc(All_Risk.annotations.mitre_attack.mitre_technique_id)  as mitre_technique_id_count, values(All_Risk.tag) as tag, values(source) as source,  dc(source) as source_count from datamodel=Risk.All_Risk where source IN ("*Cmdline  Tool Not Executed In CMD Shell*", "*Windows System Network Config Discovery Display  DNS*", "*Local Account Discovery With Wmic*", "*Net Localgroup Discovery*", "*Create  local admin accounts using net exe*", "*Local Account Discovery with Net*", "*Icacls  Deny Command*", "*ICACLS Grant Command*", "*Windows Proxy Via Netsh*", "*Processes  launching netsh*", "*Disabling Firewall with Netsh*", "*Windows System Network Connections  Discovery Netsh*", "*Network Connection Discovery With Arp*", "*Windows System Discovery  Using ldap Nslookup*", "*Windows System Shutdown CommandLine*") by All_Risk.risk_object  All_Risk.risk_object_type All_Risk.annotations.mitre_attack.mitre_tactic | `drop_dm_object_name(All_Risk)`  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | where  source_count >= 4 | `windows_common_abused_cmd_shell_risk_behavior_filter`'



<li><a href="#">NAME: Windows Computer Account Created by Computer Account

DESCRIPTION:  The following analytic identifes a Computer Account creating a new Computer  Account with specific a Service Principle Name - "RestrictedKrbHost". The RestrictedKrbHost  service class allows client applications to use Kerberos authentication when they  do not have the identity of the service but have the server name.

SEARCH:  '`wineventlog_security` EventCode=4741 user_type=computer Subject_Account_Domain!="NT  AUTHORITY"  Message=*RestrictedKrbHost* | stats  count min(_time) as firstTime max(_time)  as lastTime by dest, subject, action ,src_user, user, Account_Name, Subject_Account_Name,Subject_Account_Domain  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `windows_computer_account_created_by_computer_account_filter`'



<li><a href="#">NAME: Windows Computer Account Requesting Kerberos Ticket

DESCRIPTION:  The following analytic identifies a ComputerAccount requesting a Kerberos  Ticket. typically, a user account requests a Kerberos ticket. This behavior was  identified with KrbUpRelay, but additional Kerberos attacks have exhibited similar  behavior.

SEARCH:  '`wineventlog_security`  EventCode=4768 Account_Name="*$"  src_ip!="::1" |  stats  count min(_time) as firstTime max(_time) as lastTime by dest, subject, action,  Supplied_Realm_Name, user, Account_Name, src_ip | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `windows_computer_account_requesting_kerberos_ticket_filter`'



<li><a href="#">NAME: Windows Computer Account With SPN

DESCRIPTION:  The following analytic identifies two SPNs, HOST and RestrictedKrbHost,  added using the KrbRelayUp behavior. This particular behavior has been found in  other Kerberos based attacks.

SEARCH:  '`wineventlog_security` EventCode=4741 MSADChangedAttributes IN ("*HOST/*","*RestrictedKrbHost/*")  AND New_UAC_Value=0x80 | eval Effecting_Account=mvindex(Security_ID,1) | eval New_Computer_Account_Name=mvindex(Security_ID,0)  | stats count min(_time) as firstTime max(_time) as lastTime values(EventCode),values(Account_Domain),values(Security_ID),  values(Effecting_Account), values(New_Computer_Account_Name),values(SAM_Account_Name),values(DNS_Host_Name),values(MSADChangedAttributes)  by dest Logon_ID subject | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `windows_computer_account_with_spn_filter`'



<li><a href="#">NAME: Windows COM Hijacking InprocServer32 Modification

DESCRIPTION:  The following analytic identifies the use of reg.exe performing an add  to the InProcServer32, which may be related to COM hijacking. Adversaries can use  the COM system to insert malicious code that can be executed in place of legitimate  software through hijacking the COM references and relationships as a means for persistence.  Hijacking a COM object requires a change in the Registry to replace a reference  to a legitimate system component which may cause that component to not work when  executed. When that system component is executed through normal system operation  the adversary's code will be executed instead.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where `process_reg` Processes.process=*inprocserver32*  by Processes.dest Processes.user Processes.parent_process_name Processes.process_name  Processes.process Processes.process_id Processes.parent_process_id | `drop_dm_object_name(Processes)`  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `windows_com_hijacking_inprocserver32_modification_filter`'



<li><a href="#">NAME: Windows ConHost with Headless Argument

DESCRIPTION:  'The following analytic detects the unusual use of the Windows Console Host process (conhost.exe) with the undocumented --headless parameter to spawn a new process. This behavior is highly unusual and indicative of suspicious activity, as the --headless parameter is not commonly used in legitimate operations. The analytic identifies this behavior by looking for instances where conhost.exe is invoked with the --headless argument. This behavior is worth identifying for a Security Operations Center (SOC) as it could indicate an attacker''s attempt to execute commands or scripts in a stealthy manner, potentially to establish persistence, perform lateral movement, or carry out other malicious activities. If a true positive is identified, it suggests that an attacker has gained a foothold in the environment and is attempting to further their attack, which could lead to serious consequences such as data exfiltration, system compromise, or deployment of ransomware. Potential false positives could arise from legitimate administrative activity, hence it is important to validate the context of the detected behavior during triage.'

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.process_name=conhost.exe  Processes.process="*--headless *" by Processes.dest Processes.user Processes.parent_process  Processes.process_name Processes.process Processes.process_id Processes.parent_process_id  | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `windows_conhost_with_headless_argument_filter`'



<li><a href="#">NAME: Windows Create Local Account

DESCRIPTION:  The following analytic identifies a new local user account added to a  computer. Note that, this should be restricted to critical assets.

SEARCH:  '| tstats `security_content_summariesonly` values(All_Changes.result_id) as  result_id count min(_time) as firstTime max(_time) as lastTime from datamodel=Change  where All_Changes.result_id=4720 by All_Changes.user All_Changes.dest All_Changes.result  All_Changes.action | `drop_dm_object_name("All_Changes")` | `security_content_ctime(lastTime)`  | `security_content_ctime(firstTime)` | `windows_create_local_account_filter`'



<li><a href="#">NAME: Windows Credentials from Password Stores Chrome Extension Access

DESCRIPTION:  This analytic focuses on identifying non-chrome processes that attempt  to access the Chrome extensions file. This file contains crucial settings and information  related to the browser's extensions installed on the computer. Adversaries and malware  authors have been known to exploit this file to extract sensitive information from  the Chrome browser on targeted hosts. Detecting such anomalous behavior provides  valuable insights for analyzing suspicious processes beyond the commonly observed  chrome.exe and explorer.exe executables. By monitoring for access to the Chrome  extensions file by non-chrome processes, we can enhance our ability to detect potential  threats and protect sensitive information stored within the browser.

SEARCH:  '`wineventlog_security` EventCode=4663 object_file_path="*\\AppData\\Local\\Google\\Chrome\\User  Data\\Default\\Local Extension Settings\\*" AND NOT (process_path IN ("*:\\Windows\\explorer.exe",  "*\\chrome.exe")) | stats count min(_time) as firstTime max(_time) as lastTime by  object_file_name object_file_path process_name process_path  process_id EventCode  dest | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `windows_credentials_from_password_stores_chrome_extension_access_filter`'



<li><a href="#">NAME: Windows Credentials from Password Stores Chrome LocalState Access

DESCRIPTION:  This analytic is designed to detect non-chrome processes accessing the Chrome user data file called "local state."   This file contains important settings and information related to the browser's operations on the computer. Threat actors,   adversaries, and malware authors have been known to exploit this file in attempts to extract the encrypted master key used for  decrypting passwords saved in the Chrome browser. Detecting access to the "local state" file by non-chrome processes serves as   a valuable pivot for analyzing suspicious processes beyond the commonly observed chrome.exe and explorer.exe executables.   By monitoring for this anomaly, we can improve our ability to identify potential threats and safeguard sensitive information stored within the browser.

SEARCH:  '`wineventlog_security` EventCode=4663 object_file_path="*\\AppData\\Local\\Google\\Chrome\\User Data\\Local State"   NOT (process_name IN ("*\\chrome.exe","*:\\Windows\\explorer.exe"))  | stats count min(_time) as firstTime max(_time) as lastTime by object_file_name object_file_path process_name process_path  process_id EventCode dest  | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)`   | `windows_credentials_from_password_stores_chrome_localstate_access_filter`'



<li><a href="#">NAME: Windows Credentials from Password Stores Chrome Login Data Access

DESCRIPTION:  This analytic is designed to identify non-chrome processes accessing the Chrome user data file called "login data."   This SQLite database file contains important information related to the browser's operations on the computer. Threat actors, adversaries,   and malware authors have been known to exploit this file in attempts to extract and decrypt passwords saved in the Chrome browser.   Detecting access to the "login data" file by non-chrome processes serves as a valuable pivot for analyzing suspicious processes   beyond the commonly observed chrome.exe and explorer.exe executables. By monitoring for this anomaly, we can enhance our ability   to detect potential threats and protect sensitive information stored within the browser.

SEARCH:  '`wineventlog_security` EventCode=4663 object_file_path="*\\AppData\\Local\\Google\\Chrome\\User Data\\Default\\Login Data"  AND NOT (process_path IN ("*:\\Windows\\explorer.exe", "*:\\Windows\\System32\\dllhost.exe", "*\\chrome.exe"))         | stats count min(_time) as firstTime max(_time) as lastTime by object_file_name object_file_path process_name process_path  process_id EventCode dest  | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)`  | `windows_credentials_from_password_stores_chrome_login_data_access_filter`'



<li><a href="#">NAME: Windows Credentials from Password Stores Creation

DESCRIPTION:  The following analytic identifies a process execution of Windows OS cmdkey.exe  tool. This tool is being abused or used by several post exploitation tool and malware such as  Darkgate malware to create stored user names, passwords  or credentials in the targeted Windows OS host. This information can be used by  the attacker to gain privilege escalation and persistence in the targeted hosts  for further attacks.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time) as lastTime from datamodel=Endpoint.Processes   where Processes.process_name="cmdkey.exe" OR Processes.original_file_name = "cmdkey.exe" AND Processes.process = "*/generic*" Processes.process IN ("*/user*", "*/password*")  by Processes.process_name Processes.original_file_name Processes.process Processes.process_id  Processes.process_guid Processes.parent_process_name Processes.parent_process Processes.parent_process_guid Processes.dest Processes.user   | `drop_dm_object_name(Processes)`   | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)`   | `windows_credentials_from_password_stores_creation_filter`'



<li><a href="#">NAME: Windows Credentials from Password Stores Deletion

DESCRIPTION:  The following analytic identifies a process execution of Windows OS cmdkey.exe  tool. This tool is being abused or used by several post exploitation tool and malware such as  Darkgate malware to delete stored user names, passwords  or credentials in the targeted Windows OS host. This information can be used by  the attacker to gain privilege escalation and persistence in the targeted hosts  for further attacks.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time) as lastTime from datamodel=Endpoint.Processes   where Processes.process_name="cmdkey.exe" OR Processes.original_file_name = "cmdkey.exe" AND Processes.process = "*/delete*"  by Processes.process_name Processes.original_file_name Processes.process Processes.process_id  Processes.process_guid Processes.parent_process_name Processes.parent_process Processes.parent_process_guid Processes.dest Processes.user   | `drop_dm_object_name(Processes)`   | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)`   | `windows_credentials_from_password_stores_deletion_filter`'



<li><a href="#">NAME: Windows Credentials from Password Stores Query

DESCRIPTION:  The following analytic identifies a process execution of Windows OS cmdkey.exe  tool. This tool is being abused or used by several post exploitation tool such as  winpeas that being used by ransomware prestige to list stored user names, passwords  or credentials in the targeted Windows OS host. This information can be used by  the attacker to gain privilege escalation and persistence in the targeted hosts  for further attacks.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.process_name="cmdkey.exe"  OR Processes.original_file_name = "cmdkey.exe" AND Processes.process = "*/list*"  by Processes.process_name Processes.original_file_name Processes.process Processes.process_id  Processes.process_guid Processes.parent_process_name Processes.parent_process Processes.parent_process_guid  Processes.dest Processes.user | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `windows_credentials_from_password_stores_query_filter`'



<li><a href="#">NAME: Windows Credentials in Registry Reg Query

DESCRIPTION:  The following analytic identifies a process command line related to the  discovery of possible password or credentials in the registry. This technique is  being abused by adversaries or post exploitation tools like winpeas to steal credentials  in the registry in the targeted host. Registry can contain several sensitive information  like username and credentials that can be used for privilege escalation, persistence  or even in lateral movement. This Anomaly detection can be a good pivot to detect  a suspicious process querying a registry related to password or private keys.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where `process_reg` AND Processes.process  = "* query *" AND Processes.process IN ("*\\Software\\ORL\\WinVNC3\\Password*",  "*\\SOFTWARE\\RealVNC\\WinVNC4 /v password*", "*\\CurrentControlSet\\Services\\SNMP*",  "*\\Software\\TightVNC\\Server*", "*\\Software\\SimonTatham\\PuTTY\\Sessions*",  "*\\Software\\OpenSSH\\Agent\\Keys*", "*password*") by Processes.process_name Processes.original_file_name  Processes.process Processes.process_id Processes.process_guid Processes.parent_process_name  Processes.parent_process Processes.parent_process_guid Processes.dest Processes.user  | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `windows_credentials_in_registry_reg_query_filter`'



<li><a href="#">NAME: Windows Credential Dumping LSASS Memory Createdump

DESCRIPTION:  The following analytic identifies the use of CreateDump.exe being used  to perform a process dump. This particular binary is not native to Windows, but  is found to be brought in my many different third party applications including PowerShell  7.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.process_name=createdump.exe  OR Processes.original_file_name="FX_VER_INTERNALNAME_STR" Processes.process="*-u  *" AND Processes.process="*-f *" by Processes.dest Processes.user Processes.parent_process_name  Processes.process_name Processes.process Processes.process_id Processes.parent_process_id  | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `windows_credential_dumping_lsass_memory_createdump_filter`'



<li><a href="#">NAME: Windows Curl Download to Suspicious Path

DESCRIPTION:  'The following analytic identifies the use of Windows Curl.exe downloading  a file to a suspicious location. \  -O or --output is used when a file is to be downloaded and placed in a specified  location. \  During triage, review parallel processes for further behavior. In addition, identify  if the download was successful. If a file was downloaded, capture and analyze.'

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where `process_curl` Processes.process  IN ("*-O *","*--output*") Processes.process IN ("*\\appdata\\*","*\\programdata\\*","*\\public\\*")  by Processes.dest Processes.user Processes.parent_process_name Processes.process_name  Processes.original_file_name Processes.process Processes.process_id Processes.parent_process_id  | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `windows_curl_download_to_suspicious_path_filter`'



<li><a href="#">NAME: Windows Curl Upload to Remote Destination

DESCRIPTION:  'The following analytic identifies the use of Windows Curl.exe uploading  a file to a remote destination. \  `-T` or `--upload-file` is used when a file is to be uploaded to a remotge destination.  \  `-d` or `--data` POST is the HTTP method that was invented to send data to a receiving  web application, and it is, for example, how most common HTML forms on the web work.  \  HTTP multipart formposts are done with `-F`, but this appears to not be compatible  with the Windows version of Curl. Will update if identified adversary tradecraft.  \  Adversaries may use one of the three methods based on the remote destination and  what they are attempting to upload (zip vs txt). During triage, review parallel  processes for further behavior. In addition, identify if the upload was successful  in network logs. If a file was uploaded, isolate the endpoint and review.'

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where `process_curl` Processes.process  IN ("*-T *","*--upload-file *", "*-d *", "*--data *", "*-F *") by Processes.dest  Processes.user Processes.parent_process_name Processes.process_name Processes.original_file_name  Processes.process Processes.process_id Processes.parent_process_id | `drop_dm_object_name(Processes)`  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `windows_curl_upload_to_remote_destination_filter`'



<li><a href="#">NAME: Windows Data Destruction Recursive Exec Files Deletion

DESCRIPTION:  The following analytic identifies a suspicious process recursively deleting  files in a compromised host. This behavior was seen in several destructive malware,  wiper like caddy wiper, doublezero, and now swiftslicer that delete or overwrite  files with random generated strings to make it unrecoverable. This analytic can  also catch a possible recursive file write on multiple files using Sysmon Event  23. Sysmon treats the modified file as a deleted one as soon as it was overwritten.  This analytic can be a good indicator that a possible destructive malware is running  in a host machine or a big software application is being uninstalled.

SEARCH:  '`sysmon` EventCode=23  TargetFilename IN ("*.exe", "*.sys", "*.dll") | bin  _time span=2m | stats values(TargetFilename) as deleted_files min(_time) as firstTime  max(_time) as lastTime count by dest user EventCode Image ProcessID | where  count >=500 | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `windows_data_destruction_recursive_exec_files_deletion_filter`'



<li><a href="#">NAME: Windows Defacement Modify Transcodedwallpaper File

DESCRIPTION:  The following analytic identifies a modification to the Transcodedwallpaper  file in the wallpaper theme directory to change the wallpaper of the host machine.  This technique was seen in adversaries attempting to deface or change the desktop  wallpaper of the targeted host. During our testing, the common process that affects  or changes the wallpaper if a user changes it via desktop personalized setting is  explorer.exe.

SEARCH:  '| tstats `security_content_summariesonly` count FROM datamodel=Endpoint.Processes  where Processes.process_path !="*\\Windows\\Explorer.EXE" by _time span=1h Processes.process_id  Processes.process_name Processes.process Processes.dest Processes.process_guid  Processes.original_file_name  | `drop_dm_object_name(Processes)` |rename process_guid as proc_guid | join proc_guid,  _time [ | tstats `security_content_summariesonly` count FROM datamodel=Endpoint.Filesystem  where Filesystem.file_path = "*\\AppData\\Roaming\\Microsoft\\Windows\\Themes\\TranscodedWallpaper"  by _time span=1h Filesystem.dest Filesystem.file_create_time Filesystem.file_name  Filesystem.file_path Filesystem.process_guid | `drop_dm_object_name(Filesystem)`  |rename process_guid as proc_guid | fields file_name file_path process_name process_path  process dest file_create_time _time proc_guid] | `windows_defacement_modify_transcodedwallpaper_file_filter`'



<li><a href="#">NAME: Windows Default Group Policy Object Modified

DESCRIPTION:  The following analytic leverages Event ID 5136 to identify the modification  of a default Group Policy Object. A fresh installation of an Active Directory network  will typically contain two default group policy objects `Default Domain Controllers  Policy` and `Default Domain Policy`. The default domain controllers policy is used  to enforce and set policies to all the domain controllers within the domain environment.  The default domain policy is linked to all users and computers by default. An adversary  who has obtained privileged access to an Active Directory network may modify the  default group policy objects to obtain further access, deploy persistence or execute  malware across a large number of hosts. Security teams should monitor the modification  of the default GPOs.

SEARCH:  ' `wineventlog_security` EventCode=5136 ObjectClass=groupPolicyContainer AttributeLDAPDisplayName=versionNumber  (ObjectDN="CN={31B2F340-016D-11D2-945F-00C04FB984F9},CN=POLICIES,CN=SYSTEM,DC=*"  OR ObjectDN="CN={6AC1786C-016F-11D2-945F-00C04fB984F9},CN=POLICIES,CN=SYSTEM,DC=*")  | stats min(_time) as firstTime max(_time) as lastTime by ObjectDN SubjectUserSid  AttributeValue Computer DSName | rename AttributeValue as versionNumber | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `windows_default_group_policy_object_modified_filter`'



<li><a href="#">NAME: Windows Default Group Policy Object Modified with GPME

DESCRIPTION:  The following analytic leverages the Endpoint datamodel to identify the  potential edition of a default Group Policy Object. A fresh installation of an Active  Directory network will typically contain two default group policy objects `Default  Domain Controllers Policy` and `Default Domain Policy`. The default domain controllers  policy is used to enforce and set policies to all the domain controllers within  the domain environment. The default domain policy is linked to all users and computers  by default. An adversary who has obtained privileged access to an Active Directory  network may modify the default group policy objects to obtain further access, deploy  persistence or execute malware across a large number of hosts. Security teams should  monitor the edition of the default GPOs.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.process_name=mmc.exe  (Processes.process =*gpme.msc*) AND (Processes.process = "*31B2F340-016D-11D2-945F-00C04FB984F9*"  OR Processes.process = "*6AC1786C-016F-11D2-945F-00C04fB984F9*"  ) by Processes.dest  Processes.user Processes.parent_process_name Processes.process_name Processes.process  Processes.process_id Processes.parent_process_id | `drop_dm_object_name(Processes)`  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `windows_default_group_policy_object_modified_with_gpme_filter`'



<li><a href="#">NAME: Windows Defender ASR Audit Events

DESCRIPTION:  'This detection searches for Windows Defender ASR audit events. ASR is a feature of Windows Defender Exploit Guard that prevents actions and apps that are typically used by exploit-seeking malware to infect machines. ASR rules are applied to processes and applications. When a process or application attempts to perform an action that is blocked by an ASR rule, an event is generated. This detection searches for ASR audit events that are generated when a process or application attempts to perform an action that would be blocked by an ASR rule, but is allowed to proceed for auditing purposes.'

SEARCH:  '`ms_defender` EventCode IN (1122, 1125, 1126, 1132, 1134)  | lookup asr_rules ID OUTPUT ASR_Rule  | fillnull value=NULL  | stats count min(_time) as firstTime max(_time) as lastTime by host, Process_Name, Target_Commandline, Path, ID, EventCode, ASR_Rule  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`| rename host as dest | `windows_defender_asr_audit_events_filter`'



<li><a href="#">NAME: Windows Defender ASR Block Events

DESCRIPTION:  'This detection searches for Windows Defender ASR block events. ASR is a feature of Windows Defender Exploit Guard that prevents actions and apps that are typically used by exploit-seeking malware to infect machines. ASR rules are applied to processes and applications. When a process or application attempts to perform an action that is blocked by an ASR rule, an event is generated. This detection searches for ASR block events that are generated when a process or application attempts to perform an action that is blocked by an ASR rule. Typically, these will be enabled in block most after auditing and tuning the ASR rules themselves. Set to TTP once tuned.'

SEARCH:  '`ms_defender` EventCode IN (1121, 1126, 1129, 1131, 1133)  | lookup asr_rules ID OUTPUT ASR_Rule  | fillnull value=NULL  | stats count min(_time) as firstTime max(_time) as lastTime by host, Path, Parent_Commandline, Process_Name, ID, EventCode, ASR_Rule  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`| rename host as dest | `windows_defender_asr_block_events_filter`'



<li><a href="#">NAME: Windows Defender ASR Registry Modification

DESCRIPTION:  'This detection searches for Windows Defender ASR registry modification events. ASR is a feature of Windows Defender Exploit Guard that prevents actions and apps that are typically used by exploit-seeking malware to infect machines. ASR rules are applied to processes and applications. When a process or application attempts to perform an action that is blocked by an ASR rule, an event is generated. This detection searches for ASR registry modification events that are generated when a process or application attempts to modify a registry key that is blocked by an ASR rule. Typically, these will be enabled in block most after auditing and tuning the ASR rules themselves. Set to TTP once tuned.'

SEARCH:  '`ms_defender` EventCode IN (5007)   | rex field=New_Value "0x(?<New_Registry_Value>\\d+)$"  | rex field=Old_Value "0x(?<Old_Registry_Value>\\d+)$"  | rex field=New_Value "Rules\\\\(?<ASR_ID>[A-Fa-f0-9\\-]+)\\s*="  | lookup asr_rules ID AS ASR_ID OUTPUT ASR_Rule  | eval New_Registry_Value=case(New_Registry_Value=="0", "Disabled", New_Registry_Value=="1", "Block", New_Registry_Value=="2", "Audit", New_Registry_Value=="6", "Warn")  | eval Old_Registry_Value=case(Old_Registry_Value=="0", "Disabled", Old_Registry_Value=="1", "Block", Old_Registry_Value=="2", "Audit", Old_Registry_Value=="6", "Warn")  | stats count min(_time) as firstTime max(_time) as lastTime by host, New_Value, Old_Value, Old_Registry_Value, New_Registry_Value, ASR_Rule  | `security_content_ctime(firstTime)`| rename host as dest | `security_content_ctime(lastTime)`  | `windows_defender_asr_registry_modification_filter`'



<li><a href="#">NAME: Windows Defender ASR Rules Stacking

DESCRIPTION:  This hunting analytic targets a range of security events from Microsoft Defender, focusing on the Exploit Guard and Attack Surface Reduction (ASR) features. It monitors specific Event IDs - Event IDs 1121 and 1126 indicate active blocking of unauthorized operations or dangerous network connections, whereas Event IDs 1122 and 1125 represent audit logs for similar activities. Event ID 1129 shows user overrides on blocked operations. For ASR-related activities, Event IDs 1131 and 1133 signal blocked operations, while 1132 and 1134 are audit logs. Event ID 5007 alerts on configuration changes, possibly indicating security breaches. \  Additionally, the analytic utilizes a lookup to correlate ASR rule GUIDs with their descriptive names, enhancing understanding of the context behind these security alerts. This includes rules for blocking vulnerable drivers, restricting actions of Adobe Reader and Office applications, and protecting against various malware and unauthorized system changes. This comprehensive approach aids in assessing policy enforcement and potential security risks.

SEARCH:  '`ms_defender`    EventCode IN (1121, 1122, 1125, 1126, 1129, 1131, 1132, 1133, 1134, 5007)  | lookup asr_rules ID OUTPUT ASR_Rule  | fillnull value=NULL  | stats count min(_time) as firstTime max(_time) as lastTime by host Parent_Commandline, Process_Name, Path, ID, EventCode, ASR_Rule  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`| rename host as dest  | `windows_defender_asr_rules_stacking_filter`'



<li><a href="#">NAME: Windows Defender ASR Rule Disabled

DESCRIPTION:  'The following analytic identifies when a Windows Defender ASR rule disabled events. ASR is a feature of Windows Defender Exploit Guard that prevents actions and apps that are typically used by exploit-seeking malware to infect machines. ASR rules are applied to processes and applications. When a process or application attempts to perform an action that is blocked by an ASR rule, an event is generated. This detection searches for ASR rule disabled events that are generated when an ASR rule is disabled.'

SEARCH:  '`ms_defender` EventCode IN (5007)   | rex field=New_Value "0x(?<New_Registry_Value>\\d+)$"  | rex field=Old_Value "0x(?<Old_Registry_Value>\\d+)$"  | rex field=New_Value "Rules\\\\(?<ASR_ID>[A-Fa-f0-9\\-]+)\\s*="  | lookup asr_rules ID AS ASR_ID OUTPUT ASR_Rule  | eval New_Registry_Value=case(New_Registry_Value=="0", "Disabled", New_Registry_Value=="1", "Block", New_Registry_Value=="2", "Audit", New_Registry_Value=="6", "Warn")  | eval Old_Registry_Value=case(Old_Registry_Value=="0", "Disabled", Old_Registry_Value=="1", "Block", Old_Registry_Value=="2", "Audit", Old_Registry_Value=="6", "Warn")  | search New_Registry_Value="Disabled"  | stats count min(_time) as firstTime max(_time) as lastTime by host, New_Value, Old_Value, Old_Registry_Value, New_Registry_Value, ASR_Rule  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`| rename host as dest | `windows_defender_asr_rule_disabled_filter`'



<li><a href="#">NAME: Windows Defender Exclusion Registry Entry

DESCRIPTION:  This analytic will detect a suspicious process that modify a registry  related to windows defender exclusion feature. This registry is abused by adversaries,  malware author and red teams to bypassed Windows Defender Anti-Virus product by  excluding folder path, file path, process, extensions and etc. from its real time  or schedule scan to execute their malicious code. This is a good indicator for a  defense evasion and to look further for events after this behavior.

SEARCH:  '| tstats `security_content_summariesonly` count FROM datamodel=Endpoint.Registry  WHERE (Registry.registry_path = "*\\SOFTWARE\\Policies\\Microsoft\\Windows Defender\\Exclusions\\*")  BY _time span=1h Registry.dest Registry.user Registry.registry_path Registry.registry_key_name Registry.registry_value_name  Registry.registry_value_data Registry.process_guid | `drop_dm_object_name(Registry)` | where isnotnull(registry_value_data) | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `windows_defender_exclusion_registry_entry_filter`'



<li><a href="#">NAME: Windows Deleted Registry By A Non Critical Process File Path

DESCRIPTION:  This analytic is to detect deletion of registry with suspicious process  file path. This technique was seen in Double Zero wiper malware where it will delete  all the subkey in HKLM, HKCU and HKU registry hive as part of its destructive payload  to the targeted hosts. This anomaly detections can catch possible malware or advesaries  deleting registry as part of defense evasion or even payload impact but can also  catch for third party application updates or installation. In this scenario false  positive filter is needed.

SEARCH:  '| tstats `security_content_summariesonly` count from datamodel=Endpoint.Registry  WHERE Registry.action=deleted BY _time span=1h Registry.dest Registry.registry_path  Registry.registry_value_name Registry.registry_key_name Registry.process_guid Registry.registry_value_data  Registry.action | `drop_dm_object_name(Registry)` | join process_guid [| tstats  `security_content_summariesonly` count FROM datamodel=Endpoint.Processes WHERE NOT  (Processes.process_path IN ("*\\windows\\*", "*\\program files*")) by _time span=1h  Processes.process_id Processes.process_name Processes.process Processes.user Processes.parent_process_name  Processes.parent_process Processes.process_path Processes.process_guid | `drop_dm_object_name(Processes)`]  | fields _time parent_process_name parent_process process_name process_path process  process_guid registry_path registry_value_name registry_value_data registry_key_name  action dest user | `windows_deleted_registry_by_a_non_critical_process_file_path_filter`'



<li><a href="#">NAME: Windows Delete or Modify System Firewall

DESCRIPTION:  This analytic identifies potentially malicious 'netsh' processes that manipulate firewall configurations.   This behavior has been observed in the NJRAT malware, which deletes its added firewall rules as part of its cleanup process.   Leveraging this anomaly detection can be a valuable approach for detecting malware, such as NJRAT,   that makes alterations to firewall configurations as a component of its malicious activities.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time) as lastTime from datamodel=Endpoint.Processes   where `process_netsh` Processes.process = "* firewall *" Processes.process = "* delete *"  by Processes.parent_process Processes.parent_process_name Processes.process_name Processes.process_id Processes.process_guid Processes.process Processes.user Processes.dest  | `drop_dm_object_name("Processes")`   | `security_content_ctime(firstTime)`   | `security_content_ctime(lastTime)`   | `windows_delete_or_modify_system_firewall_filter`'



<li><a href="#">NAME: Windows DisableAntiSpyware Registry

DESCRIPTION:  The search looks for the Registry Key DisableAntiSpyware set to disable.  This is consistent with Ryuk infections across a fleet of endpoints. This particular  behavior is typically executed when an ransomware actor gains access to an endpoint  and beings to perform execution. Usually, a batch (.bat) will be executed and multiple  registry and scheduled task modifications will occur. During triage, review parallel  processes and identify any further file modifications. Endpoint should be isolated.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Registry where Registry.registry_value_name="DisableAntiSpyware"  AND Registry.registry_value_data="0x00000001" by Registry.dest Registry.user Registry.registry_path  Registry.registry_value_data | `drop_dm_object_name(Registry)` | `security_content_ctime(lastTime)`  | `security_content_ctime(firstTime)` | `windows_disableantispyware_registry_filter`'



<li><a href="#">NAME: Windows Disable Change Password Through Registry

DESCRIPTION:  This analytic is to detect a suspicious registry modification to disable  change password feature of the windows host. This registry modification may disables  the Change Password button on the Windows Security dialog box (which appears when  you press Ctrl+Alt+Del). As a result, users cannot change their Windows password  on demand. This technique was seen in some malware family like ransomware to prevent  the user to change the password after ownning the network or a system during attack.  This windows feature may implemented by administrator to prevent normal user to  change the password of a critical host or server, In this type of scenario filter  is needed to minimized false positive.

SEARCH:  '| tstats `security_content_summariesonly` count FROM datamodel=Endpoint.Registry  WHERE (Registry.registry_path= "*\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System\\DisableChangePassword"  Registry.registry_value_data = "0x00000001") BY _time span=1h Registry.dest Registry.registry_path  Registry.registry_key_name Registry.registry_value_name Registry.registry_value_data  Registry.process_guid | `drop_dm_object_name(Registry)` | where isnotnull(registry_value_data)  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `windows_disable_change_password_through_registry_filter`'



<li><a href="#">NAME: Windows Disable Lock Workstation Feature Through Registry

DESCRIPTION:  This analytic is to detect a suspicious registry modification to disable  Lock Computer windows features. This registry modification prevent the user from  locking its screen or computer that are being abused by several malware for example  ransomware. This technique was used by threat actor to make its payload more impactful  to the compromised host.

SEARCH:  '| tstats `security_content_summariesonly` count FROM datamodel=Endpoint.Registry  WHERE (Registry.registry_path= "*\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System\\DisableLockWorkstation"  Registry.registry_value_data = "0x00000001") BY _time span=1h Registry.dest Registry.user Registry.registry_path  Registry.registry_key_name Registry.registry_value_name Registry.registry_value_data  Registry.process_guid | `drop_dm_object_name(Registry)` | where isnotnull(registry_value_data)  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `windows_disable_lock_workstation_feature_through_registry_filter`'



<li><a href="#">NAME: Windows Disable LogOff Button Through Registry

DESCRIPTION:  This analytic is to detect a suspicious registry modification to disable  logoff feature in windows host. This registry when enable will prevent users to  log off of the system by using any method, including programs run from the command  line, such as scripts. It also disables or removes all menu items and buttons that  log the user off of the system. This technique was seen abused by ransomware malware  to make the compromised host un-useful and hard to remove other registry modification  made on the machine that needs restart to take effect. This windows feature may  implement by administrator in some server where shutdown is critical. In that scenario  filter of machine and users that can modify this registry is needed.

SEARCH:  '| tstats `security_content_summariesonly` count FROM datamodel=Endpoint.Registry  WHERE (Registry.registry_path= "*\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer\\*"  Registry.registry_value_name IN ("NoLogOff", "StartMenuLogOff") Registry.registry_value_data  = "0x00000001") BY _time span=1h Registry.dest Registry.user Registry.registry_path Registry.registry_key_name  Registry.registry_value_name Registry.registry_value_data Registry.process_guid  | `drop_dm_object_name(Registry)` | where isnotnull(registry_value_data)  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `windows_disable_logoff_button_through_registry_filter`'



<li><a href="#">NAME: Windows Disable Memory Crash Dump

DESCRIPTION:  The following analytic identifies a process that is attempting to disable  the ability on Windows to generate a memory crash dump. This was recently identified  being utilized by HermeticWiper. To disable crash dumps, the value must be set to  0. This feature is typically modified to perform a memory crash dump when a computer  stops unexpectedly because of a Stop error (also known as a blue screen, system  crash, or bug check).

SEARCH:  '| tstats `security_content_summariesonly` count FROM datamodel=Endpoint.Registry  where (Registry.registry_path="*\\CurrentControlSet\\Control\\CrashControl\\CrashDumpEnabled")  AND Registry.registry_value_data="0x00000000" by _time span=1h Registry.dest Registry.user  Registry.registry_path Registry.registry_value_name Registry.registry_value_data  Registry.process_guid Registry.registry_key_name  | `drop_dm_object_name(Registry)`  | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)`  | `windows_disable_memory_crash_dump_filter`'



<li><a href="#">NAME: Windows Disable Notification Center

DESCRIPTION:  The following search identifies a modification of registry to disable  the windows notification center feature in a windows host machine. This registry  modification removes notification and action center from the notification area on  the task bar. This modification are seen in RAT malware to cover their tracks upon  downloading other of its component or other payload.

SEARCH:  '| tstats `security_content_summariesonly` count FROM datamodel=Endpoint.Registry  WHERE (Registry.registry_value_name= "DisableNotificationCenter" Registry.registry_value_data  = "0x00000001") BY _time span=1h Registry.dest Registry.user Registry.registry_path  Registry.registry_key_name Registry.registry_value_name Registry.registry_value_data  Registry.process_guid | `drop_dm_object_name(Registry)` | where isnotnull(registry_value_data)  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `windows_disable_notification_center_filter`'



<li><a href="#">NAME: Windows Disable or Modify Tools Via Taskkill

DESCRIPTION:  This analytic is designed to identify potentially malicious processes that terminate other processes using taskkill.exe.  This technique has been observed in various malware instances, employed by adversaries and red teamers alike, to forcibly terminate  other processes whether they be security products or other legitimate applications as part of their malicious activities.   Detecting this anomaly serves as a valuable alert mechanism to identify suspicious processes or malware attempting to evade detection and disrupt system stability.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time) as lastTime from datamodel=Endpoint.Processes   where Processes.process_name = "taskkill.exe" Processes.process IN ("* /f*", "* /t*") Processes.process IN ("* /im*", "* /pid*")  by Processes.parent_process_name Processes.parent_process Processes.process_name Processes.process Processes.process_id Processes.process_guid  Processes.user Processes.dest  | `drop_dm_object_name("Processes")`   | `security_content_ctime(firstTime)`   | `security_content_ctime(lastTime)`   | `windows_disable_or_modify_tools_via_taskkill_filter`'



<li><a href="#">NAME: Windows Disable Shutdown Button Through Registry

DESCRIPTION:  This analytic is to detect a suspicious registry modification to disable  shutdown button on the logon user. This technique was seen in several malware especially  in ransomware family like killdisk malware variant to make the compromised host  un-useful and hard to remove other registry modification made on the machine that  needs restart to take effect. This windows feature may implement by administrator  in some server where shutdown is critical. In that scenario filter of machine and  users that can modify this registry is needed.

SEARCH:  '| tstats `security_content_summariesonly` count FROM datamodel=Endpoint.Registry  WHERE ((Registry.registry_path= "*\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System\\shutdownwithoutlogon"  Registry.registry_value_data = "0x00000000") OR (Registry.registry_path="*\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer\\NoClose"  Registry.registry_value_data = "0x00000001")) BY _time span=1h Registry.dest Registry.user Registry.registry_path  Registry.registry_key_name Registry.registry_value_name Registry.registry_value_data  Registry.process_guid | `drop_dm_object_name(Registry)` | where isnotnull(registry_value_data)  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `windows_disable_shutdown_button_through_registry_filter`'



<li><a href="#">NAME: Windows Disable Windows Event Logging Disable HTTP Logging

DESCRIPTION:  The following analytic identifies AppCmd.exe being utilized to disable  HTTP logging on IIS. Adversaries may perform this action to disable logging and  delete the logs so remove any trace or events on disk.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where NOT (Processes.parent_process_name  IN  ("msiexec.exe", "iissetup.exe")) Processes.process_name=appcmd.exe Processes.process  IN ("*set config*", "*httplogging*","*dontlog:true*") by Processes.dest Processes.user  Processes.parent_process_name Processes.process_name Processes.original_file_name  Processes.process Processes.process_id Processes.parent_process_id | `drop_dm_object_name(Processes)`  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `windows_disable_windows_event_logging_disable_http_logging_filter`'



<li><a href="#">NAME: Windows Disable Windows Group Policy Features Through Registry

DESCRIPTION:  This analytic is to detect a suspicious registry modification to disable  windows features. These techniques are seen in several ransomware malware to impair  the compromised host to make it hard for analyst to mitigate or response from the  attack. Disabling these known features make the analysis and forensic response more  hard. Disabling these feature is not so common but can still be implemented by the  administrator for security purposes. In this scenario filters for users that are  allowed doing this is needed.

SEARCH:  '| tstats `security_content_summariesonly` count FROM datamodel=Endpoint.Registry  WHERE (Registry.registry_path= "*\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer\\*"  OR Registry.registry_path= "*\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System\\*"  Registry.registry_value_name IN ("NoDesktop", "NoFind", "NoControlPanel", "NoFileMenu",  "NoSetTaskbar", "NoTrayContextMenu", "TaskbarLockAll", "NoThemesTab","NoPropertiesMyDocuments","NoVisualStyleChoice","NoColorChoice","NoPropertiesMyDocuments")  Registry.registry_value_data = "0x00000001") BY _time span=1h Registry.dest Registry.user  Registry.registry_path Registry.registry_key_name Registry.registry_value_name Registry.registry_value_data  Registry.process_guid | `drop_dm_object_name(Registry)` | where isnotnull(registry_value_data)  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `windows_disable_windows_group_policy_features_through_registry_filter`'



<li><a href="#">NAME: Windows DiskCryptor Usage

DESCRIPTION:  The following analytic identifies DiskCryptor  process name of dcrypt.exe  or internal name dcinst.exe. This utility has been utilized by adversaries to encrypt  disks manually during an operation. In addition, during install, a dcrypt.sys driver  is installed and requires a reboot in order to take effect. There are no command-line  arguments used.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where (Processes.process_name="dcrypt.exe"  OR Processes.original_file_name=dcinst.exe) by Processes.dest Processes.user Processes.parent_process_name  Processes.process_name Processes.original_file_name Processes.process Processes.process_id  Processes.parent_process_id | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `windows_diskcryptor_usage_filter`'



<li><a href="#">NAME: Windows Diskshadow Proxy Execution

DESCRIPTION:  DiskShadow.exe is a Microsoft Signed binary present on Windows Server.  It has a scripting mode intended for complex scripted backup operations. This feature  also allows for execution of arbitrary unsigned code. This analytic looks for the  usage of the scripting mode flags in executions of DiskShadow. During triage, compare  to known backup behavior in your environment and then review the scripts called  by diskshadow.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where `process_diskshadow` (Processes.process=*-s*  OR Processes.process=*/s*) by Processes.dest Processes.user Processes.parent_process  Processes.process_name Processes.process Processes.process_id Processes.parent_process_id  | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `windows_diskshadow_proxy_execution_filter`'



<li><a href="#">NAME: Windows DISM Remove Defender

DESCRIPTION:  The following analytic identifies the use of the Windows Disk Image Utility,  `dism.exe`, to remove Windows Defender. Adversaries may use `dism.exe` to disable  Defender before completing their objective.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.process_name=dism.exe  (Processes.process="*/online*" AND Processes.process="*/disable-feature*" AND Processes.process="*Windows-Defender*"  AND Processes.process="*/remove*") by Processes.dest Processes.user Processes.parent_process_name  Processes.process_name Processes.original_file_name Processes.process Processes.process_id  Processes.parent_process_id | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `windows_dism_remove_defender_filter`'



<li><a href="#">NAME: Windows DLL Search Order Hijacking Hunt

DESCRIPTION:  The following hunting analytic is an experimental query built against  a accidental feature using the latest Sysmon TA 3.0 (https://splunkbase.splunk.com/app/5709/)  which maps the module load (ImageLoaded) to process_name. This analytic will deprecate  once this is fixed. This hunting analytic identifies known libraries in Windows  that may be used in a DLL search order hijack or DLL Sideloading setting. This may  require recompiling the DLL, moving the DLL or moving the vulnerable process. The  query looks for any running out of system32 or syswow64. Some libraries natively  run out of other application paths and will need to be added to the exclusion as  needed. The lookup is comprised of Microsoft native libraries identified within  the Hijacklibs.net project.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime values(Processes.process_name) as process_name from datamodel=Endpoint.Processes  where Processes.dest!=unknown Processes.user!=unknown NOT (Processes.process_path  IN ("*\\system32\\*", "*\\syswow64\\*","*\\winsxs\\*","*\\wbem\\*"))  by Processes.dest  Processes.user Processes.parent_process_name Processes.process_name Processes.process_path  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `drop_dm_object_name(Processes)`  | lookup hijacklibs library AS process_name OUTPUT islibrary | search islibrary  = True | rename parent_process_name as process_name , process_name AS ImageLoaded, process_path AS Module_Path | `windows_dll_search_order_hijacking_hunt_filter`'



<li><a href="#">NAME: Windows DLL Search Order Hijacking Hunt with Sysmon

DESCRIPTION:  The following hunting analytic is query built against  a accidental feature using the latest Sysmon TA 3.0 (https://splunkbase.splunk.com/app/5709/)  which maps the module load (ImageLoaded) to process_name. This analytic will deprecate  once this is fixed. This hunting analytic identifies known libraries in Windows  that may be used in a DLL search order hijack or DLL Sideloading setting. This may  require recompiling the DLL, moving the DLL or moving the vulnerable process. The  query looks for any running out of system32 or syswow64. Some libraries natively  run out of other application paths and will need to be added to the exclusion as  needed. The lookup is comprised of Microsoft native libraries identified within  the Hijacklibs.net project.

SEARCH:  '`sysmon` EventCode=7 NOT (process_path IN ("*\\system32\\*", "*\\syswow64\\*","*\\winsxs\\*","*\\wbem\\*"))  | lookup hijacklibs library AS process_name OUTPUT islibrary | search islibrary  = True |rename process_name AS ImageLoaded process_path AS Module_Path  | stats count values(parent_process_name) as parent_process_name by _time dest ImageLoaded Module_Path  | `windows_dll_search_order_hijacking_hunt_with_sysmon_filter`'



<li><a href="#">NAME: Windows DLL Search Order Hijacking with iscsicpl

DESCRIPTION:  The following analytic identifies a recently disclosed search ordler  DLL hijack in iscsicpl.exe. The malicious DLL must be in a new path and iscsicpl.exe,  upon load, will execute the payload. The analytic is restricted to Windows shells.  Two proof of concepts were identified and utilized to determine the behavior. The  command-line is an option to go after, but most likely identifying a child process  off iscsicpl.exe will be more effective. Monitoring for suspicious DLL loads is  also an option.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.parent_process_name=iscsicpl.exe  `windows_shells` by Processes.dest Processes.user Processes.parent_process_name  Processes.process_name Processes.process Processes.process_id Processes.parent_process_id  | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`|  `windows_dll_search_order_hijacking_with_iscsicpl_filter`'



<li><a href="#">NAME: Windows DLL Side-Loading In Calc

DESCRIPTION:  The following analytic identifies suspicious DLL modules loaded by calc.exe  that are not in windows %systemroot%\system32 or %systemroot%\sysWoW64 folder. This  technique is well used by Qakbot malware to execute its malicious DLL file via dll  side loading technique in calc process execution. This TTP detection is a good indicator  that a suspicious dll was loaded in a public or non-common installation folder of  Windows Operating System that needs further investigation.

SEARCH:  '`sysmon` EventCode=7 Image = "*\calc.exe" AND NOT (Image IN ("*:\\windows\\system32\\*",  "*:\\windows\\sysWow64\\*")) AND NOT(ImageLoaded IN("*:\\windows\\system32\\*",  "*:\\windows\\sysWow64\\*", "*:\\windows\\WinSXS\\*")) | stats count min(_time)  as firstTime max(_time) as lastTime by Image ImageLoaded OriginalFileName Product  process_name dest EventCode Signed ProcessId | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `windows_dll_side_loading_in_calc_filter`'



<li><a href="#">NAME: Windows DLL Side-Loading Process Child Of Calc

DESCRIPTION:  The following analytic identifies the suspicious child process of calc.exe  due to dll side loading technique to execute another executable. This technique  was seen in qakbot malware that uses dll side loading technique to calc applications  to load its malicious dll code. The malicious dll that abuses dll side loading technique  will load the actual qakbot loader dll using regsvr32.exe application. This TTP  is a good indicator of qakbot since the calc.exe will not load other child processes  aside from win32calc.exe.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where (Processes.parent_process_name  = "calc.exe")  AND Processes.process_name != "win32calc.exe" by Processes.parent_process  Processes.process_name Processes.process_id Processes.process_guid Processes.process  Processes.user Processes.dest | `drop_dm_object_name("Processes")` | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `windows_dll_side_loading_process_child_of_calc_filter`'



<li><a href="#">NAME: Windows DnsAdmins New Member Added

DESCRIPTION:  The following analytic leverages Event ID 4732 to identify the addition of a new member to the DnsAdmins group within Active Directory. . Members of the DnsAdmin group can manage  the DNS service which most of the times runs on the Domain Controller. By abusing legitimate DNS management functionality, a member of the DnsAdmins group can escalate privileges by  executing malicious code on a Domain Controller as SYSTEM. Security teams should monitor the modification of the DnsAdmins group and validate the changes are legitimate.

SEARCH:  ' `wineventlog_security` EventCode=4732 TargetUserName=DnsAdmins | stats min(_time) as firstTime max(_time) as lastTime values(TargetUserName) as target_users_added values(user) as user by  dest src_user | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `windows_dnsadmins_new_member_added_filter`'



<li><a href="#">NAME: Windows DNS Gather Network Info

DESCRIPTION:  The following analytic identifies a process command line used to enumerate  DNS records. Adversaries, threat actors, or red teamers may employ this technique  to gather information about a victim's DNS, which can be utilized during targeting.  This method was also observed as part of a tool used by the Sandworm APT group in  a geopolitical cyber warfare attack. By using the dnscmd.exe Windows application,  an attacker can enumerate DNS records for specific domains within the targeted network,  potentially aiding in further attacks. This anomaly detection can serve as a valuable  starting point for identifying users and hostnames that may be compromised or targeted  by adversaries seeking to collect data information.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.process_name = "dnscmd.exe"  Processes.process = "* /enumrecords *" by Processes.parent_process Processes.process_name  Processes.process_id Processes.process_guid Processes.process Processes.user Processes.dest  | `drop_dm_object_name("Processes")` | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `windows_dns_gather_network_info_filter`'



<li><a href="#">NAME: Windows Domain Account Discovery Via Get-NetComputer

DESCRIPTION:  The following analytic leverages Event ID 4104 to identify the execution of the PowerView powershell commandlets Get-NetComputer.  This technique was seen used in the context of PowerView's Get-NetUser cmdlet as a filter or parameter   to query Active Directory user account's "samccountname", "accountexpires", "lastlogon" and so on. This hunting query is a good pivot to look for suspicious process   or malware that gather user account information in a host or within network system. 

SEARCH:  '`powershell` EventCode=4104  ScriptBlockText = "*Get-NetComputer*" ScriptBlockText IN ("*samaccountname*", "*accountexpires*", "*lastlogon*", "*lastlogoff*", "*pwdlastset*", "*logoncount*")  | rename Computer as dest, UserID as user  | stats count min(_time) as firstTime max(_time) as lastTime by EventCode ScriptBlockText dest user  | `security_content_ctime(firstTime)`   | `security_content_ctime(lastTime)`   | `windows_domain_account_discovery_via_get_netcomputer_filter`'



<li><a href="#">NAME: Windows Domain Admin Impersonation Indicator

DESCRIPTION:  The following analytic identifies potential Kerberos ticket forging attacks, specifically the Diamond Ticket attack. This is detected when a user logs into a host and the GroupMembership field in event 4627 indicates a privileged group (e.g., Domain Admins), but the user does not actually belong to that group in the directory service. The detection leverages Windows Security Event Log 4627, which logs account logon events. The analytic cross-references the GroupMembership field from the event against a pre-populated lookup of actual group memberships. Its crucial to note that the accuracy and effectiveness of this detection heavily rely on the users diligence in populating and regularly updating this lookup table. Any discrepancies between the events GroupMembership and the lookup indicate potential ticket forging. Kerberos ticket forging, especially the Diamond Ticket attack, allows attackers to impersonate any user and potentially gain unauthorized access to resources. By forging a ticket that indicates membership in a privileged group, an attacker can bypass security controls and gain elevated privileges. Detecting such discrepancies in group memberships during logon events can be a strong indicator of this attack in progress, making it crucial for security teams to monitor and investigate. If validated as a true positive, this indicates that an attacker has successfully forged a Kerberos ticket and may have gained unauthorized access to critical resources, potentially with elevated privileges.

SEARCH:  ' `wineventlog_security`  EventCode=4627 LogonType=3 NOT TargetUserName IN ("*$", "SYSTEM", "DWM-*","LOCAL SERVICE","NETWORK SERVICE", "ANONYMOUS LOGON", "UMFD-*")   | where match(GroupMembership, "Domain Admins")   | lookup domain_admins username as TargetUserName OUTPUT username | fillnull value=NotDA username  | search username = "NotDA"  | stats  count by _time, TargetUserName, GroupMembership, host  | `windows_domain_admin_impersonation_indicator_filter`'



<li><a href="#">NAME: Windows DotNet Binary in Non Standard Path

DESCRIPTION:  The following analytic identifies native .net binaries within the Windows  operating system that may be abused by adversaries by moving it to a new directory.  The analytic identifies the .net binary by using a lookup and compares the process  name and original file name (internal name). The analytic utilizes a lookup with  the is_net_windows_file macro to identify the binary process name and original file  name. if one or the other matches an alert will be generated. Adversaries abuse  these binaries as they are native to windows and native DotNet. Note that not all  SDK (post install of Windows) are captured in the lookup.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime FROM datamodel=Endpoint.Processes where NOT (Processes.process_path  IN ("*\\Windows\\ADWS\\*","*\\Windows\\SysWOW64*", "*\\Windows\\system32*", "*\\Windows\\NetworkController\\*",  "*\\Windows\\SystemApps\\*", "*\\WinSxS\\*", "*\\Windows\\Microsoft.NET\\*")) by  Processes.dest Processes.user Processes.parent_process_name Processes.parent_process Processes.process_name Processes.process  Processes.original_file_name Processes.process_path Processes.process_id Processes.parent_process_id  | `drop_dm_object_name("Processes")` | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `is_net_windows_file` | `windows_dotnet_binary_in_non_standard_path_filter`'



<li><a href="#">NAME: Windows Drivers Loaded by Signature

DESCRIPTION:  The following analytic assists with viewing all drivers being loaded  by using Sysmon EventCode 6 (Driver Load). Sysmon provides some simple fields to  assist with identifying suspicious drivers. Use this analytic to look at prevalence  of driver (count), path of driver, signature status and hash. Review these fields  with scrutiny until the ability to prove the driver is legitimate and has a purpose  in the environment.

SEARCH:  '`sysmon` EventCode=6 | stats min(_time) as firstTime max(_time) as lastTime  values(ImageLoaded) count by dest Signed Signature service_signature_verified  service_signature_exists Hashes | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `windows_drivers_loaded_by_signature_filter`'



<li><a href="#">NAME: Windows Driver Inventory

DESCRIPTION:  The following hunting / inventory query assists defenders in identifying  Drivers being loaded across the fleet. This query relies upon a PowerShell script  input to be deployed to critical systems and beyond. If capturing all via the input,  this will provide retrospection into drivers persisting. Note, that this is not  perfect across a large fleet. Modify the query as you need to view the data differently.

SEARCH:  '`driverinventory` | stats values(Path) min(_time) as firstTime max(_time)  as lastTime count by host DriverType | rename host as dest | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `windows_driver_inventory_filter`'



<li><a href="#">NAME: Windows Driver Load Non-Standard Path

DESCRIPTION:   The following analytic uses Windows EventCode 7045 to identify new Kernel  Mode Drivers being loaded in Windows from a non-standard path. Note that, adversaries  may move malicious or vulnerable drivers into these paths and load up. The idea  is that this analytic provides visibility into drivers loading in non-standard file  paths.

SEARCH:  '`wineventlog_system` EventCode=7045 ServiceType="kernel mode driver" NOT (ImagePath IN ("*\\Windows\\*", "*\\Program File*", "*\\systemroot\\*","%SystemRoot%*", "system32\*"))  | stats count min(_time) as firstTime max(_time) as lastTime by Computer EventCode ImagePath ServiceName ServiceType | rename Computer as dest  | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)`  | `windows_driver_load_non_standard_path_filter`'



<li><a href="#">NAME: Windows Enable Win32 ScheduledJob via Registry

DESCRIPTION:  'This analytic searches for a registry modification that enables the use of the at.exe or wmi Win32_ScheduledJob command to add scheduled tasks on a Windows endpoint. Specifically, it looks for the creation of a new DWORD value named "EnableAt" in the following registry path: "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Schedule\Configuration". If this value is set to 1, it enables the at.exe and wmi Win32_ScheduledJob commands to schedule tasks on the system. Detecting this registry modification is important because it may indicate that an attacker has enabled the ability to add scheduled tasks to the system, which can be used to execute malicious code at specific times or intervals.'

SEARCH:  '| tstats `security_content_summariesonly` count values(Registry.registry_key_name)  as registry_key_name values(Registry.registry_path) as registry_path min(_time)  as firstTime max(_time) as lastTime from datamodel=Endpoint.Registry where Registry.registry_path="*\\CurrentVersion\\Schedule\\Configuration*" Registry.registry_value_name=EnableAt  by  Registry.dest, Registry.user, Registry.registry_value_name, Registry.registry_value_type | `security_content_ctime(lastTime)` | `security_content_ctime(firstTime)`  | `drop_dm_object_name(Registry)` | `windows_enable_win32_scheduledjob_via_registry_filter`'



<li><a href="#">NAME: Windows Event For Service Disabled

DESCRIPTION:  This analytic will identify suspicious system event of services that  was modified from start to disabled. This technique is seen where the adversary  attempts to disable security app services, other malware services to evade the defense  systems on the compromised host

SEARCH:  '`wineventlog_system` EventCode=7040  Message = "*service was changed from  demand start to disabled." | stats count min(_time) as firstTime max(_time) as lastTime  by ComputerName EventCode Message User Sid service service_name | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `windows_event_for_service_disabled_filter`'



<li><a href="#">NAME: Windows Event Log Cleared

DESCRIPTION:  The following analytic utilizes Windows Security Event ID 1102 or System  log event 104 to identify when a Windows event log is cleared. Note that this analytic  will require tuning or restricted to specific endpoints based on criticality. During  triage, based on time of day and user, determine if this was planned. If not planned,  follow through with reviewing parallel alerts and other data sources to determine  what else may have occurred.

SEARCH:  (`wineventlog_security` EventCode=1102) OR (`wineventlog_system` EventCode=104)  | stats count min(_time) as firstTime max(_time) as lastTime by dest Message EventCode  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `windows_event_log_cleared_filter`



<li><a href="#">NAME: Windows Event Triggered Image File Execution Options Injection

DESCRIPTION:  The following hunting analytic identifies EventCode 3000 in Application  channel indicating a process exit. This behavior is based on process names being  added to the Image File Execution Options under HKLM \SOFTWARE\Microsoft\Windows  NT\CurrentVersion\Image File Execution Options\ and \SOFTWARE\Microsoft\Windows  NT\CurrentVersion\SilentProcessExit. Once these are set for a process, an eventcode  3000 will generate. The example used is from Thinkst Canary where a CanaryToken  is setup to monitor for a commonly abused living off the land binary (ex. Klist.exe)  and generate an event when it occurs. This can be seen as settings traps to monitor  for suspicious behavior. Monitor and tune this hunting analytic and setup traps  across your organization and begin monitoring.

SEARCH:  '`wineventlog_application` EventCode=3000 | rename param1 AS "Process" param2  AS "Exit_Code" | stats count min(_time) as firstTime max(_time) as lastTime by Process  Exit_Code dest | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `windows_event_triggered_image_file_execution_options_injection_filter`'



<li><a href="#">NAME: Windows Excessive Disabled Services Event

DESCRIPTION:  This analytic will identify suspicious excessive number of system events  of services that was modified from start to disabled. This technique is seen where  the adversary attempts to disable security app services, other malware services  oer serve as an destructive impact to complete the objective on the compromised  system. One good example for this scenario is Olympic destroyer where it disable  all active services in the compromised host as part of its destructive impact and  defense evasion.

SEARCH:  '`wineventlog_system` EventCode=7040 Message = "*service was changed from demand start to disabled."  | rename ComputerName as src  | stats count values(Message) as MessageList dc(Message) as MessageCount min(_time) as firstTime max(_time) as lastTime by src EventCode  User Sid   | where MessageCount >=10   | `security_content_ctime(firstTime)`   | `security_content_ctime(lastTime)`  | `windows_excessive_disabled_services_event_filter`'



<li><a href="#">NAME: Windows Executable in Loaded Modules

DESCRIPTION:  This analytic identifies potentially malicious 'ImageLoaded' events, particularly when they involve executable files.   This behavior was observed in NjRAT instances, where, during each instance of loading a module from its C2 server onto the compromised host,   Sysmon recorded the path of the actual Image or Process as an 'ImageLoaded' event, rather than the typical tracking of dynamically loaded DLL modules in memory.  This event holds significance because it tracks processes that load modules and libraries, which are typically in the .dll format rather than .exe.   Leveraging this 'Time-To-Perform' (TTP) detection method can prove invaluable for the identification of NjRAT malware or   other malicious software instances that introduce executable files as modules within a targeted host.

SEARCH:  '`sysmon` EventCode=7 ImageLoaded= *.exe  | stats count min(_time) as firstTime max(_time) as lastTime by Image ImageLoaded Signed SignatureStatus OriginalFileName process_name Computer EventCode ProcessId Hashes IMPHASH   | rename Computer as dest   | `security_content_ctime(firstTime)`   | `security_content_ctime(lastTime)`   | `windows_executable_in_loaded_modules_filter`'



<li><a href="#">NAME: Windows Execute Arbitrary Commands with MSDT

DESCRIPTION:  The following analytic identifies a recently disclosed arbitraty command  execution using Windows msdt.exe - a Diagnostics Troubleshooting Wizard. The sample  identified will use the ms-msdt:/ protocol handler to load msdt.exe to retrieve  a remote payload. During triage, review file modifications for html. Identify parallel  process execution that may be related, including an Office Product.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.process_name=msdt.exe  Processes.process IN ("*msdt*","*ms-msdt:*","*ms-msdt:/id*","*ms-msdt:-id*","*/id*")  AND (Processes.process="*IT_BrowseForFile=*" OR Processes.process="*IT_RebrowseForFile=*"  OR Processes.process="*.xml*") AND Processes.process="*PCWDiagnostic*" by Processes.dest  Processes.user Processes.parent_process_name Processes.process_name Processes.process  Processes.process_id Processes.parent_process_id | `drop_dm_object_name(Processes)`  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`| `windows_execute_arbitrary_commands_with_msdt_filter`'



<li><a href="#">NAME: Windows Exfiltration Over C2 Via Invoke RestMethod

DESCRIPTION:  The following analytic identifies the potential exfiltration of data using PowerShell's Invoke-RestMethod. This technique was observed in the Winter-Vivern malware, which uploads desktop screenshots and files from compromised or targeted hosts. Detecting this TTP can serve as a valuable indicator that a process is attempting to upload files to an external or internal URI link. We recommend examining the process, the files it is trying to upload, and the URL link or C2 destination where the data is being uploaded.

SEARCH:  '`powershell` EventCode=4104 ScriptBlockText = "*Invoke-RestMethod *" AND ScriptBlockText = "* -Uri *" AND ScriptBlockText = "* -Method *" AND ScriptBlockText = "* Post *" AND ScriptBlockText = "* -InFile *"  | stats count min(_time) as firstTime max(_time) as lastTime by EventCode ScriptBlockText Computer UserID  | `security_content_ctime(firstTime)`   | `security_content_ctime(lastTime)`   | `windows_exfiltration_over_c2_via_invoke_restmethod_filter`'



<li><a href="#">NAME: Windows Exfiltration Over C2 Via Powershell UploadString

DESCRIPTION:  The following analytic identifies potential data exfiltration using the PowerShell net.webclient command. This technique was observed in the Winter-Vivern malware, which uploads desktop screenshots and files from compromised or targeted hosts. Detecting this TTP can serve as a valuable indicator that a process is attempting to upload files to an external or internal URI link. We recommend examining the process, the files it is trying to upload, and the URL link or C2 destination where the data is being uploaded.

SEARCH:  '`powershell` EventCode=4104 ScriptBlockText = "*Net.webclient*" AND ScriptBlockText = "*.UploadString*"   | stats count min(_time) as firstTime max(_time) as lastTime by EventCode ScriptBlockText Computer UserID  | `security_content_ctime(firstTime)`   | `security_content_ctime(lastTime)`   | `windows_exfiltration_over_c2_via_powershell_uploadstring_filter`'



<li><a href="#">NAME: Windows Export Certificate

DESCRIPTION:  The following analytic identifies when a certificate is exported from  the Windows Certificate Store. This analytic utilizes the Certificates Lifecycle  log channel event ID 1007. EventID 1007 is focused on the Export of a certificate  from the local certificate store. In addition, review the ProcessName field as it  will help to determine automation/Admin or adversary extracting the certificate.  Depending on the organization, the certificate may be used for authentication to  the VPN or private resources.

SEARCH:  '`certificateservices_lifecycle` EventCode=1007 | xmlkv UserData_Xml | stats  count min(_time) as firstTime max(_time) as lastTime by Computer, SubjectName, UserData_Xml  | rename Computer as dest | `security_content_ctime(firstTime)`| `security_content_ctime(lastTime)`  | `windows_export_certificate_filter`'



<li><a href="#">NAME: Windows Njrat Fileless Storage via Registry

DESCRIPTION:  The following analytic identifies a suspicious registry modification associated with NjRat,   a telltale sign of its fileless technique. NjRat employs this method to manage its keylogs and execute downloaded DLL module plugins discreetly on the compromised host.   This approach is particularly effective at evading conventional file-based detection systems, as it stores indicators of compromise (IOCs) in the registry.   Leveraging this TTP (Tactics, Techniques, and Procedures) detection can significantly enhance the identification of NjRAT infections.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time) as lastTime from datamodel=Endpoint.Registry   where Registry.registry_path="*\\[kl]" OR  Registry.registry_value_data IN ("*[ENTER]*", "*[TAP]*", "*[Back]*")  by Registry.dest Registry.user Registry.registry_path Registry.registry_value_data Registry.registry_key_name Registry.registry_value_name  | `drop_dm_object_name(Registry)`   | `security_content_ctime(lastTime)`  | `security_content_ctime(firstTime)`   | `windows_njrat_fileless_storage_via_registry_filter`'



<li><a href="#">NAME: Windows Files and Dirs Access Rights Modification Via Icacls

DESCRIPTION:  This analytic aims to identify potential adversaries who manipulate the  security permissions of specific files or directories. This technique is frequently  observed in the tradecraft of Advanced Persistent Threats (APTs) and coinminer scripts.  By modifying the security permissions, adversaries seek to evade detection and impede  access to their component files. Such actions indicate a deliberate effort to maintain  control over compromised systems and hinder investigation or remediation efforts.  Detecting these security permission changes can serve as a valuable indicator of  an ongoing attack and enable timely response to mitigate the impact of the adversary's  activities.

SEARCH:  '| tstats `security_content_summariesonly` min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.process_name IN( "icacls.exe",  "cacls.exe","xcacls.exe") AND Processes.process IN ("*:R*", "*:W*", "*:F*", "*:C*",,  "*:N*","*/P*", "*/E*") by Processes.parent_process_name Processes.parent_process  Processes.process_name Processes.process Processes.process_guid Processes.dest Processes.user  | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `windows_files_and_dirs_access_rights_modification_via_icacls_filter`'



<li><a href="#">NAME: Windows File Share Discovery With Powerview

DESCRIPTION:  The following analytic identifies the use of the Invoke-ShareFinder PowerShell commandlet part of PowerView. This module obtains the list of all  active domain computers and lists the active shares on each computer. Network file shares in Active Directory environments may contain sensitive information  like backups, scripts, credentials, etc. Adversaries who have obtained a foothold in an AD network may leverage PowerView to identify secrets and leverage them   for Privilege Escalation or Lateral Movement.

SEARCH:  '`powershell` EventCode=4104  (ScriptBlockText=Invoke-ShareFinder*)  | stats count min(_time) as firstTime max(_time) as lastTime by Opcode Computer UserID EventCode ScriptBlockText   | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `windows_file_share_discovery_with_powerview_filter`'



<li><a href="#">NAME: Windows File Transfer Protocol In Non-Common Process Path

DESCRIPTION:  The following analytic identifies a possible windows application having  a FTP connection in a non common installation path in windows operating system.This  network protocol is being used by adversaries, threat actors and malware like AgentTesla  as a Command And Control communication to transfer its collected stolen information  like the desktop screenshots, browser information and system information of a targeted  or compromised host.

SEARCH:  '`sysmon` EventCode=3 NOT(Image IN("*\\program files*", "*\\windows\\system32\\*","*\\windows\\SysWOW64\\*"))  (DestinationPortName="ftp" OR DestinationPort=21) | stats count min(_time) as firstTime  max(_time) as lastTime by Image DestinationPort DestinationPortName DestinationHostname  DestinationIp SourcePort SourcePortName Protocol SourceHostname dest user |  `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `windows_file_transfer_protocol_in_non_common_process_path_filter`'



<li><a href="#">NAME: Windows File Without Extension In Critical Folder

DESCRIPTION:  This analytic is to look for suspicious file creation in the critical  folder like "System32\Drivers" folder without file extension. This artifacts was  seen in latest hermeticwiper where it drops its driver component in Driver Directory  both the compressed(without file extension) and the actual driver component (with  .sys file extension). This TTP is really a good indication that a host might be  compromised by this destructive malware that wipes the boot sector of the system.

SEARCH:  '| tstats `security_content_summariesonly` count FROM datamodel=Endpoint.Filesystem  where Filesystem.file_path IN ("*\\System32\\drivers\\*", "*\\syswow64\\drivers\\*")  by _time span=5m Filesystem.dest Filesystem.user Filesystem.file_name Filesystem.file_path  Filesystem.process_guid Filesystem.file_create_time | `drop_dm_object_name(Filesystem)`  | rex field="file_name" "\.(?<extension>[^\.]*$)" | where isnull(extension) | join  process_guid [| tstats `security_content_summariesonly` count FROM datamodel=Endpoint.Processes  by _time span=5m Processes.process_name Processes.dest Processes.process_guid Processes.user  | `drop_dm_object_name(Processes)`] | stats count min(_time) as firstTime max(_time)  as lastTime by dest process_name process_guid file_name file_path file_create_time  user | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `windows_file_without_extension_in_critical_folder_filter`'



<li><a href="#">NAME: Windows Findstr GPP Discovery

DESCRIPTION:  The following analytic identifies the use of the findstr command employed  to search for unsecured credentials Group Policy Preferences (GPP). GPP are tools  that allow administrators to create domain policies with embedded credentials. These  policies allow administrators to set local accounts. These group policies are stored  in SYSVOL on a domain controller. This means that any domain user can view the SYSVOL  share and decrypt the password (using the AES key that has been made public). While  Microsoft released a patch that impedes Administrators to create unsecure credentials,  existing Group Policy Preferences files with passwords are not removed from SYSVOL.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where (Processes.process_name=findstr.exe  AND Processes.process=*sysvol* AND Processes.process=*cpassword*) by Processes.dest  Processes.user Processes.parent_process_name Processes.process_name Processes.process  Processes.process_id Processes.parent_process_id Processes.original_file_name |  `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `windows_findstr_gpp_discovery_filter`'



<li><a href="#">NAME: Windows Find Domain Organizational Units with GetDomainOU

DESCRIPTION:  This analytic leverages PowerShell Script Block Logging (EventCode=4104) to detect the execution of the `Get-DomainOU` commandlet. `Get-DomainOU` is a component of PowerView, a PowerShell toolkit designed for Windows domain enumeration. Identifying the use of `Get-DomainOU` is crucial as adversaries and Red Teams might employ it to gain insights into organizational units within Active Directory, potentially aiding in lateral movement or privilege escalation strategies.

SEARCH:  '`powershell` EventCode=4104 ScriptBlockText = "*Get-DomainOU*"   | stats count min(_time) as firstTime max(_time) as lastTime by EventCode ScriptBlockText Computer UserID | rename Computer as dest, UserID as user   | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`   | `windows_find_domain_organizational_units_with_getdomainou_filter`'



<li><a href="#">NAME: Windows Find Interesting ACL with FindInterestingDomainAcl

DESCRIPTION:  This analytic leverages PowerShell Script Block Logging (EventCode=4104) to detect the execution of the `Find-InterestingDomainAcl` commandlet. `Find-InterestingDomainAcl` is part of PowerView, a PowerShell toolkit designed for Windows domain enumeration. Detecting the use of `Find-InterestingDomainAcl` is crucial as adversaries and Red Teams might employ it to identify unusual or misconfigured Access Control Lists (ACLs) within the domain. Such ACLs can provide attackers with insights into potential privilege escalation opportunities or weak security postures within Active Directory.

SEARCH:  '`powershell` EventCode=4104 ScriptBlockText = "*Find-InterestingDomainAcl*"   | stats count min(_time) as firstTime max(_time) as lastTime by EventCode ScriptBlockText Computer UserID | rename Computer as dest, UserID as user  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`   | `windows_find_interesting_acl_with_findinterestingdomainacl_filter`' 



<li><a href="#">NAME: Windows Forest Discovery with GetForestDomain

DESCRIPTION:  This analytic utilizes PowerShell Script Block Logging (EventCode=4104) to detect the execution of the `Get-ForestDomain` commandlet. `Get-ForestDomain` is a component of PowerView, a PowerShell toolkit designed for Windows domain enumeration. Detecting the use of `Get-ForestDomain` is essential as adversaries and Red Teams might employ it to gain insights into the forest and domain configurations of an Active Directory environment.  Such information can provide attackers with a broader understanding of the domain structure and potential avenues for lateral movement or privilege escalation.

SEARCH:  '`powershell` EventCode=4104 ScriptBlockText = "*Get-ForestDomain*"   | stats count min(_time) as firstTime max(_time) as lastTime by EventCode ScriptBlockText Computer UserID | rename Computer as dest, UserID as user  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`   | `windows_forest_discovery_with_getforestdomain_filter`'



<li><a href="#">NAME: Windows Gather Victim Host Information Camera

DESCRIPTION:  The following analytic detects a powershell script that enumerate camera  mounted to the targeted host. This technique was seen in DCRat malware, where it  runs a powershell command to look for camera information that will be pass on to  its C2 server. This anomaly detection can be a good pivot to check who and why this  enumeration is needed and what parent process execute this powershell script command.

SEARCH:  '`powershell` EventCode=4104 ScriptBlockText= "* Win32_PnPEntity *" ScriptBlockText=  "*SELECT*" ScriptBlockText= "*WHERE*" ScriptBlockText = "*PNPClass*" ScriptBlockText  IN ("*Image*", "*Camera*") | stats count min(_time) as firstTime max(_time) as lastTime  by EventCode ScriptBlockText Computer UserID | rename Computer as dest | rename UserID as user | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `windows_gather_victim_host_information_camera_filter`'



<li><a href="#">NAME: Windows Gather Victim Identity SAM Info

DESCRIPTION:  The following analytic identifies a process that loads the samlib.dll  module. This module is being abused by adversaries, threat actors and red teamers  to access information of SAM objects or access credentials information in DC. This  hunting query can be a good indicator that a process is capable of accessing the  SAM object.

SEARCH:  '`sysmon` EventCode=7  (ImageLoaded = "*\\samlib.dll" AND OriginalFileName  = "samlib.dll") OR (ImageLoaded = "*\\samcli.dll" AND OriginalFileName = "SAMCLI.DLL")  AND NOT (Image IN("C:\\Windows\\*", "C:\\Program File*", "%systemroot%\\*")) | stats  count min(_time) as firstTime max(_time) as lastTime by Image ImageLoaded process_name  dest EventCode Signed ProcessId | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `windows_gather_victim_identity_sam_info_filter`'



<li><a href="#">NAME: Windows Gather Victim Network Info Through Ip Check Web Services

DESCRIPTION:  The following analytic identifies process that attempts to connect to  a known IP web services. This technique is commonly used by trickbot and other malware  to perform reconnaissance against the infected machine and look for its IP address.

SEARCH:  '`sysmon` EventCode=22  QueryName IN ("*wtfismyip.com", "*checkip.*", "*ipecho.net", "*ipinfo.io",   "*api.ipify.org", "*icanhazip.com", "*ip.anysrc.com","*api.ip.sb", "ident.me", "www.myexternalip.com",   "*zen.spamhaus.org", "*cbl.abuseat.org", "*b.barracudacentral.org", "*dnsbl-1.uceprotect.net",   "*spam.dnsbl.sorbs.net", "*iplogger.org*", "*ip-api.com*", "*geoip.*")   |  stats  min(_time) as firstTime max(_time) as lastTime count by  Image ProcessId QueryName QueryStatus QueryResults EventCode Computer   | rename Computer as dest  | `security_content_ctime(firstTime)`   | `security_content_ctime(lastTime)`   | `windows_gather_victim_network_info_through_ip_check_web_services_filter`'



<li><a href="#">NAME: Windows Get-AdComputer Unconstrained Delegation Discovery

DESCRIPTION:  The following analytic utilizes PowerShell Script Block Logging (EventCode=4104)  to identify the Get-ADComputer commandlet used with specific parameters to discover  Windows endpoints with Kerberos Unconstrained Delegation. Red Teams and adversaries  alike may leverage use this technique for situational awareness and Active Directory  Discovery.

SEARCH:  ' `powershell` EventCode=4104 (Message = "*Get-ADComputer*" AND Message =  "*TrustedForDelegation*") | stats count min(_time) as firstTime max(_time) as lastTime  by EventCode Message ComputerName User | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `windows_get_adcomputer_unconstrained_delegation_discovery_filter`'



<li><a href="#">NAME: Windows Get Local Admin with FindLocalAdminAccess

DESCRIPTION:  This analytic leverages PowerShell Script Block Logging (EventCode=4104) to detect the execution of the `Find-LocalAdminAccess` commandlet. `Find-LocalAdminAccess` is part of PowerView, a PowerShell toolkit designed for Windows domain enumeration. Detecting the use of `Find-LocalAdminAccess` is vital as adversaries and Red Teams might employ it to identify machines where the current user context has local administrator access. Such information can provide attackers with potential targets for lateral movement or privilege escalation within the network.

SEARCH:  '`powershell` EventCode=4104 ScriptBlockText = "*Find-LocalAdminAccess*"   | stats count min(_time) as firstTime max(_time) as lastTime by EventCode ScriptBlockText Computer UserID | rename Computer as dest, UserID as user  | `security_content_ctime(firstTime)`   | `security_content_ctime(lastTime)`   | `windows_get_local_admin_with_findlocaladminaccess_filter`'



<li><a href="#">NAME: Windows Group Policy Object Created

DESCRIPTION:  The following analytic leverages Event IDs 5136 and 51137 to identify  the creation of a new Group Policy Object. With GPOs, system administrators can  manage and configure applications, software operations, and user settings throughout  an entire organization. GPOs can be abused and leveraged by adversaries to escalate  privileges or deploy malware across an Active Directory network. As an example,  the Lockbit ransomware malware will create new group policies on the domain controller  that are then pushed out to every device on the network. Security teams should monitor  the creation of new Group Policy Objects.

SEARCH:  ' `wineventlog_security` EventCode=5137 OR (EventCode=5136 AttributeValue!="New  Group Policy Object" AND (AttributeLDAPDisplayName=displayName OR AttributeLDAPDisplayName=gPCFileSysPath)  ) ObjectClass=groupPolicyContainer | stats values(AttributeValue) as details values(SubjectUserSid)  as User values(ObjectDN) as ObjectDN by ObjectGUID Computer | eval GPO_Name = mvindex(details,  0) | eval GPO_Path = mvindex(details, 1) | fields - details | `windows_group_policy_object_created_filter`'



<li><a href="#">NAME: Windows Hidden Schedule Task Settings

DESCRIPTION:  The following analytic detects creation of hidden scheculed tasks such that it this task is not visible on the UI. Such behavior is indicative of certain malware, such as Industroyer2, or attacks leveraging living-off-the-land binaries (LOLBINs) to download additional payloads to a compromised machine. This analytic relies on the Windows Security EventCode 4698, indicating the creation of a scheduled task. The search focuses on identifying instances where the 'Hidden' setting is enabled, signaling potential nefarious activity. To implement this search, you need to ingest logs with task scheduling details from your endpoints. As false positives are currently unknown, it is advised to tune and filter based on the known use of task scheduling in your environment. This analytic provides crucial visibility into stealthy, potentially harmful scheduled tasks on Windows systems.

SEARCH:  '`wineventlog_security` EventCode=4698 | xmlkv Message | search Hidden = true  | stats count min(_time) as firstTime max(_time) as lastTime by  Task_Name, Command,  Author, Hidden, dest | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `windows_hidden_schedule_task_settings_filter`'



<li><a href="#">NAME: Windows Hide Notification Features Through Registry

DESCRIPTION:  This analytic is to detect a suspicious registry modification to hide  common windows notification feature from compromised host. This technique was seen  in some ransomware family to add more impact to its payload that are visually seen  by user aside from the encrypted files and ransomware notes. Even this a good anomaly  detection, administrator may implement this changes for auditing or security reason.  In this scenario filter is needed.

SEARCH:  '| tstats `security_content_summariesonly` count FROM datamodel=Endpoint.Registry  WHERE (Registry.registry_path= "*\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer\\*"  Registry.registry_value_name IN ("HideClock", "HideSCAHealth", "HideSCANetwork",  "HideSCAPower", "HideSCAVolume") Registry.registry_value_data = "0x00000001") BY  _time span=1h Registry.dest Registry.user Registry.registry_path Registry.registry_key_name Registry.registry_value_name  Registry.registry_value_data Registry.process_guid | `drop_dm_object_name(Registry)` | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `windows_hide_notification_features_through_registry_filter`'



<li><a href="#">NAME: Windows High File Deletion Frequency

DESCRIPTION:  This search looks for high frequency of file deletion relative to process  name and process id. These events usually happen when the ransomware tries to encrypt  the files with the ransomware file extensions and sysmon treat the original files  to be deleted as soon it was replace as encrypted data.

SEARCH:  '`sysmon` EventCode=23 TargetFilename IN ("*.cmd", "*.ini","*.gif", "*.jpg",  "*.jpeg", "*.db", "*.ps1", "*.doc*", "*.xls*", "*.ppt*", "*.bmp","*.zip", "*.rar",  "*.7z", "*.chm", "*.png", "*.log", "*.vbs", "*.js", "*.vhd", "*.bak", "*.wbcat",  "*.bkf" , "*.backup*", "*.dsk", "*.win") | stats values(TargetFilename) as deleted_files  min(_time) as firstTime max(_time) as lastTime count by dest user EventCode  Image ProcessID |where count >=100 | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `windows_high_file_deletion_frequency_filter`'



<li><a href="#">NAME: Windows Hijack Execution Flow Version Dll Side Load

DESCRIPTION:  This analytic is to detect a process loading version.dll that is not  in %windir%\\system32 or %windir%\\syswow64 dir path. This event is seen in ransomware  and APT malware that executes malicious version.dll placed in the same folder of  onedrive application that will execute that module. This technique is known to be  DLL side loading. This technique was used to execute an agent of Brute Ratel C4  red teaming tools to serve as remote admin tool to collect and compromise target  host.

SEARCH:  '`sysmon` EventCode=7 ImageLoaded = "*\\version.dll" AND (Signed = "false"  OR NOT(ImageLoaded IN("*\\windows\\system32*",  "*\\windows\\syswow64\\*"))) | stats  count min(_time) as firstTime max(_time) as lastTime by Image ImageLoaded process_name  dest EventCode Signed ProcessId | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `windows_hijack_execution_flow_version_dll_side_load_filter`'



<li><a href="#">NAME: Windows Hunting System Account Targeting Lsass

DESCRIPTION:  The following hunting analytic identifies all processes requesting access  into Lsass.exe. his behavior may be related to credential dumping or applications  requiring access to credentials. Triaging this event will require understanding  the GrantedAccess from the SourceImage. In addition, whether the account is privileged  or not. Review the process requesting permissions and review parallel processes.

SEARCH:  '`sysmon` EventCode=10 TargetImage=*lsass.exe | stats count min(_time) as  firstTime max(_time) as lastTime by dest, TargetImage, GrantedAccess, SourceImage,  SourceProcessId, SourceUser, TargetUser  | `security_content_ctime(firstTime)` |  `security_content_ctime(lastTime)` | `windows_hunting_system_account_targeting_lsass_filter`'



<li><a href="#">NAME: Windows Identify Protocol Handlers

DESCRIPTION:  'The following hunting analytic will identify any protocol handlers utilized  on the command-line. A protocol handler is an application that knows how to handle  particular types of links: for example, a mail client is a protocol handler for  "mailto:" links. When the user clicks a "mailto:" link, the browser opens the application  selected as the handler for the "mailto:" protocol (or offers them a choice of handlers,  depending on their settings). To identify protocol handlers we can use NirSoft https://www.nirsoft.net/utils/url_protocol_view.html  URLProtocolView or query the registry using PowerShell.'

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime values(Processes.process) as process values(Processes.parent_process)  as parent_process from datamodel=Endpoint.Processes  by Processes.dest Processes.parent_process_name Processes.user  Processes.process_name Processes.process | `security_content_ctime(firstTime)` |  `security_content_ctime(lastTime)` | `drop_dm_object_name(Processes)` | lookup windows_protocol_handlers  handler AS process OUTPUT handler ishandler | where ishandler="TRUE" | `windows_identify_protocol_handlers_filter`'



<li><a href="#">NAME: Windows IIS Components Add New Module

DESCRIPTION:  The following analytic identifies the process AppCmd.exe installing a  new module into IIS. AppCmd is a utility to manage IIS web sites and App Pools.  An adversary may run this command to install a webshell or backdoor. This has been  found to be used for credit card scraping, persistence, and further post-exploitation.  An administrator may run this to install new modules for a web site or during IIS  updates.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where NOT (Processes.parent_process_name  IN  ("msiexec.exe", "iissetup.exe")) Processes.process_name=appcmd.exe Processes.process  IN ("*install *", "*module *") AND Processes.process="*image*" by Processes.dest  Processes.user Processes.parent_process_name Processes.process_name Processes.original_file_name  Processes.process Processes.process_id Processes.parent_process_id | `drop_dm_object_name(Processes)`  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `windows_iis_components_add_new_module_filter`'



<li><a href="#">NAME: Windows IIS Components Get-WebGlobalModule Module Query

DESCRIPTION:  The following analytic requires the use of PowerShell inputs to run Get-WebGlobalModule  to list out all the IIS Modules installed. The output is a list of Module names  and the Image path of the DLL.

SEARCH:  '`iis_get_webglobalmodule` | stats count min(_time) as firstTime max(_time)  as lastTime by host name image | rename host as dest | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `windows_iis_components_get_webglobalmodule_module_query_filter`'



<li><a href="#">NAME: Windows IIS Components Module Failed to Load

DESCRIPTION:  The following analytic utilizes EventCode 2282 which generates when a  Module DLL could not be loaded due to a configuration problem. This typically occurs  when a IIS module is installed but is failing to load. This typically results in  thousands of events until the issue is resolved. Review the module that is failing  and determine if it is legitimate or not.

SEARCH:  '`wineventlog_application` EventCode=2282 | stats  count min(_time) as firstTime  max(_time) as lastTime by  EventCode dest Name ModuleDll | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `windows_iis_components_module_failed_to_load_filter`'



<li><a href="#">NAME: Windows IIS Components New Module Added

DESCRIPTION:  The following analytic uses the Windows Event log - Microsoft-IIS-Configuration/Operational  - which must be enabled and logged on Windows IIS servers before it can be Splunked.  The following analytic identifies newly installed IIS modules. Per Microsoft, IIS  modules are not commonly added to a production IIS server, so alerting on this event  ID should be enabled.IIS modules can be installed at a global level or at a site  level. In detecting malicious IIS modules, it is important to check both the global  and site level for unauthorized modules. Regular monitoring of these locations for  such modules and comparing against a known good list can help detect and identify  malicious IIS modules.

SEARCH:  '`iis_operational_logs` EventCode=29 | stats  count min(_time) as firstTime  max(_time) as lastTime by OpCode EventCode ComputerName Message | rename ComputerName  AS dest | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `windows_iis_components_new_module_added_filter`'



<li><a href="#">NAME: Windows Impair Defenses Disable HVCI

DESCRIPTION:  The following analytic refers to a detection mechanism designed to identify when the Hypervisor-protected Code Integrity (HVCI) feature is disabled within the Windows registry. HVCI is a security feature in Windows 10 and Windows Server 2016 that helps protect the kernel and system processes from being tampered with by malicious code.  HVCI relies on hardware-assisted virtualization and Microsoft's Hyper-V hypervisor to ensure that only kernel-mode code that has been signed by Microsoft or the system's hardware manufacturer can be executed. This prevents attackers from exploiting vulnerabilities to run unsigned code, like kernel-mode rootkits or other malicious software, at the kernel level.  Disabling HVCI may expose the system to security risks and could be an indicator of a potential compromise or unauthorized activity. The analytic aims to detect and report events or configurations that lead to the disabling of HVCI.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Registry where Registry.registry_path = "*\\CurrentControlSet\\Control\\DeviceGuard\\Scenarios\\HypervisorEnforcedCodeIntegrity\\Enabled" Registry.registry_value_data="0x00000000"  by  Registry.registry_path Registry.registry_value_name  Registry.registry_value_data Registry.process_guid Registry.action  Registry.user  Registry.dest | `drop_dm_object_name(Registry)` | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `windows_impair_defenses_disable_hvci_filter`'



<li><a href="#">NAME: Windows Impair Defenses Disable Win Defender Auto Logging

DESCRIPTION:  The search looks for the Registry Key DefenderApiLogger or DefenderAuditLogger  set to disable. This is consistent with RAT malware across a fleet of endpoints.  This particular behavior is typically executed when an adversary gains access to  an endpoint and beings to perform execution. Usually, a batch (.bat) will be executed  and multiple registry and scheduled task modifications will occur. During triage,  review parallel processes and identify any further file modifications.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Registry where (Registry.registry_path = "*WMI\\Autologger\\DefenderApiLogger\\Start"  OR Registry.registry_path = "*WMI\\Autologger\\DefenderAuditLogger\\Start")  Registry.registry_value_data  ="0x00000000" by  Registry.registry_path Registry.registry_value_name Registry.registry_value_data  Registry.process_guid Registry.action Registry.dest Registry.user | `drop_dm_object_name(Registry)`  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `windows_impair_defenses_disable_win_defender_auto_logging_filter`'



<li><a href="#">NAME: Windows Impair Defense Add Xml Applocker Rules

DESCRIPTION:  The following analytic is to identify a process that imports applocker  xml policy using PowerShell commandlet. This technique was seen in Azorult malware  where it drop an xml Applocker policy that will deny several AV products and further  executed the PowerShell Applocker commandlet.

SEARCH:  '| tstats `security_content_summariesonly` values(Processes.process) as process  min(_time) as firstTime max(_time) as lastTime from datamodel=Endpoint.Processes  where `process_powershell` AND Processes.process="*Import-Module Applocker*" AND  Processes.process="*Set-AppLockerPolicy *"  AND Processes.process="* -XMLPolicy  *" by Processes.dest Processes.user Processes.parent_process Processes.process_name  Processes.original_file_name Processes.process Processes.process_id Processes.parent_process_id  | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `windows_impair_defense_add_xml_applocker_rules_filter`'



<li><a href="#">NAME: Windows Impair Defense Change Win Defender Health Check Intervals

DESCRIPTION:  The following analytic identifies a modification in the Windows registry to change the health check interval of Windows Defender.  Specifically, a value of 1 typically signifies that Windows Defender would perform health checks at a much higher frequency than the default settings.   However, it's important to note that modifying this value to 1 might not necessarily conform to the actual behavior, as certain registry settings may   have specific accepted values or a defined range that differs from a simple binary representation.  Changing registry values, especially those related to system services, should be approached cautiously.   Incorrect modifications can potentially impact system stability or performance. Always ensure you understand the implications and   have a backup before altering registry settings.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime FROM datamodel=Endpoint.Registry where Registry.registry_path= "*\\Windows Defender\\ServiceKeepAlive"  Registry.registry_value_data="0x00000001"   by Registry.registry_key_name Registry.user Registry.registry_path Registry.registry_value_data Registry.action Registry.dest  | `drop_dm_object_name(Registry)`   | `security_content_ctime(firstTime)`   | `security_content_ctime(lastTime)`  | `windows_impair_defense_change_win_defender_health_check_intervals_filter`'



<li><a href="#">NAME: Windows Impair Defense Change Win Defender Quick Scan Interval

DESCRIPTION:  The following analytic identifies a modification in the Windows registry to change Windows Defender   Quick Scan Interval. The "QuickScanInterval" in Windows Defender, specifically within the context of antivirus software,   typically refers to the interval or frequency at which the system conducts quick scans for malware or potential threats.  This setting dictates how often Windows Defender performs quick scans on the system. Quick scans are less comprehensive   than full system scans but provide a faster way to check critical areas for potential threats or malware.  This registry setting is being abuse by several threat actors, adversaries and red teamers to bypasses Windows defender detections.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime FROM datamodel=Endpoint.Registry where Registry.registry_path= "*\\Windows Defender\\Scan\\QuickScanInterval"   by Registry.registry_key_name Registry.user Registry.registry_path Registry.registry_value_data Registry.action Registry.dest  | `drop_dm_object_name(Registry)`   | `security_content_ctime(firstTime)`   | `security_content_ctime(lastTime)`   | `windows_impair_defense_change_win_defender_quick_scan_interval_filter`'



<li><a href="#">NAME: Windows Impair Defense Change Win Defender Throttle Rate

DESCRIPTION:  The following analytic identifies a modification in the Windows registry to change the ThrottleDetectionEventsRate of Windows Defender.  The ThrottleDetectionEventsRate registry setting in Windows Defender is related to controlling the rate at which detection events are logged or   reported by Windows Defender Antivirus.  This registry setting determines how frequently Windows Defender logs or reports detection events. Adjusting the ThrottleDetectionEventsRate value   can impact the logging frequency of detection events such as malware detections, scanning results, or security-related events recorded by Windows Defender.  A higher value might mean that detection events are reported less frequently, potentially reducing the volume of recorded events, while a lower value could   increase the reporting frequency, resulting in more frequent logs of detection events.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime FROM datamodel=Endpoint.Registry where Registry.registry_path= "*\\Windows Defender\\NIS\\Consumers\\IPS\\ThrottleDetectionEventsRate"   by Registry.registry_key_name Registry.user Registry.registry_path Registry.registry_value_data Registry.action Registry.dest  | `drop_dm_object_name(Registry)`   | `security_content_ctime(firstTime)`   | `security_content_ctime(lastTime)`  | `windows_impair_defense_change_win_defender_throttle_rate_filter`'



<li><a href="#">NAME: Windows Impair Defense Change Win Defender Tracing Level

DESCRIPTION:  The following analytic identifies a modification in the Windows registry to change the Windows Defender Wpp Tracing levels.   The "WppTracingLevel" registry setting is typically related to Windows software tracing and diagnostics, specifically involving   Windows Software Trace Preprocessor (WPP) tracing.  WPP tracing is a mechanism used by developers to instrument code for diagnostic purposes, allowing for the collection of detailed logs   and traces during software execution. It helps in understanding the behavior of the software, identifying issues, and analyzing its performance.  Without specific documentation or references to "WppTracingLevel" within Windows Defender settings or its functionalities, it's challenging   to provide precise details about its intended use or configuration within Windows Defender.  Modifying registry settings without understanding their implications can affect system behavior or security. Always proceed cautiously   and ensure changes align with best practices and organizational requirements.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime FROM datamodel=Endpoint.Registry where Registry.registry_path= "*\\Windows Defender\\Reporting\\WppTracingLevel"  Registry.registry_value_data="0x00000001"  by Registry.registry_key_name Registry.user Registry.registry_path Registry.registry_value_data Registry.action Registry.dest  | `drop_dm_object_name(Registry)`   | `security_content_ctime(firstTime)`   | `security_content_ctime(lastTime)`   | `windows_impair_defense_change_win_defender_tracing_level_filter`'



<li><a href="#">NAME: Windows Impair Defense Configure App Install Control

DESCRIPTION:  The following analytic identifies a modification in the Windows registry to change or disable Windows Defender   smartscreen app install control. Microsoft Edge's App Install Control feature helps manage the installation of web-based applications.  When attackers modify "ConfigureAppInstallControlEnabled" to 0, they are likely attempting to disable the App Install Control feature   in Microsoft Edge. This change might allow users to bypass restrictions imposed by the browser on the installation of web-based applications.  Disabling this feature might increase the risk of users being able to install potentially malicious or untrusted web applications without   restrictions or controls imposed by the browser. This action could potentially lead to security vulnerabilities or compromise if users   inadvertently install harmful applications.

SEARCH:  '| tstats `security_content_summariesonly` count FROM datamodel=Endpoint.Registry  WHERE (Registry.registry_path= "*\\Microsoft\\Windows Defender\\SmartScreen\\ConfigureAppInstallControl" Registry.registry_value_data= "Anywhere") OR  (Registry.registry_path= "*\\Microsoft\\Windows Defender\\SmartScreen\\ConfigureAppInstallControlEnabled" Registry.registry_value_data= "0x00000000")  BY _time span=1h Registry.dest Registry.user Registry.registry_path Registry.registry_key_name Registry.registry_value_name Registry.registry_value_data Registry.process_guid   | `drop_dm_object_name(Registry)`  | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)`  | `windows_impair_defense_configure_app_install_control_filter`'



<li><a href="#">NAME: Windows Impair Defense Define Win Defender Threat Action

DESCRIPTION:  The following analytic identifies a modification in the Windows registry to define the threat action of Windows Defender.   The ThreatSeverityDefaultAction registry setting in Windows Defender is used to define the default action taken by Windows Defender   when it encounters threats of specific severity levels.  A setting like ThreatSeverityDefaultAction is designed to define how Windows Defender responds to threats based on their severity.   For example, it might determine whether Windows Defender quarantines, removes, or takes other actions against threats based on their severity levels.  In this context, a registry value of 1 typically indicates an action to "clean," aiming to disinfect or resolve the detected threat,   while a registry value of 9 signifies "no action," meaning that the antivirus software refrains from taking immediate steps against the identified threat.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime FROM datamodel=Endpoint.Registry where Registry.registry_path= "*\\Windows Defender\\Threats\\ThreatSeverityDefaultAction*"   Registry.registry_value_data IN ("0x00000001", "9")  by Registry.registry_key_name Registry.user Registry.registry_path Registry.registry_value_data Registry.action Registry.dest  | `drop_dm_object_name(Registry)`   | `security_content_ctime(firstTime)`   | `security_content_ctime(lastTime)`   | `windows_impair_defense_define_win_defender_threat_action_filter`'



<li><a href="#">NAME: Windows Impair Defense Delete Win Defender Context Menu

DESCRIPTION:  The search looks for the deletion of Windows Defender context menu within  the registry. This is consistent behavior with RAT malware across a fleet of endpoints.  This particular behavior is executed when an adversary gains access to an endpoint  and begins to perform execution. Usually, a batch (.bat) will be executed and multiple  registry and scheduled task modifications will occur. During triage, review parallel  processes and identify any further file modifications.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Registry where Registry.registry_path = "*\\shellex\\ContextMenuHandlers\\EPP"  Registry.action = deleted by  Registry.registry_path Registry.registry_value_name  Registry.registry_value_data Registry.process_guid Registry.action Registry.dest  Registry.user | `drop_dm_object_name(Registry)` | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `windows_impair_defense_delete_win_defender_context_menu_filter`'



<li><a href="#">NAME: Windows Impair Defense Delete Win Defender Profile Registry

DESCRIPTION:  The search looks for the deletion of Windows Defender main profile within  the registry. This was used by RAT malware across a fleet of endpoints. This particular  behavior is typically executed when an adversary gains access to an endpoint and  beings to perform execution. Usually, a batch (.bat) will be executed and multiple  registry and scheduled task modifications will occur. During triage, review parallel  processes and identify any further file modifications.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Registry where Registry.registry_path = "*\\Policies\\Microsoft\\Windows  Defender" Registry.action = deleted by  Registry.registry_path Registry.registry_value_name  Registry.registry_value_data Registry.process_guid Registry.action  Registry.user  Registry.dest | `drop_dm_object_name(Registry)` | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `windows_impair_defense_delete_win_defender_profile_registry_filter`'



<li><a href="#">NAME: Windows Impair Defense Deny Security Software With Applocker

DESCRIPTION:  The following analytic identifies a modification in the Windows registry  by the Applocker utility that contains details or registry data values related to  denying the execution of several security products. This technique was seen in Azorult  malware where it drops an xml Applocker policy that will deny several AV products  and then loaded by using PowerShell Applocker commandlet.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime FROM datamodel=Endpoint.Registry where (Registry.registry_path= "*\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Group  Policy Objects\\*" AND Registry.registry_path= "*}Machine\\Software\\Policies\\Microsoft\\Windows\\SrpV2*")  OR Registry.registry_path="*\\Software\\Policies\\Microsoft\\Windows\\SrpV2*" AND  Registry.registry_value_data = "*Action\=\"Deny\"*" AND Registry.registry_value_data  IN("*O=SYMANTEC*","*O=MCAFEE*","*O=KASPERSKY*","*O=BLEEPING COMPUTER*", "*O=PANDA  SECURITY*","*O=SYSTWEAK SOFTWARE*", "*O=TREND MICRO*", "*O=AVAST*", "*O=GRIDINSOFT*",  "*O=MICROSOFT*", "*O=NANO SECURITY*", "*O=SUPERANTISPYWARE.COM*", "*O=DOCTOR WEB*",  "*O=MALWAREBYTES*", "*O=ESET*", "*O=AVIRA*", "*O=WEBROOT*") by  Registry.user Registry.registry_path  Registry.registry_value_data Registry.action Registry.registry_key_name Registry.dest  | `drop_dm_object_name(Registry)` | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `windows_impair_defense_deny_security_software_with_applocker_filter`'



<li><a href="#">NAME: Windows Impair Defense Disable Controlled Folder Access

DESCRIPTION:  The following analytic identifies a modification in the Windows registry to disable Windows Defender   Controlled Folder Access feature. The EnableControlledFolderAccess registry setting is associated with the Controlled   Folder Access feature in Windows Defender. Controlled Folder Access is a security feature designed to protect certain   folders from unauthorized access or modification by malicious applications, including ransomware.  When EnableControlledFolderAccess is set to 0, it usually indicates that the Controlled Folder Access feature   within Windows Defender is not active. Consequently, the protection mechanism for the specified folders against   unauthorized access by potentially malicious applications or ransomware is not enabled.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime FROM datamodel=Endpoint.Registry where Registry.registry_path= "*\\Windows Defender\\Windows Defender Exploit Guard\\Controlled Folder Access\\EnableControlledFolderAccess"  Registry.registry_value_data="0x00000000"   by Registry.registry_key_name Registry.user Registry.registry_path Registry.registry_value_data Registry.action Registry.dest  | `drop_dm_object_name(Registry)`   | `security_content_ctime(firstTime)`   | `security_content_ctime(lastTime)`   | `windows_impair_defense_disable_controlled_folder_access_filter`'



<li><a href="#">NAME: Windows Impair Defense Disable Defender Firewall And Network

DESCRIPTION:  The following analytic identifies a modification in the Windows registry to disable firewall   and network protection section settings of windows security. The specific impact of this change depends   on the context and the purpose behind modifying this registry value. In general, setting UILockdown to 1   might imply enforcing a restriction or lockdown in the user interface (UI) related to firewall and network   protection settings within Windows Defender Security Center. This could potentially restrict users from modifying   certain firewall or network protection settings through the UI.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime FROM datamodel=Endpoint.Registry where Registry.registry_path= "*\\Windows Defender Security Center\\Firewall and network protection\\UILockdown"  Registry.registry_value_data="0x00000001"   by Registry.registry_key_name Registry.user Registry.registry_path Registry.registry_value_data Registry.action Registry.dest  | `drop_dm_object_name(Registry)`   | `security_content_ctime(firstTime)`   | `security_content_ctime(lastTime)`   | `windows_impair_defense_disable_defender_firewall_and_network_filter`'



<li><a href="#">NAME: Windows Impair Defense Disable Defender Protocol Recognition

DESCRIPTION:  The following analytic identifies a modification in the Windows registry to disable Windows Defender   protocol recognition feature. The DisableProtocolRecognition setting in Windows Defender is not a commonly known   or documented registry setting. It's possible that this specific setting might not exist within the standard   Windows Defender configurations or that it might be specific to certain environments, versions, or configurations.  It might potentially control or influence the antivirus software's ability to recognize and handle specific protocols   or communication methods used by malware or suspicious software.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime FROM datamodel=Endpoint.Registry where Registry.registry_path= "*\\Windows Defender\\NIS\\DisableProtocolRecognition"   Registry.registry_value_data="0x00000001"  by Registry.registry_key_name Registry.user Registry.registry_path Registry.registry_value_data Registry.action Registry.dest  | `drop_dm_object_name(Registry)`   | `security_content_ctime(firstTime)`   | `security_content_ctime(lastTime)`   | `windows_impair_defense_disable_defender_protocol_recognition_filter`'



<li><a href="#">NAME: Windows Impair Defense Disable PUA Protection

DESCRIPTION:  The following analytic identifies a modification in the Windows registry to disable Windows Defender   PUA protection.  Setting PUAProtection to 0 typically disables the detection and protection against Potentially Unwanted Applications   by Microsoft Defender Antivirus. Potentially Unwanted Applications include software that may not be inherently   malicious but could exhibit behaviors that users may find undesirable, such as adware, browser toolbars, or software bundlers.  Disabling this feature might be preferred in certain situations, but it's essential to consider potential security implications.   Enabling PUA protection provides an additional layer of defense against software that might negatively impact user experience   or security.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime FROM datamodel=Endpoint.Registry where Registry.registry_path= "*\\Windows Defender\\PUAProtection"  Registry.registry_value_data="0x00000000"  by Registry.registry_key_name Registry.user Registry.registry_path Registry.registry_value_data Registry.action Registry.dest  | `drop_dm_object_name(Registry)`   | `security_content_ctime(firstTime)`   | `security_content_ctime(lastTime)`   | `windows_impair_defense_disable_pua_protection_filter`'



<li><a href="#">NAME: Windows Impair Defense Disable Realtime Signature Delivery

DESCRIPTION:  The following analytic identifies a modification in the Windows registry to disable windows defender   realtime signature delivery feature. This setting governs how Windows Defender Antivirus receives updated signature   definitions for identifying and combating malware threats in real-time. The actual impact and behaviors associated   with different values for RealtimeSignatureDelivery can vary based on specific Windows Defender configurations and policies.  For instance, setting this value to 0 or 1 might control whether real-time signatures are delivered via different methods   such as through Windows Update or directly from Microsoft's cloud-based services.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime FROM datamodel=Endpoint.Registry where Registry.registry_path= "*\\Windows Defender\\Signature Updates\\RealtimeSignatureDelivery"  Registry.registry_value_data="0x00000000"   by Registry.registry_key_name Registry.user Registry.registry_path Registry.registry_value_data Registry.action Registry.dest  | `drop_dm_object_name(Registry)`   | `security_content_ctime(firstTime)`   | `security_content_ctime(lastTime)`   | `windows_impair_defense_disable_realtime_signature_delivery_filter`'



<li><a href="#">NAME: Windows Impair Defense Disable Web Evaluation

DESCRIPTION:  The following analytic identifies a modification in the Windows registry to disable Windows Defender   web content evaluation. The "EnableWebContentEvaluation" registry entry typically relates to security settings   within Microsoft Edge or Internet Explorer, enabling the evaluation of web content for security purposes.  When attackers modify "EnableWebContentEvaluation" to 0, they might attempt to disable the browser's   capability to evaluate web content for security purposes. Disabling this feature could potentially impact   the browser's ability to assess the security risks associated with web content, such as potentially malicious scripts,   active content, or unsafe web elements.  By turning off content evaluation, attackers might aim to exploit security vulnerabilities present in web content without   triggering security warnings or blocks. This manipulation increases the risk of users accessing or interacting with malicious   content, potentially leading to security compromises or system exploitation.

SEARCH:  '| tstats `security_content_summariesonly` count FROM datamodel=Endpoint.Registry  WHERE Registry.registry_path= "*\\Windows\\CurrentVersion\\AppHost\\EnableWebContentEvaluation"  Registry.registry_value_data= "0x00000000"   BY _time span=1h Registry.dest Registry.user Registry.registry_path Registry.registry_key_name Registry.registry_value_name  Registry.registry_value_data Registry.process_guid   | `drop_dm_object_name(Registry)`  | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)`   | `windows_impair_defense_disable_web_evaluation_filter`'



<li><a href="#">NAME: Windows Impair Defense Disable Win Defender App Guard

DESCRIPTION:  The following analytic identifies a modification in the Windows registry to disable Windows Defender   audit application guard.  Microsoft Defender Application Guard provides enhanced security by isolating potentially malicious documents and   websites in a containerized environment, protecting the system against various threats. Auditing and logging are   essential components of security measures, providing visibility into activities within the isolated environment.  Disabling auditing events within Application Guard might not be a standard or recommended practice since auditing   is crucial for security monitoring and threat detection within the isolated container. However, there might be   settings or configurations related to audit policies in the broader Windows Defender or operating system settings.  This registry setting is being abuse by several threat actors, adversaries and red teamers to bypasses Windows defender detections.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime FROM datamodel=Endpoint.Registry where Registry.registry_path= "*\\Policies\\Microsoft\\AppHVSI\\AuditApplicationGuard"  Registry.registry_value_data="0x00000000"  by Registry.registry_key_name Registry.user Registry.registry_path Registry.registry_value_data Registry.action Registry.dest  | `drop_dm_object_name(Registry)`   | `security_content_ctime(firstTime)`   | `security_content_ctime(lastTime)`   | `windows_impair_defense_disable_win_defender_app_guard_filter`'



<li><a href="#">NAME: Windows Impair Defense Disable Win Defender Compute File Hashes

DESCRIPTION:  The following analytic identifies a modification in the Windows registry to disable Windows Defender file hashes computation.  The EnableFileHashComputation registry setting likely pertains to whether Windows Defender's MpEngine (Malware Protection Engine) computes   file hashes. Setting this value to 0 might disable the file hash computation feature within Windows Defender, which could affect certain   malware detection or scanning functionalities that rely on file hash analysis. This registry setting is being abuse by several threat actors, adversaries   and red teamers to bypasses Windows defender detections.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime FROM datamodel=Endpoint.Registry where Registry.registry_path= "*\\Windows Defender\\MpEngine\\EnableFileHashComputation"  Registry.registry_value_data="0x00000000"   by Registry.registry_key_name Registry.user Registry.registry_path Registry.registry_value_data Registry.action Registry.dest  | `drop_dm_object_name(Registry)`   | `security_content_ctime(firstTime)`   | `security_content_ctime(lastTime)`   | `windows_impair_defense_disable_win_defender_compute_file_hashes_filter`'



<li><a href="#">NAME: Windows Impair Defense Disable Win Defender Gen reports

DESCRIPTION:  The following analytic identifies a modification in the Windows registry to disable Windows Defender   generic ports. This registry can disable the sending of Watson events in Windows Defender. This is by preventing   the transmission of generic or non-specific error reports to Microsoft's Windows Error Reporting service,   commonly known as Watson. This kind of setting could potentially be employed to limit or control the data sent to   Microsoft for error analysis, often in scenarios where privacy or specific reporting requirements are in place.  This registry setting is being abuse by several threat actors, adversaries and red teamers to bypasses Windows defender detections. 

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime FROM datamodel=Endpoint.Registry where Registry.registry_path= "*\\Windows Defender\\Reporting\\DisableGenericRePorts"  Registry.registry_value_data="0x00000001"  by Registry.registry_key_name Registry.user Registry.registry_path Registry.registry_value_data Registry.action Registry.dest  | `drop_dm_object_name(Registry)`   | `security_content_ctime(firstTime)`   | `security_content_ctime(lastTime)`   | `windows_impair_defense_disable_win_defender_gen_reports_filter`'



<li><a href="#">NAME: Windows Impair Defense Disable Win Defender Network Protection

DESCRIPTION:  The following analytic identifies a modification in the Windows registry to disable Windows Defender   exploit guard network protection. The EnableNetworkProtection registry entry controls the activation or deactivation   of Network Protection within Windows Defender Exploit Guard. When set to 1, it typically signifies that Network Protection   is enabled, offering additional security measures against network-based threats by analyzing and blocking potentially   malicious network activity. This registry setting is being abuse by several threat actors, adversaries   and red teamers to bypasses Windows defender detections.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime FROM datamodel=Endpoint.Registry where Registry.registry_path= "*\\Windows Defender\\Windows Defender Exploit Guard\\Network Protection\\EnableNetworkProtection"  Registry.registry_value_data="0x00000000"   by Registry.registry_key_name Registry.user Registry.registry_path Registry.registry_value_data Registry.action Registry.dest  | `drop_dm_object_name(Registry)`   | `security_content_ctime(firstTime)`   | `security_content_ctime(lastTime)`   | `windows_impair_defense_disable_win_defender_network_protection_filter`'



<li><a href="#">NAME: Windows Impair Defense Disable Win Defender Report Infection

DESCRIPTION:  The following analytic identifies a modification in the Windows registry to disable windows defender   report infection information. Setting this registry key to 1, Instructs Windows Defender not to report detailed   information about infections or threats detected on the system to Microsoft. Enabling this setting might limit   or prevent the transmission of specific data related to infections, such as details about the detected malware,   to Microsoft's servers for analysis or logging purposes.  This registry is being abused by adversaries, threat actors and red-teamers to bypasses Windows Defender detections.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime FROM datamodel=Endpoint.Registry where Registry.registry_path= "*\\Microsoft\\MRT\\DontReportInfectionInformation"  Registry.registry_value_data="0x00000001"   by Registry.registry_key_name Registry.user Registry.registry_path Registry.registry_value_data Registry.action Registry.dest  | `drop_dm_object_name(Registry)`   | `security_content_ctime(firstTime)`   | `security_content_ctime(lastTime)`   | `windows_impair_defense_disable_win_defender_report_infection_filter`'



<li><a href="#">NAME: Windows Impair Defense Disable Win Defender Scan On Update

DESCRIPTION:  The following analytic identifies a modification in the Windows registry to disable Windows Defender   Scan On Update. The "DisableScanOnUpdate" registry setting in Windows Defender, when set to a value of 1, typically   signifies the feature that prevents automatic scans from initiating when updates to Windows Defender   or its antivirus definitions are installed.  Any modifications to registry settings, it's important to ensure that changes align with security policies and best practices.  Incorrect settings might affect the system's security or functionality. Always consider the implications and ensure changes   are made based on accurate information and organizational requirements.  This registry setting is being abuse by several threat actors, adversaries and red teamers to bypasses Windows defender detections.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime FROM datamodel=Endpoint.Registry where Registry.registry_path= "*\\Windows Defender\\Signature Updates\\DisableScanOnUpdate"  Registry.registry_value_data="0x00000001"  by Registry.registry_key_name Registry.user Registry.registry_path Registry.registry_value_data Registry.action Registry.dest  | `drop_dm_object_name(Registry)`   | `security_content_ctime(firstTime)`   | `security_content_ctime(lastTime)`   | `windows_impair_defense_disable_win_defender_scan_on_update_filter`'



<li><a href="#">NAME: Windows Impair Defense Disable Win Defender Signature Retirement

DESCRIPTION:  The following analytic identifies a modification in the Windows registry to disable windows defender   Signature Retirement. The DisableSignatureRetirement registry setting in Windows Defender controls the retirement   or expiration of antivirus signatures used by Windows Defender Antivirus.  When DisableSignatureRetirement is set to 1, it usually indicates that Windows Defender won't automatically retire   or expire antivirus signatures. Antivirus signatures are files containing information about known malware and are   used by Windows Defender to detect and protect against threats.  Disabling signature retirement might prevent Windows Defender from automatically removing or retiring older or less   relevant antivirus signatures. This can potentially increase the number of signatures in use and might impact system   resources or the effectiveness of threat detection.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime FROM datamodel=Endpoint.Registry where Registry.registry_path= "*\\Windows Defender\\NIS\\Consumers\\IPS\\DisableSignatureRetirement"   Registry.registry_value_data="0x00000001"  by Registry.registry_key_name Registry.user Registry.registry_path Registry.registry_value_data Registry.action Registry.dest  | `drop_dm_object_name(Registry)`   | `security_content_ctime(firstTime)`   | `security_content_ctime(lastTime)`   | `windows_impair_defense_disable_win_defender_signature_retirement_filter`'



<li><a href="#">NAME: Windows Impair Defense Overide Win Defender Phishing Filter

DESCRIPTION:  The following analytic identifies a modification in the Windows registry to disable windows defender   phishing filter. This setting controls whether users can manually disable or modify the browser's built-in phishing filter.  When attackers modify "PreventOverride" to 0, it might indicate an attempt to disable the prevention of user overrides for   the phishing filter within Microsoft Edge. This change allows users to bypass or disable the built-in phishing protection provided by the browser.  By allowing users to override the phishing filter, attackers may attempt to deceive users into visiting phishing websites or   malicious pages without triggering warnings or protections from the browser's built-in security measures. This manipulation increases the   risk of users unknowingly accessing potentially harmful websites, leading to potential security incidents or compromises.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime FROM datamodel=Endpoint.Registry where Registry.registry_key_name = "*\\MicrosoftEdge\\PhishingFilter" Registry.registry_value_name IN ("EnabledV9", "PreventOverride")  Registry.registry_value_data="0x00000000"   by Registry.registry_key_name Registry.user Registry.registry_path Registry.registry_value_data Registry.action Registry.dest  | `drop_dm_object_name(Registry)`   | `security_content_ctime(firstTime)`   | `security_content_ctime(lastTime)`  | `windows_impair_defense_overide_win_defender_phishing_filter_filter`'



<li><a href="#">NAME: Windows Impair Defense Override SmartScreen Prompt

DESCRIPTION:  The following analytic identifies a modification in the Windows registry to override windows defender   smartscreen prompt. The "PreventSmartScreenPromptOverride" registry setting is associated with the Windows SmartScreen feature,   specifically related to controlling whether users can override SmartScreen prompts.  When attackers modify "PreventSmartScreenPromptOverride" to 0, it signifies an attempt to disable the prevention of user overrides   for SmartScreen prompts. By doing so, attackers aim to allow users to bypass or ignore SmartScreen warnings or prompts.  This change increases the risk by permitting users to disregard warnings about potentially unsafe or malicious files or   websites that would typically trigger SmartScreen alerts. It could lead to users unintentionally executing or accessing   malicious content, potentially resulting in security incidents or system compromises.

SEARCH:  '| tstats `security_content_summariesonly` count FROM datamodel=Endpoint.Registry  WHERE Registry.registry_path= "*\\Microsoft\\Edge\\PreventSmartScreenPromptOverride" Registry.registry_value_data= "0x00000000"  BY _time span=1h Registry.dest Registry.user Registry.registry_path Registry.registry_key_name Registry.registry_value_name Registry.registry_value_data Registry.process_guid   | `drop_dm_object_name(Registry)`  | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)`   | `windows_impair_defense_override_smartscreen_prompt_filter`'



<li><a href="#">NAME: Windows Impair Defense Set Win Defender Smart Screen Level To Warn

DESCRIPTION:  The following analytic identifies a modification in the Windows registry to set windows defender   smart screen level to warn. Setting the ShellSmartScreenLevel to warn implies a SmartScreen configuration   where the system displays a warning prompt when users attempt to run or access potentially risky or unrecognized   files or applications. This warning serves as a cautionary alert to users, advising them about the potential   risks associated with the file or application they are trying to execute.  Changing SmartScreen settings to "warn" might be employed by attackers to reduce the likelihood of triggering   immediate suspicion from users when running malicious executables. By setting it to "warn," the system prompts a   cautionary warning rather than outright blocking the execution, potentially increasing the chances of users   proceeding with running the file despite the warning.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime FROM datamodel=Endpoint.Registry where Registry.registry_path= "*\\Microsoft\\Windows\\System\\ShellSmartScreenLevel"  Registry.registry_value_data="Warn"   by Registry.registry_key_name Registry.user Registry.registry_path Registry.registry_value_data Registry.action Registry.dest  | `drop_dm_object_name(Registry)`   | `security_content_ctime(firstTime)`   | `security_content_ctime(lastTime)`   | `windows_impair_defense_set_win_defender_smart_screen_level_to_warn_filter`'



<li><a href="#">NAME: Windows Indicator Removal Via Rmdir

DESCRIPTION:  The following analytic identifies a process execute rmdir commandline to delete files and directory tree.   This technique has been observed in the actions of various malware strains, such as DarkGate,   as they attempt to eliminate specific files or components during their cleanup operations within compromised hosts.   Notably, this deletion method doesn't exclusively require elevated privileges and can be executed by regular users or network administrators,   although it's not the typical approach used for file deletion.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time) as lastTime from datamodel=Endpoint.Processes   where Processes.process = "*rmdir*" Processes.process = "* /s *" Processes.process = "* /q *"  by Processes.process_name Processes.original_file_name Processes.process Processes.process_id  Processes.process_guid Processes.parent_process_name Processes.parent_process Processes.parent_process_guid Processes.dest Processes.user   | `drop_dm_object_name(Processes)`   | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)`   | `windows_indicator_removal_via_rmdir_filter`'



<li><a href="#">NAME: Windows Indirect Command Execution Via forfiles

DESCRIPTION:  The following analytic detects programs that have been started by forfiles.exe.  According to Microsoft, the 'The forfiles command lets you run a command on or pass  arguments to multiple files'. While this tool can be used to start legitimate programs,  usually within the context of a batch script, it has been observed being used to  evade protections on command line execution.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.parent_process="*forfiles*  /c *" by Processes.dest Processes.user Processes.parent_process Processes.parent_process_name  Processes.process_name Processes.process Processes.process_id Processes.parent_process_id  Processes.process_path | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `windows_indirect_command_execution_via_forfiles_filter`'



<li><a href="#">NAME: Windows Indirect Command Execution Via pcalua

DESCRIPTION:  The following analytic detects programs that have been started by pcalua.exe.  pcalua.exe is the Microsoft Windows Program Compatability Assistant.  While this  tool can be used to start legitimate programs, it has been observed being used to  evade protections on command line execution.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.parent_process="*pcalua*  -a*" by Processes.dest Processes.user Processes.parent_process Processes.parent_process_name  Processes.process_name Processes.process Processes.process_id Processes.parent_process_id  Processes.process_path | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `windows_indirect_command_execution_via_pcalua_filter`'



<li><a href="#">NAME: Windows Indirect Command Execution Via Series Of Forfiles

DESCRIPTION:  This analytic is developed to detect suspicious excessive usage of forfiles.exe  process. This event was seen in post exploitation tool WINPEAS that was used by  Ransomware Prestige. Forfiles command lets you run a command on or pass arguments  to multiple files. This Windows OS built-in tool being abused to list all files  in specific directory or drive.

SEARCH:  '| tstats `security_content_summariesonly` values(Processes.process) as process  values(Processes.process_guid) as process_guid  values(Processes.process_name) as  process_name count min(_time) as firstTime max(_time) as lastTime  from datamodel=Endpoint.Processes  where Processes.process_name = "forfiles.exe" OR Processes.original_file_name =  "forfiles.exe" by Processes.parent_process_name Processes.parent_process Processes.dest  Processes.user _time span=1m | where count >=20 | `drop_dm_object_name(Processes)`  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `windows_indirect_command_execution_via_series_of_forfiles_filter`'



<li><a href="#">NAME: Windows Information Discovery Fsutil

DESCRIPTION:  The following analytic identifies a process execution of Windows OS built-in  tool FSUTIL to discover file system information. This tool is being abused or used  by several adversaries or threat actor to query/list all drives, drive type, volume  information or volume statistics by using the FSINFO parameter of this tool. This  technique was seen in WINPEAS post exploitation tool that is being used by ransomware  prestige to gain privilege and persistence to the targeted host.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.process_name="fsutil.exe"  OR Processes.original_file_name = "fsutil.exe" AND Processes.process = "*fsinfo*"  by Processes.process_name Processes.original_file_name Processes.process Processes.process_id  Processes.process_guid Processes.parent_process_name Processes.parent_process Processes.parent_process_guid  Processes.dest Processes.user | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `windows_information_discovery_fsutil_filter`'



<li><a href="#">NAME: Windows Ingress Tool Transfer Using Explorer

DESCRIPTION:  The following analytic identifies the Windows Explorer process with a  URL within the command-line. Explorer.exe is known Windows process that handles  start menu, taskbar, desktop and file manager. Many adversaries abuse this process,  like DCRat malware, where it attempts to open the URL with the default browser application  on the target host by putting the URL as a parameter on explorer.exe process. This  anomaly detection might be a good pivot to check which user and how this process  was executed, what is the parent process and what is the URL link. This technique  is not commonly used to open an URL.

SEARCH:  '| tstats `security_content_summariesonly` min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where (Processes.process_name = explorer.exe  OR Processes.original_file_name = explorer.exe) AND NOT (Processes.parent_process_name  IN("userinit.exe", "svchost.exe")) Processes.process IN ("* http://*", "* https://*")  by  Processes.parent_process_name Processes.parent_process Processes.process_name  Processes.original_file_name Processes.process Processes.process_id Processes.parent_process_id  Processes.dest Processes.user | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `windows_ingress_tool_transfer_using_explorer_filter`'



<li><a href="#">NAME: Windows Input Capture Using Credential UI Dll

DESCRIPTION:  The following analytic identifies a process that loads the credui.dll  module. This legitimate module is typically abused by adversaries, threat actors  and red teamers to create a credential UI prompt dialog box to lure users for possible  credential theft or can be used to dump the credentials of a targeted host. This  hunting query is a good pivot to check why the process loaded this dll and if it  is a legitimate file. This hunting query may hit false positive for a third party  application that uses a credential login UI for user login.

SEARCH:  '`sysmon` EventCode=7  (ImageLoaded = "*\\credui.dll" AND OriginalFileName  = "credui.dll") OR (ImageLoaded = "*\\wincredui.dll" AND OriginalFileName = "wincredui.dll")  AND NOT(Image IN("*\\windows\\explorer.exe", "*\\windows\\system32\\*", "*\\windows\\sysWow64\\*",  "*:\\program files*")) | stats count min(_time) as firstTime max(_time) as lastTime  by Image ImageLoaded OriginalFileName dest EventCode Signed ProcessId ProcessGuid  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `windows_input_capture_using_credential_ui_dll_filter`'



<li><a href="#">NAME: Windows InstallUtil Credential Theft

DESCRIPTION:  'The following analytic identifies the Windows InstallUtil.exe binary  loading `vaultcli.dll` and Samlib.dll`. This technique may be used to execute code  to bypassing application control and capture credentials by utilizing a tool like  MimiKatz. \  When `InstallUtil.exe` is used in a malicous manner, the path to an executable on  the filesystem is typically specified. Take note of the parent process. In a suspicious  instance, this will be spawned from a non-standard process like `Cmd.exe`, `PowerShell.exe`  or `Explorer.exe`. \  If used by a developer, typically this will be found with multiple command-line  switches/arguments and spawn from Visual Studio. \  During triage review resulting network connections, file modifications, and parallel  processes. Capture any artifacts and review further.'

SEARCH:  '`sysmon` EventCode=7  parent_process_name=installutil.exe ImageLoaded IN  ("*\\samlib.dll", "*\\vaultcli.dll") | stats count min(_time) as firstTime max(_time)  as lastTime by dest, parent_process_name, ImageLoaded, OriginalFileName, ProcessId   | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `windows_installutil_credential_theft_filter`'



<li><a href="#">NAME: Windows InstallUtil in Non Standard Path

DESCRIPTION:  The following analytic identifies the Windows binary InstallUtil.exe  running from a non-standard location. The analytic utilizes a macro for InstallUtil  and identifies both the process_name and original_file_name.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime FROM datamodel=Endpoint.Processes where `process_installutil` NOT (Processes.process_path  IN ("*\\Windows\\ADWS\\*","*\\Windows\\SysWOW64*", "*\\Windows\\system32*", "*\\Windows\\NetworkController\\*",  "*\\Windows\\SystemApps\\*", "*\\WinSxS\\*", "*\\Windows\\Microsoft.NET\\*")) by  Processes.dest Processes.user Processes.parent_process_name Processes.parent_process Processes.process_name Processes.process  Processes.original_file_name Processes.process_id Processes.parent_process_id Processes.process_hash  | `drop_dm_object_name("Processes")` | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `windows_installutil_in_non_standard_path_filter`'



<li><a href="#">NAME: Windows InstallUtil Remote Network Connection

DESCRIPTION:  'The following analytic identifies the Windows InstallUtil.exe binary  making a remote network connection. This technique may be used to download and execute  code while bypassing application control. \  When `InstallUtil.exe` is used in a malicous manner, the path to an executable on  the filesystem is typically specified. Take note of the parent process. In a suspicious  instance, this will be spawned from a non-standard process like `Cmd.exe`, `PowerShell.exe`  or `Explorer.exe`. \  If used by a developer, typically this will be found with multiple command-line  switches/arguments and spawn from Visual Studio. \  During triage review resulting network connections, file modifications, and parallel  processes. Capture any artifacts and review further.'

SEARCH:  '| tstats `security_content_summariesonly` count FROM datamodel=Endpoint.Processes  where `process_installutil` by _time span=1h  Processes.process_id Processes.process_name  Processes.dest Processes.user Processes.process_path Processes.process Processes.parent_process_name  Processes.original_file_name | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | join  process_id [| tstats `security_content_summariesonly`  count FROM datamodel=Network_Traffic.All_Traffic where All_Traffic.dest_port !=  0 by All_Traffic.process_id All_Traffic.dest All_Traffic.dest_port | `drop_dm_object_name(All_Traffic)`  | rename dest as C2 ] | table _time user dest parent_process_name process_name process_path  process process_id dest_port C2 | `windows_installutil_remote_network_connection_filter`'



<li><a href="#">NAME: Windows InstallUtil Uninstall Option

DESCRIPTION:  'The following analytic identifies the Windows InstallUtil.exe binary.  This will execute code while bypassing application control using the `/u` (uninstall)  switch. \  InstallUtil uses the functions install and uninstall within the System.Configuration.Install  namespace to process .net assembly. Install function requires admin privileges,  however, uninstall function can be run as an unprivileged user.\  When `InstallUtil.exe` is used in a malicous manner, the path to an executable on  the filesystem is typically specified. Take note of the parent process. In a suspicious  instance, this will be spawned from a non-standard process like `Cmd.exe`, `PowerShell.exe`  or `Explorer.exe`. \  If used by a developer, typically this will be found with multiple command-line  switches/arguments and spawn from Visual Studio. \  During triage review resulting network connections, file modifications, and parallel  processes. Capture any artifacts and review further.'

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where `process_installutil` Processes.process  IN ("*/u*", "*uninstall*") by Processes.dest Processes.user Processes.parent_process_name  Processes.process_name Processes.original_file_name Processes.process Processes.process_id  Processes.parent_process_id | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `windows_installutil_uninstall_option_filter`'



<li><a href="#">NAME: Windows InstallUtil Uninstall Option with Network

DESCRIPTION:  'The following analytic identifies the Windows InstallUtil.exe binary  making a remote network connection. This technique may be used to download and execute  code while bypassing application control using the `/u` (uninstall) switch. \  InstallUtil uses the functions install and uninstall within the System.Configuration.Install  namespace to process .net assembly. Install function requires admin privileges,  however, uninstall function can be run as an unprivileged user.\  When `InstallUtil.exe` is used in a malicous manner, the path to an executable on  the filesystem is typically specified. Take note of the parent process. In a suspicious  instance, this will be spawned from a non-standard process like `Cmd.exe`, `PowerShell.exe`  or `Explorer.exe`. \  If used by a developer, typically this will be found with multiple command-line  switches/arguments and spawn from Visual Studio. \  During triage review resulting network connections, file modifications, and parallel  processes. Capture any artifacts and review further.'

SEARCH:  '| tstats `security_content_summariesonly` count FROM datamodel=Endpoint.Processes  where `process_installutil` Processes.process IN ("*/u*", "*uninstall*") by _time  span=1h  Processes.user Processes.process_id Processes.process_name Processes.dest Processes.process_path  Processes.process Processes.parent_process_name | `drop_dm_object_name(Processes)`  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | join  process_id  [| tstats `security_content_summariesonly` count FROM datamodel=Network_Traffic.All_Traffic  where All_Traffic.dest_port != 0 by All_Traffic.process_id All_Traffic.dest All_Traffic.dest_port  | `drop_dm_object_name(All_Traffic)` | rename dest as C2 ] | table _time user dest parent_process_name  process_name process_path process process_id dest_port C2 | `windows_installutil_uninstall_option_with_network_filter`'



<li><a href="#">NAME: Windows InstallUtil URL in Command Line

DESCRIPTION:  'The following analytic identifies the Windows InstallUtil.exe binary  passing a HTTP request on the command-line. This technique may be used to download  and execute code while bypassing application control. \  When `InstallUtil.exe` is used in a malicous manner, the path to an executable on  the filesystem is typically specified. Take note of the parent process. In a suspicious  instance, this will be spawned from a non-standard process like `Cmd.exe`, `PowerShell.exe`  or `Explorer.exe`. \  If used by a developer, typically this will be found with multiple command-line  switches/arguments and spawn from Visual Studio. \  During triage review resulting network connections, file modifications, and parallel  processes. Capture any artifacts and review further.'

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where `process_installutil` Processes.process  IN ("*http://*","*https://*") by Processes.dest Processes.user Processes.parent_process_name  Processes.process_name Processes.original_file_name Processes.process Processes.process_id  Processes.parent_process_id | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `windows_installutil_url_in_command_line_filter`'



<li><a href="#">NAME: Windows ISO LNK File Creation

DESCRIPTION:  The following analytic identifies the use of a delivered ISO file that  has been mounted and the afformention lnk or file opened within it. When the ISO  file is opened, the files are saved in the %USER%\AppData\Local\Temp\<random folder  name>\ path. The analytic identifies .iso.lnk written to the path. The name of the  ISO file is prepended.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime FROM datamodel=Endpoint.Filesystem where Filesystem.file_path IN ("*\\Microsoft\\Windows\\Recent\\*")  Filesystem.file_name IN ("*.iso.lnk", "*.img.lnk", "*.vhd.lnk", "*vhdx.lnk") by  Filesystem.file_create_time Filesystem.process_id Filesystem.file_name Filesystem.file_path  Filesystem.dest | `drop_dm_object_name(Filesystem)` | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `windows_iso_lnk_file_creation_filter`'



<li><a href="#">NAME: Windows Java Spawning Shells

DESCRIPTION:  The following analytic identifies the process name of java.exe and w3wp.exe  spawning a Windows shell. This is potentially indicative of exploitation of the  Java application and may be related to current event CVE-2021-44228 (Log4Shell).  The shells included in the macro are "cmd.exe", "powershell.exe". Upon triage, review  parallel processes and command-line arguments to determine legitimacy.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.parent_process_name=java.exe  OR Processes.parent_process_name=w3wp.exe `windows_shells` by Processes.dest Processes.user  Processes.parent_process_name Processes.process_name Processes.process Processes.process_id  Processes.parent_process_id | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `windows_java_spawning_shells_filter`'



<li><a href="#">NAME: Windows Kerberos Local Successful Logon

DESCRIPTION:  The following analytic identifies a local successful authentication event  on a Windows endpoint using the Kerberos package. The target user security identified  will be set to the built-in local Administrator account, along with the remote address  as localhost - 127.0.0.1. This may be indicative of a kerberos relay attack. Upon  triage, review for recently ran binaries on disk. In addition, look for new computer  accounts added to Active Directory and other anomolous AD events.

SEARCH:  '`wineventlog_security`  EventCode=4624 Logon_Type=3 Authentication_Package=Kerberos  action=success src_ip=127.0.0.1 | stats count min(_time) as firstTime max(_time)  as lastTime by dest, subject, action, Security_ID, user, Account_Name, src_ip |  `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `windows_kerberos_local_successful_logon_filter`'



<li><a href="#">NAME: Windows Known GraphicalProton Loaded Modules

DESCRIPTION:  The following analytic identifies a potential suspicious process loading dll modules related to Graphicalproton backdoor implant of SVR.  These DLL modules have been observed in SVR attacks, commonly used to install backdoors on targeted hosts.   This anomaly detection highlights the need for thorough investigation and immediate mitigation measures to safeguard the network against potential breaches.

SEARCH:  '`sysmon` EventCode=7    ImageLoaded IN ("*\\AclNumsInvertHost.dll", "*\\ModeBitmapNumericAnimate.dll", "*\\UnregisterAncestorAppendAuto.dll", "*\\DeregisterSeekUsers.dll", "*\\ScrollbarHandleGet.dll", "*\\PerformanceCaptionApi.dll", "*\\WowIcmpRemoveReg.dll", "*\\BlendMonitorStringBuild.dll", "*\\HandleFrequencyAll.dll", "*\\HardSwapColor.dll", "*\\LengthInMemoryActivate.dll", "*\\ParametersNamesPopup.dll", "*\\ModeFolderSignMove.dll", "*\\ChildPaletteConnected.dll", "*\\AddressResourcesSpec.dll")   | stats count min(_time) as firstTime max(_time) as lastTime by Image ImageLoaded process_name dest EventCode Signed ProcessId Hashes IMPHASH   | `security_content_ctime(firstTime)`   | `security_content_ctime(lastTime)`   | `windows_known_graphicalproton_loaded_modules_filter`'



<li><a href="#">NAME: Windows KrbRelayUp Service Creation

DESCRIPTION:  The following analytic identifies the default service name created by  KrbRelayUp. Defenders should be aware that attackers could change the hardcoded  service name of the KrbRelayUp tool and bypass this detection.

SEARCH:  '`wineventlog_system` EventCode=7045 Service_Name IN ("KrbSCM") | stats count  min(_time) as firstTime max(_time) as lastTime by dest EventCode Service_File_Name Service_Name  Service_Start_Type Service_Type | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `windows_krbrelayup_service_creation_filter`'



<li><a href="#">NAME: Windows Large Number of Computer Service Tickets Requested

DESCRIPTION:  The following analytic leverages Event ID 4769, `A Kerberos  service ticket was requested`, to identify more than 30 computer service  ticket requests from one source. When a domain joined endpoint connects to other remote  endpoint, it will first request a Kerberos Service Ticket with the computer name as the  Service Name. A user requesting a large number of computer service tickets  for different endpoints could represent malicious behavior like lateral movement,  malware staging, reconnaissance, etc.\  Active Directory environments can be very different depending on the organization. Users should test this detection and customize   the arbitrary threshold as needed.

SEARCH:  ' `wineventlog_security` EventCode=4769 ServiceName="*$" TargetUserName!="*$"  | bucket span=5m _time   | stats dc(ServiceName) AS unique_targets values(ServiceName) as host_targets by _time, IpAddress, TargetUserName  | where unique_targets > 30  | `windows_large_number_of_computer_service_tickets_requested_filter`'



<li><a href="#">NAME: Windows Lateral Tool Transfer RemCom

DESCRIPTION:  This analytic identifies the use of RemCom.exe - The open source psexec.  This utility provides the ability to move laterally and run scripts or commands  remotely.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where (Processes.process_name=remcom.exe  OR Processes.original_file_name=RemCom.exe) Processes.process="*\\*" Processes.process  IN ("*/user:*", "*/pwd:*") by Processes.dest Processes.user Processes.parent_process_name  Processes.process_name Processes.original_file_name Processes.process Processes.process_id  Processes.parent_process_id | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `windows_lateral_tool_transfer_remcom_filter`'



<li><a href="#">NAME: Windows Ldifde Directory Object Behavior

DESCRIPTION:  The following analytic identifies the use of Ldifde.exe, which provides  the ability to create, modify, or delete LDAP directory objects. Natively, the binary  is only installed on a domain controller. However, adversaries or administrators  may install the Windows Remote Server Admin Tools for ldifde.exe. Ldifde.exe is  a Microsoft Windows command-line utility used to import or export LDAP directory  entries. LDAP stands for Lightweight Directory Access Protocol, which is a protocol  used for accessing and managing directory information services over an IP network.  LDIF, on the other hand, stands for LDAP Data Interchange Format, a standard plain-text  data interchange format for representing LDAP directory entries. -i This is a flag  used with Ldifde.exe to denote import mode. In import mode, Ldifde.exe takes an  LDIF file and imports its contents into the LDAP directory. The data in the LDIF  file might include new objects to be created, or modifications or deletions to existing  objects. -f This flag is used to specify the filename of the LDIF file that Ldifde.exe  will import from (in the case of the -i flag) or export to (without the -i flag).  For example, if you wanted to import data from a file called data.ldif, you would  use the command ldifde -i -f data.ldif. Keep in mind that while the use of Ldifde.exe  is legitimate in many contexts, it can also be used maliciously. For instance, an  attacker who has gained access to a domain controller could potentially use Ldifde.exe  to export sensitive data or make unauthorized changes to the directory. Therefore,  it's important to monitor for unusual or unauthorized use of this tool.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.process_name=ldifde.exe  Processes.process IN ("*-i *", "*-f *") by Processes.dest Processes.user Processes.parent_process_name  Processes.process_name Processes.original_file_name Processes.process Processes.process_id  Processes.parent_process_id | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `windows_ldifde_directory_object_behavior_filter`'



<li><a href="#">NAME: Windows Linked Policies In ADSI Discovery

DESCRIPTION:  The following analytic utilizes PowerShell Script Block Logging (EventCode=4104)  to identify the `[Adsisearcher]` type accelerator being used to query Active Directory  for domain groups. Red Teams and adversaries may leverage `[Adsisearcher]` to enumerate  domain organizational unit for situational awareness and Active Directory Discovery.

SEARCH:  '`powershell` EventCode=4104 ScriptBlockText = "*[adsisearcher]*" ScriptBlockText  = "*objectcategory=organizationalunit*" ScriptBlockText = "*findAll()*" | stats  count min(_time) as firstTime max(_time) as lastTime by EventCode ScriptBlockText  Computer user_id  | rename Computer as dest, user_id as user   | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `windows_linked_policies_in_adsi_discovery_filter`'



<li><a href="#">NAME: Windows Local Administrator Credential Stuffing

DESCRIPTION:  The following analytic leverages events 4625 and 4624 to identify an endpoint using the builtin local Administrator account to authenticate to a large numbers of endpoints. Specifically,   the logic will trigger when an endpoints attempts to authenticate to more than 30 target computers within a 5 minute timespan. This behavior could  represent an adversary who has obtained access to local credentials and is trying to validate if these credentials work on other hosts to escalate their privileges.   As environments differ across organizations, security teams should customize the thresholds of this detection as needed.

SEARCH:  ' `wineventlog_security` EventCode=4625 OR EventCode=4624 Logon_Type=3 TargetUserName=Administrator  | bucket span=5m _time  | stats dc(Computer) AS unique_targets values(Computer) as host_targets by _time, IpAddress, TargetUserName, EventCode  | where unique_targets > 30  | `windows_local_administrator_credential_stuffing_filter`'



<li><a href="#">NAME: Windows LSA Secrets NoLMhash Registry

DESCRIPTION:  The following analytic identifies a modification in the Windows registry related to the Local Security Authority (LSA) in Windows.   This registry value is used to determine whether the system should store passwords in the weaker Lan Manager (LM) hash format.   Setting it to 0 disables this feature, meaning LM hashes will be stored.   Modifying these settings should be done carefully and with a clear understanding of the impact it might have on system security and functionality.  This command is often used in security configurations to enforce stronger password storage methods and prevent the storage of weaker LM hashes,   which are more susceptible to certain types of attacks.   This TTP detection can be a good indicator of any process or user that tries to modify the LSA security configuration.

SEARCH:  '| tstats `security_content_summariesonly` count FROM datamodel=Endpoint.Registry   WHERE (Registry.registry_path= "*\\System\\CurrentControlSet\\Control\\Lsa\\NoLMHash"  Registry.registry_value_data = 0x00000000)   BY _time span=1h Registry.dest Registry.user Registry.registry_path Registry.registry_key_name Registry.registry_value_name Registry.registry_value_data Registry.process_guid   | `drop_dm_object_name(Registry)`   | where isnotnull(registry_value_data)  | `security_content_ctime(firstTime)`   | `security_content_ctime(lastTime)`   | `windows_lsa_secrets_nolmhash_registry_filter`'



<li><a href="#">NAME: Windows Mail Protocol In Non-Common Process Path

DESCRIPTION:  The following analytic identifies a possible windows application having  a SMTP connection in a non common installation path in windows operating system.This  network protocol is being used by adversaries, threat actors and malware like AgentTesla  as a Command And Control communication to transfer its collected stolen information  like the desktop screenshots, browser information and system information of a targeted  or compromised host.

SEARCH:  '`sysmon` EventCode=3 NOT(Image IN("*\\program files*", "*\\thunderbird.exe","*\\outlook.exe"))  (DestinationPortName="smtp" OR DestinationPort=25 OR DestinationPort=587) | stats  count min(_time) as firstTime max(_time) as lastTime by Image DestinationPort DestinationPortName  DestinationHostname SourceHostname SourcePort SourcePortName Protocol DestinationIp  dest user | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `windows_mail_protocol_in_non_common_process_path_filter`'



<li><a href="#">NAME: Windows Mark Of The Web Bypass

DESCRIPTION:  The following analytic identifies a suspicious process that delete mark-of-the-web data stream.   This technique has been observed in various instances of malware and adversarial activities aimed at circumventing   security restrictions within the Windows Operating System, particularly pertaining to files downloaded from the internet.   An example of this scenario is demonstrated by Ave Maria RAT, which attempts to delete this data stream as a means to evade such restrictions.

SEARCH:  '`sysmon` EventCode=23 TargetFilename = "*:Zone.Identifier"   | stats  min(_time) as firstTime max(_time) as lastTime count by user EventCode Image TargetFilename ProcessID dest   | `security_content_ctime(firstTime)`   | `security_content_ctime(lastTime)`   | `windows_mark_of_the_web_bypass_filter`'



<li><a href="#">NAME: Windows Masquerading Explorer As Child Process

DESCRIPTION:  The following analytic identifies a suspicious parent process of explorer.exe.  Explorer is usually executed by userinit.exe that will exit after execution that  causes the main explorer.exe no parent process. Some malware like qakbot spawn another  explorer.exe to inject its code. This TTP detection is a good indicator that a process  spawning explorer.exe might inject code or masquerading its parent child process  to evade detections.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.parent_process_name  IN("cmd.exe", "powershell.exe", "regsvr32.exe") AND Processes.process_name = "explorer.exe"  by Processes.parent_process Processes.parent_process_name Processes.process_name  Processes.process_id Processes.process_guid Processes.process Processes.user Processes.dest  Processes.parent_process_id | `drop_dm_object_name("Processes")` | `security_content_ctime(firstTime)`  |`security_content_ctime(lastTime)` | `windows_masquerading_explorer_as_child_process_filter`'



<li><a href="#">NAME: Windows Masquerading Msdtc Process

DESCRIPTION:  The following analytic identifies a suspicious msdtc.exe with specific command-line parameters, particularly -a or -b,   which are regarded as potential indicators of the presence of the insidious PlugX malware. This malware is notorious for its covert   operations and is frequently utilized by threat actors for unauthorized access, data exfiltration, and espionage.  The analytic's focus on the -a or -b command-line parameters within msdtc.exe is rooted in the PlugX malware's sophisticated tactic   of masquerading its activities. To elude detection, PlugX employs a technique where it injects a concealed,   headless PlugX Dynamic Link Library (DLL) module into the legitimate msdtc.exe process. By leveraging these   specific command-line parameters, the malware attempts to disguise its presence within a system's legitimate processes,   thereby evading immediate suspicion.

SEARCH:  '| tstats `security_content_summariesonly` min(_time) as firstTime max(_time) as lastTime from datamodel=Endpoint.Processes   where Processes.process_name = "msdtc.exe" Processes.process = "*msdtc.exe*" Processes.process IN ("* -a*", "* -b*")  by Processes.dest Processes.user Processes.parent_process_name Processes.parent_process Processes.process_name Processes.original_file_name   Processes.process Processes.process_id Processes.parent_process_id  | `drop_dm_object_name(Processes)`   | `security_content_ctime(firstTime)`   | `security_content_ctime(lastTime)`   | `windows_masquerading_msdtc_process_filter`'



<li><a href="#">NAME: Windows Mimikatz Binary Execution

DESCRIPTION:  As simple as it sounds, this analytic identifies when the native mimikatz.exe  binary executes on Windows. It does look for the original file name as well, just  in case the binary is renamed. Adversaries sometimes bring in the default binary  and run it directly. Benjamin Delpy originally created Mimikatz as a proof of concept  to show Microsoft that its authentication protocols were vulnerable to an attack.  Instead, he inadvertently created one of the most widely used and downloaded threat  actor tools of the past 20 years. Mimikatz is an open-source application that allows  users to view and save authentication credentials such as Kerberos tickets.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where (Processes.process_name=mimikatz.exe  OR Processes.original_file_name=mimikatz.exe) by Processes.dest Processes.user Processes.parent_process_name  Processes.process_name Processes.original_file_name Processes.process Processes.process_id  Processes.parent_process_id | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `windows_mimikatz_binary_execution_filter`'



<li><a href="#">NAME: Windows Mimikatz Crypto Export File Extensions

DESCRIPTION:  The following analytic identifies hardcoded extensions related to the  Crypo module within Mimikatz. Moving certificates or downloading them is not malicious,  however with Mimikatz having hardcoded names it helps to identify potential usage  of certificates being exported.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime FROM datamodel=Endpoint.Filesystem where Filesystem.file_name IN ("*.keyx.rsa.pvk","*sign.rsa.pvk","*sign.dsa.pvk","*dsa.ec.p8k","*dh.ec.p8k",  "*.pfx", "*.der") by _time span=1h Filesystem.dest Filesystem.file_create_time Filesystem.file_name  Filesystem.file_path | `security_content_ctime(lastTime)` | `security_content_ctime(firstTime)`  | `drop_dm_object_name(Filesystem)` | `windows_mimikatz_crypto_export_file_extensions_filter`'



<li><a href="#">NAME: Windows Modify Registry AuthenticationLevelOverride

DESCRIPTION:  The following analytic identifies a modification in the Windows registry related to authentication level settings.  This registry is the configuration for authentication level settings within the Terminal Server Client settings in Windows.  AuthenticationLevelOverride might be used to control or override the authentication level used by the Terminal Server Client for remote connections.  DarkGate malware modify this registry as part of its malicious installation in a targeted host for its remote desktop capabilities.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time) as lastTime from datamodel=Endpoint.Registry   where Registry.registry_path = "*\\Terminal Server Client\\AuthenticationLevelOverride"  Registry.registry_value_data = 0x00000000  by  Registry.registry_path Registry.registry_value_name Registry.registry_value_data Registry.process_guid Registry.action Registry.user Registry.dest   | `drop_dm_object_name(Registry)`   | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `windows_modify_registry_authenticationleveloverride_filter`'



<li><a href="#">NAME: Windows Modify Registry Auto Minor Updates

DESCRIPTION:  The following analytic identifies a suspicious registry modification of Windows auto update configuration.   This technique was being abused by several adversaries, malware authors and also red-teamers to bypass detection or   to be able to compromise the target host with zero day exploit or as an additional defense evasion technique.  RedLine Stealer is one of the malware we've seen that uses this technique to evade detection and add more payload on the target host.  This detection looks for registry modification that will "Treat minor updates like other updates".

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time) as lastTime from datamodel=Endpoint.Registry   where Registry.registry_path="*\\SOFTWARE\\Policies\\Microsoft\\Windows\\WindowsUpdate\\AU\\AutoInstallMinorUpdates"  AND Registry.registry_value_data="0x00000000"   by Registry.dest Registry.user Registry.registry_path Registry.registry_value_data Registry.registry_key_name   | `drop_dm_object_name(Registry)`   | `security_content_ctime(lastTime)`  | `security_content_ctime(firstTime)`   | `windows_modify_registry_auto_minor_updates_filter`'



<li><a href="#">NAME: Windows Modify Registry Auto Update Notif

DESCRIPTION:  The following analytic identifies a suspicious registry modification of Windows auto update notification.   This technique was being abused by several adversaries, malware authors and also red-teamers to bypass detection or   to be able to compromise the target host with zero day exploit or as an additional defense evasion technique.  RedLine Stealer is one of the malware we've seen that uses this technique to evade detection and add more payload on the target host.  This detection looks for registry modification that will switch the automatic windows update to "Notify before download".

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time) as lastTime from datamodel=Endpoint.Registry   where Registry.registry_path="*\\SOFTWARE\\Policies\\Microsoft\\Windows\\WindowsUpdate\\AU\\AUOptions"  AND Registry.registry_value_data="0x00000002"   by Registry.dest Registry.user Registry.registry_path Registry.registry_value_data Registry.registry_key_name   | `drop_dm_object_name(Registry)`   | `security_content_ctime(lastTime)`  | `security_content_ctime(firstTime)`   | `windows_modify_registry_auto_update_notif_filter`'



<li><a href="#">NAME: Windows Modify Registry Default Icon Setting

DESCRIPTION:  This analytic is developed to detect suspicious registry modification  to change the default icon association of windows to ransomware . This technique  was seen in Lockbit ransomware where it modified the default icon association of  the compromised Windows OS  host with its dropped ransomware icon file as part of  its  defacement payload. This registry is not commonly modified by a normal user  so having this anomaly detection may help to catch possible lockbit ransomware infection  or other malware.

SEARCH:  '| tstats `security_content_summariesonly` count  min(_time) as firstTime  max(_time) as lastTime FROM datamodel=Endpoint.Registry where Registry.registry_path  ="*\\defaultIcon\\(Default)*" Registry.registry_path = "*HKCR\\*" by Registry.registry_path  Registry.registry_key_name Registry.registry_value_name Registry.action Registry.dest  Registry.user  | `security_content_ctime(lastTime)` | `security_content_ctime(firstTime)` | `drop_dm_object_name(Registry)`  | `windows_modify_registry_default_icon_setting_filter`'



<li><a href="#">NAME: Windows Modify Registry DisableRemoteDesktopAntiAlias

DESCRIPTION:  The following analytic identifies a modification in the Windows registry to DisableRemoteDesktopAntiAlias.  This registry setting might be intended to manage or control anti-aliasing behavior (smoothing of edges and fonts) within Remote Desktop sessions.   DarkGate malware modify this registry as part of its malicious installation in a targeted host for its remote desktop capabilities.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time) as lastTime from datamodel=Endpoint.Registry   where Registry.registry_path = "*\\Terminal Services\\DisableRemoteDesktopAntiAlias"  Registry.registry_value_data = 0x00000001  by  Registry.registry_path Registry.registry_value_name Registry.registry_value_data Registry.process_guid Registry.action Registry.user Registry.dest   | `drop_dm_object_name(Registry)`   | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)`   | `windows_modify_registry_disableremotedesktopantialias_filter`'



<li><a href="#">NAME: Windows Modify Registry DisableSecuritySettings

DESCRIPTION:  The following analytic identifies a modification in the Windows registry  to disable security settings of Terminal Services. altering or disabling security  settings within Terminal Services. Terminal Services, now known as Remote Desktop  Services (RDS) in more recent Windows versions, allows users to access applications,  data, and even an entire desktop remotely. DarkGate malware modify this registry  as part of its malicious installation in a targeted host for its remote desktop  capabilities.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Registry where Registry.registry_path = "*\\Terminal  Services\\DisableSecuritySettings"  Registry.registry_value_data = 0x00000001 by  Registry.registry_path  Registry.registry_value_name Registry.registry_value_data Registry.process_guid  Registry.action Registry.user Registry.dest | `drop_dm_object_name(Registry)` |  `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `windows_modify_registry_disablesecuritysettings_filter`'



<li><a href="#">NAME: Windows Modify Registry Disable Restricted Admin

DESCRIPTION:  The following analytic identifies a modification in the Windows registry related to DisableRestrictedAdmin.  This registry entry is used to control the behavior of Restricted Admin mode, which is a security feature that limits   the exposure of sensitive credentials when connecting remotely to another computer. When this registry value is set to 0 it   indicates that Restricted Admin mode is enabled (default behavior). As with any modifications to registry settings,   changing this entry should be approached cautiously, ensuring a clear understanding of the implications for system   security and functionality. Unauthorized changes to these security settings can pose risks and should be monitored   closely for any signs of tampering or unauthorized alterations. 

SEARCH:  '| tstats `security_content_summariesonly` count FROM datamodel=Endpoint.Registry   WHERE (Registry.registry_path= "*\\System\\CurrentControlSet\\Control\\Lsa\\DisableRestrictedAdmin"  Registry.registry_value_data = 0x00000000)   BY _time span=1h Registry.dest Registry.user Registry.registry_path Registry.registry_key_name Registry.registry_value_name Registry.registry_value_data Registry.process_guid   | `drop_dm_object_name(Registry)`   | where isnotnull(registry_value_data)  | `security_content_ctime(firstTime)`   | `security_content_ctime(lastTime)`   | `windows_modify_registry_disable_restricted_admin_filter`'



<li><a href="#">NAME: Windows Modify Registry Disable Toast Notifications

DESCRIPTION:  The following analytic is to identify a modification in the Windows registry  to disable toast notifications. This Windows Operating System feature is responsible  for alerting or notifying user if application or OS need some updates. Adversaries  and malwares like Azorult abuse this technique to disable important update notification  in compromised host. This anomaly detection is a good pivot to look for further  events related to defense evasion and execution.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime FROM datamodel=Endpoint.Registry where Registry.registry_path= "*\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\PushNotifications\\ToastEnabled*"  Registry.registry_value_data="0x00000000" by Registry.registry_key_name Registry.user  Registry.registry_path Registry.registry_value_data Registry.action Registry.dest  | `drop_dm_object_name(Registry)` | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `windows_modify_registry_disable_toast_notifications_filter`'



<li><a href="#">NAME: Windows Modify Registry Disable WinDefender Notifications

DESCRIPTION:  The following analytic identifies a suspicious registry modification  to disable Windows Defender notification. This technique was being abused by several  adversaries, malware authors and also red-teamers to evade detection on the targeted  machine. RedLine Stealer is one of the malware we've seen that uses this technique  to bypass Windows defender detection.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Registry where Registry.registry_path="*\\SOFTWARE\\Policies\\Microsoft\\Windows  Defender Security Center\\Notifications\\DisableNotifications" AND Registry.registry_value_data="0x00000001"  by Registry.dest Registry.user Registry.registry_path Registry.registry_value_data  Registry.registry_key_name | `drop_dm_object_name(Registry)` | `security_content_ctime(lastTime)`  | `security_content_ctime(firstTime)` | `windows_modify_registry_disable_windefender_notifications_filter`'



<li><a href="#">NAME: Windows Modify Registry Disable Windows Security Center Notif

DESCRIPTION:  The following analytic is to identify a modification in the Windows registry  to disable windows center notifications. This Windows Operating System feature is  responsible for alerting or notifying user if application or OS need some updates.  Adversaries and malwares like Azorult abuse this technique to disable important  update notification in compromised host. This anomaly detection is a good pivot  to look for further events related to defense evasion and execution.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime FROM datamodel=Endpoint.Registry where Registry.registry_path= "*\\Windows\\CurrentVersion\\ImmersiveShell\\UseActionCenterExperience*"  Registry.registry_value_data="0x00000000" by Registry.registry_key_name Registry.user  Registry.registry_path Registry.registry_value_data Registry.action Registry.dest  | `drop_dm_object_name(Registry)` | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `windows_modify_registry_disable_windows_security_center_notif_filter`'



<li><a href="#">NAME: Windows Modify Registry Disable Win Defender Raw Write Notif

DESCRIPTION:  The following analytic identifies a modification in the Windows registry  to disable Windows Defender raw write notification feature. This policy controls  whether raw volume write notifications are sent to behavior monitoring or not. This  registry was recently identified in Azorult malware to bypass Windows Defender detections  or behavior monitoring in terms of volume write.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime FROM datamodel=Endpoint.Registry where Registry.registry_path= "*\\Windows  Defender\\Real-Time Protection\\DisableRawWriteNotification*" Registry.registry_value_data="0x00000001"  by Registry.registry_key_name Registry.user Registry.registry_path Registry.registry_value_data  Registry.action Registry.dest | `drop_dm_object_name(Registry)` | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `windows_modify_registry_disable_win_defender_raw_write_notif_filter`'



<li><a href="#">NAME: Windows Modify Registry Disabling WER Settings

DESCRIPTION:  The following analytic identifies a modification in the Windows registry  to disable Windows error reporting settings. This Windows feature allows the user  to report bugs, errors, failure or problems encountered in specific application  or processes. Adversaries use this technique to hide any error or failure that some  of its malicious components trigger.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime FROM datamodel=Endpoint.Registry where Registry.registry_path= "*\\SOFTWARE\\Microsoft\\Windows\\Windows  Error Reporting\\disable*" Registry.registry_value_data="0x00000001" by Registry.registry_key_name  Registry.user Registry.registry_path Registry.registry_value_data Registry.action  Registry.dest | `drop_dm_object_name(Registry)` | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `windows_modify_registry_disabling_wer_settings_filter`'



<li><a href="#">NAME: Windows Modify Registry DisAllow Windows App

DESCRIPTION:  The following analytic identifies modification in the Windows registry  to prevent user running specific computer programs that could aid them in manually  removing malware or detecting it using security products. This technique was recently  identified in Azorult malware where it uses this registry value to prevent several  AV products to execute on the compromised host machine.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime FROM datamodel=Endpoint.Registry where Registry.registry_path= "*\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer\\DisallowRun*"  Registry.registry_value_data="0x00000001" by Registry.registry_key_name Registry.user  Registry.registry_path Registry.registry_value_data Registry.action Registry.dest  | `drop_dm_object_name(Registry)` | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `windows_modify_registry_disallow_windows_app_filter`'



<li><a href="#">NAME: Windows Modify Registry DontShowUI

DESCRIPTION:  The following analytic identifies a modification in the Windows Error Reporting registry to DontShowUI.  DarkGate malware modify this registry as part of its malicious installation in a targeted host for its remote desktop capabilities.  When this registry value is present and set to a specific configuration, it can influence the behavior of error reporting dialogs or prompts,   suppressing them from being displayed to the user.For instance, setting DontShowUI to a value of 1 often indicates that the   Windows Error Reporting UI prompts will be suppressed, meaning users won't see error reporting pop-ups when errors occur.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time) as lastTime from datamodel=Endpoint.Registry   where Registry.registry_path = "*\\SOFTWARE\\Microsoft\\Windows\\Windows Error Reporting\\DontShowUI"  Registry.registry_value_data = 0x00000001  by  Registry.registry_path Registry.registry_value_name Registry.registry_value_data Registry.process_guid Registry.action Registry.user Registry.dest   | `drop_dm_object_name(Registry)`   | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)`   | `windows_modify_registry_dontshowui_filter`'



<li><a href="#">NAME: Windows Modify Registry Do Not Connect To Win Update

DESCRIPTION:  The following analytic identifies a suspicious registry modification of Windows auto update configuration.   This technique was being abused by several adversaries, malware authors and also red-teamers to bypass detection or   to be able to compromise the target host with zero day exploit or as an additional defense evasion technique.  RedLine Stealer is one of the malware we've seen that uses this technique to evade detection and add more payload on the target host.  This detection looks for registry modification that will disable Windos update functionality, and may cause connection to public services such as the Windows Store to stop working.  This policy applies only when this PC is configured to connect to an intranet update service using the "Specify intranet Microsoft update service location" policy.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time) as lastTime from datamodel=Endpoint.Registry   where Registry.registry_path="*\\SOFTWARE\\Policies\\Microsoft\\Windows\\WindowsUpdate\\DoNotConnectToWindowsUpdateInternetLocations"  AND Registry.registry_value_data="0x00000001"   by Registry.dest Registry.user Registry.registry_path Registry.registry_value_data Registry.registry_key_name   | `drop_dm_object_name(Registry)`   | `security_content_ctime(lastTime)`  | `security_content_ctime(firstTime)`   | `windows_modify_registry_do_not_connect_to_win_update_filter`'



<li><a href="#">NAME: Windows Modify Registry EnableLinkedConnections

DESCRIPTION:  The following analytic identifies a suspicious registry modification of Windows linked connection configuration.   This technique was being abused by several adversaries, malware like BlackByte ransomware to enable the linked connections feature,   that allows network shares to be accessed using both standard and administrator-level privileges simultaneously.   By default, Windows does not enable this feature to enhance security.

SEARCH:  '| tstats `security_content_summariesonly` count FROM datamodel=Endpoint.Registry   WHERE (Registry.registry_path= "*\\Microsoft\\Windows\\CurrentVersion\\Policies\\System\\EnableLinkedConnections" Registry.registry_value_data = "0x00000001")   BY _time span=1h Registry.registry_path Registry.registry_key_name Registry.registry_value_name Registry.registry_value_data Registry.process_guid Registry.dest  | `drop_dm_object_name(Registry)`   | `security_content_ctime(firstTime)`   | `security_content_ctime(lastTime)`   | `windows_modify_registry_enablelinkedconnections_filter`'



<li><a href="#">NAME: Windows Modify Registry LongPathsEnabled

DESCRIPTION:  The following analytic identifies a suspicious registry modification of Windows long path enable configuration.   This technique was being abused by several adversaries, malware like BlackByte to enable long file path support in the operating system.   By default, Windows has a limitation on the maximum length of a file path, which is set to 260 characters.   Enabling the LongPathsEnabled setting allows you to work with file paths longer than 260 characters.

SEARCH:  '| tstats `security_content_summariesonly` count FROM datamodel=Endpoint.Registry   WHERE (Registry.registry_path= "*\\CurrentControlSet\\Control\\FileSystem\\LongPathsEnabled" Registry.registry_value_data = "0x00000001")   BY _time span=1h Registry.registry_path Registry.registry_key_name Registry.registry_value_name Registry.registry_value_data Registry.process_guid Registry.dest  | `drop_dm_object_name(Registry)`   | `security_content_ctime(firstTime)`   | `security_content_ctime(lastTime)`   | `windows_modify_registry_longpathsenabled_filter`'



<li><a href="#">NAME: Windows Modify Registry MaxConnectionPerServer

DESCRIPTION:  The following analytic identifies a suspicious registry modification of Windows max connection per server configuration.   This particular technique has been observed in various threat actors, adversaries, and even in malware such as the Warzone (Ave Maria) RAT.  By altering the max connection per server setting in the Windows registry, attackers can potentially increase the number of concurrent connections   allowed to a remote server. This modification could be exploited for various malicious purposes, including facilitating distributed denial-of-service (DDoS) attacks or enabling more effective lateral movement within a compromised network.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time) as lastTime FROM datamodel=Endpoint.Registry   where (Registry.registry_path= "*\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\MaxConnectionsPerServer*" OR Registry.registry_path= "*\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\MaxConnectionsPer1_0Server*")  Registry.registry_value_data = "0x0000000a" by Registry.registry_key_name Registry.user Registry.registry_path Registry.registry_value_data Registry.action Registry.dest   | `drop_dm_object_name(Registry)`   | `security_content_ctime(firstTime)`   | `security_content_ctime(lastTime)`   | `windows_modify_registry_maxconnectionperserver_filter`'



<li><a href="#">NAME: Windows Modify Registry NoChangingWallPaper

DESCRIPTION:  The following analytic identifies alterations in the Windows registry aimed at restricting wallpaper modifications.   This tactic has been exploited by the Rhysida ransomware as a part of its destructive payload within compromised systems.   By making this registry modification, the ransomware seeks to impede users from changing the wallpaper forcibly set by the malware,   restricting the user's control over their system's visual settings.

SEARCH:  '| tstats `security_content_summariesonly` count FROM datamodel=Endpoint.Registry   WHERE (Registry.registry_path= "*\\Windows\\CurrentVersion\\Policies\\ActiveDesktop\\NoChangingWallPaper"  Registry.registry_value_data = 1)   BY _time span=1h Registry.dest Registry.user Registry.registry_path Registry.registry_key_name Registry.registry_value_name Registry.registry_value_data Registry.process_guid   | `drop_dm_object_name(Registry)`   | where isnotnull(registry_value_data)  | `security_content_ctime(firstTime)`   | `security_content_ctime(lastTime)`   | `windows_modify_registry_nochangingwallpaper_filter`'



<li><a href="#">NAME: Windows Modify Registry No Auto Reboot With Logon User

DESCRIPTION:  The following analytic identifies a suspicious registry modification of Windows auto update configuration.   This technique was being abused by several adversaries, malware authors and also red-teamers to bypass detection or   to be able to compromise the target host with zero day exploit or as an additional defense evasion technique.  RedLine Stealer is one of the malware we've seen that uses this technique to evade detection and add more payload on the target host.  This detection looks for registry modification that will allow "Logged-on user gets to choose whether or not to restart his or her compute".

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time) as lastTime from datamodel=Endpoint.Registry   where Registry.registry_path="*\\SOFTWARE\\Policies\\Microsoft\\Windows\\WindowsUpdate\\AU\\NoAutoRebootWithLoggedOnUsers"  AND Registry.registry_value_data="0x00000001"   by Registry.dest Registry.user Registry.registry_path Registry.registry_value_data Registry.registry_key_name   | `drop_dm_object_name(Registry)`   | `security_content_ctime(lastTime)`  | `security_content_ctime(firstTime)`   | `windows_modify_registry_no_auto_reboot_with_logon_user_filter`'



<li><a href="#">NAME: Windows Modify Registry No Auto Update

DESCRIPTION:  The following analytic identifies a suspicious registry modification  of Windows auto update configuration. This technique was being abused by several  adversaries, malware authors and also red-teamers to bypass detection or to be able  to compromise the target host with zero day exploit or as an additional defense  evasion technique. RedLine Stealer is one of the malware we've seen that uses this  technique to evade detection and add more payload on the target host. This detection  looks for registry modification that will "Disable Automatic Updates".

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Registry where Registry.registry_path="*\\SOFTWARE\\Policies\\Microsoft\\Windows\\WindowsUpdate\\AU\\NoAutoUpdate"  AND Registry.registry_value_data="0x00000001" by Registry.dest Registry.user Registry.registry_path  Registry.registry_value_data Registry.registry_key_name | `drop_dm_object_name(Registry)`  | `security_content_ctime(lastTime)` | `security_content_ctime(firstTime)` | `windows_modify_registry_no_auto_update_filter`'



<li><a href="#">NAME: Windows Modify Registry ProxyEnable

DESCRIPTION:  The following analytic identifies a modification in the Windows registry to enable proxy.  This method has been exploited by various malware and adversaries to establish proxy communication on compromised hosts,   facilitating connections to malicious Command and Control (C2) servers.  Identifying this anomaly serves as a crucial indicator to unveil suspicious processes attempting to activate the proxy   feature within the Windows operating system. Detecting such attempts becomes pivotal in flagging potential threats, especially   those aiming to leverage proxy configurations for unauthorized communication with malicious entities.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time) as lastTime from datamodel=Endpoint.Registry   where Registry.registry_path = "*\\Internet Settings\\ProxyEnable"  Registry.registry_value_data = 0x00000001  by  Registry.registry_path Registry.registry_value_name Registry.registry_value_data Registry.process_guid Registry.action Registry.user Registry.dest   | `drop_dm_object_name(Registry)`   | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)`   | `windows_modify_registry_proxyenable_filter`'



<li><a href="#">NAME: Windows Modify Registry ProxyServer

DESCRIPTION:  The following analytic identifies a modification in the Windows registry to setup proxy server.  This method has been exploited by various malware and adversaries to establish proxy communication on compromised hosts,   facilitating connections to malicious Command and Control (C2) servers.  Identifying this anomaly serves as a crucial indicator to unveil suspicious processes attempting to activate the proxy   feature within the Windows operating system. Detecting such attempts becomes pivotal in flagging potential threats, especially   those aiming to leverage proxy configurations for unauthorized communication with malicious entities.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time) as lastTime from datamodel=Endpoint.Registry   where Registry.registry_path = "*\\Internet Settings\\ProxyServer"   by  Registry.registry_path Registry.registry_value_name Registry.registry_value_data Registry.process_guid Registry.action Registry.user Registry.dest   | `drop_dm_object_name(Registry)`   | where isnotnull(registry_value_data)  | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)`   | `windows_modify_registry_proxyserver_filter`'



<li><a href="#">NAME: Windows Modify Registry Qakbot Binary Data Registry

DESCRIPTION:  The following analytic identifies a suspicious registry entry created  by Qakbot malware as part of its malicious execution. This "Binary Data" Registry  was  created by newly spawn explorer.exe where its malicious code is injected to it.  The registry consist of 8 random registry value name with encrypted binary data  on its registry value data. This anomaly detections can be a good pivot for possible  Qakbot malware infection or other malware that uses registry to save or store there  config or malicious code on the registry data stream.

SEARCH:  '| tstats `security_content_summariesonly` count dc(registry_value_name) as registry_value_name_count FROM datamodel=Endpoint.Registry where Registry.registry_path="*\\SOFTWARE\\Microsoft\\*" AND Registry.registry_value_data = "Binary Data" by _time span=1m Registry.dest Registry.user Registry.registry_path Registry.registry_value_name Registry.registry_value_data Registry.process_guid Registry.process_id Registry.registry_key_name | `drop_dm_object_name(Registry)` | eval registry_key_name_len = len(registry_key_name) | eval registry_value_name_len = len(registry_value_name) | regex registry_value_name="^[0-9a-fA-F]{8}" | where registry_key_name_len < 80 AND registry_value_name_len == 8 | join process_guid, _time     [| tstats `security_content_summariesonly` count FROM datamodel=Endpoint.Processes where Processes.process_name IN ("explorer.exe", "wermgr.exe","dxdiag.exe", "OneDriveSetup.exe", "mobsync.exe", "msra.exe", "xwizard.exe") by _time span=1m Processes.process_id Processes.process_name Processes.process Processes.dest Processes.parent_process_name Processes.parent_process Processes.process_guid Processes.process_path     | `drop_dm_object_name(Processes)`         ] | stats min(_time) as firstTime max(_time) as lastTime values(registry_value_name) as registry_value_name dc(registry_value_name) as registry_value_name_count values(registry_key_name) by dest process_guid process_name parent_process_name| `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | where registry_value_name_count >= 5  | `windows_modify_registry_qakbot_binary_data_registry_filter`'



<li><a href="#">NAME: Windows Modify Registry Regedit Silent Reg Import

DESCRIPTION:  The following analytic identifies modification of Windows registry using  regedit.exe application with silent mode parameter. regedit.exe windows application  is commonly used as GUI app to check or modify registry. This application is also  has undocumented command-line parameter and one of those are silent mode parameter  that performs action without stopping for confirmation with dialog box. Importing  registry from .reg files need to monitor in a production environment since it can  be used adversaries to import RMS registry in compromised host.

SEARCH:  '| tstats `security_content_summariesonly` values(Processes.process) as process  min(_time) as firstTime max(_time) as lastTime from datamodel=Endpoint.Processes  where (Processes.process_name="regedit.exe" OR Processes.original_file_name="regedit.exe")  AND Processes.process="* /s *" AND Processes.process="*.reg*" by Processes.dest  Processes.user Processes.parent_process Processes.process_name Processes.original_file_name  Processes.process Processes.process_id Processes.parent_process_id | `drop_dm_object_name(Processes)`  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `windows_modify_registry_regedit_silent_reg_import_filter`'



<li><a href="#">NAME: Windows Modify Registry Reg Restore

DESCRIPTION:  The following analytic identifies a process execution of reg.exe with  "restore" parameter. This reg.exe parameter is commonly used to restore registry  backup data in a targeted host. This approach or technique was also seen in post-exploitation  tool like winpeas where it uses "reg save" and "reg restore" to check the registry  modification restriction in targeted host after gaining access to it.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where  `process_reg` AND Processes.process  = "* restore *" by Processes.process_name Processes.original_file_name Processes.process  Processes.process_id Processes.process_guid Processes.parent_process_name Processes.parent_process  Processes.parent_process_guid Processes.dest Processes.user | `drop_dm_object_name(Processes)`  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `windows_modify_registry_reg_restore_filter`'



<li><a href="#">NAME: Windows Modify Registry Risk Behavior

DESCRIPTION:  This analytic is designed to identify instances where three or more distinct analytics associated with Mitre ID T1112 - Modification of registry information are triggered. Such occurrences could indicate the presence of multiple malicious registry modifications on a host. Malicious actors frequently manipulate the Windows Registry to hide important configuration details within specific Registry keys. This technique allows them to obscure their activities, erase any evidence during cleanup operations, and establish continuous access and execution of malicious code.

SEARCH:  '| tstats `security_content_summariesonly` min(_time) as firstTime max(_time) as lastTime   sum(All_Risk.calculated_risk_score) as risk_score,   count(All_Risk.calculated_risk_score) as risk_event_count,   values(All_Risk.annotations.mitre_attack.mitre_tactic_id) as annotations.mitre_attack.mitre_tactic_id,  dc(All_Risk.annotations.mitre_attack.mitre_tactic_id) as mitre_tactic_id_count,   values(All_Risk.annotations.mitre_attack.mitre_technique_id) as annotations.mitre_attack.mitre_technique_id,   dc(All_Risk.annotations.mitre_attack.mitre_technique_id) as mitre_technique_id_count,   values(All_Risk.tag) as tag, values(source) as source,   dc(source) as source_count from datamodel=Risk.All_Risk   where source IN ("*registry*") All_Risk.annotations.mitre_attack.mitre_technique_id IN ("*T1112*")   by All_Risk.risk_object All_Risk.risk_object_type All_Risk.annotations.mitre_attack.mitre_tactic   | `drop_dm_object_name(All_Risk)`   | `security_content_ctime(firstTime)`   | `security_content_ctime(lastTime)`   | where source_count >= 3   | `windows_modify_registry_risk_behavior_filter`'



<li><a href="#">NAME: Windows Modify Registry Suppress Win Defender Notif

DESCRIPTION:  The following analytic is to identify a modification in the Windows registry  to suppress windows defender notification. This technique was abuse by adversaries  and threat actor to bypassed windows defender on the targeted host. Azorult malware  is one of the malware use this technique that also disable toast notification and  other windows features as part of its malicious behavior.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime FROM datamodel=Endpoint.Registry where Registry.registry_path= "*\\Windows  Defender\\UX Configuration\\Notification_Suppress*" Registry.registry_value_data="0x00000001"  by Registry.registry_key_name Registry.user Registry.registry_path Registry.registry_value_data  Registry.action Registry.dest | `drop_dm_object_name(Registry)` | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `windows_modify_registry_suppress_win_defender_notif_filter`'



<li><a href="#">NAME: Windows Modify Registry Tamper Protection

DESCRIPTION:  The following analytic identifies a suspicious registry modification to tamper Windows Defender protection.   This technique was being abused by several adversaries, malware authors and also red-teamers to evade detection on the targeted machine.   RedLine Stealer is one of the malware we've seen that uses this technique to bypass Windows defender detection.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time) as lastTime from datamodel=Endpoint.Registry   where Registry.registry_path="*\\SOFTWARE\\Microsoft\\Windows Defender\\Features\\TamperProtection"  AND Registry.registry_value_data="0x00000000"   by Registry.dest Registry.user Registry.registry_path Registry.registry_value_data Registry.registry_key_name   | `drop_dm_object_name(Registry)`   | `security_content_ctime(lastTime)`  | `security_content_ctime(firstTime)`   | `windows_modify_registry_tamper_protection_filter`'



<li><a href="#">NAME: Windows Modify Registry UpdateServiceUrlAlternate

DESCRIPTION:  The following analytic identifies a suspicious registry modification of Windows auto update configuration.   This technique was being abused by several adversaries, malware authors and also red-teamers to bypass detection or   to be able to compromise the target host with zero day exploit or as an additional defense evasion technique.  RedLine Stealer is one of the malware we've seen that uses this technique to evade detection and add more payload on the target host.  This detection looks for registry modification that specifies an intranet server to host updates from Microsoft Update.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time) as lastTime from datamodel=Endpoint.Registry   where Registry.registry_path="*\\SOFTWARE\\Policies\\Microsoft\\Windows\\WindowsUpdate\\UpdateServiceUrlAlternate"  by Registry.dest Registry.user Registry.registry_path Registry.registry_value_data Registry.registry_key_name   | `drop_dm_object_name(Registry)`   | `security_content_ctime(lastTime)`  | `security_content_ctime(firstTime)`   | `windows_modify_registry_updateserviceurlalternate_filter`'



<li><a href="#">NAME: Windows Modify Registry USeWuServer

DESCRIPTION:  The following analytic identifies a suspicious registry modification of Windows auto update configuration.   This technique was being abused by several adversaries, malware authors and also red-teamers to bypass detection or   to be able to compromise the target host with zero day exploit or as an additional defense evasion technique.  RedLine Stealer is one of the malware we've seen that uses this technique to evade detection and add more payload on the target host.  This detection looks for registry modification that will use "The WUServer value unless this key is set".

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time) as lastTime from datamodel=Endpoint.Registry   where Registry.registry_path="*\\SOFTWARE\\Policies\\Microsoft\\Windows\\WindowsUpdate\\AU\\UseWUServer"  AND Registry.registry_value_data="0x00000001"   by Registry.dest Registry.user Registry.registry_path Registry.registry_value_data Registry.registry_key_name   | `drop_dm_object_name(Registry)`   | `security_content_ctime(lastTime)`  | `security_content_ctime(firstTime)`   | `windows_modify_registry_usewuserver_filter`'



<li><a href="#">NAME: Windows Modify Registry With MD5 Reg Key Name

DESCRIPTION:  This analytic is designed to identify potentially malicious registry modification characterized by MD5-like registry key names.   This technique has been notably observed in NjRAT malware, which employs such registries for fileless storage of keylogs and .DLL plugins.   Detecting this tactic serves as an effective means of identifying possible NjRAT malware instances that create or modify registries as   part of their malicious activities.

SEARCH:  '| tstats `security_content_summariesonly`  count min(_time) as firstTime max(_time) as lastTime from datamodel=Endpoint.Registry   where  Registry.registry_path = "*\\SOFTWARE\\*" Registry.registry_value_data = "Binary Data"  by Registry.dest Registry.user Registry.registry_path Registry.registry_value_name Registry.registry_value_data Registry.registry_key_name   | `drop_dm_object_name(Registry)`   | eval dropped_reg_path = split(registry_path, "\\")   | eval dropped_reg_path_split_count = mvcount(dropped_reg_path)   | eval validation_result= if(match(registry_value_name,"^[0-9a-fA-F]{32}$"),"md5","nonmd5")  | where validation_result = "md5" AND dropped_reg_path_split_count <= 5  | table dest user registry_path registry_value_name registry_value_data registry_key_name reg_key_name dropped_reg_path_split_count validation_result  | `security_content_ctime(lastTime)`   | `security_content_ctime(firstTime)`   | `windows_modify_registry_with_md5_reg_key_name_filter`'



<li><a href="#">NAME: Windows Modify Registry WuServer

DESCRIPTION:  The following analytic identifies a suspicious registry modification of Windows auto update configuration.   This technique was being abused by several adversaries, malware authors and also red-teamers to bypass detection or   to be able to compromise the target host with zero day exploit or as an additional defense evasion technique.  RedLine Stealer is one of the malware we've seen that uses this technique to evade detection and add more payload on the target host.  This detection looks for registry modification related to the WSUS server used by Automatic Updates and (by default) API callers.   This policy is paired with WUStatusServer; both must be set to the same value in order for them to be valid.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time) as lastTime from datamodel=Endpoint.Registry   where Registry.registry_path="*\\SOFTWARE\\Policies\\Microsoft\\Windows\\WindowsUpdate\\WUServer"  by Registry.dest Registry.user Registry.registry_path Registry.registry_value_data Registry.registry_key_name   | `drop_dm_object_name(Registry)`   | `security_content_ctime(lastTime)`  | `security_content_ctime(firstTime)`   | `windows_modify_registry_wuserver_filter`'



<li><a href="#">NAME: Windows Modify Registry wuStatusServer

DESCRIPTION:  The following analytic identifies a suspicious registry modification of Windows auto update configuration.   This technique was being abused by several adversaries, malware authors and also red-teamers to bypass detection or   to be able to compromise the target host with zero day exploit or as an additional defense evasion technique.  RedLine Stealer is one of the malware we've seen that uses this technique to evade detection and add more payload on the target host.  This detection looks for registry modification related to the server to which reporting information will be sent for client computers   that use the WSUS server configured by the WUServer key. This policy is paired with WUServer; both must be set to the same value in order for them to be valid.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time) as lastTime from datamodel=Endpoint.Registry   where Registry.registry_path="*\\SOFTWARE\\Policies\\Microsoft\\Windows\\WindowsUpdate\\WUStatusServer"  by Registry.dest Registry.user Registry.registry_path Registry.registry_value_data Registry.registry_key_name   | `drop_dm_object_name(Registry)`   | `security_content_ctime(lastTime)`  | `security_content_ctime(firstTime)`   | `windows_modify_registry_wustatusserver_filter`'



<li><a href="#">NAME: Windows Modify Show Compress Color And Info Tip Registry

DESCRIPTION:  This analytic is to look for suspicious registry modification related  to file compression color and information tips. This IOC was seen in hermetic wiper  where it has a thread that will create this registry entry to change the color of  compressed or encrypted files in NTFS file system as well as the pop up information  tips. This is a good indicator that a process tries to modified one of the registry  GlobalFolderOptions related to file compression attribution in terms of color in  NTFS file system.

SEARCH:  '| tstats `security_content_summariesonly` count FROM datamodel=Endpoint.Registry  WHERE (Registry.registry_path = "*\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Advanced*"  AND Registry.registry_value_name  IN("ShowCompColor", "ShowInfoTip")) BY _time span=1h Registry.dest Registry.user  Registry.registry_path Registry.registry_key_name Registry.registry_value_name Registry.registry_value_data  Registry.process_guid | `drop_dm_object_name(Registry)` | where isnotnull(registry_value_data)  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `windows_modify_show_compress_color_and_info_tip_registry_filter`'



<li><a href="#">NAME: Windows Modify System Firewall with Notable Process Path

DESCRIPTION:  The following analytic detects a potential suspicious modification of firewall  rule allowing to execute specific application in public and suspicious windows process file path. This technique was identified when  an adversary and red teams to bypassed firewall file execution restriction in a  targetted host. Take note that this event or command can run by administrator during  testing or allowing legitimate tool or application.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time) as lastTime from datamodel=Endpoint.Processes   where Processes.process = "*firewall*" Processes.process = "*allow*" Processes.process = "*add*" Processes.process = "*ENABLE*"   Processes.process IN ("*\\windows\\fonts\\*", "*\\windows\\temp\\*", "*\\users\\public\\*", "*\\windows\\debug\\*", "*\\Users\\Administrator\\Music\\*", "*\\Windows\\servicing\\*", "*\\Users\\Default\\*","*Recycle.bin*", "*\\Windows\\Media\\*", "\\Windows\\repair\\*", "*\\temp\\*", "*\\PerfLogs\\*")  by Processes.dest Processes.user Processes.parent_process_name Processes.parent_process Processes.process_name Processes.process Processes.process_id Processes.parent_process_id   | `drop_dm_object_name(Processes)`   | `security_content_ctime(firstTime)`   | `security_content_ctime(lastTime)`   | `windows_modify_system_firewall_with_notable_process_path_filter`'



<li><a href="#">NAME: Windows MOF Event Triggered Execution via WMI

DESCRIPTION:  The following anaytic identifies MOFComp.exe loading a MOF file. The  Managed Object Format (MOF) compiler parses a file containing MOF statements and  adds the classes and class instances defined in the file to the WMI repository.  Typically, MOFComp.exe does not reach out to the public internet or load a MOF file  from User Profile paths. A filter and consumer is typically registered in WMI. Review  parallel processes and query WMI subscriptions to gather artifacts. The default  path of mofcomp.exe is C:\Windows\System32\wbem.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where (Processes.parent_process_name  IN ("cmd.exe", "powershell.exe") Processes.process_name=mofcomp.exe) OR (Processes.process_name=mofcomp.exe  Processes.process IN ("*\\AppData\\Local\\*","*\\Users\\Public\\*", "*\\WINDOWS\\Temp\\*"))  by Processes.dest Processes.user Processes.parent_process_name Processes.process_name  Processes.process Processes.process_id Processes.parent_process_id | `drop_dm_object_name(Processes)`  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `windows_mof_event_triggered_execution_via_wmi_filter`'



<li><a href="#">NAME: Windows MOVEit Transfer Writing ASPX

DESCRIPTION:  The following analytic detects the creation of new ASPX files in the MOVEit Transfer application's "wwwroot" directory. This activity is indicative of the recent critical vulnerability found in MOVEit Transfer, where threat actors have been observed exploiting a zero-day vulnerability to install a malicious ASPX file (e.g., "human2.aspx") in the wwwroot directory. The injected file could then be used to exfiltrate sensitive data, including user credentials and file metadata. The vulnerability affects the MOVEit Transfer managed file transfer software developed by Progress, a subsidiary of US-based Progress Software Corporation. This analytic requires endpoint data reflecting process and filesystem activity. The identified process must be responsible for the creation of new ASPX or ASHX files in the specified directory.

SEARCH:  '| tstats `security_content_summariesonly` count FROM datamodel=Endpoint.Processes  where Processes.process_name=System  by _time span=1h Processes.process_id Processes.process_name  Processes.dest | `drop_dm_object_name(Processes)` | join process_guid, _time [|  tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime FROM datamodel=Endpoint.Filesystem where Filesystem.file_path IN ("*\\MOVEitTransfer\\wwwroot\\*") Filesystem.file_name  IN("*.aspx", "*.ashx", "*.asp*") OR Filesystem.file_name IN ("human2.aspx","_human2.aspx") by _time span=1h Filesystem.dest Filesystem.file_create_time  Filesystem.file_name Filesystem.file_path | `drop_dm_object_name(Filesystem)` |  fields _time dest file_create_time file_name file_path process_name process_path  process] | dedup file_create_time | table dest file_create_time, file_name, file_path,  process_name | `windows_moveit_transfer_writing_aspx_filter`'



<li><a href="#">NAME: Windows MSExchange Management Mailbox Cmdlet Usage

DESCRIPTION:  The following analytic uses the Exchange Management logs, that are enabled  by default, to identify suspicious Cmdlet usage related to ProxyShell and ProxyNotShell  abuse.

SEARCH:  '`msexchange_management` EventCode=1 Message IN ("*New-MailboxExportRequest*",  "*New-ManagementRoleAssignment*", "*New-MailboxSearch*", "*Get-Recipient*", "*Search-Mailbox*")  | stats count min(_time) as firstTime max(_time) as lastTime by host Message | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | rename host AS dest | `windows_msexchange_management_mailbox_cmdlet_usage_filter`'



<li><a href="#">NAME: Windows Mshta Execution In Registry

DESCRIPTION:  The following analytic identifies the usage of mshta.exe Windows binary  in registry to execute malicious script. This technique was seen in kovter malware  where it create several registry entry which is a encoded javascript and will be  executed by another registry containing mshta and javascript activexobject to execute  the encoded script using wscript.shell. This TTP is a good indication of kovter  malware or other adversaries or threat actors leveraging fileless detection that  survive system reboot.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime FROM datamodel=Endpoint.Registry where Registry.registry_value_data  = "*mshta*" OR Registry.registry_value_data IN ("*javascript:*", "*vbscript:*","*WScript.Shell*")  by Registry.registry_key_name Registry.registry_path Registry.registry_value_data  Registry.action Registry.dest Registry.user| `drop_dm_object_name(Registry)` | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `windows_mshta_execution_in_registry_filter`'



<li><a href="#">NAME: Windows MSIExec DLLRegisterServer

DESCRIPTION:  The following analytic identifies the usage of msiexec.exe using the  /y switch parameter, which grants the ability for msiexec to load DLLRegisterServer.  Upon triage, review parent process and capture any artifacts for further review.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where `process_msiexec` Processes.process  IN ("*/y*", "*-y*") by Processes.dest Processes.user Processes.parent_process_name  Processes.process_name Processes.original_file_name Processes.process Processes.process_id  Processes.parent_process_id | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `windows_msiexec_dllregisterserver_filter`'



<li><a href="#">NAME: Windows MsiExec HideWindow Rundll32 Execution

DESCRIPTION:  The following analytic identifies a msiexec.exe process with hidewindow rundll32 process commandline.    One such tactic involves utilizing system processes like "msiexec," "hidewindow," and "rundll32" through command-line execution.   By leveraging these legitimate processes, QakBot masks its malicious operations, hiding behind seemingly normal system activities.   This clandestine approach allows the trojan to carry out unauthorized tasks discreetly, such as downloading additional payloads,   executing malicious code, or establishing communication with remote servers. This obfuscation through trusted system processes   enables QakBot to operate stealthily, evading detection by security mechanisms and perpetuating its harmful actions without raising suspicion.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.parent_process_name = msiexec.exe  Processes.process = "* /HideWindow *" Processes.process = "* rundll32*"  by Processes.dest Processes.user Processes.parent_process_name Processes.parent_process Processes.process_name Processes.process Processes.process_id Processes.parent_process_id  | `drop_dm_object_name(Processes)`   | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)`   | `windows_msiexec_hidewindow_rundll32_execution_filter`'



<li><a href="#">NAME: Windows MSIExec Remote Download

DESCRIPTION:  The following analytic identifies msiexec.exe with http in the command-line.  This procedure will utilize msiexec.exe to download a remote file and load it. During  triage, review parallel processes and capture any artifacts on disk for review.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where `process_msiexec` Processes.process  IN ("*http://*", "*https://*") by Processes.dest Processes.user Processes.parent_process_name  Processes.process_name Processes.original_file_name Processes.process Processes.process_id  Processes.parent_process_id | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `windows_msiexec_remote_download_filter`'



<li><a href="#">NAME: Windows MSIExec Spawn Discovery Command

DESCRIPTION:  The following analytic identifies MSIExec spawning multiple discovery  commands, including spawning Cmd.exe or PowerShell.exe. Typically, child processes  are not common from MSIExec other than MSIExec spawning itself.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.parent_process_name=msiexec.exe  Processes.process_name IN ("powershell.exe","cmd.exe", "nltest.exe","ipconfig.exe","systeminfo.exe")  by Processes.dest Processes.user Processes.parent_process_name Processes.process_name  Processes.original_file_name Processes.process Processes.process_id Processes.parent_process_id  | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `windows_msiexec_spawn_discovery_command_filter`'



<li><a href="#">NAME: Windows MSIExec Spawn WinDBG

DESCRIPTION:  This analytic identifies the unusual behavior of MSIExec spawning WinDBG. It is designed to detect potential malicious activities. The search specifically looks for instances where the parent process name is 'msiexec.exe' and the process name is 'windbg.exe'. During the triage process, it is recommended to review the file path for additional artifacts that may provide further insights into the event.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.parent_process_name=msiexec.exe Processes.process_name=windbg.exe by Processes.dest Processes.user Processes.parent_process_name Processes.parent_process_path Processes.parent_process Processes.process_name Processes.process_path  Processes.process Processes.process_id Processes.parent_process_id  | `drop_dm_object_name(Processes)`   | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)`| `windows_msiexec_spawn_windbg_filter`'



<li><a href="#">NAME: Windows MSIExec Unregister DLLRegisterServer

DESCRIPTION:  The following analytic identifies the usage of msiexec.exe using the  /z switch parameter, which grants the ability for msiexec to unload DLLRegisterServer.  Upon triage, review parent process and capture any artifacts for further review.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where `process_msiexec` Processes.process  IN ("*/z*", "*-z*") by Processes.dest Processes.user Processes.parent_process_name  Processes.process_name Processes.original_file_name Processes.process Processes.process_id  Processes.parent_process_id | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `windows_msiexec_unregister_dllregisterserver_filter`'



<li><a href="#">NAME: Windows MSIExec With Network Connections

DESCRIPTION:  The following analytic identifies MSIExec with any network connection  over port 443 or 80. Typically, MSIExec does not perform network communication to  the internet.

SEARCH:  '| tstats `security_content_summariesonly` count FROM datamodel=Endpoint.Processes  where `process_msiexec` by _time Processes.user Processes.process_id Processes.process_name Processes.dest  Processes.process_path Processes.process Processes.parent_process_name | `drop_dm_object_name(Processes)`  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | join  process_id  [| tstats `security_content_summariesonly` count FROM datamodel=Network_Traffic.All_Traffic  where All_Traffic.dest_port IN ("80","443") by All_Traffic.process_id All_Traffic.dest  All_Traffic.dest_port All_Traffic.dest_ip | `drop_dm_object_name(All_Traffic)` ]  | table _time user dest parent_process_name process_name process_path process process_id  dest_port dest_ip | `windows_msiexec_with_network_connections_filter`'



<li><a href="#">NAME: Windows Multiple Accounts Deleted

DESCRIPTION:  The following analytic flags when more than five unique Windows accounts are deleted within a 10-minute period, identified by Event Code 4726 in the Windows Security Event Log. Using the wineventlog_security dataset, it segments data into 10-minute intervals to monitor account deletions, a pattern that could suggest malicious intent like an attacker erasing traces. Teams should adjust the detection's threshold and timeframe to suit their specific environment.

SEARCH:  ' `wineventlog_security` EventCode=4726 status=success  | bucket span=10m _time  | stats count dc(user) as unique_users values(user) as user by EventCode signature _time src_user SubjectDomainName TargetDomainName Logon_ID  | where unique_users > 5  | `windows_multiple_accounts_deleted_filter`'



<li><a href="#">NAME: Windows Multiple Accounts Disabled

DESCRIPTION:  This Splunk detection focuses on instances where more than five unique Windows accounts are disabled within a 10-minute window, as indicated by Event Code 4725 in the Windows Security Event Log. The query analyzes the wineventlog_security dataset, grouping data into 10-minute segments, and tracks the count and distinct count of TargetUserName, the accounts being disabled. This pattern of disabling multiple accounts rapidly is unusual and could signal internal policy breaches or an external attacker's attempt to disrupt normal operations. Teams are advised to tailor the threshold and timeframe of this detection to their environment's specifics

SEARCH:  ' `wineventlog_security` EventCode=4725 status=success  | bucket span=10m _time  | stats count dc(user) as unique_users values(user) as user by EventCode signature _time src_user SubjectDomainName TargetDomainName Logon_ID  | where unique_users > 5  | `windows_multiple_accounts_disabled_filter`'



<li><a href="#">NAME: Windows Multiple Account Passwords Changed

DESCRIPTION:  This Splunk detection identifies situations where over five unique Windows account passwords are changed within a 10-minute interval, captured by Event Code 4724 in the Windows Security Event Log. The query utilizes the wineventlog_security dataset, organizing data into 10-minute periods to monitor the count and distinct count of TargetUserName, the accounts with altered passwords. Rapid password changes across multiple accounts are atypical and might indicate unauthorized access or an internal actor compromising account security. Teams should calibrate the detection's threshold and timeframe to fit their specific operational context.

SEARCH:  ' `wineventlog_security` EventCode=4724 status=success  | bucket span=10m _time  | stats count dc(user) as unique_users values(user) as user by EventCode signature _time src_user SubjectDomainName TargetDomainName Logon_ID  | where unique_users > 5  | `windows_multiple_account_passwords_changed_filter`'



<li><a href="#">NAME: Windows Multi hop Proxy TOR Website Query

DESCRIPTION:  The following analytic identifies a dns query to a known TOR proxy website.  This technique was seen in several adversaries, threat actors and malware like AgentTesla  to To disguise the source of its malicious traffic. adversaries may chain together  multiple proxies. This Anomaly detection might be a good pivot for a process trying  to download or use TOR proxies in a compromised host machine.

SEARCH:  '`sysmon` EventCode=22 QueryName IN ("*.torproject.org", "www.theonionrouter.com")  | stats count min(_time) as firstTime max(_time) as lastTime by Image QueryName  QueryStatus ProcessId  Computer | rename Computer as dest | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `windows_multi_hop_proxy_tor_website_query_filter`'



<li><a href="#">NAME: Windows Ngrok Reverse Proxy Usage

DESCRIPTION:  The following analytic identifies the use of ngrok.exe being utilized  on the Windows operating system. Unfortunately, there is no original file name for  Ngrok, so it may be worth an additional hunt to identify any command-line arguments.  The sign of someone using Ngrok is not malicious, however, more recently it has  become an adversary tool.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.process_name=ngrok.exe  Processes.process IN ("*start*", "*--config*","*http*","*authtoken*", "*http*",  "*tcp*") by Processes.dest Processes.user Processes.parent_process_name Processes.process_name  Processes.original_file_name Processes.process Processes.process_id Processes.parent_process_id  | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`|  `windows_ngrok_reverse_proxy_usage_filter`'



<li><a href="#">NAME: Windows NirSoft AdvancedRun

DESCRIPTION:  The following analytic identifies the use of AdvancedRun.exe. AdvancedRun.exe  has similar capabilities as other remote programs like psexec. AdvancedRun may also  ingest a configuration file with all settings defined and perform its activity.  The analytic is written in a way to identify a renamed binary and also the common  command-line arguments.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where (Processes.process_name=advancedrun.exe  OR Processes.original_file_name=advancedrun.exe) Processes.process IN ("*EXEFilename*","*/cfg*","*RunAs*",  "*WindowState*") by Processes.dest Processes.user Processes.parent_process_name  Processes.process_name Processes.process Processes.original_file_name Processes.process_id  Processes.parent_process_id | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)`|  `security_content_ctime(lastTime)` | `windows_nirsoft_advancedrun_filter`'



<li><a href="#">NAME: Windows NirSoft Utilities

DESCRIPTION:  The following hunting analytic assists with identifying the proces execution  of commonly used utilities from NirSoft. Potentially not adversary behavior, but  worth identifying to know if the software is present and being used.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime FROM datamodel=Endpoint.Processes by Processes.dest Processes.user Processes.parent_process_name  Processes.process_name Processes.process Processes.original_file_name Processes.process_path  Processes.process_id Processes.parent_process_id | `drop_dm_object_name("Processes")`  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `is_nirsoft_software`  | `windows_nirsoft_utilities_filter`'



<li><a href="#">NAME: Windows Non Discord App Access Discord LevelDB

DESCRIPTION:  The following analytic detects suspicious file access within the Discord LevelDB database.   This database contains critical data such as user profiles, messages, guilds, channels, settings, and cached information.   Access to this data poses a risk of Discord credential theft or unauthorized access to sensitive information on the   compromised system. Detecting such anomalies can serve as an effective pivot to identify non-Discord applications   accessing this database, potentially indicating the presence of malware or trojan stealers aimed at data theft.

SEARCH:  '`wineventlog_security` EventCode=4663 object_file_path IN ("*\\discord\\Local Storage\\leveldb*")   AND process_name != *\\discord.exe AND NOT (process_path IN ("*:\\Windows\\System32\\*", "*:\\Windows\\SysWow64\\*", "*:\\Program Files*", "*:\\Windows\\*"))  | stats count min(_time) as firstTime max(_time) as lastTime by object_file_name object_file_path process_name process_path  process_id EventCode dest   | `security_content_ctime(firstTime)`   | `security_content_ctime(lastTime)`   | `windows_non_discord_app_access_discord_leveldb_filter`'



<li><a href="#">NAME: Windows Non-System Account Targeting Lsass

DESCRIPTION:  The following analytic identifies non SYSTEM accounts requesting access  to lsass.exe. This behavior may be related to credential dumping or applications  requiring access to credentials. Triaging this event will require understanding  the GrantedAccess from the SourceImage. In addition, whether the account is privileged  or not. Review the process requesting permissions and review parallel processes.

SEARCH:  '`sysmon` EventCode=10 TargetImage=*lsass.exe NOT (SourceUser="NT AUTHORITY\\*")  | stats count min(_time) as firstTime max(_time) as lastTime by dest, parent_process_name,  parent_process_path ,parent_process_id, TargetImage, GrantedAccess, SourceUser,  TargetUser | rename TargetUser as user | `security_content_ctime(firstTime)`| `security_content_ctime(lastTime)`  | `windows_non_system_account_targeting_lsass_filter`'



<li><a href="#">NAME: Windows Odbcconf Hunting

DESCRIPTION:  The following analytic identifies Odbcconf.exe running in the environment  to assist with identifying tuning higher fidelity analytics related to Odbcconf.exe.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.process_name=odbcconf.exe  by Processes.dest Processes.user Processes.parent_process_name Processes.process_name  Processes.process Processes.process_id Processes.parent_process_id | `drop_dm_object_name(Processes)`  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `windows_odbcconf_hunting_filter`'



<li><a href="#">NAME: Windows Odbcconf Load DLL

DESCRIPTION:  The following analytic identifies odbcconf.exe, Windows Open Database  Connectivity utility, utilizing the action function of regsvr to load a DLL. An  example will look like - odbcconf.exe /A { REGSVR T1218-2.dll }. During triage,  review parent process, parallel procesess and file modifications.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.process_name=odbcconf.exe  Processes.process IN ("*/a *",  "*-a*") Processes.process="*regsvr*"  by Processes.dest  Processes.user Processes.parent_process_name Processes.process_name Processes.process  Processes.process_id Processes.parent_process_id | `drop_dm_object_name(Processes)`  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `windows_odbcconf_load_dll_filter`'



<li><a href="#">NAME: Windows Odbcconf Load Response File

DESCRIPTION:  The following analytic identifies the odbcconf.exe, Windows Open Database  Connectivity utility, loading up a resource file. The file extension is arbitrary  and may be named anything. The resource file itself may have different commands  supported by Odbcconf to load up a DLL (REGSVR) on disk or additional commands.  During triage, review file modifications and parallel processes.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.process_name=odbcconf.exe  Processes.process IN ("*-f *","*/f *") Processes.process="*.rsp*"  by Processes.dest  Processes.user Processes.parent_process_name Processes.process_name Processes.process  Processes.process_id Processes.parent_process_id | `drop_dm_object_name(Processes)`  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `windows_odbcconf_load_response_file_filter`'



<li><a href="#">NAME: Windows Office Product Spawning MSDT

DESCRIPTION:  The following analytic identifies a Microsoft Office product spawning  the Windows msdt.exe process. MSDT is a Diagnostics Troubleshooting Wizard native  to Windows. This behavior is related to a recently identified sample utilizing protocol  handlers to evade preventative controls, including if macros are disabled in the  document. During triage, review file modifications for html. In addition, parallel  processes including PowerShell and CertUtil.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.parent_process_name  IN ("winword.exe","excel.exe","powerpnt.exe","outlook.exe","mspub.exe","visio.exe","onenote.exe","onenotem.exe","onenoteviewer.exe","onenoteim.exe","msaccess.exe")  Processes.process_name=msdt.exe by Processes.dest Processes.user Processes.parent_process_name Processes.parent_process  Processes.process_name Processes.original_file_name Processes.process Processes.process_id  Processes.parent_process_id | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)`|  `security_content_ctime(lastTime)` | `windows_office_product_spawning_msdt_filter`'



<li><a href="#">NAME: Windows PaperCut NG Spawn Shell

DESCRIPTION:  The following analytic is designed to detect instances where the PaperCut  NG application (pc-app.exe) spawns a Windows shell, specifically cmd.exe or PowerShell.  This behavior may indicate potential malicious activity, such as an attacker attempting  to gain unauthorized access or execute harmful commands on the affected system.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.parent_process_name=pc-app.exe  `process_cmd` OR `process_powershell` OR Processes.process_name=java.exe by Processes.dest  Processes.user Processes.parent_process_name Processes.process_name Processes.original_file_name  Processes.process Processes.process_id Processes.parent_process_id | `drop_dm_object_name(Processes)`  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `windows_papercut_ng_spawn_shell_filter`'



<li><a href="#">NAME: Windows Parent PID Spoofing with Explorer

DESCRIPTION:  The following analytic identifies a suspicious explorer.exe process that has "/root" process commandline.   The presence of this parameter is considered a significant indicator as it could indicate attempts at spoofing the parent process   by a specific program or malware. By spoofing the parent process, the malicious entity aims to circumvent detection mechanisms and   operate undetected within the system.  This technique of manipulating the command-line parameter (/root) of explorer.exe is a form of masquerading utilized by certain malware   or suspicious processes. The objective is to obscure the true nature of the activity by imitating a legitimate system process. By doing so,   it attempts to evade scrutiny and evade detection by security measures.

SEARCH:  '| tstats `security_content_summariesonly` min(_time) as firstTime max(_time) as lastTime from datamodel=Endpoint.Processes   where Processes.process="*explorer.exe*" Processes.process="*/root,*"   by Processes.dest Processes.user Processes.parent_process_name Processes.parent_process Processes.process_name   Processes.original_file_name Processes.process Processes.process_id Processes.parent_process_id  | `drop_dm_object_name(Processes)`   | `security_content_ctime(firstTime)`   | `security_content_ctime(lastTime)`   | `windows_parent_pid_spoofing_with_explorer_filter`'



<li><a href="#">NAME: Windows Password Managers Discovery

DESCRIPTION:  The following analytic identifies a process command line that retrieves  information related to password manager software. This technique was seen in several  post exploitation tools like winpeas that are being used by Ransomware Prestige  to gather this type of information. Password Managers applications are designed  to store user credentials, normally in an encrypted database. Credentials are typically  accessible after a user provides a master password that unlocks the database. After  the database is unlocked, these credentials may be copied to memory. These databases  can be stored as files on disk. Due to this password manager software designed adversaries  may find or look for keywords related to the Password Manager databases that can  be stolen or extracted for further attacks.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.process = "*dir *"  OR  Processes.process = "*findstr*" AND Processes.process IN ( "*.kdbx*", "*credential*",  "*key3.db*","*pass*", "*cred*", "*key4.db*", "*accessTokens*", "*access_tokens*",  "*.htpasswd*", "*Ntds.dit*") by Processes.process_name Processes.original_file_name  Processes.process Processes.process_id Processes.process_guid Processes.parent_process_name  Processes.parent_process Processes.parent_process_guid Processes.dest Processes.user  | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `windows_password_managers_discovery_filter`'



<li><a href="#">NAME: Windows Phishing PDF File Executes URL Link

DESCRIPTION:  This analytic is developed to detect suspicious pdf viewer processes  that have a browser application child processes. This event was seen in a pdf spear  phishing attachment containing a malicious URL link to download the actual payload.  When a user clicks the malicious link the pdf viewer application will execute a  process of the host default browser to connect to the malicious site. This anomaly  detection can be a good indicator that a possible pdf file has a link executed by  a user. The pdf viewer and browser list in this detection is still in progress,  add the common browser and pdf viewer you use in opening pdf in your network.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.parent_process_name  IN  ("AcroRd32.exe", "FoxitPDFReader.exe") Processes.process_name IN ("firefox.exe",  "chrome.exe", "iexplore.exe") by Processes.user Processes.parent_process_name Processes.process_name  Processes.parent_process  Processes.process Processes.process_id Processes.dest |`drop_dm_object_name(Processes)`  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `windows_phishing_pdf_file_executes_url_link_filter`'



<li><a href="#">NAME: Windows Phishing Recent ISO Exec Registry

DESCRIPTION:  The following hunting analytic identifies registry artifacts when an  ISO container is opened, clicked or mounted on the Windows operating system. As  Microsoft makes changes to macro based document execution, adversaries have begun  to utilize container based initial access based phishing campaigns to evade preventative  controls. Once the ISO is clicked or mounted it will create a registry artifact  related to this event as a recent application executed or opened.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime FROM datamodel=Endpoint.Registry where Registry.registry_key_name= "*\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\RecentDocs\\.iso"  OR Registry.registry_key_name= "*\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\RecentDocs\\.img"  by Registry.registry_key_name Registry.user Registry.registry_path Registry.registry_value_data  Registry.action Registry.dest | `drop_dm_object_name(Registry)` | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `windows_phishing_recent_iso_exec_registry_filter`'



<li><a href="#">NAME: Windows Possible Credential Dumping

DESCRIPTION:  'The following analytic is an enhanced version of two previous analytics  that identifies common GrantedAccess permission requests and CallTrace DLLs in order  to detect credential dumping. \  GrantedAccess is the requested permissions by the SourceImage into the TargetImage.  \  CallTrace Stack trace of where open process is called. Included is the DLL and the  relative virtual address of the functions in the call stack right before the open  process call. \  dbgcore.dll or dbghelp.dll  are two core Windows debug DLLs that have minidump functions  which provide a way for applications to produce crashdump files that contain a useful  subset of the entire process context. \  The idea behind using ntdll.dll is to blend in by using native api of ntdll.dll.  For example in sekurlsa module there are many ntdll exported api, like RtlCopyMemory,  used to execute this module which is related to lsass dumping.'

SEARCH:  '`sysmon` EventCode=10 TargetImage=*\\lsass.exe granted_access IN ("0x01000",  "0x1010", "0x1038", "0x40", "0x1400", "0x1fffff", "0x1410", "0x143a", "0x1438",  "0x1000") CallTrace IN ("*dbgcore.dll*", "*dbghelp.dll*", "*ntdll.dll*", "*kernelbase.dll*",  "*kernel32.dll*") NOT SourceUser IN ("NT AUTHORITY\\SYSTEM", "NT AUTHORITY\\NETWORK  SERVICE") | stats count min(_time) as firstTime max(_time) as lastTime by dest,  SourceImage, GrantedAccess, TargetImage, SourceProcessId, SourceUser, TargetUser  | rename SourceUser as user | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `windows_possible_credential_dumping_filter`'



<li><a href="#">NAME: Windows Post Exploitation Risk Behavior

DESCRIPTION:  The following correlation identifies a four or more number of distinct analytics associated with the Windows Post-Exploitation analytic story, which enables the identification of potentially suspicious behavior. Windows Post-Exploitation refers to the phase that occurs after an attacker successfully compromises a Windows system. During this stage, attackers strive to maintain persistence, gather sensitive information, escalate privileges, and exploit the compromised environment further. Timely detection of post-exploitation activities is crucial for prompt response and effective mitigation. Common post-exploitation detections encompass identifying suspicious processes or services running on the system, detecting unusual network connections or traffic patterns, identifying modifications to system files or registry entries, monitoring abnormal user account activities, and flagging unauthorized privilege escalations. Ensuring the detection of post-exploitation activities is essential to proactively prevent further compromise, minimize damage, and restore the security of the Windows environment.

SEARCH:  '| tstats `security_content_summariesonly` min(_time) as firstTime max(_time) as lastTime   sum(All_Risk.calculated_risk_score) as risk_score,   count(All_Risk.calculated_risk_score) as risk_event_count,   values(All_Risk.annotations.mitre_attack.mitre_tactic_id) as annotations.mitre_attack.mitre_tactic_id,  dc(All_Risk.annotations.mitre_attack.mitre_tactic_id) as mitre_tactic_id_count,   values(All_Risk.annotations.mitre_attack.mitre_technique_id) as annotations.mitre_attack.mitre_technique_id,   dc(All_Risk.annotations.mitre_attack.mitre_technique_id) as mitre_technique_id_count,   values(All_Risk.tag) as tag, values(source) as source,   dc(source) as source_count from datamodel=Risk.All_Risk   where All_Risk.analyticstories IN ("*Windows Post-Exploitation*")   by All_Risk.risk_object All_Risk.risk_object_type All_Risk.annotations.mitre_attack.mitre_tactic   | `drop_dm_object_name(All_Risk)`   | `security_content_ctime(firstTime)`   | `security_content_ctime(lastTime)`   | where source_count >= 4   | `windows_post_exploitation_risk_behavior_filter`'



<li><a href="#">NAME: Windows PowerShell Add Module to Global Assembly Cache

DESCRIPTION:  The following PowerShell Script Block analytic identifies the native  ability to add a DLL to the Windows Global Assembly Cache. Each computer where the  Common Language Runtime is installed has a machine-wide code cache called the Global  Assembly Cache. The Global Assembly Cache stores assemblies specifically designated  to be shared by several applications on the computer. By adding a DLL to the GAC,  this allows an adversary to call it via any other means across the operating systems.  This is native and built into Windows. Per the Microsoft blog, the more high fidelity  method may be to look for W3WP.exe spawning PowerShell that includes the same CommandLine  as identified in this analytic.

SEARCH:  '`powershell` EventCode=4104 ScriptBlockText IN("*system.enterpriseservices.internal.publish*")  | stats count min(_time) as firstTime max(_time) as lastTime by EventCode ScriptBlockText  Computer user_id | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `windows_powershell_add_module_to_global_assembly_cache_filter`'



<li><a href="#">NAME: Windows Powershell Cryptography Namespace

DESCRIPTION:  The following analytic identifies suspicious PowerShell script execution  via EventCode 4104 that is processing cryptography namespace library. This technique  was seen in several powershell malware, loader, downloader and stager that will  decrypt or decode the next malicious stager or the actual payload. This Anomaly  detection can be a good indicator that a powershell process to decrypt code. We  recommend to further check the parent_process_name, the file or data it tries to  decrypt, network connection and user who execute the script.

SEARCH:  '`powershell` EventCode=4104 ScriptBlockText = "*System.Security.Cryptography*"  AND NOT(ScriptBlockText IN ("*SHA*", "*MD5*", "*DeriveBytes*")) | stats count min(_time)  as firstTime max(_time) as lastTime by EventCode ScriptBlockText Computer UserID | rename Computer as dest | rename UserID as user  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `windows_powershell_cryptography_namespace_filter`'



<li><a href="#">NAME: Windows PowerShell Disable HTTP Logging

DESCRIPTION:  The following analtyic identifies the use of get-WebConfigurationProperty  and Set-ItemProperty attempting to disable HTTP logging on windows via PowerShell.  Adversaries may perform this action to disable HTTP logging to cover tracks and  delete logs on disk.

SEARCH:  '`powershell` EventCode=4104 ScriptBlockText IN("*get-WebConfigurationProperty*","*Set-ItemProperty*")  AND ScriptBlockText IN ("*httpLogging*","*Logfile.enabled*") AND ScriptBlockText  IN ("*dontLog*", "*false*")   | stats count min(_time) as firstTime max(_time) as  lastTime by EventCode ScriptBlockText Computer user_id | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `windows_powershell_disable_http_logging_filter`'



<li><a href="#">NAME: Windows PowerShell Export Certificate

DESCRIPTION:  The following analytic identifies the PowerShell Cmdlet export-certificate  utilizing Script Block Logging. This particular behavior is related to an adversary  attempting to steal certificates local to the Windows endpoint within the Certificate  Store.

SEARCH:  '`powershell` EventCode=4104 ScriptBlockText IN ("*export-certificate*") |  rename Computer as dest  | stats count min(_time) as firstTime max(_time) as lastTime  by EventCode ScriptBlockText dest user_id | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `windows_powershell_export_certificate_filter`'



<li><a href="#">NAME: Windows PowerShell Export PfxCertificate

DESCRIPTION:  The following analytic identifies the PowerShell Cmdlet export-pfxcertificate  utilizing Script Block Logging. This particular behavior is related to an adversary  attempting to steal certificates local to the Windows endpoint within the Certificate  Store.

SEARCH:  '`powershell` EventCode=4104 ScriptBlockText IN ("*export-pfxcertificate*")  | rename Computer as dest  | stats count min(_time) as firstTime max(_time) as lastTime  by EventCode ScriptBlockText dest user_id | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `windows_powershell_export_pfxcertificate_filter`'



<li><a href="#">NAME: Windows PowerShell Get CIMInstance Remote Computer

DESCRIPTION:  This analytic identifies the use of Get-CimInstance cmdlet with the -ComputerName parameter, which indicates that the cmdlet is being used to retrieve information from a remote computer. This can be useful for detecting instances of remote access, such as when an attacker uses PowerShell to connect to a remote system and gather information. By monitoring for this cmdlet with the -ComputerName parameter, security analysts can identify potential malicious activity on remote systems and take appropriate action to mitigate any threats.

SEARCH:  '`powershell` EventCode=4104 ScriptBlockText="*get-ciminstance*" AND ScriptBlockText="*computername*"  | stats count min(_time) as firstTime max(_time) as lastTime by EventCode ScriptBlockText Computer user_id   | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `windows_powershell_get_ciminstance_remote_computer_filter`'



<li><a href="#">NAME: Windows PowerShell IIS Components WebGlobalModule Usage

DESCRIPTION:  The following analytic identifies the usage of PowerShell Cmdlets - New-WebGlobalModule,  Enable-WebGlobalModule and Set-WebGlobalModule being utilized to create (new), enable  (start) or modify a current IIS Module. These commands are equivalent to AppCmd.exe  parameters. Adversaries may utilize these cmdlets as they are lesser known and perform  the same activity as AppCmd.

SEARCH:  '`powershell` EventCode=4104 ScriptBlockText IN("*New-WebGlobalModule*","*Enable-WebGlobalModule*","*Set-WebGlobalModule*")  | stats count min(_time) as firstTime max(_time) as lastTime by EventCode ScriptBlockText  Computer user_id | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  |  `windows_powershell_iis_components_webglobalmodule_usage_filter`'



<li><a href="#">NAME: Windows Powershell Import Applocker Policy

DESCRIPTION:  The following analytic is to identify the imports of Windows PowerShell  Applocker commandlets. This technique was seen in Azorult malware where it drops  an xml Applocker policy that will deny several AV product and then loaded using  PowerShell Applocker commandlet.

SEARCH:  '`powershell` EventCode=4104 ScriptBlockText="*Import-Module Applocker*" ScriptBlockText="*Set-AppLockerPolicy  *" ScriptBlockText="* -XMLPolicy *" | stats count min(_time) as firstTime max(_time)  as lastTime by EventCode ScriptBlockText Computer UserID | rename Computer as dest | rename UserID as user | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `windows_powershell_import_applocker_policy_filter`'



<li><a href="#">NAME: Windows Powershell RemoteSigned File

DESCRIPTION:  This analytic identifies the use of "remotesigned" execution policy for  a file. This security setting determines whether PowerShell scripts can be executed  on a computer. When the execution policy is set to "remotesigned," it allows locally  created scripts to run without any restrictions, but scripts downloaded from the  internet must have a digital signature from a trusted publisher.

SEARCH:  '| tstats `security_content_summariesonly` min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where `process_powershell` Processes.process="*  remotesigned *" Processes.process="* -File *" by Processes.dest Processes.user Processes.parent_process  Processes.process_name Processes.original_file_name Processes.process Processes.process_id  Processes.parent_process_id | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `windows_powershell_remotesigned_file_filter`'



<li><a href="#">NAME: Windows PowerShell ScheduleTask

DESCRIPTION:  "The following analytic detects potential malicious activities related to PowerShell's task scheduling cmdlets. It looks for anomalies in PowerShell logs, specifically EventCode 4104, associated with script block logging. The analytic flags unusual or suspicious use patterns of key task-related cmdlets such as 'New-ScheduledTask', 'Set-ScheduledTask', and others, which are often used by attackers for persistence and remote execution of malicious code. \If a true positive is found, it suggests an possible attacker is attempting to persist within the environment or potentially deliver additional malicious payloads, leading to data theft, ransomware, or other damaging outcomes. To implement this analytic, PowerShell Script Block Logging needs to be enabled on some or all endpoints. Analysts should be aware of benign administrative tasks that can trigger alerts and tune the analytic accordingly to reduce false positives. \Upon triage, review the PowerShell logs for any unusual or unexpected cmdlet usage, IP addresses, user accounts, or timestamps. If these factors align with known malicious behavior patterns, immediate mitigation steps, such as isolation of the affected systems, user account changes, and relevant threat hunting activities, should be initiated. This proactive analysis significantly enhances an organization's capacity to swiftly respond to, and potentially prevent, the execution of advanced persistent threats in their network."

SEARCH:  '`powershell` EventCode=4104 ScriptBlockText IN ("*New-ScheduledTask*", "*New-ScheduledTaskAction*", "*New-ScheduledTaskSettingsSet*", "*New-ScheduledTaskTrigger*", "*Register-ClusteredScheduledTask*", "*Register-ScheduledTask*", "*Set-ClusteredScheduledTask*", "*Set-ScheduledTask*", "*Start-ScheduledTask*", "*Enable-ScheduledTask*")  | stats count min(_time) as firstTime max(_time) as lastTime by EventCode ScriptBlockText Computer user_id  | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)`  | `windows_powershell_scheduletask_filter`'



<li><a href="#">NAME: Windows PowerShell WMI Win32 ScheduledJob

DESCRIPTION:  The following analytic detects the use of the PowerShell script block logging mechanism to detect the use of the Win32_ScheduledJob WMI class. This class allows the creation and management of scheduled tasks on Windows systems. However, due to security concerns, the class has been disabled by default in Windows systems, and its use must be explicitly enabled by modifying the registry. As a result, the detection of the use of this class may indicate malicious activity, especially if the class was enabled on the system by the attacker. Therefore, it is recommended to monitor the use of Win32_ScheduledJob through PowerShell script block logging and to investigate any suspicious activity. 

SEARCH:  '`powershell` EventCode=4104 ScriptBlockText="*win32_scheduledjob*"  | stats count min(_time) as firstTime max(_time) as lastTime by EventCode ScriptBlockText Computer UserID | rename Computer as dest | rename UserID as user  | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `windows_powershell_wmi_win32_scheduledjob_filter`'



<li><a href="#">NAME: Windows PowerSploit GPP Discovery

DESCRIPTION:  The following analytic identifies the use of the Get-GPPPassword PowerShell commandlet employed to search for unsecured credentials Group Policy Preferences (GPP).  GPP are tools that allow administrators to create domain policies with embedded credentials. These policies allow administrators to set local accounts.  These group policies are stored in SYSVOL on a domain controller. This means that any domain user can view the SYSVOL share and decrypt the password (using the AES key that has been made public).  While Microsoft released a patch that impedes Administrators to create unsecure credentials, existing Group Policy Preferences files with passwords are not removed from SYSVOL.

SEARCH:  ' `powershell` EventCode=4104  (ScriptBlockText=Get-GPPPassword OR ScriptBlockText=Get-CachedGPPPassword)  | stats count min(_time) as firstTime max(_time) as lastTime by Opcode Computer UserID EventCode ScriptBlockText   | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `windows_powersploit_gpp_discovery_filter`'



<li><a href="#">NAME: Windows PowerView AD Access Control List Enumeration

DESCRIPTION:  The following analytic leverages Event ID 4104 to identify the execution of the PowerView powershell commandlets `Get-ObjectAcl` or `Get-DomainObjectAcl`. This commandlets  are used to enumerate Access Control List permissions given to Active Directory objects. In an active directory environment, an object is an entity that represents an available resource within   the organizations network, such as domain controllers, users, groups, computers, shares, etc.  Maintaining Active Directory permissions is complicated and hard to manage, especially in complex   and large environments with multiple domains. Weak permissions may allow adversaries and red teamers to escalate their privileges in Active Directory. PowerView is a common tool leveraged  by attackers to identify and exploit configuration weaknesses.

SEARCH:  ' `powershell` EventCode=4104  (ScriptBlockText=*get-objectacl* OR ScriptBlockText=*Get-DomainObjectAcl* )  | stats count min(_time) as firstTime max(_time) as lastTime by Opcode Computer UserID EventCode ScriptBlockText  | `security_content_ctime(firstTime)`   | `security_content_ctime(lastTime)`  | `windows_powerview_ad_access_control_list_enumeration_filter`'



<li><a href="#">NAME: Windows PowerView Constrained Delegation Discovery

DESCRIPTION:  The following analytic utilizes PowerShell Script Block Logging (EventCode=4104)  to identify commandlets used by the PowerView hacking tool leveraged to discover  Windows endpoints with Kerberos Constrained Delegation. Red Teams and adversaries  alike may leverage use this technique for situational awareness and Active Directory  Discovery.

SEARCH:  '`powershell` EventCode=4104 (Message = "*Get-DomainComputer*" OR Message  = "*Get-NetComputer*") AND (Message = "*-TrustedToAuth*") | stats count min(_time)  as firstTime max(_time) as lastTime by EventCode Message ComputerName User | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `windows_powerview_constrained_delegation_discovery_filter`'



<li><a href="#">NAME: Windows PowerView Kerberos Service Ticket Request

DESCRIPTION:  The following analytic utilizes PowerShell Script Block Logging (EventCode=4104)  to identify the execution of the `Get-DomainSPNTicket` commandlets with specific  parameters. This commandlet is a part of PowerView, a PowerShell tool used to perform  enumeration and discovery on Windows Active Directory networks. As the name suggests,  this commandlet is used to request the kerberos ticket for a specified service principal  name (SPN). Once the ticket is received, it may be cracked using password cracking  tools like hashcat to extract the password of the SPN account. Red Teams and adversaries  alike may leverage PowerView and these commandlets to identify accounts that can  be attacked with the Kerberoasting technique.

SEARCH:  '`powershell` EventCode=4104 ScriptBlockText=*Get-DomainSPNTicket* | stats  count min(_time) as firstTime max(_time) as lastTime by EventCode ScriptBlockText  Computer UserID | rename Computer as dest | rename UserID as user| `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `windows_powerview_kerberos_service_ticket_request_filter`'



<li><a href="#">NAME: Windows PowerView SPN Discovery

DESCRIPTION:  The following analytic utilizes PowerShell Script Block Logging (EventCode=4104)  to identify the execution of the `Get-DomainUser` or `Get-NetUSer` commandlets with  specific parameters. These commandlets are part of PowerView, a PowerShell tool  used to perform enumeration and discovery on Windows Active Directory networks.  As the names suggest, these commandlets are used to identify domain users in a network  and combining them with the `-SPN` parameter allows adversaries to discover domain  accounts associated with a Service Principal Name (SPN). Red Teams and adversaries  alike may leverage PowerView and these commandlets to identify accounts that can  be attacked with the Kerberoasting technique.

SEARCH:  '`powershell` EventCode=4104 (ScriptBlockText =*Get-NetUser* OR ScriptBlockText=*Get-DomainUser*)  ScriptBlockText= *-SPN* | stats count min(_time) as firstTime max(_time) as lastTime  by EventCode ScriptBlockText Computer UserID | rename Computer as dest | rename  UserID as user | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`|  `windows_powerview_spn_discovery_filter`'



<li><a href="#">NAME: Windows PowerView Unconstrained Delegation Discovery

DESCRIPTION:  The following analytic utilizes PowerShell Script Block Logging (EventCode=4104)  to identify commandlets used by the PowerView hacking tool leveraged to discover  Windows endpoints with Kerberos Unconstrained Delegation. Red Teams and adversaries  alike may leverage use this technique for situational awareness and Active Directory  Discovery.

SEARCH:  '`powershell` EventCode=4104 (Message = "*Get-DomainComputer*" OR Message  = "*Get-NetComputer*") AND (Message = "*-Unconstrained*") | stats count min(_time)  as firstTime max(_time) as lastTime by EventCode Message ComputerName User | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `windows_powerview_unconstrained_delegation_discovery_filter`'



<li><a href="#">NAME: Windows Private Keys Discovery

DESCRIPTION:  The following analytic identifies a process command line that retrieves  information related to private keys files. This technique was seen in several post  exploitation tools like winpeas that are being used by Ransomware Prestige to search  for private key certificates on the compromised host for insecurely stored credentials.  This files can be used by adversaries to gain privileges, persistence or remote  service authentication to collect more sensitive information. Some private keys  required password for operation, so in this case adversaries may need to have that  passphrase either via keylogging or brute force attack.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.process = "*dir *"  OR  Processes.process = "*findstr*" AND Processes.process IN ( "*.rdg*", "*.gpg*",  "*.pgp*", "*.p12*", "*.der*", "*.csr*", "*.cer*", "*.ovpn*", "*.key*",  "*.ppk*",  "*.p12*", "*.pem*", "*.pfx*", "*.p7b*", "*.asc*") by Processes.process_name Processes.original_file_name  Processes.process Processes.process_id Processes.process_guid Processes.parent_process_name  Processes.parent_process Processes.parent_process_guid Processes.dest Processes.user  | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `windows_private_keys_discovery_filter`'



<li><a href="#">NAME:  Windows Privilege Escalation Suspicious Process Elevation

DESCRIPTION:  The following analytic detects when any low->high integrity level process running from a user account spawns an elevated (high/system integrity) process in a suspicious location or with system level process integrity. This behavior may indicate when a threat actor has successfully elevated privileges.

SEARCH:  >-  | tstats `security_content_summariesonly` count min(_time) as firstTime from datamodel=Endpoint.Processes where Processes.process_integrity_level IN ("low","medium","high") NOT Processes.user IN ("*SYSTEM","*LOCAL SERVICE","*NETWORK SERVICE","DWM-*","*$") by Processes.dest, Processes.user, Processes.parent_process_guid, Processes.parent_process, Processes.parent_process_name Processes.process_name Processes.process, Processes.process_path, Processes.process_guid,  Processes.process_integrity_level, Processes.process_current_directory | `drop_dm_object_name(Processes)` | eval join_guid = process_guid, integrity_level = CASE(match(process_integrity_level,"low"),1,match(process_integrity_level,"medium"),2,match(process_integrity_level,"high"),3,match(process_integrity_level,"system"),4,true(),0) | rename user as src_user, parent_process* as orig_parent_process*, process* as parent_process* | join max=0 dest join_guid  [| tstats  `security_content_summariesonly` count max(_time) as lastTime from datamodel=Endpoint.Processes where (Processes.process_integrity_level IN ("system") NOT Processes.user IN ("*SYSTEM","*LOCAL SERVICE","*NETWORK SERVICE","DWM-*","*$")) OR (Processes.process_integrity_level IN ("high","system") AND (Processes.parent_process_path IN ("*\\\\*","*\\Users\\*","*\\Temp\\*","*\\ProgramData\\*") OR Processes.process_path IN ("*\\\\*","*\\Users\\*","*\\Temp\\*","*\\ProgramData\\*"))) by Processes.dest,  Processes.user, Processes.parent_process_guid, Processes.process_name, Processes.process, Processes.process_path, Processes.process_integrity_level, Processes.process_current_directory | `drop_dm_object_name(Processes)` | eval elevated_integrity_level = CASE(match(process_integrity_level,"low"),1,match(process_integrity_level,"medium"),2,match(process_integrity_level,"high"),3,match(process_integrity_level,"system"),4,true(),0) | rename parent_process_guid as join_guid ] | where  elevated_integrity_level > integrity_level OR user != elevated_user | fields dest, user, src_user, parent_process_name, parent_process, parent_process_path, parent_process_guid, parent_process_integrity_level, parent_process_current_directory, process_name, process, process_path, process_guid, process_integrity_level, process_current_directory, orig_parent_process_name, orig_parent_process, orig_parent_process_guid, firstTime, lastTime, count  | `security_content_ctime(firstTime)`  |  `security_content_ctime(lastTime)` |  `windows_privilege_escalation_suspicious_process_elevation_filter`



<li><a href="#">NAME:  Windows Privilege Escalation System Process Without System Parent

DESCRIPTION:  The following analytic detects any system integrity level process that was spawned by a process not running as a system account. This behavior is often seen when attackers successfully escalate privileges to SYSTEM from a user controlled process or service.

SEARCH:  >-  `sysmon` EventCode=1 IntegrityLevel="system" ParentUser=* NOT ParentUser IN ("*SYSTEM","*LOCAL SERVICE","*NETWORK SERVICE","*DWM-*","*$","-") | eval src_user = replace(ParentUser,"^[^\\\]+\\\\","") | stats count min(_time) as firstTime max(_time) as lastTime values(process_name) as process_name values(process) as process, values(process_path) as process_path, values(process_current_directory) as process_current_directory values(parent_process) as parent_process by dest, user, src_user,  parent_process_name, parent_process_guid | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `windows_privilege_escalation_system_process_without_system_parent_filter`



<li><a href="#">NAME:  Windows Privilege Escalation User Process Spawn System Process

DESCRIPTION:  The following analytic detects when any process low->high integrity level process spawns a system integrity process from a user controlled location. This behavior is often seen when attackers successfully escalate privileges to SYSTEM from a user controlled process or service.

SEARCH:  >-  | tstats `security_content_summariesonly` count min(_time) as firstTime from datamodel=Endpoint.Processes where Processes.process_integrity_level IN ("low","medium","high") NOT Processes.user IN ("*SYSTEM","*LOCAL SERVICE","*NETWORK SERVICE","DWM-*","*$") AND Processes.process_path IN ("*\\\\*","*\\Users\\*","*\\Temp\\*","*\\ProgramData\\*") by Processes.dest, Processes.user, Processes.parent_process_guid, Processes.parent_process, Processes.parent_process_name Processes.process_name  Processes.process, Processes.process_path, Processes.process_guid, Processes.process_integrity_level, Processes.process_current_directory | `drop_dm_object_name(Processes)` | eval join_guid = process_guid | join max=0 dest join_guid  [| tstats `security_content_summariesonly` count max(_time) as lastTime from datamodel=Endpoint.Processes where Processes.process_integrity_level IN ("system") AND Processes.parent_process_path IN ("*\\\\*","*\\Users\\*","*\\Temp\\*","*\\ProgramData\\*") by  Processes.dest, Processes.user, Processes.parent_process_guid, Processes.process_name, Processes.process, Processes.process_path, Processes.process_integrity_level, Processes.process_current_directory | `drop_dm_object_name(Processes)` | rename parent_process_guid as join_guid, process* as system_process*, user as system_user ] | fields dest, user, parent_process, parent_process_name, parent_process_guid, process, process_name, process_guid, process_integrity_level,process_path,  process_current_directory, system_process_name, system_process, system_process_path, system_process_integrity_level, system_process_current_directory, system_user, firstTime, lastTime, count | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `windows_privilege_escalation_user_process_spawn_system_process_filter`



<li><a href="#">NAME: Windows Processes Killed By Industroyer2 Malware

DESCRIPTION:  The following analytic is to look for known processes killed by industroyer2  malware. This technique was seen in the industroyer2 malware attack that tries to  kill several processes of windows host machines related to the energy facility network.  This anomaly might be a good indicator to check which process kill these processes  or why the process was killed.

SEARCH:  '`sysmon` EventCode=5 process_name IN ("PServiceControl.exe", "PService_PPD.exe")  | stats min(_time) as firstTime max(_time) as lastTime count by process_name process  process_path process_guid process_id EventCode dest user_id | `security_content_ctime(firstTime)`|  `security_content_ctime(lastTime)` | `windows_processes_killed_by_industroyer2_malware_filter`'



<li><a href="#">NAME: Windows Process Commandline Discovery

DESCRIPTION:  The following analytic detects Windows Management Instrumentation Command-line (WMIC) command   used to retrieve information about running processes and specifically fetches the command lines used to launch those processes.  This Hunting detection can be a good indicator for possible suspicious user or process getting list of process with its command line using wmic application which is not a   common practice for a non-technical user.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time) as lastTime from datamodel=Endpoint.Processes   where `process_wmic` Processes.process= "* process *" Processes.process= "* get commandline *" by Processes.dest Processes.user Processes.parent_process Processes.process_name Processes.process Processes.process_id Processes.parent_process_id   | `drop_dm_object_name(Processes)`   | `security_content_ctime(firstTime)`   | `security_content_ctime(lastTime)`   | `windows_process_commandline_discovery_filter`'



<li><a href="#">NAME: Windows Process Injection into Notepad

DESCRIPTION:  The following analytic utilizes Sysmon to identify process injection into Notepad.exe, based on GrantedAccess requests - 0x40 and 0x1fffff. This particular behavior is attributed to the defaults of the SliverC2 framework by BishopFox.   By default, the analytic filters out any SourceImage paths of System32, Syswow64 and program files. Add more as needed, or remove and monitor what is consistently injecting into notepad.exe.   This particular behavior will occur from a source image that is the initial payload dropped. 

SEARCH:  '`sysmon` EventCode=10 TargetImage IN (*\\notepad.exe) NOT (SourceImage IN ("*\\system32\\*","*\\syswow64\\*","*\\Program Files\\*")) GrantedAccess IN ("0x40","0x1fffff") | stats count min(_time) as firstTime max(_time) as lastTime by dest SourceImage TargetImage GrantedAccess CallTrace  | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `windows_process_injection_into_notepad_filter`'



<li><a href="#">NAME: Windows Process Injection In Non-Service SearchIndexer

DESCRIPTION:  The following analytic identifies a non-service searchindexer.exe process.   QakBot, a notorious banking trojan and information stealer, often deploys a process named "searchindexer.exe"   as part of its malicious activities. This legitimate Windows process, "Search Indexer," is manipulated by   QakBot to masquerade and evade detection within the system. The malware uses this deceptive tactic to   camouflage its presence, remaining inconspicuous while performing unauthorized actions like data exfiltration,   keystroke logging, and communication with command and control servers. By adopting the guise of a genuine system process,   the malicious "searchindexer.exe" process helps QakBot evade scrutiny and continue its malevolent operations without arousing suspicion.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.parent_process_name != services.exe Processes.process_name=searchindexer.exe   by Processes.dest Processes.user Processes.parent_process_name Processes.parent_process Processes.process_name Processes.process Processes.process_id Processes.parent_process_id  | `drop_dm_object_name(Processes)`   | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)`   | `windows_process_injection_in_non_service_searchindexer_filter`'



<li><a href="#">NAME: Windows Process Injection Of Wermgr to Known Browser

DESCRIPTION:  This analytic identifies the suspicious Remote Thread execution of wermgr.exe  process to "firefox.exe", "chrome.exe" and other known browsers. This technique  was seen in Qakbot malware that executes its malicious code by injecting its code  in legitimate Windows Operating System processes such as wermgr.exe to steal information  in the compromised host. This TTP detection can be a good pivot to detect wermgr.exe  process injected with qakbot code that tries to remote thread code execution in  known browsers like firefox and edge which is not a common behavior of this wermgr.exe  application.

SEARCH:  '`sysmon` EventCode=8 SourceImage = "*\\wermgr.exe" TargetImage IN ("*\\firefox.exe",  "*\\chrome.exe", "*\\iexplore.exe","*\\microsoftedgecp.exe") | stats count min(_time)  as firstTime max(_time) as lastTime by SourceImage TargetImage SourceProcessGuid  SourceProcessId StartAddress StartFunction TargetProcessGuid TargetProcessId  EventCode  dest | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `windows_process_injection_of_wermgr_to_known_browser_filter`'



<li><a href="#">NAME: Windows Process Injection Remote Thread

DESCRIPTION:  The following analytic identifies a suspicious remote thread execution  in some process being abused by threat actor and malware like qakbot. Qakbot is  one of the malware using this technique to load its malicious dll module or malicious  code in the targeted host. This TTP can be a good pivot to verify what is the behavior  of the targeted Image process after this detection trigger. look for network connection,  child process execution, file access and many more that helps to verify the indication  of malware infection.

SEARCH:  '`sysmon` EventCode=8 TargetImage IN ("*\\Taskmgr.exe", "*\\calc.exe", "*\\notepad.exe",  "*\\rdpclip.exe", "*\\explorer.exe", "*\\wermgr.exe", "*\\ping.exe", "*\\OneDriveSetup.exe",  "*\\dxdiag.exe", "*\\mobsync.exe", "*\\msra.exe", "*\\xwizard.exe","*\\cmd.exe", "*\\powershell.exe") | stats count  min(_time) as firstTime max(_time) as lastTime by  TargetImage TargetProcessId SourceProcessId  EventCode  StartAddress SourceImage dest | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `windows_process_injection_remote_thread_filter`'



<li><a href="#">NAME: Windows Process Injection Wermgr Child Process

DESCRIPTION:  The following analytic identifies a suspicious wermgr.exe parent process  having a child process not related to error, fault or windows werfault event. This  technique was seen in Qakbot malware where it inject its malicious code in wermgr  to evade detections and hide from the analyst to execute its recon and its malicious  behavior. This Anomaly detection can be a good pivot to start investigating a possible  qakbot infection in the network. The Wermgr.exe process is not known to have other  child processes aside from itself or werfault.exe

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.parent_process_name  = "wermgr.exe" AND NOT (Processes.process_name IN ("WerFaultSecure.exe", "wermgr.exe",  "WerFault.exe")) by Processes.dest Processes.user Processes.parent_process_name  Processes.process_name Processes.process Processes.process_id Processes.parent_process_id  Processes.original_file_name | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `windows_process_injection_wermgr_child_process_filter`'



<li><a href="#">NAME: Windows Process Injection With Public Source Path

DESCRIPTION:  The following analytic identifies a process in a non-standard file path  on Windows attempting to create a remote thread into a process. This Windows API,CreateRemoteThread,  is commonly used by adversaries for process injection to evade detections or gain  privilege escalation.

SEARCH:  '`sysmon` EventCode=8 TargetImage = "*.exe" AND NOT(SourceImage IN("C:\\Windows\\*",  "C:\\Program File*", "%systemroot%\\*")) | stats count min(_time) as firstTime max(_time)  as lastTime by SourceImage TargetImage signature TargetProcessGuid SourceProcessGuid  TargetProcessId SourceProcessId StartAddress EventCode dest | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `windows_process_injection_with_public_source_path_filter`'



<li><a href="#">NAME: Windows Process With NamedPipe CommandLine

DESCRIPTION:  This analytic is to look for process commandline that contains named  pipe. This technique was seen in some adversaries, threat actor and malware like  olympic destroyer to communicate to its other child processes after process injection  that serve as defense evasion and privilege escalation. On the other hand this analytic  may catch some normal process that using this technique for example browser application.  In that scenario we include common process path we've seen during testing that cause  false positive which is the program files. False positive may still be arise if  the normal application is in other folder path.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.process = "*\\\\.\\pipe\\*"  NOT (Processes.process_path IN ("*\\program files*")) by Processes.parent_process_name  Processes.parent_process Processes.process_name Processes.process Processes.original_file_name  Processes.process_id Processes.parent_process_path Processes.process_guid Processes.parent_process_id  Processes.dest Processes.user Processes.process_path | `drop_dm_object_name(Processes)`  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `windows_process_with_namedpipe_commandline_filter`'



<li><a href="#">NAME: Windows Protocol Tunneling with Plink

DESCRIPTION:  The following analytic identifies the use of Plink being utilized to  proxy egress or laterally in an organization. The analytic is limited to specific  Plink options on the command-line, including -R -L and -D which will have the remote  and local IP address or port and -l for a username. Modify the options as seen fit  for your organization.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.process_name=plink.exe  OR Processes.original_file_name=Plink Processes.process IN ("*-R *", "*-L *", "*-D  *", "*-l *") by Processes.dest Processes.user Processes.parent_process_name Processes.process_name  Processes.original_file_name Processes.process Processes.process_id Processes.parent_process_id  | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`|  `windows_protocol_tunneling_with_plink_filter`'



<li><a href="#">NAME: Windows Proxy Via Netsh

DESCRIPTION:  This search looks for processes launching netsh.exe for connection proxy.  Netsh is a command-line scripting utility that allows you to, either locally or  remotely, display or modify the network configuration of a computer that is currently  running. Netsh can be used as a persistence proxy technique to execute a helper  DLL when netsh.exe is executed. In this search, we are looking for processes spawned  by netsh.exe and executing commands via the command line.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where `process_netsh` Processes.process  = "* portproxy *" Processes.process = "* v4tov4 *" by Processes.parent_process_name  Processes.parent_process Processes.original_file_name Processes.process_name Processes.process  Processes.user Processes.dest |`drop_dm_object_name("Processes")` |`security_content_ctime(firstTime)`  |`security_content_ctime(lastTime)` | `windows_proxy_via_netsh_filter`'



<li><a href="#">NAME: Windows Proxy Via Registry

DESCRIPTION:  This search looks for processes launching netsh.exe for connection proxy. Netsh is a command-line  scripting utility that allows you to, either locally or remotely, display or modify  the network configuration of a computer that is currently running. Netsh can be  used as a persistence proxy technique to execute a helper DLL when netsh.exe is  executed. In this search, we are looking for processes spawned by netsh.exe and  executing commands via the command line.

SEARCH:  '| tstats `security_content_summariesonly` count  min(_time) as firstTime max(_time) as lastTime FROM datamodel=Endpoint.Registry   where Registry.registry_path ="*\\System\\CurrentControlSet\\Services\\PortProxy\\v4tov4\\tcp*"   by Registry.registry_path Registry.registry_key_name Registry.registry_value_name Registry.action Registry.dest  Registry.user  | `security_content_ctime(lastTime)`   | `security_content_ctime(firstTime)`   | `drop_dm_object_name(Registry)`   | `windows_proxy_via_registry_filter`'



<li><a href="#">NAME: Windows Query Registry Browser List Application

DESCRIPTION:  The following analytic identifies a suspicious process accessing default internet browsers registry entry.   This registry is used by Windows to store information about default internet browsers installed on a system.   Malware, adversaries or red-teamers can abuse this registry key to collect data about the installed internet browsers and their associated settings.  This information can be used to steal sensitive data such as login credentials, browsing history, and saved passwords.  We observed noise that needs to be filter out so we add several known path of Windows Application to make this detection more stable.

SEARCH:  '`wineventlog_security` EventCode=4663 object_file_path IN ("*\\SOFTWARE\\Clients\\StartMenuInternet\\*", "*\\SOFTWARE\\Clients\\StartMenuInternet\\*")  AND NOT (process_path IN ("*:\\Windows\\System32\\*", "*:\\Windows\\SysWow64\\*", "*:\\Program Files*", "*:\\Windows\\*"))         | stats count min(_time) as firstTime max(_time) as lastTime by object_file_name object_file_path process_name process_path  process_id EventCode dest  | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)`   | `windows_query_registry_browser_list_application_filter`'



<li><a href="#">NAME: Windows Query Registry Reg Save

DESCRIPTION:  The following analytic identifies a process execution of reg.exe with  "save" parameter. This reg.exe parameter is commonly being abused by threat actors,  adversaries and red-teamers to dump credentials or to check the registry modification  capabilities of certain users or administrators in targeted hosts. This approach  was seen in post-exploitation tool like winpeas where it uses "reg save" and "reg  restore" to check registry modification restriction in targeted host after gaining  access to it.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where  `process_reg` AND Processes.process  = "* save *" by Processes.process_name Processes.original_file_name Processes.process  Processes.process_id Processes.process_guid Processes.parent_process_name Processes.parent_process  Processes.parent_process_guid Processes.dest Processes.user | `drop_dm_object_name(Processes)`  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `windows_query_registry_reg_save_filter`'



<li><a href="#">NAME: Windows Query Registry UnInstall Program List

DESCRIPTION:  The following analytic identifies a suspicious query on uninstall application list in Windows OS registry.   This registry  is commonly used by legitimate software to store information about installed applications on a Windows system, such as their name, version, publisher, and installation path.  However, malware, adversaries or even red-teamers can abuse this registry key to retrieve information stored in the "Uninstall" key to gather data about installed applications in the target host.  This Anomaly detection can be a good pivot to detect a possible suspicious process accessing this registry which is not commonly accessed by a normal user.

SEARCH:  '`wineventlog_security` EventCode=4663 object_file_path="\\REGISTRY\\MACHINE\\SOFTWARE\\WOW6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\*"   | stats count min(_time) as firstTime max(_time) as lastTime by object_file_name object_file_path process_name process_path  process_id EventCode dest  | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)`  | `windows_query_registry_uninstall_program_list_filter`'



<li><a href="#">NAME: Windows Raccine Scheduled Task Deletion

DESCRIPTION:  The following analytic identifies the Raccine Rules Updater scheduled  task being deleted. Adversaries may attempt to remove this task in order to prevent  the update of Raccine.  Raccine is a "ransomware vaccine" created by security researcher  Florian Roth, designed to intercept and prevent precursors and active ransomware  behavior.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.process_name=schtasks.exe  Processes.process="*delete*" AND Processes.process="*Raccine*" by Processes.dest  Processes.user Processes.parent_process_name Processes.process_name Processes.original_file_name  Processes.process Processes.process_id Processes.parent_process_id | `drop_dm_object_name(Processes)`  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `windows_raccine_scheduled_task_deletion_filter`'



<li><a href="#">NAME: Windows Rapid Authentication On Multiple Hosts

DESCRIPTION:  The following analytic leverages Event ID 4624 to identify a source computer authenticating to a large number of remote endpoints within an Active Directory network.  Specifically, the logic will trigger when a source endpoint authenticates to 30 or more target computers within a 5 minute timespan. This behavior could represent an adversary who is  moving laterally across the environment or enumerating network shares in the search for sensitive files.  As environments differ across organizations, security teams should customize the thresholds of this detection as needed.

SEARCH:  '  `wineventlog_security` EventCode=4624 LogonType=3 TargetUserName!="ANONYMOUS LOGON" TargetUserName!="*$"  | bucket span=5m _time  | stats dc(Computer) AS unique_targets values(Computer) as host_targets by _time, IpAddress, TargetUserName  | where unique_targets > 30  | `windows_rapid_authentication_on_multiple_hosts_filter`'



<li><a href="#">NAME: Windows Rasautou DLL Execution

DESCRIPTION:  The following analytic identifies the Windows Windows Remote Auto Dialer,  rasautou.exe executing an arbitrary DLL. This technique is used to execute arbitrary  shellcode or DLLs via the rasautou.exe LOLBin capability. During triage, review  parent and child process behavior including file and image loads.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.process_name=rasautou.exe  Processes.process="* -d *"AND Processes.process="* -p *" by Processes.dest Processes.user  Processes.parent_process_name Processes.process_name Processes.process Processes.process_id  Processes.parent_process_id Processes.original_file_name | `drop_dm_object_name(Processes)`  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `windows_rasautou_dll_execution_filter`'



<li><a href="#">NAME: Windows Raw Access To Disk Volume Partition

DESCRIPTION:  This analytic is to look for suspicious raw access read to device disk  partition of the host machine. This technique was seen in several attacks by adversaries  or threat actor to wipe, encrypt or overwrite the boot sector of each partition  as part of their impact payload for example the "hermeticwiper" malware. This detection  is a good indicator that there is a process try to read or write on boot sector.

SEARCH:  '`sysmon` EventCode=9 Device = \\Device\\HarddiskVolume* NOT (Image IN("*\\Windows\\System32\\*",  "*\\Windows\\SysWOW64\\*")) | stats count min(_time) as firstTime max(_time) as  lastTime by dest signature signature_id process_guid process_name process_path Device | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `windows_raw_access_to_disk_volume_partition_filter`'



<li><a href="#">NAME: Windows Raw Access To Master Boot Record Drive

DESCRIPTION:  This analytic is to look for suspicious raw access read to drive where  the master boot record is placed. This technique was seen in several attacks by  adversaries or threat actor to wipe, encrypt or overwrite the master boot record  code as part of their impact payload. This detection is a good indicator that there  is a process try to read or write on MBR sector.

SEARCH:  '`sysmon` EventCode=9 Device = \\Device\\Harddisk0\\DR0 NOT (Image IN("*\\Windows\\System32\\*",  "*\\Windows\\SysWOW64\\*")) | stats count min(_time) as firstTime max(_time) as  lastTime by Computer Image Device ProcessGuid ProcessId EventDescription EventCode  | rename Computer as dest  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `windows_raw_access_to_master_boot_record_drive_filter`'



<li><a href="#">NAME: Windows RDP Connection Successful

DESCRIPTION:  The following analytic identifies successful remote desktop connections. Utilize this analytic to hunt for successful attempts. In addition, the query may be modified for EventCode=1148 to potentially identify failed attempts. In testing, 1148 would not generate based on a failed logon attempt.  Note this analytic requires enabling and a stanza in a inputs.conf.

SEARCH:  '`remoteconnectionmanager` EventCode=1149  | stats count min(_time) as firstTime max(_time) as lastTime by ComputerName, Source_Network_Address, User, Message  | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | rename ComputerName as dest | `windows_rdp_connection_successful_filter`'



<li><a href="#">NAME: Windows Registry BootExecute Modification

DESCRIPTION:  This analytic monitors the BootExecute registry key for any modifications from its default value, which could indicate potential malicious activity. The BootExecute registry key, located at HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager, manages the list of applications and services that are executed during system boot. By default, the BootExecute value is set to "autocheck autochk *". Attackers might attempt to modify this value to achieve persistence, load malicious code, or tamper with the system's boot process.

SEARCH:  '| tstats `security_content_summariesonly` count FROM datamodel=Endpoint.Registry  WHERE Registry.registry_path="HKLM\\System\\CurrentControlSet\\Control\\Session Manager\\BootExecute" BY _time span=1h Registry.dest Registry.registry_path Registry.registry_key_name  Registry.registry_value_name Registry.registry_value_data Registry.process_guid, Registry.action  | `drop_dm_object_name(Registry)` | where isnotnull(registry_value_data)  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`| `windows_registry_bootexecute_modification_filter`'



<li><a href="#">NAME: Windows Registry Certificate Added

DESCRIPTION:  The following analytic identifies installation of a root CA certificate  by monitoring the registry.  In short, there are specific certificate registry paths that will be written to  (SetValue) when a new certificate is added. The high-fidelity events to pay attention  to are SetValue events where the TargetObject property ends with "<THUMBPRINT_VALUE>\Blob"  as this indicates the direct installation or modification of a root certificate  binary blob. The other high fidelity reference will be which process is making the  registry modifications. There are very few processes that modify these day to day,  therefore monitoring for all to start (hunting) provides a great beginning.

SEARCH:  '| tstats `security_content_summariesonly` count from datamodel=Endpoint.Registry  where Registry.registry_path IN ("*\\certificates\\*") AND Registry.registry_value_name="Blob"  by _time span=1h Registry.dest Registry.user Registry.registry_path Registry.registry_value_name  Registry.process_guid Registry.registry_key_name Registry.registry_value_data |  `drop_dm_object_name(Registry)`   | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)`  | `windows_registry_certificate_added_filter`'



<li><a href="#">NAME: Windows Registry Delete Task SD

DESCRIPTION:  The following analytic identifies a process attempting to delete a scheduled  task SD (Security Descriptor) from within the registry path of that task. This may  occur from a non-standard process running and may not come from reg.exe. This particular  behavior will remove the actual Task Name from the Task Scheduler GUI and from the  command-line query - schtasks.exe /query. In addition, in order to perform this  action, the user context will need to be SYSTEM.\  Identifying the deletion of a scheduled task's Security Descriptor from the registry is significant for a SOC as it may indicate malicious activity attempting to remove evidence of a scheduled task, potentially for defense evasion purposes. If a true positive is detected, it suggests an attacker with privileged access attempting to remove traces of their activities, which can have a significant impact on the security and functionality of affected systems. Immediate investigation and response are required to mitigate further risks and preserve the integrity of the environment.

SEARCH:  '| tstats `security_content_summariesonly` count from datamodel=Endpoint.Registry  where Registry.registry_path IN ("*\\Schedule\\TaskCache\\Tree\\*") Registry.user="SYSTEM"  Registry.registry_value_name="SD" (Registry.action=Deleted OR Registry.action=modified)  by _time  Registry.dest Registry.process_guid Registry.user Registry.registry_path  Registry.registry_value_name Registry.registry_key_name Registry.registry_value_data  Registry.status Registry.action | `drop_dm_object_name(Registry)` | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `windows_registry_delete_task_sd_filter`'



<li><a href="#">NAME: Windows Registry Modification for Safe Mode Persistence

DESCRIPTION:  The following analytic identifies a modification or registry add to the  safeboot registry as an autostart mechanism. This technique is utilized by adversaries  to persist a driver or service into Safe Mode. Two keys are monitored in this analytic,  Minimal  and Network. adding values to Minimal will load into Safe Mode and by adding into  Network it will provide the service or drive the ability to perform network connections  in Safe Mode.

SEARCH:  '| tstats `security_content_summariesonly` count from datamodel=Endpoint.Registry  where Registry.registry_path IN ("*SYSTEM\\CurrentControlSet\\Control\\SafeBoot\\Minimal\\*","*SYSTEM\\CurrentControlSet\\Control\\SafeBoot\\Network\\*")  by _time span=1h Registry.dest Registry.user Registry.registry_path Registry.registry_value_name  Registry.process_guid Registry.registry_key_name Registry.registry_value_data |  `drop_dm_object_name(Registry)`  | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)`  | `windows_registry_modification_for_safe_mode_persistence_filter`'



<li><a href="#">NAME: Windows Registry Payload Injection

DESCRIPTION:  The following analytic identifies when suspiciouly long data is written  to the registry. This behavior is often associated with certain fileless malware  threats or persistence techniques used by threat actors. Data stored in the registy  is considered fileless since it does not get written to disk and is traditionally  not well defended since normal users can modify thier own registry.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) AS firstTime max(_time)  AS lastTime FROM datamodel=Endpoint.Processes BY _time span=1h Processes.user Processes.process_id  Processes.process_name Processes.process Processes.process_path Processes.dest Processes.parent_process_name  Processes.parent_process Processes.process_guid| `drop_dm_object_name(Processes)`  | join max=0 dest process_guid [| tstats `security_content_summariesonly` count  from datamodel=Endpoint.Registry where Registry.registry_value_data=* by _time span=1h  Registry.dest Registry.registry_path Registry.registry_value_name Registry.process_guid  Registry.registry_value_data Registry.registry_key_name | `drop_dm_object_name(Registry)`  | eval reg_data_len = len(registry_value_data) | where reg_data_len > 512] | fields  firstTime lastTime dest user parent_process_name parent_process process_name process_path  process registry_key_name registry_path registry_value_name registry_value_data  process_guid | where isnotnull(registry_value_data)| `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)`| `windows_registry_payload_injection_filter`'



<li><a href="#">NAME: 'Windows Registry SIP Provider Modification'

DESCRIPTION:  'The following analytic detects modifications to the Windows Registry SIP Provider. It identifies this behavior by monitoring Sysmon Event ID 7, which logs registry modification events. The analytic specifically looks for changes in registry paths and values associated with Cryptography Providers and OID Encoding Types. This behavior is worth identifying as it may indicate an attempt to subvert trust controls, a technique often used by adversaries to bypass security measures and maintain persistence in an environment. If a true positive is found, it suggests an attacker is trying to manipulate the system''s cryptographic functions, potentially leading to unauthorized access, data theft, or other damaging outcomes. Upon triage, review the registry paths and values modified, and look for concurrent processes to identify the attack source. Review the path of the SIP being added. This approach helps analysts detect potential threats earlier and mitigate the risks.'

SEARCH:  '| tstats `security_content_summariesonly` count values(Registry.registry_key_name)  as registry_key_name values(Registry.registry_path) as registry_path min(_time)  as firstTime max(_time) as lastTime from datamodel=Endpoint.Registry where Registry.registry_path IN ("*\\SOFTWARE\\Microsoft\\Cryptography\\Providers\\*", "*\\SOFTWARE\\Microsoft\\Cryptography\\OID\\EncodingType*", "*\\SOFTWARE\\WOW6432Node\\Microsoft\\Cryptography\\Providers\\*", "*\\SOFTWARE\\WOW6432Node\\Microsoft\\Cryptography\\OID\\EncodingType*") Registry.registry_value_name IN ("Dll","$DLL") by  Registry.dest , Registry.user Registry.registry_value_name, Registry.registry_value_data | `security_content_ctime(lastTime)` | `security_content_ctime(firstTime)`  | `drop_dm_object_name(Registry)`| `windows_registry_sip_provider_modification_filter`'



<li><a href="#">NAME: Windows Regsvr32 Renamed Binary

DESCRIPTION:  The following hunting analytic identifies renamed instances of regsv32.exe  executing. regsv32.exe is natively found in C:\Windows\system32 and C:\Windows\syswow64.  During investigation, validate if it is the legitimate regsv32.exe executing and  what dll module content it is loading. This query relies on the original filename  or internal name from the PE meta data. Expand the query as needed by looking for  specific command line arguments outlined in other analytics.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.process_name != regsvr32.exe  AND Processes.original_file_name=regsvr32.exe by Processes.dest Processes.user Processes.parent_process_name  Processes.process_name Processes.process Processes.process_id Processes.parent_process_id  Processes.original_file_name | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `windows_regsvr32_renamed_binary_filter`'



<li><a href="#">NAME: Windows Remote Access Software BRC4 Loaded Dll

DESCRIPTION:  The following anomaly detection identifies the behavior related to 4  native Windows DLLs being loaded by a non-standard process. Identified by MDSec  during their research into Brute Ratel, MDSec identified a high signal analytic  by calling out these 4 DLLs being loaded into a process. LogonCLI.dll is the Net  Logon Client DLL and is related to users and other domain services to get authenticated.  Credui.dll is Credential Manager User Interface. Credential managers receive notifications  when authentication information changes. For example, credential managers are notified  when a user logs on or an account password changes. Samcli.dll is the Security Accounts  Manager Client DLL. Adversaries may attempt to extract credential material from  the Security Account Manager (SAM) database either through in-memory techniques  or through the Windows Registry where the SAM database is stored. Dbghelp.dll is  Windows Image Helper. Windows Image Helper is commonly seen in credential dumping  due to native functions. All of these modules are important to monitor and track  and combined may lead to credentail access or dumping.

SEARCH:  '`sysmon` EventCode=7 |bin _time span=30s | eval BRC4_AnomalyLoadedDll=case(OriginalFileName=="credui.dll",  1, OriginalFileName=="DBGHELP.DLL", 1, OriginalFileName=="SAMCLI.DLL", 1, OriginalFileName=="winhttp.dll",  1, 1=1, 0) | eval BRC4_LoadedDllPath=case(match(ImageLoaded, "credui.dll"), 1, match(ImageLoaded,  "dbghelp.dll"), 1, match(ImageLoaded, "samcli.dll"), 1, match(ImageLoaded, "winhttp.dll"),  1, 1=1, 0) | stats count min(_time) as firstTime max(_time) as lastTime values(ImageLoaded)  as ImageLoaded values(OriginalFileName) as OriginalFileName dc(ImageLoaded) as ImageLoadedCount  by Image  BRC4_LoadedDllPath BRC4_AnomalyLoadedDll dest EventCode Signed | where  ImageLoadedCount  == 4 AND (BRC4_LoadedDllPath == 1 OR BRC4_AnomalyLoadedDll == 1) | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `windows_remote_access_software_brc4_loaded_dll_filter`'



<li><a href="#">NAME: Windows Remote Access Software Hunt

DESCRIPTION:  The following hunting analytic is meant to help organizations understand  what remote access software is being used in the environment. When reviewing this  hunt, confirm the software identified is authorized to be utilized. Based on fidelity,  create a new analytic for specific utilities banned within the organization. Adversaries  use these utilities to retain remote access capabilities to the environment. Utilities  in the lookup include AnyDesk, GoToMyPC, LogMeIn, TeamViewer and much more. Review  the lookup for the entire list and add any others.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime values(Processes.process) as process values(Processes.parent_process)  as parent_process from datamodel=Endpoint.Processes where Processes.dest!=unknown  Processes.user!=unknown by Processes.dest Processes.user Processes.process_name  Processes.process | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `drop_dm_object_name(Processes)` | lookup remote_access_software remote_utility  AS process_name OUTPUT isutility | search isutility = True | `windows_remote_access_software_hunt_filter`'



<li><a href="#">NAME: Windows Remote Access Software RMS Registry

DESCRIPTION:  The following analytic is to identify a modification or creation of Windows  registry related to the Remote Manipulator System (RMS) Remote Admin tool. RMS is  a legitimate tool developed by russian organization TektonIT and has been observed  being abused by adversaries to gain remote access to the targeted host. Azorult  malware utilized RMS to gain remote access.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime FROM datamodel=Endpoint.Registry where Registry.registry_path= "*\\SYSTEM\\Remote  Manipulator System*" by Registry.registry_key_name Registry.user Registry.registry_path  Registry.registry_value_data Registry.action Registry.dest | `drop_dm_object_name(Registry)`  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `windows_remote_access_software_rms_registry_filter`'



<li><a href="#">NAME: Windows Remote Assistance Spawning Process

DESCRIPTION:  The following analytic identifies the use of Microsoft Remote Assistance,  msra.exe, spawning PowerShell.exe or cmd.exe as a child process. Msra.exe by default  has no command-line arguments and typically spawns itself. It will generate a network  connection to the remote system that is connected. This behavior is indicative of  another process injected into msra.exe. Review the parent process or cross process  events to identify source.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.parent_process_name=msra.exe  `windows_shells` by Processes.dest Processes.user Processes.parent_process_name  Processes.process_name Processes.original_file_name Processes.process Processes.process_id  Processes.parent_process_id | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `windows_remote_assistance_spawning_process_filter`'



<li><a href="#">NAME: Windows Remote Create Service

DESCRIPTION:  This analytic identifies an endpoint that remotely connects to another  endpoint to create a new service using sc.exe. On the remote endpoint, the new service  will be created and this action will trigger the creation of EventCode 7045 along  with all the resulting service information.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.process_name=sc.exe  Processes.process IN ("*create*")  Processes.process="*\\\\*" by Processes.dest  Processes.user Processes.parent_process_name Processes.process_name Processes.original_file_name  Processes.process Processes.process_id Processes.parent_process_id | `drop_dm_object_name(Processes)`  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `windows_remote_create_service_filter`'



<li><a href="#">NAME: Windows Remote Services Allow Rdp In Firewall

DESCRIPTION:  The following analytic is to identify a modification in the Windows firewall  to enable remote desktop protocol on a targeted machine. This technique was seen  in several adversaries, malware or red teamer to remotely access the compromised  or targeted host by allowing this protocol in firewall. Even this protocol might  be allowed in some production environment, This TTP behavior is a good pivot to  check who and why the user want to enable this feature through firewall which is  also common traits of attack to start lateral movement.

SEARCH:  '| tstats `security_content_summariesonly` values(Processes.process) as cmdline  values(Processes.parent_process_name) as parent_process values(Processes.process_name)  count min(_time) as firstTime max(_time) as lastTime from datamodel=Endpoint.Processes  where (Processes.process_name = "netsh.exe" OR Processes.original_file_name= "netsh.exe")  AND Processes.process = "*firewall*" AND Processes.process = "*add*" AND Processes.process  = "*protocol=TCP*" AND Processes.process = "*localport=3389*" AND Processes.process  = "*action=allow*" by Processes.dest Processes.user Processes.parent_process Processes.process_name  Processes.process Processes.process_id Processes.parent_process_id | `drop_dm_object_name(Processes)`  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `windows_remote_services_allow_rdp_in_firewall_filter`'



<li><a href="#">NAME: Windows Remote Services Allow Remote Assistance

DESCRIPTION:  The following analytic is to identify a modification in the Windows registry  to enable remote desktop assistance on a targeted machine. This technique was seen  in several adversaries, malware or red teamer like azorult to remotely access the  compromised or targeted host by enabling this protocol in registry. Even this protocol  might be allowed in some production environment, This Anomaly behavior is a good  pivot to check who and why the user want to enable this feature through registry  which is un-common. And as per stated in microsoft documentation the default value  of this registry is false that makes this a good indicator of suspicious behavior.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime FROM datamodel=Endpoint.Registry where Registry.registry_path= "*\\Control\\Terminal  Server\\fAllowToGetHelp*" Registry.registry_value_data="0x00000001" by Registry.registry_key_name  Registry.user Registry.registry_path Registry.registry_value_data Registry.action  Registry.dest | `drop_dm_object_name(Registry)` | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `windows_remote_services_allow_remote_assistance_filter`'



<li><a href="#">NAME: Windows Remote Services Rdp Enable

DESCRIPTION:  The following analytic is to identify a modification in the Windows registry  to enable remote desktop protocol on a targeted machine. This technique was seen  in several adversaries, malware or red teamer to remotely access the compromised  or targeted host by enabling this protocol in registry. Even this protocol might  be allowed in some production environment, This TTP behavior is a good pivot to  check who and why the user want to enable this feature through registry which is  un-common.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime FROM datamodel=Endpoint.Registry where Registry.registry_path= "*\\Control\\Terminal  Server\\fDenyTSConnections*" Registry.registry_value_data="0x00000000" by Registry.registry_key_name  Registry.user Registry.registry_path Registry.registry_value_data Registry.action  Registry.dest | `drop_dm_object_name(Registry)` | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `windows_remote_services_rdp_enable_filter`'



<li><a href="#">NAME: Windows Remote Service Rdpwinst Tool Execution

DESCRIPTION:  The following analytic identifies RDPWInst.exe tool, which is a RDP wrapper  library tool designed to enable remote desktop host support and concurrent RDP session  on reduced functionality system. Unfortunately, this open project was abused by  adversaries to enable RDP connection to the targeted host for remote access and  potentially be for lateral movement.

SEARCH:  '| tstats `security_content_summariesonly` values(Processes.process) as process  min(_time) as firstTime max(_time) as lastTime from datamodel=Endpoint.Processes  where (Processes.process_name="RDPWInst.exe" OR Processes.original_file_name="RDPWInst.exe")  AND Processes.process IN ("* -i*", "* -s*", "* -o*", "* -w*", "* -r*") by Processes.dest  Processes.user Processes.parent_process Processes.process_name Processes.original_file_name  Processes.process Processes.process_id Processes.parent_process_id | `drop_dm_object_name(Processes)`  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `windows_remote_service_rdpwinst_tool_execution_filter`'



<li><a href="#">NAME: Windows Replication Through Removable Media

DESCRIPTION:  This analytic is developed to detect suspicious executable or script  files created or dropped in the root drive of a targeted host. This technique is  commonly used by threat actors, adversaries or even red teamers to replicate or  spread in possible removable drives. Back then, WORM malware was popular for this  technique where it would drop a copy of itself in the root drive to be able to spread  or to have a lateral movement in other network machines. Nowadays, Ransomware like  CHAOS ransomware also use this technique to spread its malicious code in possible  removable drives. This TTP detection can be a good indicator that a process might  create a persistence technique or lateral movement of a targeted machine. We suggest  checking the process name that creates this event, the file created, user type,  and the reason why that executable or scripts are dropped in the root drive.

SEARCH:  '|tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Filesystem where (Filesystem.file_name = *.exe  OR Filesystem.file_name = *.dll OR Filesystem.file_name = *.sys OR Filesystem.file_name  = *.com OR Filesystem.file_name = *.vbs OR Filesystem.file_name = *.vbe OR Filesystem.file_name  = *.js  OR Filesystem.file_name= *.bat OR Filesystem.file_name = *.cmd OR Filesystem.file_name  = *.pif) by Filesystem.file_create_time Filesystem.process_id  Filesystem.file_name  Filesystem.file_path Filesystem.user Filesystem.dest | `drop_dm_object_name(Filesystem)` | eval  dropped_file_path = split(file_path, "\\") | eval dropped_file_path_split_count  = mvcount(dropped_file_path) | eval root_drive = mvindex(dropped_file_path,0) |  where LIKE(root_drive, "%:") AND dropped_file_path_split_count = 2  AND root_drive!=  "C:" | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `windows_replication_through_removable_media_filter`'



<li><a href="#">NAME: Windows Root Domain linked policies Discovery

DESCRIPTION:  The following analytic utilizes PowerShell Script Block Logging (EventCode=4104)  to identify the `[Adsisearcher]` type accelerator being used to query Active Directory  for domain groups. Red Teams and adversaries may leverage `[Adsisearcher]` to enumerate  root domain linked policies for situational awareness and Active Directory Discovery.

SEARCH:  '`powershell` EventCode=4104 ScriptBlockText = "*[adsisearcher]*" ScriptBlockText  = "*.SearchRooT*" ScriptBlockText = "*.gplink*" | stats count min(_time) as firstTime  max(_time) as lastTime by EventCode ScriptBlockText Computer user_id  | rename Computer as dest, user_id as user   | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)`   | `windows_root_domain_linked_policies_discovery_filter`'



<li><a href="#">NAME: Windows Rundll32 Apply User Settings Changes

DESCRIPTION:  This search is to detect a suspicious rundll32 commandline to update a user's system parameters related to desktop backgrounds,   display settings, and visual themes. Specifically, it triggers the system to refresh and apply changes to the user-specific settings,   such as wallpaper modifications or visual theme updates, ensuring that the changes take effect without the need to restart the system or log out   and log back in. This technique was seen in Rhysida Ransomware and script as part of its defense evasion. This technique is not a common practice  to lock a screen and maybe a good indicator of compromise.  This command could also potentially be exploited by malware to disguise its activities or make unauthorized changes to a user's system settings   without their knowledge or consent.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time) as lastTime from datamodel=Endpoint.Processes   where Processes.process_name=rundll32.exe Processes.process= "*user32.dll,UpdatePerUserSystemParameters*"   by Processes.dest Processes.user Processes.parent_process Processes.process_name Processes.process Processes.process_id Processes.parent_process_id Processes.parent_process_name   | `drop_dm_object_name(Processes)`  | `security_content_ctime(firstTime)`   | `security_content_ctime(lastTime)`   | `windows_rundll32_apply_user_settings_changes_filter`'



<li><a href="#">NAME: Windows Rundll32 WebDAV Request

DESCRIPTION:  The following analytic identifies rundll32.exe with the commandline arguments  loading davclnt.dll function - davsetcookie - to be used to access a remote WebDav  instance. This particular behavior was recently showcased in CVE-2023-23397.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.process_name=rundll32.exe  Processes.process IN ("*\\windows\\system32\\davclnt.dll,*davsetcookie*","*\\windows\\syswow64\\davclnt.dll,*davsetcookie*")  by Processes.dest Processes.user Processes.parent_process_name Processes.process_name  Processes.process Processes.process_id Processes.parent_process_id | `drop_dm_object_name(Processes)`  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `windows_rundll32_webdav_request_filter`'



<li><a href="#">NAME: Windows Rundll32 WebDav With Network Connection

DESCRIPTION:  The following analytic identifies rundll32.exe with the commandline arguments  loading davclnt.dll function - davsetcookie - to be used to access a remote WebDav  instance. The analytic attempts to use join from Processes and All_Traffic to identify  the network connection. This particular behavior was recently showcased in CVE-2023-23397.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime FROM datamodel=Endpoint.Processes where Processes.parent_process_name=svchost.exe  `process_rundll32` Processes.process IN ("*\\windows\\system32\\davclnt.dll,*davsetcookie*",  "*\\windows\\syswow64\\davclnt.dll,*davsetcookie*") by host _time span=1h Processes.process_id  Processes.process_name Processes.dest Processes.process_path Processes.process Processes.parent_process_name  Processes.parent_process | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | rename dest as src | join host process_id  [ | tstats `security_content_summariesonly` count latest(All_Traffic.dest) as dest  latest(All_Traffic.dest_ip) as dest_ip latest(All_Traffic.dest_port) as dest_port  FROM datamodel=Network_Traffic.All_Traffic where All_Traffic.dest_port!=0 NOT (All_Traffic.dest_ip  IN (10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16))  by host All_Traffic.process_id  | `drop_dm_object_name(All_Traffic)`] | `windows_rundll32_webdav_with_network_connection_filter`'



<li><a href="#">NAME: Windows Scheduled Task Created Via XML

DESCRIPTION:  'The following analytic detects the creation of suspicious scheduled  tasks in Windows, specifically tasks created using schtasks.exe with the -create  flag and an XML parameter in the command-line. This technique is commonly employed  by threat actors, adversaries, and red teamers to establish persistence or achieve  privilege escalation on targeted hosts. Notably, malware like Trickbot and Winter-Vivern  have been observed using XML files to create scheduled tasks. Monitoring and investigating  this activity is crucial to mitigate potential security risks. It is important to  be aware that scripts or administrators may trigger this analytic, leading to potential  false positives. To minimize false positives, adjust the filter based on the parent  process or application.\  When a true positive is detected, it suggests an attacker''s attempt to gain persistence  or execute additional malicious payloads, potentially resulting in data theft, ransomware,  or other damaging outcomes. During triage, review the source of the scheduled task,  the command to be executed, and capture any relevant on-disk artifacts. Analyze  concurrent processes to identify the source of the attack. This analytic enables  analysts to detect and respond to potential threats early, mitigating the associated  risks effectively.'

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.process_name=schtasks.exe  Processes.process=*create* Processes.process="* /xml *" by Processes.user  Processes.parent_process_name  Processes.parent_process Processes.process_name Processes.process Processes.process_guid  Processes.process_id Processes.parent_process_guid Processes.dest | `drop_dm_object_name(Processes)`  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `windows_scheduled_task_created_via_xml_filter`'



<li><a href="#">NAME: Windows Scheduled Task Service Spawned Shell

DESCRIPTION:  The following analytic identifies when the Task Scheduler service "svchost.exe  -k netsvcs -p -s Schedule" is the parent process to common command line, scripting,  or shell execution binaries. Attackers often abuse the task scheduler service with  these binaries as an execution and persistence mechanism in order to blend in with  normal Windows operations. This TTP is also commonly seen for legitimate purposes  such as business scripts or application updates.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.parent_process="*\\system32\\svchost.exe*"  AND Processes.parent_process="*-k*" AND Processes.parent_process= "*netsvcs*" AND  Processes.parent_process="*-p*" AND Processes.parent_process="*-s*" AND Processes.parent_process="*Schedule*"  Processes.process_name IN("powershell.exe", "wscript.exe", "cscript.exe", "cmd.exe",  "sh.exe", "ksh.exe", "zsh.exe", "bash.exe", "scrcons.exe","pwsh.exe") by Processes.dest  Processes.user Processes.parent_process Processes.process_name Processes.process  Processes.process_id Processes.parent_process_id Processes.parent_process_name |  `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `windows_scheduled_task_service_spawned_shell_filter`'



<li><a href="#">NAME: Windows Scheduled Task with Highest Privileges

DESCRIPTION:  'The following analytic detects the creation of a new task with the highest  execution privilege via Schtasks.exe. This tactic is often observed in AsyncRAT  attacks, where the scheduled task is used for persistence and privilege escalation.  AsyncRAT sets up a scheduled task with parameters ''/rl'' and ''highest'', triggering  this technique. It''s a strong indicator of potential malware or adversaries seeking  to establish persistence and escalate privileges through scheduled tasks. This is  crucial for a Security Operations Center (SOC) as it can prevent unauthorized system  access and potential data breaches.\  The analytic works by monitoring logs for process name, parent process, and command-line  executions. In the presence of the ''*/rl '' and '' highest *'' commands in a schtasks.exe  process, an alert is triggered.'

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime  from datamodel=Endpoint.Processes where Processes.process_name = "schtasks.exe"  Processes.process = "*/rl *" Processes.process = "* highest *" by Processes.process_name  Processes.parent_process_name Processes.parent_process Processes.process Processes.process_guid  Processes.dest Processes.user | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `windows_scheduled_task_with_highest_privileges_filter`'



<li><a href="#">NAME: Windows Schtasks Create Run As System

DESCRIPTION:  The following analytic identifies the creation of a new task to start  and run as an elevated user - SYSTEM using Schtasks.exe. This behavior is commonly  used by adversaries to spawn a process in an elevated state. If a true positive  is found, it suggests an attacker is attempting to persist within the environment  or potentially deliver additional malicious payloads, leading to data theft, ransomware,  or other damaging outcomes. Upon triage, review the scheduled task's source and  the command to be executed. Capture and inspect any relevant on-disk artifacts,  and look for concurrent processes to identify the attack source. This approach helps  analysts detect potential threats earlier and mitigate the risks.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where `process_schtasks` Processes.process="*/create  *" AND Processes.process="*/ru *" AND Processes.process="*system*" by Processes.dest  Processes.user Processes.parent_process_name Processes.process_name Processes.original_file_name  Processes.process Processes.process_id Processes.parent_process_id | `drop_dm_object_name(Processes)`  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `windows_schtasks_create_run_as_system_filter`'



<li><a href="#">NAME: Windows Screen Capture Via Powershell

DESCRIPTION:  The following analytic identifies a potential PowerShell script that captures screen images on compromised or targeted hosts. This technique was observed in the Winter-Vivern malware, which attempts to capture desktop screens using a PowerShell script and send the images to its C2 server as part of its exfiltration strategy. This TTP serves as a useful indicator that a PowerShell process may be gathering desktop screenshots from a host system, potentially signaling malicious activity.

SEARCH:  '`powershell` EventCode=4104 ScriptBlockText = "*[Drawing.Graphics]::FromImage(*" AND ScriptBlockText = "*New-Object Drawing.Bitmap*"   AND ScriptBlockText = "*.CopyFromScreen*"  | stats count min(_time) as firstTime max(_time) as lastTime by EventCode ScriptBlockText Computer UserID  | `security_content_ctime(firstTime)`   | `security_content_ctime(lastTime)`   | `windows_screen_capture_via_powershell_filter`'



<li><a href="#">NAME: Windows Security Account Manager Stopped

DESCRIPTION:  The search looks for a Windows Security Account Manager (SAM) was stopped  via command-line. This is consistent with Ryuk infections across a fleet of endpoints.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime FROM datamodel=Endpoint.Processes WHERE ("Processes.process_name"="net*.exe"  "Processes.process"="*stop \"samss\"*") BY Processes.dest Processes.user Processes.process Processes.process_guid Processes.process_name  | `drop_dm_object_name(Processes)` | `security_content_ctime(lastTime)` | `security_content_ctime(firstTime)`  | `windows_security_account_manager_stopped_filter`'



<li><a href="#">NAME: Windows Security Support Provider Reg Query

DESCRIPTION:  The following analytic identifies a process command line related to the  discovery of possible Security Support Providers in the registry. This technique  is being abused by adversaries or post exploitation tools like winpeas to gather  LSA protection and configuration in the registry in the targeted host. This registry  entry can contain several information related to LSA that validates users for local  and remote sign-ins and enforces local security policies. Understanding LSA protection  may give a good information in accessing LSA content in memory which is commonly  attack by adversaries and tool like mimikatz to scrape password hashes or clear  plain text passwords.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where `process_reg` AND Processes.process  = "* query *" AND Processes.process = "*\\SYSTEM\\CurrentControlSet\\Control\\LSA*"  Processes.process IN ("*RunAsPPL*" , "*LsaCfgFlags*") by Processes.process_name  Processes.original_file_name Processes.process Processes.process_id Processes.process_guid  Processes.parent_process_name Processes.parent_process Processes.parent_process_guid  Processes.dest Processes.user | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `windows_security_support_provider_reg_query_filter`'



<li><a href="#">NAME: Windows Server Software Component GACUtil Install to GAC

DESCRIPTION:  The following analytic identifies the Windows SDK utility - GACUtil.exe,  being utilized to add a DLL into the Global Assembly Cache (GAC). Each computer  where the Common Language Runtime is installed has a machine-wide code cache called  the Global Assembly Cache. The Global Assembly Cache stores assemblies specifically  designated to be shared by several applications on the computer. By adding a DLL  to the GAC, this allows an adversary to call it via any other means across the operating  systems. As outlined by Microsoft in their blog, it is not common to see this spawning  from W3WP.exe, however, in a non-development environment it may not be common at  all. Note that in order to utilize GACutil.exe, The Windows SDK must be installed,  this is not a native binary.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.process_name=gacutil.exe  Processes.process IN ("*-i *","*/i *") by Processes.dest Processes.user Processes.parent_process_name  Processes.process_name Processes.process Processes.process_id Processes.parent_process_id  | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `windows_server_software_component_gacutil_install_to_gac_filter`'



<li><a href="#">NAME: Windows Service Created Within Public Path

DESCRIPTION:  The following analytc uses Windows Event Id 7045, `New Service Was Installed`,  to identify the creation of a Windows Service where the service binary path is located  in public paths. This behavior could represent the installation of a malicious service.  Red Teams and adversaries alike may create malicious Services for lateral movement  or remote code execution

SEARCH:  '`wineventlog_system` EventCode=7045  Service_File_Name = "*\.exe" NOT (Service_File_Name  IN ("C:\\Windows\\*", "C:\\Program File*", "C:\\Programdata\\*", "%systemroot%\\*"))  | stats count min(_time) as firstTime max(_time) as lastTime by ComputerName EventCode  Service_File_Name Service_Name Service_Start_Type Service_Type | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `windows_service_created_within_public_path_filter`'



<li><a href="#">NAME: Windows Service Created with Suspicious Service Path

DESCRIPTION:  The following analytics uses Windows Event Id 7045, `New Service Was  Installed`, to identify the creation of a Windows Service where the service binary  path path is located in a non-common Service folder in Windows. Red Teams and adversaries  alike may create malicious Services for lateral movement or remote code execution  as well as persistence and execution. The Clop ransomware has also been seen in  the wild abusing Windows services.

SEARCH:  ' `wineventlog_system` EventCode=7045  Service_File_Name = "*.exe" NOT (Service_File_Name  IN ("*:\\Windows\\*", "*:\\Program File*", "*:\\Programdata\\*", "*%systemroot%\\*"))  | stats count min(_time) as firstTime max(_time) as lastTime by EventCode Service_File_Name  Service_Name Service_Start_Type Service_Type dest user | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `windows_service_created_with_suspicious_service_path_filter`'



<li><a href="#">NAME: Windows Service Create Kernel Mode Driver

DESCRIPTION:  The following analytic identifes a new kernel driver being added to Windows  using sc.exe. Adding a Kernel driver is not common day to day and should be investigated  to further understand the source.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.process_name=sc.exe  Processes.process="*kernel*" by Processes.dest Processes.user Processes.parent_process_name  Processes.process_name Processes.process Processes.process_id Processes.parent_process_id  | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `windows_service_create_kernel_mode_driver_filter`'



<li><a href="#">NAME: Windows Service Create RemComSvc

DESCRIPTION:  The following analytic identifies RemComSvc installed on an endpoint. This typically occurs when someone is moving laterally with RemCom.exe.

SEARCH:  '`wineventlog_system` EventCode=7045 ServiceName="RemCom Service" | stats count min(_time) as firstTime max(_time) as lastTime by  dest ImagePath ServiceName ServiceType   | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `windows_service_create_remcomsvc_filter`'



<li><a href="#">NAME: Windows Service Create SliverC2

DESCRIPTION:  When an adversary utilizes SliverC2 to laterally move with the Psexec module, it will create a service with the name and description of "Sliver" and "Sliver Implant". Note that these may be easily changed and are specific to only SliverC2.  We have also created the same regex as Microsoft has outlined to attempt to capture the suspicious service path (regex101 reference).

SEARCH:  '`wineventlog_system` EventCode=7045 ServiceName="sliver"  | stats count min(_time) as firstTime max(_time) as lastTime by Computer EventCode ImagePath ServiceName ServiceType | rename Computer as dest  | `security_content_ctime(firstTime)`   | `security_content_ctime(lastTime)` | `windows_service_create_sliverc2_filter`'



<li><a href="#">NAME: Windows Service Create with Tscon

DESCRIPTION:  The following analytic detects potential RDP Hijacking attempts by monitoring  a series of actions taken by an attacker to gain unauthorized access to a remote  system. The attacker first runs the quser command to query the remote host for disconnected  user sessions. Upon identifying a disconnected session, they use the sc.exe command  to create a new Windows service with a binary path that launches tscon.exe. By specifying  the disconnected session ID and a destination ID, the attacker can transfer the  disconnected session to a new RDP session, effectively hijacking the user's session.  This analytic allows security teams to detect and respond to RDP Hijacking attempts,  mitigating potential risks and impacts on targeted systems.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.process_name=sc.exe  Processes.process="*/dest:rdp-tcp*" by Processes.dest Processes.user Processes.parent_process_name  Processes.process_name Processes.process Processes.process_id Processes.parent_process_id  | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `windows_service_create_with_tscon_filter`'



<li><a href="#">NAME: Windows Service Creation on Remote Endpoint

DESCRIPTION:  This analytic looks for the execution of `sc.exe` with command-line arguments  utilized to create a Windows Service on a remote endpoint. Red Teams and adversaries  alike may abuse the Service Control Manager for lateral movement and remote code  execution.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where (Processes.process_name=sc.exe  OR Processes.original_file_name=sc.exe) (Processes.process=*\\\\* AND Processes.process=*create*  AND Processes.process=*binpath*) by Processes.dest Processes.user Processes.parent_process_name  Processes.process_name Processes.process Processes.process_id Processes.parent_process_id  | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)`| `security_content_ctime(lastTime)`  | `windows_service_creation_on_remote_endpoint_filter`'



<li><a href="#">NAME: Windows Service Creation Using Registry Entry

DESCRIPTION:  The following analytic detects when reg.exe modify registry keys that  define Windows services and their configurations in Windows to detect potential  threats earlier and mitigate the risks. This detection is made by a Splunk query  that searches for specific keywords in the process name, parent process name, user,  and process ID. This detection is important because it suggests that an attacker  has modified the registry keys that define Windows services and their configurations,  which can allow them to maintain access to the system and potentially move laterally  within the network. It is a common technique used by attackers to gain persistence  on a compromised system and its impact can lead to data theft, ransomware, or other  damaging outcomes. False positives can occur since legitimate uses of reg.exe to  modify registry keys for Windows services can also trigger this alert. Next steps  include reviewing the process and user context of the reg.exe activity and identify  any other concurrent processes that might be associated with the attack upon triage.

SEARCH:  '| tstats `security_content_summariesonly` count FROM datamodel=Endpoint.Registry  WHERE (Registry.registry_path="*\\SYSTEM\\CurrentControlSet\\Services*" Registry.registry_value_name  = ImagePath) BY _time span=1h Registry.dest Registry.user Registry.registry_path  Registry.registry_key_name Registry.registry_value_name Registry.registry_value_data  Registry.process_guid | `drop_dm_object_name(Registry)` | where isnotnull(registry_value_data)  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `windows_service_creation_using_registry_entry_filter`'



<li><a href="#">NAME: Windows Service Deletion In Registry

DESCRIPTION:  The following analytic identifies a service being deleted from the Windows  Registry under CurrentControlSet\Services. Adversaries may delete a service as part  of defense evasion.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime FROM datamodel=Endpoint.Registry where Registry.registry_path= "*\\SYSTEM\\CurrentControlSet\\Services*"  AND (Registry.action = deleted OR (Registry.registry_value_name = DeleteFlag AND  Registry.registry_value_data = 0x00000001 AND Registry.action=modified)) by Registry.registry_key_name  Registry.user Registry.registry_path Registry.registry_value_data Registry.registry_value_name  Registry.action Registry.dest | `drop_dm_object_name(Registry)` | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `windows_service_deletion_in_registry_filter`'



<li><a href="#">NAME: Windows Service Initiation on Remote Endpoint

DESCRIPTION:  This analytic looks for the execution of `sc.exe` with command-line arguments  utilized to start a Windows Service on a remote endpoint. Red Teams and adversaries  alike may abuse the Service Control Manager for lateral movement and remote code  execution.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where (Processes.process_name=sc.exe  OR Processes.original_file_name=sc.exe) (Processes.process=*\\\\* AND Processes.process=*start*)  by Processes.dest Processes.user Processes.parent_process_name Processes.process_name  Processes.process Processes.process_id Processes.parent_process_id | `drop_dm_object_name(Processes)`  | `security_content_ctime(firstTime)`| `security_content_ctime(lastTime)` | `windows_service_initiation_on_remote_endpoint_filter`'



<li><a href="#">NAME: Windows Service Stop By Deletion

DESCRIPTION:  The following analytic identifies Windows Service Control, `sc.exe`,  attempting to delete a service. This is typically identified in parallel with other  instances of service enumeration of attempts to stop a service and then delete it.  Adversaries utilize this technique to terminate security services or other related  services to continue there objective and evade detections.

SEARCH:  '| tstats `security_content_summariesonly` values(Processes.process) as process  min(_time) as firstTime max(_time) as lastTime from datamodel=Endpoint.Processes  where (Processes.process_name = sc.exe OR Processes.original_file_name = sc.exe)  Processes.process="* delete *" by Processes.dest Processes.user Processes.parent_process_name  Processes.process_name Processes.original_file_name Processes.process Processes.process_id  Processes.parent_process_id | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `windows_service_stop_by_deletion_filter`'



<li><a href="#">NAME: Windows Service Stop Via Net  and SC Application

DESCRIPTION:  This analytic identifies suspicious attempts to stop services on a system  using either `net.exe` or `sc.exe`. This technique is used by adversaries to terminate  security services or other related services to continue their objective and evade  detections. This technique is also commonly used by ransomware threat actors to  successfully encrypt databases or files being processed or used by Windows OS Services.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime  from datamodel=Endpoint.Processes where `process_net` OR  Processes.process_name  = "sc.exe" OR Processes.original_file_name= "sc.exe" AND Processes.process="*stop*"  by  Processes.process_name Processes.original_file_name Processes.process Processes.process_id  Processes.process_guid Processes.parent_process_name Processes.parent_process Processes.parent_process_guid  Processes.dest Processes.user | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `windows_service_stop_via_net__and_sc_application_filter`'



<li><a href="#">NAME: Windows Service Stop Win Updates

DESCRIPTION:  The following analytic identifies a windows update service being disabled  in Windows OS. This technique is being abused by adversaries or threat actors to  add defense mechanisms to their malware implant in the targeted host. Disabling  windows update will put the compromised host vulnerable in some zero day exploit  or even some update features against threats. RedLine Stealer kills this service  as part of its defense evasion mechanism.

SEARCH:  '`wineventlog_system` EventCode=7040 (service_name IN ("Update Orchestrator  Service for Windows Update", "WaaSMedicSvc", "Windows Update") OR param1 IN ("UsoSvc",  "WaaSMedicSvc", "wuauserv")) AND (param3=disabled OR start_mode = disabled) | stats  count min(_time) as firstTime max(_time) as lastTime by Computer Error_Code service_name  start_mode param1 param2 param3 param4 | rename Computer as dest | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `windows_service_stop_win_updates_filter`'



<li><a href="#">NAME: Windows SIP Provider Inventory

DESCRIPTION:  The following inventory analytic is used with a PowerShell scripted inputs to capture all SIP providers on a Windows system. This analytic is used to identify potential malicious SIP providers that may be used to subvert trust controls. Upon review, look for new and non-standard paths for SIP providers.

SEARCH:  '`subjectinterfacepackage` Dll=*\\*.dll | stats count min(_time) as firstTime max(_time) as lastTime values(Dll) by Path host| `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`| `windows_sip_provider_inventory_filter`'



<li><a href="#">NAME: Windows SIP WinVerifyTrust Failed Trust Validation

DESCRIPTION:  The following analytic utilizes a Windows Event Log - CAPI2 - or CryptoAPI 2, to identify failed trust validation. Typically, this event log is meant for diagnosing PKI issues, however is a great source to identify failed trust validation. Note that this event log is noisy as it captures common PKI requests from many different processes. EventID 81 is generated anytime a trust validation fails. The description for EventID 81 is "The digital signature of the object did not verify." STRT tested this analytic using Mimikatz binary.

SEARCH:  '`capi2_operational` EventID=81 "The digital signature of the object did not verify." | xmlkv UserData_Xml | stats count min(_time) as firstTime max(_time) as lastTime by Computer, UserData_Xml | rename Computer as dest | `windows_sip_winverifytrust_failed_trust_validation_filter`'



<li><a href="#">NAME: Windows Snake Malware File Modification Crmlog

DESCRIPTION:  The following analytic identfies a .crmlog written to windows\registration. Per the report, typically, this file has been found within the %windows%\Registration directory with the format of <RANDOM_GUID>.<RANDOM_GUID>.crmlog and is decrypted by Snake's kernel driver.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Filesystem where Filesystem.file_path="*\\windows\\registration\\*" AND  Filesystem.file_name="*.crmlog"  by Filesystem.file_create_time Filesystem.process_id  Filesystem.file_name  Filesystem.file_path Filesystem.dest | `drop_dm_object_name(Filesystem)` | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)`| `windows_snake_malware_file_modification_crmlog_filter`'



<li><a href="#">NAME: Windows Snake Malware Kernel Driver Comadmin

DESCRIPTION:  'The following analytic identifies the comadmin.dat file written to disk, which is related to Snake Malware. From the report, Snakes installer drops the kernel driver and a custom DLL which is used to load the driver into a  single AES encrypted file on disk. Typically, this file is named comadmin.dat and is stored in the %windows%\system32\Com directory.'

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Filesystem where Filesystem.file_path="*\\windows\\system32\\com\\*" AND Filesystem.file_name="comadmin.dat"  by Filesystem.file_create_time Filesystem.process_id  Filesystem.file_name  Filesystem.file_path Filesystem.dest | `drop_dm_object_name(Filesystem)` | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `windows_snake_malware_kernel_driver_comadmin_filter`'



<li><a href="#">NAME: Windows Snake Malware Registry Modification wav OpenWithProgIds

DESCRIPTION:  The follow analytic identifies the registry being modified at .wav\\OpenWithProgIds\, which is related to the Snake Malware campaign. Upon execution, Snake's WerFault.exe will attempt to decrypt an encrypted blob within the Windows  registry that is typically found at HKLM:\SOFTWARE\Classes\.wav\OpenWithProgIds. The encrypted data includes the AES key, IV, and path that is used to find and decrypt the file containing Snake's kernel driver and kernel driver loader.

SEARCH:  '| tstats `security_content_summariesonly` count values(Registry.registry_key_name)  as registry_key_name values(Registry.registry_path) as registry_path min(_time)  as firstTime max(_time) as lastTime from datamodel=Endpoint.Registry where Registry.registry_path="*\\.wav\\OpenWithProgIds\\*"  by Registry.dest  Registry.user  Registry.registry_path Registry.registry_key_name Registry.registry_value_name |  `security_content_ctime(lastTime)` | `security_content_ctime(firstTime)` | `drop_dm_object_name(Registry)` | `windows_snake_malware_registry_modification_wav_openwithprogids_filter`'



<li><a href="#">NAME: Windows Snake Malware Service Create

DESCRIPTION:  'The following analytic identifies a new service WerFaultSvc being created with a binary path located in the windows winsxs path. Per the report, the Snake version primarily discussed in this advisory registers a service to maintain persistence on a system. Typically this service is named WerFaultSvc which we assess was used to blend in with the legitimate Windows service WerSvc. On boot, this service will execute Snakes WerFault.exe,  which Snake developers chose to hide among the numerous valid Windows WerFault.exe files in the windows WinSxS directory. Executing WerFault.exe will start the process of decrypting Snakes components and loading them into memory.'

SEARCH:  '`wineventlog_system` EventCode=7045  ImagePath="*\\windows\\winSxS\\*" ImagePath="*\Werfault.exe"  | stats count min(_time) as firstTime max(_time) as lastTime by Computer EventCode ImagePath ServiceName ServiceType | rename Computer as dest  | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `windows_snake_malware_service_create_filter`'



<li><a href="#">NAME: Windows SOAPHound Binary Execution

DESCRIPTION:  The following analytic identifies the common command-line argument used  by SOAPHound `soaphound.exe`. Being the script is publicly available, function names may be modified,  but these changes are dependent upon the operator. In most instances the defaults  are used.  It does not cover the entirety of every argument in order to avoid false positives.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time) as lastTime from datamodel=Endpoint.Processes where Processes.process_name="soaphound.exe" OR Processes.original_file_name="soaphound.exe" AND Processes.process IN ("*--buildcache *", "*--bhdump *", "*--certdump *", "*--dnsdump *", "*-c *", "*--cachefilename *", "*-o *", "*--outputdirectory *") by Processes.process Processes.dest Processes.process_current_directory Processes.process_name Processes.process_path Processes.process_integrity_level Processes.parent_process Processes.parent_process_path Processes.parent_process_guid Processes.parent_process_id Processes.process_guid Processes.process_id Processes.user  | `drop_dm_object_name(Processes)`   | `security_content_ctime(firstTime)`   | `security_content_ctime(lastTime)`| `windows_soaphound_binary_execution_filter`'



<li><a href="#">NAME: Windows Spearphishing Attachment Connect To None MS Office Domain

DESCRIPTION:  this detection was designed to identifies suspicious office documents  that connect to a website aside from Microsoft Office Domain. This technique was  seen in several malicious documents that abuses .rels xml properties of MS office  to connect or download malicious files. This hunting query can be a good pivot or  guide to check what URL link it tries to connect, what domain, where the documents  came from and how the connection happens.

SEARCH:  '`sysmon` EventCode=22 Image IN ("*\\winword.exe","*\\excel.exe","*\\powerpnt.exe","*\\mspub.exe","*\\visio.exe","*\\wordpad.exe","*\\wordview.exe","*\\onenote.exe",  "*\\onenotem.exe","*\\onenoteviewer.exe","*\\onenoteim.exe", "*\\msaccess.exe")  AND NOT(QueryName IN ("*.office.com", "*.office.net")) | stats count min(_time)  as firstTime max(_time) as lastTime by Image QueryName QueryResults QueryStatus  Computer | rename Computer as dest | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `windows_spearphishing_attachment_connect_to_none_ms_office_domain_filter`'



<li><a href="#">NAME: Windows Spearphishing Attachment Onenote Spawn Mshta

DESCRIPTION:  The following detection identifies the latest behavior utilized by different  malware families (including TA551, AsyncRat, Redline and DCRAT). This detection  identifies onenote Office Product spawning `mshta.exe`. In malicious instances,  the command-line of `mshta.exe` will contain the `hta` file locally, or a URL to  the remote destination. In addition, Threat Research has released a detections identifying  suspicious use of `mshta.exe`. In this instance, we narrow our detection down to  the Office suite as a parent process. During triage, review all file modifications.  Capture and analyze any artifacts on disk. The Office Product, or `mshta.exe` will  have reached out to a remote destination, capture and block the IPs or domain. Review  additional parallel processes for further activity.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.parent_process_name  IN ("onenote.exe", "onenotem.exe") `process_mshta` by Processes.dest Processes.user  Processes.parent_process Processes.process_name Processes.original_file_name Processes.process  Processes.process_id Processes.parent_process_id | `drop_dm_object_name(Processes)`  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `windows_spearphishing_attachment_onenote_spawn_mshta_filter`'



<li><a href="#">NAME: Windows Special Privileged Logon On Multiple Hosts

DESCRIPTION:  The following analytic leverages Event ID 4672 to identify a source user  authenticating with special privileges across a large number remote endpoints. Specifically,  the logic will trigger when a source user obtains special privileges across 30 or  more target computers within a 5 minute timespan. Special privileges are assigned  to a new logon session when sensitive privileges like SeDebugPrivilege and SeImpersonatePrivilege  are assigned. This behavior could represent an adversary who is moving laterally  and executing remote code across the network. It can also be triggered by other  behavior like an adversary enumerating network shares. As environments differ across  organizations, security teams should customize the thresholds of this detection  as needed.

SEARCH:  ' `wineventlog_security` EventCode=4672 AND NOT(Caller_User_Name IN ("DWM-1","DWM-2","DWM-3","LOCAL SERVICE","NETWORK SERVICE","SYSTEM","*$")) | bucket span=5m _time | stats dc(Computer)  AS unique_targets values(Computer) as host_targets values(PrivilegeList) as privileges  by _time, Caller_User_Name | rename Caller_User_Name as user| where unique_targets > 30 | `windows_special_privileged_logon_on_multiple_hosts_filter`'



<li><a href="#">NAME: Windows SQL Spawning CertUtil

DESCRIPTION:  The following analytic detects the use of certutil to download software,  a behavior exhibited by the threat actor Flax Typhoon. This actor deploys a VPN  connection by downloading an executable file for SoftEther VPN from their network  infrastructure using one of several LOLBins, including certutil. The actor then  uses the Service Control Manager (SCM) to create a Windows service that launches  the VPN connection automatically when the system starts. This behavior allows the  actor to monitor the availability of the compromised system and establish an RDP  connection. This analytic identifies this behavior by monitoring for the use of  certutil in conjunction with the downloading of software. This behavior is worth  identifying for a SOC as it indicates a potential compromise of the system and the  establishment of a persistent threat. If a true positive is found, it suggests an  attacker has gained access to the environment and is attempting to maintain that  access, potentially leading to further malicious activities such as data theft or  ransomware attacks. Be aware of potential false positives - legitimate uses of certutil  in your environment may cause benign activities to be flagged. Upon triage, review  the command executed and look for concurrent processes to identify the attack source.  This approach helps analysts detect potential threats earlier and mitigate the risks.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.parent_process_name  IN ("sqlservr.exe", "sqlagent.exe", "sqlps.exe", "launchpad.exe", "sqldumper.exe")  `process_certutil` (Processes.process=*urlcache* Processes.process=*split*) OR Processes.process=*urlcache*  by Processes.dest Processes.user Processes.parent_process Processes.parent_process_name  Processes.process_name Processes.process Processes.process_id Processes.original_file_name  Processes.parent_process_id | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `windows_sql_spawning_certutil_filter`'



<li><a href="#">NAME: Windows Steal Authentication Certificates Certificate Issued

DESCRIPTION:  The following analytic identifies when a new certificate is issued against  the Certificate Services - AD CS. By its very nature this is not malicious, but  should be tracked and correlated with other events related to certificates being  issued. When the CA issues the certificate, it creates EID 4887 'Certificate Services  approved a certificate request and issued a certificate". The event supplies the  requester user context, the DNS hostname of the machine they requested the certificate  from, and the time they requested the certificate. The attributes fields in these  event commonly has values for CDC, RMD, and CCM which correspond to Client DC, Request  Machine DNS name, and Cert Client Machine, respectively.

SEARCH:  '`wineventlog_security`  EventCode=4887 | stats count min(_time) as firstTime  max(_time) as lastTime by dest, name, Requester, action, Attributes, Subject | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)`| `windows_steal_authentication_certificates_certificate_issued_filter`'



<li><a href="#">NAME: Windows Steal Authentication Certificates Certificate Request

DESCRIPTION:  The following analytic identifies when a new certificate is requested  against the Certificate Services - AD CS. By its very nature this is not malicious,  but should be tracked and correlated with other events related to certificate requests.  When an account requests a certificate, the CA generates event ID (EID) 4886 "Certificate  Services received a certificate request".

SEARCH:  '`wineventlog_security` EventCode=4886 | stats count min(_time) as firstTime  max(_time) as lastTime by dest, name, Requester, action, Attributes | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `windows_steal_authentication_certificates_certificate_request_filter`'



<li><a href="#">NAME: Windows Steal Authentication Certificates CertUtil Backup

DESCRIPTION:  The following analytic is focused on CertUtil.exe performing a backup  of the Certificate Store. Typically, administrators may perform this task to migrate  or perform backups of the store, however it may be found uncommon in most organizations.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where `process_certutil` Processes.process  IN ("*-backupdb *", "*-backup *") by Processes.dest Processes.user Processes.parent_process_name  Processes.process_name Processes.original_file_name Processes.process Processes.process_id  Processes.parent_process_id | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `windows_steal_authentication_certificates_certutil_backup_filter`'



<li><a href="#">NAME: Windows Steal Authentication Certificates CryptoAPI

DESCRIPTION:  The following analytic utilizes a Windows Event Log - CAPI2 - or CryptoAPI  2, to identify suspicious certificate extraction. Typically, this event log is meant  for diagnosing PKI issues, however is a great source to identify certificate exports.  Note that this event log is noisy as it captures common PKI requests from many different  processes. EventID 70 is generated anytime a certificate is exported. The description  for EventID 70 is "Acquire Certificate Private Key". STRT tested this analytic using  Mimikatz binary and the implementation of Mimikatz in Cobalt Strike.

SEARCH:  '`capi2_operational` EventCode=70 | xmlkv UserData_Xml | stats count min(_time)  as firstTime max(_time) as lastTime by Computer, UserData_Xml | rename Computer  as dest | `security_content_ctime(firstTime)`| `security_content_ctime(lastTime)`  | `windows_steal_authentication_certificates_cryptoapi_filter`'



<li><a href="#">NAME: Windows Steal Authentication Certificates CS Backup

DESCRIPTION:  The following analytic identifies when the Active Directory Certificate  Services store is backed up utilizing Event ID 4876. This event triggers whenever  the backup occurs in the UI of CertSrv.msc or via CertUtil.exe -BackupDB occurs.

SEARCH:  '`wineventlog_security` EventCode=4876| stats count min(_time) as firstTime  max(_time) as lastTime by dest, name, action, Caller_Domain ,Caller_User_Name |  `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `windows_steal_authentication_certificates_cs_backup_filter`'



<li><a href="#">NAME: Windows Steal Authentication Certificates Export Certificate

DESCRIPTION:  The following analytic identifies the use of export-certificate, the  PowerShell cmdlet, being utilized on the command-line in an attempt to export the  certifcate from the local Windows Certificate Store.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.process="*export-certificate*"  by Processes.dest Processes.user Processes.parent_process_name Processes.process_name  Processes.process Processes.process_id Processes.parent_process_id | `drop_dm_object_name(Processes)`  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `windows_steal_authentication_certificates_export_certificate_filter`'



<li><a href="#">NAME: Windows Steal Authentication Certificates Export PfxCertificate

DESCRIPTION:  The following analytic identifies the use of export-pfxcertificate, the  PowerShell cmdlet, being utilized on the command-line in an attempt to export the  certifcate from the local Windows Certificate Store.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.process="*export-pfxcertificate*"  by Processes.dest Processes.user Processes.parent_process_name Processes.process_name  Processes.process Processes.process_id Processes.parent_process_id | `drop_dm_object_name(Processes)`  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `windows_steal_authentication_certificates_export_pfxcertificate_filter`'



<li><a href="#">NAME: Windows Steal Authentication Certificates - ESC1 Abuse

DESCRIPTION:  The following analytic identifies when a new certificate is requested and/or granted against the Active Directory Certificate Services (AD CS) using a Subject Alternative Name (SAN). This action by its self is not malicious, however improperly configured certificate templates can be abused to permit privilege escalation and environment compromise due to over permissive settings (AD CS ESC1)

SEARCH:  >-  `wineventlog_security` EventCode IN (4886,4887) Attributes="*SAN:*upn*" Attributes="*CertificateTemplate:*"  | stats count min(_time) as firstTime max(_time) as lastTime values(name) as name values(status) as status values(Subject) as ssl_subject  values(SubjectKeyIdentifier) as ssl_hash by Computer, EventCode, Requester, Attributes, RequestId  | `security_content_ctime(firstTime)`   | `security_content_ctime(lastTime)`| fillnull  | rex field=Attributes "(?i)CertificateTemplate:(?<object>[^\r\n]+)"  | rex field=Attributes "(?i)ccm:(?<req_src>[^\r\n]+)"  | rex max_match=10 field=Attributes "(?i)(upn=(?<req_user_1>[^\r\n&]+))"  | rex max_match=10 field=Attributes "(?i)(dns=(?<req_dest_1>[^\r\n&]+))"  | rex field=Requester "(.+\\\\)?(?<src_user>[^\r\n]+)"  | eval flavor_text = case(EventCode=="4886","A suspicious certificate was requested using request ID: ".'RequestId',EventCode=="4887", "A suspicious certificate was issued using request ID: ".'RequestId'.". To revoke this certifacte use this request ID or the SSL fingerprint [".'ssl_hash'."]"), dest = upper(coalesce(req_dest_1,req_dest_2)), src = upper(coalesce(req_src,Computer)) | fields - req_* | rename Attributes as object_attrs, EventCode as signature_id, name as signature, RequestId as ssl_serial, Requester as ssl_subject_common_name| `windows_steal_authentication_certificates___esc1_abuse_filter`



<li><a href="#">NAME: Windows Steal Authentication Certificates - ESC1 Authentication

DESCRIPTION:  The following analytic identifies when a suspicious certificate is granted using Active Directory Certificate Services (AD CS) with a Subject Alternative Name (SAN) and then immediately used for authentication. This action alone may not be malicious, however improperly configured certificate templates can be abused to permit privilege escalation and environment compromise due to over permissive settings (AD CS ESC1).

SEARCH:  >-  `wineventlog_security` EventCode IN (4887) Attributes="*SAN:*upn*" Attributes="*CertificateTemplate:*"  | stats count min(_time) as firstTime max(_time) as lastTime values(name) as name values(status) as status values(Subject) as ssl_subject values(SubjectKeyIdentifier) as ssl_hash by Computer, EventCode, Requester, Attributes, RequestId  | rex field=Attributes "(?i)CertificateTemplate:(?<object>[^\r\n]+)"  | rex field=Attributes "(?i)ccm:(?<req_src>[^\r\n]+)"  | rex max_match=10 field=Attributes "(?i)(upn=(?<req_user_1>[^\r\n&]+))"  | rex max_match=10 field=Attributes "(?i)(dns=(?<req_dest_1>[^\r\n&]+))"  | rex field=Requester "(.+\\\\)?(?<src_user>[^\r\n]+)"  | rename Attributes as object_attrs, EventCode as signature_id, name as signature, RequestId as ssl_serial, Requester as ssl_subject_common_name  | eval user = lower(coalesce(req_user_1,req_user_2))   | join user  [  | search `wineventlog_security` EventCode=4768 CertThumbprint=*  | rename TargetUserName as user, Computer as auth_dest, IpAddress as auth_src  | fields auth_src,auth_dest,user  ]  | eval src = upper(coalesce(auth_src,req_src)), dest = upper(coalesce(auth_dest,req_dest_1,req_dest_2)), risk_score = 90  | eval flavor_text = case(signature_id=="4887", "User account [".'user'."] authenticated after a suspicious certificate was issued for it by [".'src_user'."] using certificate request ID: ".'ssl_serial')  | fields - req_* auth_*  | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)`  | `windows_steal_authentication_certificates___esc1_authentication_filter`



<li><a href="#">NAME: Windows Steal or Forge Kerberos Tickets Klist

DESCRIPTION:  The following analytic identifies a process execution of Windows OS klist.exe  tool. This tool is being abused or used by several post exploitation tool such as  winpeas that being used by ransomware prestige to display or gather list of currently  cached kerberos ticket. This cahced data can be used for lateral movement or even  privilege escalation on the targeted host. This hunting query can be a good pivot  in possible kerberos attack or pass the hash technique.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.process_name="klist.exe"  OR Processes.original_file_name = "klist.exe" Processes.parent_process_name IN ("cmd.exe",  "powershell*") by Processes.process_name Processes.original_file_name Processes.process  Processes.process_id Processes.process_guid Processes.parent_process_name Processes.parent_process  Processes.parent_process_guid Processes.dest Processes.user | `drop_dm_object_name(Processes)`  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `windows_steal_or_forge_kerberos_tickets_klist_filter`'



<li><a href="#">NAME: Windows Suspect Process With Authentication Traffic

DESCRIPTION:  >-  This analytic identifies executables running from public or temporary locations that are communicating over windows domain  authentication ports/protocol. The ports/protocols include LDAP(389), LDAPS(636), and Kerberos(88). Authentications from applications   running from user controlled locations may not be malicious, however actors often attempt to access domain resources after initial   compromise from executables in these locations.

SEARCH:  >-  | tstats `security_content_summariesonly` count min(_time) as firstTime max(_time) as lastTime values(All_Traffic.process_id) as process_id   from datamodel=Network_Traffic.All_Traffic where All_Traffic.dest_port IN ("88","389","636")   AND All_Traffic.app IN ("*\\users\\*", "*\\programdata\\*", "*\\temp\\*", "*\\Windows\\Tasks\\*", "*\\appdata\\*", "*\\perflogs\\*")   by All_Traffic.app,All_Traffic.src,All_Traffic.src_ip,All_Traffic.user,All_Traffic.dest,All_Traffic.dest_ip,All_Traffic.dest_port  | `drop_dm_object_name(All_Traffic)`   | rex field=app ".*\\\(?<process_name>.*)$"  | rename app as process  | `security_content_ctime(firstTime)`   | `security_content_ctime(lastTime)`  | `windows_suspect_process_with_authentication_traffic_filter`



<li><a href="#">NAME: Windows System Binary Proxy Execution Compiled HTML File Decompile

DESCRIPTION:  The following analytic identifies the decompile parameter with the HTML  Help application, HH.exe. This is a uncommon command to see ran and behavior. Most  recently this was seen in a APT41 campaign where a CHM file was delivered and a  script inside used a technique for running an arbitrary command in a CHM file via  an ActiveX object. This unpacks an HTML help file to a specified path for launching  the next stage.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where `process_hh` Processes.process=*-decompile*  by Processes.dest Processes.user Processes.parent_process_name Processes.process_name  Processes.process Processes.process_id Processes.parent_process_id | `drop_dm_object_name(Processes)`  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `windows_system_binary_proxy_execution_compiled_html_file_decompile_filter`'



<li><a href="#">NAME: Windows System Discovery Using ldap Nslookup

DESCRIPTION:  The following analytic identifies the execution of nslookup.exe tool  to get domain information. Nslookup.exe is a command-line tool that can display  information to diagnose domain name systems. This Nslookup feature is being abused  by Qakbot malware to gather domain information such as SRV service location records,  server name and many more.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where (Processes.process_name = "nslookup.exe"  OR Processes.original_file_name = "nslookup.exe") AND Processes.process = "*_ldap._tcp.dc._msdcs*"  by Processes.parent_process Processes.parent_process_name Processes.process_name  Processes.process_id Processes.process_guid Processes.process Processes.user Processes.dest  Processes.parent_process_id Processes.original_file_name | `drop_dm_object_name("Processes")`  | `security_content_ctime(firstTime)` |`security_content_ctime(lastTime)` | `windows_system_discovery_using_ldap_nslookup_filter`'



<li><a href="#">NAME: Windows System Discovery Using Qwinsta

DESCRIPTION:  The following analytic identifies the execution of qwinsta.exe executable  in Windows Operating System. This Windows executable file can display information  about sessions on a remote desktop session host server. The information includes  servername, sessionname, username and many more. This tool is being abused of Qakbot  malware to gather information to the targeted or compromised host that will be send  back to its Command And Control server.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.process_name = "qwinsta.exe"  OR Processes.original_file_name = "qwinsta.exe" by Processes.parent_process Processes.parent_process_name  Processes.process_name Processes.process_id Processes.process_guid Processes.process  Processes.user Processes.dest Processes.parent_process_id Processes.original_file_name  | `drop_dm_object_name("Processes")` | `security_content_ctime(firstTime)` |`security_content_ctime(lastTime)`  | `windows_system_discovery_using_qwinsta_filter`'



<li><a href="#">NAME: Windows System File on Disk

DESCRIPTION:  The following hunting analytic will assist with identifying new .sys  files introduced in the environment. This query is meant to identify sys file creates  on disk. There will be noise, but reducing common process names or applications  should help to limit any volume. The idea is to identify new sys files written to  disk and identify them before they're added as a new kernel mode driver.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime FROM datamodel=Endpoint.Filesystem where Filesystem.file_name="*.sys*"  by _time span=1h Filesystem.dest Filesystem.file_create_time Filesystem.file_name  Filesystem.file_path Filesystem.file_hash | `drop_dm_object_name(Filesystem)` |  `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`| `windows_system_file_on_disk_filter`'



<li><a href="#">NAME: Windows System LogOff Commandline

DESCRIPTION:  The following analytic identifies Windows commandline to logoff a windows  host machine. This technique was seen in several APT, RAT like dcrat and other commodity  malware to shutdown the machine to add more impact, interrupt access, aid destruction  of the system like wiping disk or inhibit system recovery. This TTP is a good pivot  to check why application trigger this commandline which is not so common way to  logoff a machine.

SEARCH:  '| tstats `security_content_summariesonly` values(Processes.process) as process  min(_time) as firstTime max(_time) as lastTime from datamodel=Endpoint.Processes  where (Processes.process_name = shutdown.exe OR Processes.original_file_name = shutdown.exe)  Processes.process="*shutdown*" Processes.process IN ("* /l*", "* -l*") Processes.process IN ("* /t*","* -t*","* /f*","* -f*")  by Processes.dest Processes.user Processes.parent_process Processes.process_name  Processes.original_file_name Processes.process Processes.process_id Processes.parent_process_id  | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `windows_system_logoff_commandline_filter`'



<li><a href="#">NAME: Windows System Network Config Discovery Display DNS

DESCRIPTION:  The following analytic identifies a process command line that retrieves  dns reply information using Windows OS built-in tool IPConfig. This technique is  being abused by threat actors, adversaries and post exploitation tools like WINPEAS  to retrieve DNS information for the targeted host. This IPConfig parameter (/displaydns)  can show dns server resource record, record name, record type, time to live data  length and dns reply. This hunting detection can be a good pivot to check which  process is executing this command line in specific host system that may lead to  malware or adversaries gathering network information.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.process_name="ipconfig.exe"  OR Processes.original_file_name = "ipconfig.exe" AND Processes.process = "*/displaydns*"  by Processes.process_name Processes.original_file_name Processes.process Processes.process_id  Processes.process_guid Processes.parent_process_name Processes.parent_process Processes.parent_process_guid  Processes.dest Processes.user | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `windows_system_network_config_discovery_display_dns_filter`'



<li><a href="#">NAME: Windows System Network Connections Discovery Netsh

DESCRIPTION:  The following analytic identifies a process execution of Windows OS built-in  tool netsh.exe to show state, configuration and profile of host firewall. This tool  is being used or abused by several adversaries or even post exploitation tool to  bypass firewall rules or to discover firewall settings. This hunting detection can  help to detect a possible suspicious usage of netsh.exe to retrieve firewall settings  or even firewall wlan profile. We recommend checking which parent process and process  name execute this command. Also check the process file path for verification that  may lead to further TTP's threat behavior.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where `process_netsh`AND Processes.process  = "* show *" Processes.process IN ("*state*", "*config*", "*wlan*", "*profile*")  by Processes.process_name Processes.original_file_name Processes.process Processes.process_id  Processes.process_guid Processes.parent_process_name Processes.parent_process Processes.parent_process_guid  Processes.dest Processes.user | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `windows_system_network_connections_discovery_netsh_filter`'



<li><a href="#">NAME: Windows System Reboot CommandLine

DESCRIPTION:  The following analytic identifies Windows commandline to reboot a windows  host machine. This technique was seen in several APT, RAT like dcrat and other commodity  malware to shutdown the machine to add more impact, interrupt access, aid destruction  of the system like wiping disk or inhibit system recovery. This TTP is a good pivot  to check why application trigger this commandline which is not so common way to  reboot a machine. Compare to shutdown and logoff shutdown.exe feature, reboot seen  in some automation script like ansible to reboot the machine.

SEARCH:  '| tstats `security_content_summariesonly` values(Processes.process) as process  min(_time) as firstTime max(_time) as lastTime from datamodel=Endpoint.Processes  where (Processes.process_name = shutdown.exe OR Processes.original_file_name = shutdown.exe)  Processes.process="*shutdown*" Processes.process IN ("* /r*", "* -r*") Processes.process IN ("* /t*","* -t*","* /f*","* -f*")  by Processes.dest Processes.user Processes.parent_process Processes.process_name  Processes.original_file_name Processes.process Processes.process_id Processes.parent_process_id  | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `windows_system_reboot_commandline_filter`'



<li><a href="#">NAME: Windows System Script Proxy Execution Syncappvpublishingserver

DESCRIPTION:  The following analytic identifies the abuse of Syncappvpublishingserver.vbs,  which is a native script on Windows that may be utilized to download remote files  or perform privilege escalation.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.process_name IN ("wscript.exe","cscript.exe")  Processes.process="*syncappvpublishingserver.vbs*" by Processes.dest Processes.user  Processes.parent_process_name Processes.process_name Processes.process Processes.process_id  Processes.parent_process_id | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `windows_system_script_proxy_execution_syncappvpublishingserver_filter`'



<li><a href="#">NAME: Windows System Shutdown CommandLine

DESCRIPTION:  This detection rule is designed to identify the execution of the Windows  shutdown command via command line interface. The shutdown command can be utilized  by system administrators to properly halt, power off, or reboot a computer. However,  in a security context, attackers who have gained unauthorized access to a system  may also use this command in an effort to erase tracks, or to cause disruption and  denial of service. In some instances, they might execute the shutdown command after  installing a backdoor, to force the system to restart, ensuring that changes take  effect or evading detection by security tools. Monitoring for the use of the Windows  shutdown command, especially in conjunction with other unusual or unauthorized activities,  can be an important part of identifying malicious behavior within a network. It  is advised that security professionals analyze the context in which the shutdown  command is being executed to differentiate between legitimate administrative functions  and potentially malicious activity.

SEARCH:  '| tstats `security_content_summariesonly` values(Processes.process) as process  min(_time) as firstTime max(_time) as lastTime from datamodel=Endpoint.Processes  where (Processes.process_name = shutdown.exe OR Processes.original_file_name = shutdown.exe)  Processes.process="*shutdown*" AND Processes.process IN("* /s*", "* -s*") AND Processes.process IN ("* /t*","* -t*","* /f*","* -f*")  by Processes.dest Processes.user Processes.parent_process Processes.process_name  Processes.original_file_name Processes.process Processes.process_id Processes.parent_process_id  | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `windows_system_shutdown_commandline_filter`'



<li><a href="#">NAME: Windows System Time Discovery W32tm Delay

DESCRIPTION:  The following analytic identifies DCRat delay time tactics using w32tm.  This technique was seen in DCRAT malware where it uses stripchart function of w32tm.exe  application to delay the execution of its payload like c2 communication , beaconing  and execution. This anomaly detection may help the analyst to check other possible  event like the process who execute this command that may lead to DCRat attack.

SEARCH:  '| tstats `security_content_summariesonly` values(Processes.process) as process  min(_time) as firstTime max(_time) as lastTime from datamodel=Endpoint.Processes  where Processes.process_name = w32tm.exe Processes.process= "* /stripchart *" Processes.process=  "* /computer:localhost *" Processes.process= "* /period:*" Processes.process= "*  /dataonly *" Processes.process= "* /samples:*" by  Processes.parent_process Processes.process_name  Processes.original_file_name Processes.process Processes.process_id Processes.parent_process_id  Processes.dest Processes.user | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `windows_system_time_discovery_w32tm_delay_filter`'



<li><a href="#">NAME: Windows System User Discovery Via Quser

DESCRIPTION:  The following analytic identifies a process execution of Windows OS quser.exe  tool. This tool is being abused or used by several post exploitation tool such as  winpeas that being used by ransomware prestige to display or gather information  about user sessions on a Remote Desktop Session Host server. This command can find  out if a specific user is logged on to a specific Remote Desktop Session Host server.  This tool can retrieve some RDP information that can be use by attacker for further  attack like Name of the user , Name of the session on the Remote Desktop Session  Host server, Session ID, State of the session (active or disconnected), Idle time  (the number of minutes since the last keystroke or mouse movement at the session)  and Date and time the user logged on.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.process_name="quser.exe"  OR Processes.original_file_name = "quser.exe" by Processes.process_name Processes.original_file_name  Processes.process Processes.process_id Processes.process_guid Processes.parent_process_name  Processes.parent_process Processes.parent_process_guid Processes.dest Processes.user  | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `windows_system_user_discovery_via_quser_filter`'



<li><a href="#">NAME: Windows System User Privilege Discovery

DESCRIPTION:  This analytic looks for the execution of `whoami.exe` with /priv parameter.   This whoami command is used to display or shows the privileges assigned to the current user account.   This hunting query can be a good pivot start to look for suspicious usage of whoami application that might related to a malware or adversaries.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time) as lastTime from datamodel=Endpoint.Processes   where Processes.process_name="whoami.exe" Processes.process= "*/priv*" by Processes.dest Processes.user Processes.parent_process Processes.process_name Processes.process Processes.process_id Processes.parent_process_id   | `drop_dm_object_name(Processes)`   | `security_content_ctime(firstTime)`   | `security_content_ctime(lastTime)`   | `windows_system_user_privilege_discovery_filter`'



<li><a href="#">NAME: Windows Terminating Lsass Process

DESCRIPTION:  This analytic is to detect a suspicious process terminating Lsass process.  Lsass process is known to be a critical process that is responsible for enforcing  security policy system. This process was commonly targetted by threat actor or red  teamer to gain privilege escalation or persistence in the targeted machine because  it handles credentials of the logon users. In this analytic we tried to detect a  suspicious process having a granted access PROCESS_TERMINATE to lsass process to  modify or delete protected registrys. This technique was seen in doublezero malware  that tries to wipe files and registry in compromised hosts. This anomaly detection  can be a good pivot of incident response for possible credential dumping or evading  security policy in a host or network environment.

SEARCH:  '`sysmon` EventCode=10 TargetImage=*lsass.exe GrantedAccess = 0x1 | stats  count min(_time) as firstTime max(_time) as lastTime by SourceImage, TargetImage,  TargetProcessId, SourceProcessId, GrantedAccess CallTrace, dest | rename dest  as dest | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `windows_terminating_lsass_process_filter`'



<li><a href="#">NAME: Windows Time Based Evasion

DESCRIPTION:  This analytic is designed to detect potentially malicious processes that initiate a ping delay using an invalid IP address.   This evasion technique was observed in NJRAT, where the malware employed ping commands as a means to introduce a time delay before self-deletion on the compromised host.   Identifying this (TTP) behavior can serve as a valuable indicator for detecting NJRAT infections or other malware that employ time delays as   evasion tactics.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time) as lastTime from datamodel=Endpoint.Processes   where Processes.process_name = "ping.exe" Processes.parent_process = "* ping 0 -n *" OR Processes.process = "* ping 0 -n *"  by Processes.parent_process Processes.process_name Processes.process_id Processes.process_guid Processes.process Processes.user Processes.dest  | `drop_dm_object_name("Processes")`   | `security_content_ctime(firstTime)`   | `security_content_ctime(lastTime)`   | `windows_time_based_evasion_filter`'



<li><a href="#">NAME: Windows Time Based Evasion via Choice Exec

DESCRIPTION:  This analytic is designed to detect potentially suspicious batch files that leverage choice.exe as a delay tactic.   This technique, observed in the SnakeKeylogger malware, is utilized for time delays or 'Sleep' commands in its code execution   or before the deletion of its copies on compromised hosts. Detecting this anomaly serves as a valuable pivot to uncover   suspicious processes attempting to evade detection through time-based evasion techniques.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time) as lastTime from datamodel=Endpoint.Processes   where Processes.process_name =choice.exe  Processes.process = "*/T*"  Processes.process = "*/N*"  by Processes.parent_process_name Processes.process_name Processes.process Processes.process_id Processes.parent_process_id Processes.process_guid Processes.dest Processes.user   | `drop_dm_object_name(Processes)`   | `security_content_ctime(firstTime)`   | `security_content_ctime(lastTime)`   | `windows_time_based_evasion_via_choice_exec_filter`'



<li><a href="#">NAME: Windows UAC Bypass Suspicious Child Process

DESCRIPTION:  The following analytic detects when an executable known for User Account Control bypass exploitation, spawns a child process in user controlled location or a command shell executable (cmd, powershell, etc). This behavioral chain may indicate that an attacker has used a UAC Bypass exploit to successfully escalate privileges.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time) as lastTime from datamodel=Endpoint.Processes where Processes.process_integrity_level IN ("high","system") AND Processes.parent_process_name IN (`uacbypass_process_name`) AND (Processes.process_name IN ("cmd.exe","powershell.exe","pwsh.exe","wscript","cscript.exe","bash.exe","werfault.exe") OR Processes.process IN ("*\\\\*","*\\Users\\*","*\\ProgramData\\*","*\\Temp\\*")) by Processes.dest, Processes.user, Processes.parent_process_guid, Processes.parent_process, Processes.parent_process_name Processes.process_name Processes.process, Processes.process_path, Processes.process_integrity_level, Processes.process_current_directory   | `drop_dm_object_name(Processes)`   | where parent_process_name != process_name   | `security_content_ctime(firstTime)`   | `security_content_ctime(lastTime)`   | `windows_uac_bypass_suspicious_child_process_filter`'



<li><a href="#">NAME: Windows UAC Bypass Suspicious Escalation Behavior

DESCRIPTION:  The following analytic detects when a process spawns an executable known for User Account Control bypass exploitation, and then monitors for any subsequent child processes that are above the integrity level of the original spawning process. This behavioral chain may indicate that an attacker has used a UAC Bypass exploit to successfully escalate privileges.

SEARCH:  '| tstats `security_content_summariesonly` count max(_time) as lastTime from datamodel=Endpoint.Processes where Processes.process_integrity_level IN ("low","medium") by Processes.dest, Processes.user, Processes.process_name, Processes.process, Processes.process_guid, Processes.process_path, Processes.process_integrity_level, Processes.process_current_directory   | `drop_dm_object_name(Processes)`   | eval original_integrity_level = CASE(match(process_integrity_level,"low"),1,match(process_integrity_level,"medium"),2,match(process_integrity_level,"high"),3,match(process_integrity_level,"system"),4,true(),0)   | rename process_guid as join_guid_1, process* as parent_process*   | join max=0 dest join_guid_1       [| tstats `security_content_summariesonly` count min(_time) as firstTime from datamodel=Endpoint.Processes where Processes.process_integrity_level IN ("high","system") AND Processes.process_name IN (`uacbypass_process_name`) by Processes.dest, Processes.parent_process_guid, Processes.process_name, Processes.process_guid       | `drop_dm_object_name(Processes)`       | rename parent_process_guid as join_guid_1, process_guid as join_guid_2, process_name as uac_process_name ]   | join max=0 dest join_guid_2       [| tstats `security_content_summariesonly` count min(_time) as firstTime from datamodel=Endpoint.Processes where Processes.parent_process_name IN (`uacbypass_process_name`) AND Processes.process_integrity_level IN ("high","system") by Processes.dest, Processes.parent_process_guid, Processes.process_name, Processes.process, Processes.process_guid, Processes.process_path, Processes.process_integrity_level, Processes.process_current_directory       | `drop_dm_object_name(Processes)`       | rename parent_process_guid as join_guid_2       | eval elevated_integrity_level = CASE(match(process_integrity_level,"low"),1,match(process_integrity_level,"medium"),2,match(process_integrity_level,"high"),3,match(process_integrity_level,"system"),4,true(),0)]   | where elevated_integrity_level > original_integrity_level   | table dest user parent_process parent_process_name parent_process_integrity_level process_integrity_level process process_name uac_process_name count firstTime lastTime  | `security_content_ctime(firstTime)`   | `security_content_ctime(lastTime)`   | `windows_uac_bypass_suspicious_escalation_behavior_filter`'



<li><a href="#">NAME: Windows Unsecured Outlook Credentials Access In Registry

DESCRIPTION:  The following analytic identifies a suspicious query on outlook credentials registry in Windows OS registry.   typically refers to user profiles associated with Microsoft Outlook. Within this key, Outlook stores configuration settings,   including account information such as email addresses, server details, and authentication credentials. Accessing or modifying   this registry key can potentially compromise users' email security, making it a target for attackers seeking to steal sensitive   information or execute unauthorized actions within Outlook. This anomaly detection is a good pivot to catch possible Trojan Stealer or RAT   that tries to steal sensitive information to its targeted host.

SEARCH:  '`wineventlog_security` EventCode=4663 object_file_path IN ("*\\Profiles\\Outlook\\9375CFF0413111d3B88A00104B2A6676*", "*\\Windows Messaging Subsystem\\Profiles\\9375CFF0413111d3B88A00104B2A6676*")   AND process_name != *\\outlook.exe   | stats count min(_time) as firstTime max(_time) as lastTime by object_file_name object_file_path process_name process_path  process_id EventCode dest   | `security_content_ctime(firstTime)`   | `security_content_ctime(lastTime)`   | `windows_unsecured_outlook_credentials_access_in_registry_filter`'



<li><a href="#">NAME: Windows Unsigned DLL Side-Loading

DESCRIPTION:  This analytic focuses on detecting potentially malicious unsigned DLLs created in either the c:\windows\system32 or c:\windows\syswow64 folders.   This particular technique was observed in the context of the Warzone (Ave Maria) RAT, where it employed a method known as DLL hijacking (dll-side-loading)   by dropping the "dismcore.dll" to achieve privilege escalation.  DLL hijacking is a stealthy attack technique used by cybercriminals to exploit the way Windows searches and loads DLLs. By placing a malicious DLL with the   same name as one that a legitimate application is expected to load, the attacker can gain unauthorized access and execute malicious code.  In the case of Warzone RAT (Ave Maria), the dropped "dismcore.dll" was intended to deceive the system into loading the rogue DLL instead of the legitimate version,   thereby granting the malware elevated privileges and enabling further compromise of the target system.  Detecting such suspicious DLLs is crucial in preventing privilege escalation attacks and other potential security breaches. Regular security assessments, thorough monitoring,   and implementing security best practices are essential in safeguarding systems from such threats.

SEARCH:  '`sysmon` EventCode=7 Signed=false OriginalFileName = "-" SignatureStatus="unavailable" ImageLoaded IN ("*:\\windows\\system32\\*", "*:\\windows\\syswow64\\*")   | stats count min(_time) as firstTime max(_time) as lastTime by Image ImageLoaded Signed SignatureStatus OriginalFileName process_name dest EventCode ProcessId Hashes IMPHASH   | `security_content_ctime(firstTime)`   | `security_content_ctime(lastTime)`   | `windows_unsigned_dll_side_loading_filter`'



<li><a href="#">NAME: Windows User Execution Malicious URL Shortcut File

DESCRIPTION:  This analytic will identify suspicious creation of URL shortcut link  files. This technique was seen in CHAOS ransomware where it will drop this .url  link file in %startup% folder that contains the path of its malicious dropped file  to execute upon the reboot of the targeted host. The creation of this file can be  created by a normal application or software but it is a good practice to verify  this type of file specially the resource it tries to execute which is commonly a  website.

SEARCH:  '|tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Filesystem where NOT(Filesystem.file_path IN  ("*\\Program Files*")) Filesystem.file_name = *.url by Filesystem.file_create_time  Filesystem.process_id  Filesystem.file_name Filesystem.user Filesystem.file_path  Filesystem.process_guid Filesystem.dest | `drop_dm_object_name(Filesystem)` | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `windows_user_execution_malicious_url_shortcut_file_filter`'



<li><a href="#">NAME: Windows Valid Account With Never Expires Password

DESCRIPTION:  The following analytic identifies net.exe updating user account policies  for password requirement with non-expiring password. This technique was seen in  several adversaries and malware like Azorult to maintain the foothold (persistence),  gaining privilege escalation, defense evasion and possible for lateral movement  for specific users or created user account on the targeted host. This TTP detections  is a good pivot to see further what other events that users executes on the machines.

SEARCH:  '| tstats `security_content_summariesonly` values(Processes.process) as process  min(_time) as firstTime max(_time) as lastTime from datamodel=Endpoint.Processes  where `process_net` AND Processes.process="* accounts *" AND Processes.process="*  /maxpwage:unlimited" by Processes.dest Processes.user Processes.parent_process_name Processes.process_name  Processes.original_file_name Processes.process Processes.process_id Processes.parent_process_id  | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `windows_valid_account_with_never_expires_password_filter`'



<li><a href="#">NAME: Windows Vulnerable 3CX Software

DESCRIPTION:  The following analytic leverages Sysmon, a powerful system monitoring and logging tool, to pinpoint instances of the 3CXDesktopApp.exe with a FileVersion of 18.12.x.Recently, 3CX has discovered a vulnerability specifically in versions 18.12.407 and 18.12.416 of the desktop app.

SEARCH:  '`sysmon` (process_name=3CXDesktopApp.exe OR OriginalFileName=3CXDesktopApp.exe)  FileVersion=18.12.* | stats count min(_time) as firstTime max(_time) as lastTime by dest, parent_process_name,process_name, OriginalFileName, CommandLine   | `security_content_ctime(firstTime)`   | `security_content_ctime(lastTime)`| `windows_vulnerable_3cx_software_filter`'



<li><a href="#">NAME: Windows Vulnerable Driver Loaded

DESCRIPTION:   The following analytic utilizes a known list of vulnerable Windows drivers  to help defenders find potential persistence or privelege escalation via a vulnerable  driver. This analytic uses Sysmon EventCode 6, driver loading. A known gap with  this lookup is that it does not use the hash or known signer of the vulnerable driver  therefore it is up to the defender to identify version and signing info and confirm  it is a vulnerable driver.

SEARCH:   "`sysmon` EventCode=6 | lookup loldrivers driver_name AS ImageLoaded OUTPUT  is_driver driver_description | search is_driver = TRUE | stats  min(_time) as firstTime  max(_time) as lastTime count by dest ImageLoaded driver_description | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `windows_vulnerable_driver_loaded_filter`"



<li><a href="#">NAME: Windows WinDBG Spawning AutoIt3

DESCRIPTION:  The following analytic identifies instances of the WinDBG process spawning AutoIt3. This behavior may indicate malicious activity as AutoIt3 is often used by threat actors for scripting malicious automation. The search specifically looks for instances where the parent process name is 'windbg.exe' and the process name is 'autoit3.exe' or 'autoit*.exe'. During the triage process, it is recommended to review the file path for additional artifacts that may provide further insights into the event.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time) as lastTime from datamodel=Endpoint.Processes  where Processes.parent_process_name=windbg.exe  AND (Processes.process_name IN ("autoit3.exe", "autoit*.exe") OR Processes.original_file_name IN ("autoit3.exe", "autoit*.exe")) by Processes.dest, Processes.user, Processes.parent_process_name, Processes.process_name, Processes.original_file_name, Processes.process, Processes.process_id, Processes.parent_process_id  | `drop_dm_object_name(Processes)`   | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)`  | eval matches_extension=if(match(process, "\\.(au3|a3x|exe|aut|aup)$"), "Yes", "No")  | search matches_extension="Yes" | `windows_windbg_spawning_autoit3_filter`'



<li><a href="#">NAME: Windows WinLogon with Public Network Connection

DESCRIPTION:  'The following analytic is designed to detect anomalous behavior associated  with the BlackLotus Campaign, a sophisticated bootkit attack reported by ESET and  further investigated in a blog by Microsoft, which provided hunting queries for  security analysts. The primary focus of this analytic is to identify instances of  Winlogon.exe, a critical Windows process, connecting to public IP space, which is  indicative of potential malicious activity.\ The BlackLotus Campaign is a bootkit-based  attack that compromises system integrity by infecting the Master Boot Record (MBR)  and Volume Boot Record (VBR). This malware variant can bypass traditional security  measures, load before the operating system, and maintain persistence on the target  system.\  Winlogon.exe is a critical Windows process responsible for managing user logon and  logoff processes. Under normal circumstances, Winlogon.exe should not be connecting  to public IP addresses. However, if it does, it may indicate that the process has  been compromised as part of the BlackLotus Campaign or another malicious operation.\  This analytic monitors network connections made by Winlogon.exe and triggers an  alert if it detects connections to public IP space. By identifying such anomalous  behavior, security analysts can investigate further and respond swiftly to potential  threats.'

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.process_name IN (winlogon.exe)  Processes.process!=unknown  by Processes.dest Processes.user Processes.parent_process_name Processes.process_name  Processes.process Processes.process_id Processes.parent_process_id | `drop_dm_object_name(Processes)`  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | join  process_id  [| tstats `security_content_summariesonly` count FROM datamodel=Network_Traffic.All_Traffic  where All_Traffic.dest_port != 0 NOT (All_Traffic.dest IN (127.0.0.1,10.0.0.0/8,172.16.0.0/12,  192.168.0.0/16, 0:0:0:0:0:0:0:1)) by All_Traffic.process_id All_Traffic.dest All_Traffic.dest_port  | `drop_dm_object_name(All_Traffic)` | rename dest as publicIp ] | table dest parent_process_name  process_name process_path process process_id dest_port publicIp | `windows_winlogon_with_public_network_connection_filter`'



<li><a href="#">NAME: Windows WMI Impersonate Token

DESCRIPTION:  The following analytic identifies a possible wmi token impersonation  activities in a process or command. This technique was seen in Qakbot malware where  it will execute a vbscript code contains wmi impersonation object to gain privilege  escalation or as defense evasion. This Anomaly detection looks for wmiprvse.exe  SourceImage having a duplicate handle or full granted access in a target process.

SEARCH:  '`sysmon` EventCode=10 SourceImage = "*\\wmiprvse.exe"  GrantedAccess IN ("0x1478",  "0x1fffff") | stats count min(_time) as firstTime max(_time) as lastTime by SourceImage  TargetImage SourceProcessGUID TargetProcessGUID SourceProcessId TargetProcessId  GrantedAccess CallTrace dest | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `windows_wmi_impersonate_token_filter`'



<li><a href="#">NAME: Windows WMI Process And Service List

DESCRIPTION:  The following analytic identifies suspicious process command line, where  WMI is performing an event query looking for running processes or running services.  This technique is commonly found where the adversary will identify services and  system information on the compromised machine. During triage, review parallel processes  within the same timeframe. Review the full script block to identify other related  artifacts.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where `process_wmic` Processes.process  IN ("*process list*", "*service list*") by Processes.process_name Processes.original_file_name  Processes.process Processes.process_id Processes.process_guid Processes.parent_process_name  Processes.parent_process Processes.parent_process_guid Processes.dest Processes.user  | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `windows_wmi_process_and_service_list_filter`'



<li><a href="#">NAME: Windows WMI Process Call Create

DESCRIPTION:  This analytic is to look for wmi commandlines to execute or create process.  This technique was used by adversaries or threat actor to execute their malicious  payload in local or remote host. This hunting query is a good pivot to start to  look further which process trigger the wmi or what process it execute locally or  remotely.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where `process_wmic` Processes.process  = "* process *" Processes.process = "* call *" Processes.process = "* create *"  by Processes.parent_process_name Processes.parent_process Processes.process_name  Processes.process Processes.original_file_name Processes.process_id Processes.parent_process_path  Processes.process_guid Processes.parent_process_id Processes.dest Processes.user  Processes.process_path | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `windows_wmi_process_call_create_filter`'



<li><a href="#">NAME: WinEvent Scheduled Task Created to Spawn Shelldatamodel: []

DESCRIPTION:  The following query utilizes Windows Security EventCode 4698, indicating 'a scheduled task was created', to identify potentially suspicious tasks. These tasks may be registered on Windows through either schtasks.exe or TaskService, and are set up to execute a command with a native Windows shell such as PowerShell, Cmd, Wscript, or Cscript.\  The search will return the initial and final times the task was registered, along with details like the 'Command' set to be executed, 'Task Name', 'Author', whether it's 'Enabled', and if it is 'Hidden'.\  Schtasks.exe is typically found in C:\Windows\system32 and C:\Windows\syswow64. The DLL 'taskschd.dll' is loaded when either schtasks.exe or TaskService is launched. If this DLL is found loaded by another process, it's possible that a scheduled task is being registered within the context of that process in memory.\  During triage, it's essential to identify the source of the scheduled task. Was it registered via schtasks.exe or TaskService? Review the job that was created and the command set to be executed. It's also recommended to capture and review any artifacts on disk, and identify any parallel processes within the same timeframe to locate the source.

SEARCH:  '`wineventlog_security` EventCode=4698 | xmlkv Message | search Command IN  ("*powershell.exe*", "*wscript.exe*", "*cscript.exe*", "*cmd.exe*", "*sh.exe*",  "*ksh.exe*", "*zsh.exe*", "*bash.exe*", "*scrcons.exe*", "*pwsh.exe*") | stats count  min(_time) as firstTime max(_time) as lastTime by dest, Task_Name, Command, Author,  Enabled, Hidden | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `winevent_scheduled_task_created_to_spawn_shell_filter`'



<li><a href="#">NAME: WinEvent Scheduled Task Created Within Public Pathdatamodel: []

DESCRIPTION:  'The following analytic utilizes Windows Security EventCode 4698, which  indicates the creation of a scheduled task on a Windows system. The purpose of this  query is to identify suspicious tasks that have been registered using either schtasks.exe or TaskService and involve executing a command from a user-writable file path.\  When this analytic is triggered, it provides information such as the first and last  registration time of the task, the command to be executed, the task name, author,  and whether it is set as hidden or not. It is worth noting that schtasks.exe is  commonly located in C:\Windows\system32 and C:\Windows\syswow64, and it loads the  taskschd.dll DLL when launched. If this DLL is loaded by another process, it suggests  that a scheduled task may be registered within that process''s context in memory.\  During the triage process, it is essential to identify the source of the scheduled  task creation, whether it was initiated through schtasks.exe or TaskService. The  analyst should review the task that was created, including the command to be executed.  Additionally, any artifacts on disk related to the task should be captured and analyzed. It is also recommended to identify any parallel processes that occurred within the same timeframe to determine the source of the task creation.\    By conducting this triage process, security analysts can gain insights into potentiallymalicious or suspicious scheduled tasks, helping them identify the source and assess the impact of the task. This analytic is valuable for a Security Operations Center (SOC) as it can detect unauthorized or suspicious activity that could indicate an attacker''s attempt to establish persistence or execute unauthorized commands on the system.'

SEARCH:  '`wineventlog_security` EventCode=4698 | xmlkv Message | search Command IN ("*\\users\\public\\*", "*\\programdata\\*", "*\\temp\\*", "*\\Windows\\Tasks\\*", "*\\appdata\\*", "*\\perflogs\\*")| stats count min(_time) as firstTime max(_time) as lastTime by ComputerName, Task_Name, Command, Author, Enabled, Hidden |  rename ComputerName as dest | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `winevent_scheduled_task_created_within_public_path_filter`'



<li><a href="#">NAME: WinEvent Windows Task Scheduler Event Action Started

DESCRIPTION:  The following hunting analytic aims to identify suspicious tasks that have been registered and executed in Windows using EventID 200 (action run) and 201 (action completed) from the Windows Task Scheduler logs. This analytic helps detect evasive techniques used to register tasks on Windows systems. It is recommended to filter the results based on the ActionName field by specifying specific paths that are not commonly used in your environment.\  After implementing this analytic, it is important to review parallel events related to the scheduled tasks. EventID 106 will be generated when a new task is created, but it does not necessarily mean that the task has been executed. Analysts should capture any files on disk associated with the task and perform further analysis.\  To implement this analytic, Task Scheduler logs must be collected. This can be done by adding a stanza for [WinEventLog://Microsoft-Windows-TaskScheduler/Operational] in the inputs.conf file and setting renderXml=false. It is worth noting that not translating the logs into XML may require specific extraction of items from the Message field.\  False positives are expected with this analytic, so it is important to filter the results based on the paths or specific keywords of interest in the ActionName field to reduce noise.\  Identifying and analyzing scheduled tasks that have been executed is crucial for a Security Operations Center (SOC) as it helps detect potentially malicious or unauthorized activities on Windows systems. By capturing and investigating the associated events, analysts can uncover signs of persistence mechanisms, unauthorized code execution, or suspicious behaviors. The impact of a true positive could range from unauthorized access to data exfiltration or the execution of malicious payloads.

SEARCH:  '`wineventlog_task_scheduler` EventCode IN ("200","201") | rename ComputerName  as dest | stats count min(_time) as firstTime max(_time) as lastTime by Message  dest EventCode category | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `winevent_windows_task_scheduler_event_action_started_filter`'



<li><a href="#">NAME: Winhlp32 Spawning a Process

DESCRIPTION:  The following analytic identifies winhlp32.exe, found natively in `c:\windows\`,  spawning a child process that loads a file out of appdata, programdata, or temp.  Winhlp32.exe has a rocky past in that multiple vulnerabilities were found and added  to MetaSploit. WinHlp32.exe is required to display 32-bit Help files that have the  ".hlp" file name extension. This particular instance is related to a Remcos sample  where dynwrapx.dll is added to the registry under inprocserver32, and later module  loaded by winhlp32.exe to spawn wscript.exe and load a vbs or file from disk. During  triage, review parallel processes to identify further suspicious behavior. Review  module loads for unsuspecting unsigned modules. Capture any file modifications and  analyze.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.parent_process_name=winhlp32.exe  Processes.process IN ("*\\appdata\\*","*\\programdata\\*", "*\\temp\\*") by Processes.dest  Processes.user Processes.parent_process_name Processes.process_name Processes.original_file_name  Processes.process Processes.process_id Processes.parent_process_id | `drop_dm_object_name(Processes)`  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `winhlp32_spawning_a_process_filter`'



<li><a href="#">NAME: WinRAR Spawning Shell Application

DESCRIPTION:  The following analytic detects the execution of Windows shell processes  initiated by WinRAR, specifically looking for instances where WinRAR spawns processes  like "cmd.exe", "powershell.exe", "certutil.exe", "mshta.exe", or "bitsadmin.exe".  This behavior is worth identifying for a Security Operations Center (SOC) because  it is indicative of a spoofing attack exploit, such as the one associated with WinRAR  CVE-2023-38831. Cybercriminals exploited this vulnerability to craft ZIP archives  with spoofed extensions, hiding the launch of malicious scripts within an archive.  When a victim opened the specially crafted archive, it executed the malware, leading  to unauthorized access to their broker accounts and enabling the cybercriminals  to perform illicit financial transactions and withdraw funds. If a true positive  is found, it suggests that an attacker has successfully exploited the vulnerability  to execute malicious scripts, leading to unauthorized access, financial loss, and  potentially the delivery of additional malicious payloads. The impact of the attack  could be severe, involving financial loss, unauthorized access to sensitive accounts,  and the potential for further malicious activity such as data theft or ransomware  attacks.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.parent_process_name=winrar.exe  `windows_shells` OR Processes.process_name IN ("certutil.exe","mshta.exe","bitsadmin.exe")  by Processes.dest Processes.user Processes.parent_process_name Processes.parent_process  Processes.process_name Processes.process Processes.process_id Processes.parent_process_id  | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `winrar_spawning_shell_application_filter`'



<li><a href="#">NAME: WinRM Spawning a Process

DESCRIPTION:  The following analytic identifies suspicious processes spawning from  WinRM (wsmprovhost.exe). This analytic is related to potential exploitation of CVE-2021-31166.  which is a kernel-mode device driver http.sys vulnerability. Current proof of concept  code will blue-screen the operating system. However, http.sys used by many different  Windows processes, including WinRM. In this case, identifying suspicious process  create (child processes) from `wsmprovhost.exe` is what this analytic is identifying.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.parent_process_name=wsmprovhost.exe  Processes.process_name IN ("cmd.exe","sh.exe","bash.exe","powershell.exe","pwsh.exe","schtasks.exe","certutil.exe","whoami.exe","bitsadmin.exe","scp.exe")  by Processes.dest Processes.user Processes.parent_process Processes.process_name  Processes.process Processes.process_id Processes.parent_process_id | `drop_dm_object_name(Processes)`  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `winrm_spawning_a_process_filter`'



<li><a href="#">NAME: Winword Spawning Cmd

DESCRIPTION:  The following detection identifies Microsoft Word spawning `cmd.exe`.  Typically, this is not common behavior and not default with winword.exe. Winword.exe  will generally be found in the following path `C:\Program Files\Microsoft Office\root\Office16`  (version will vary). Cmd.exe spawning from winword.exe is common for a spearphishing  attachment and is actively used. Albeit, the command-line will indicate what is  being executed. During triage, review parallel processes and identify any files  that may have been written. It is possible that COM is utilized to trampoline the  child process to `explorer.exe` or `wmiprvse.exe`.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.parent_process_name=winword.exe  `process_cmd` by Processes.dest Processes.user Processes.parent_process Processes.original_file_name  Processes.process_name Processes.process Processes.process_id Processes.parent_process_id  | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `winword_spawning_cmd_filter`'



<li><a href="#">NAME: Winword Spawning PowerShell

DESCRIPTION:  The following detection identifies Microsoft Word spawning PowerShell.  Typically, this is not common behavior and not default with winword.exe. Winword.exe  will generally be found in the following path `C:\Program Files\Microsoft Office\root\Office16`  (version will vary). PowerShell spawning from winword.exe is common for a spearphishing  attachment and is actively used. Albeit, the command executed will most likely be  encoded and captured via another detection. During triage, review parallel processes  and identify any files that may have been written.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.parent_process_name="winword.exe"  `process_powershell` by Processes.dest Processes.user Processes.parent_process Processes.process_name  Processes.original_file_name Processes.process Processes.process_id Processes.parent_process_id  | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)`| `security_content_ctime(lastTime)`  | `winword_spawning_powershell_filter`'



<li><a href="#">NAME: Winword Spawning Windows Script Host

DESCRIPTION:  The following detection identifies Microsoft Winword.exe spawning Windows  Script Host - `cscript.exe` or `wscript.exe`. Typically, this is not common behavior  and not default with Winword.exe. Winword.exe will generally be found in the following  path `C:\Program Files\Microsoft Office\root\Office16` (version will vary). `cscript.exe`  or `wscript.exe` default location is `c:\windows\system32\` or c:windows\syswow64\`.  `cscript.exe` or `wscript.exe` spawning from Winword.exe is common for a spearphishing  attachment and is actively used. Albeit, the command-line executed will most likely  be obfuscated and captured via another detection. During triage, review parallel  processes and identify any files that may have been written. Review the reputation  of the remote destination and block accordingly.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.parent_process_name="winword.exe"  Processes.process_name IN ("cscript.exe", "wscript.exe") by Processes.dest Processes.user  Processes.parent_process Processes.process_name Processes.process Processes.process_id  Processes.parent_process_id | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `winword_spawning_windows_script_host_filter`'



<li><a href="#">NAME: Wmic Group Discovery

DESCRIPTION:  'The following hunting analytic identifies the use of `wmic.exe` enumerating  local groups on the endpoint. \  Typically, by itself, is not malicious but may raise suspicion based on time of  day, endpoint and username. \  During triage, review parallel processes and identify any further suspicious behavior.'

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.process_name=wmic.exe  (Processes.process="*group get name*") by Processes.dest Processes.user Processes.parent_process_name  Processes.process_name Processes.process Processes.original_file_name Processes.process_id  Processes.parent_process_id | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)`|  `security_content_ctime(lastTime)` | `wmic_group_discovery_filter`'



<li><a href="#">NAME: Wmic NonInteractive App Uninstallation

DESCRIPTION:  This analytic indentifies WMIC command-line attempting to uninstall application  non-interactively. This technique was seen in IcedID to uninstall AV products on  the compromised host to evade detection. This Hunting query maybe a good indicator  that some process tries to uninstall application using wmic which is not a common  behavior. This approach may seen in some script or third part appication to uninstall  their application but it is a good thing to check what it uninstall and why.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.process_name=wmic.exe  Processes.process="* product *" Processes.process="*where name*" Processes.process="*call  uninstall*" Processes.process="*/nointeractive*" by Processes.dest Processes.user  Processes.parent_process_name Processes.process_name Processes.process Processes.original_file_name  Processes.process_id Processes.parent_process_id | `drop_dm_object_name(Processes)`  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `wmic_noninteractive_app_uninstallation_filter`'



<li><a href="#">NAME: WMIC XSL Execution via URL

DESCRIPTION:  The following analytic identifies `wmic.exe` loading a remote XSL (eXtensible  Stylesheet Language) script. This originally was identified by Casey Smith, dubbed  Squiblytwo, as an application control bypass. Many adversaries will utilize this  technique to invoke JScript or VBScript within an XSL file. This technique can also  execute local/remote scripts and, similar to its Regsvr32 "Squiblydoo" counterpart,  leverages a trusted, built-in Windows tool. Adversaries may abuse any alias in Windows  Management Instrumentation provided they utilize the /FORMAT switch. Upon identifying  a suspicious execution, review for confirmed network connnection and script download.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where `process_wmic` Processes.process  IN ("*http://*", "*https://*") Processes.process="*/format:*" by Processes.parent_process_name  Processes.original_file_name Processes.parent_process Processes.process_name Processes.process_id  Processes.process Processes.dest Processes.user | `drop_dm_object_name(Processes)`  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `wmic_xsl_execution_via_url_filter`'



<li><a href="#">NAME: Wmiprsve LOLBAS Execution Process Spawn

DESCRIPTION:  The following analytic identifies `wmiprsve.exe` spawning a LOLBAS execution  process. When adversaries execute code on remote endpoints abusing Windows Management  Instrumentation (WMI), the executed command is spawned as a child process of `wmiprvse.exe`.  The LOLBAS project documents Windows native binaries that can be abused by threat  actors to perform tasks like executing malicious code. Looking for child processes  of wmiprvse.exe that are part of the LOLBAS project can help defenders identify  lateral movement activity.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where (Processes.parent_process_name=wmiprvse.exe)  (Processes.process_name IN ("Regsvcs.exe", "Ftp.exe", "OfflineScannerShell.exe",  "Rasautou.exe", "Schtasks.exe", "Xwizard.exe", "Dllhost.exe", "Pnputil.exe", "Atbroker.exe",  "Pcwrun.exe", "Ttdinject.exe","Mshta.exe", "Bitsadmin.exe", "Certoc.exe", "Ieexec.exe",  "Microsoft.Workflow.Compiler.exe", "Runscripthelper.exe", "Forfiles.exe", "Msbuild.exe",  "Register-cimprovider.exe", "Tttracer.exe", "Ie4uinit.exe", "Bash.exe", "Hh.exe",  "SettingSyncHost.exe", "Cmstp.exe", "Mmc.exe", "Stordiag.exe", "Scriptrunner.exe",  "Odbcconf.exe", "Extexport.exe", "Msdt.exe", "WorkFolders.exe", "Diskshadow.exe",  "Mavinject.exe", "Regasm.exe", "Gpscript.exe", "Rundll32.exe", "Regsvr32.exe", "Msiexec.exe",  "Wuauclt.exe", "Presentationhost.exe", "Wmic.exe", "Runonce.exe", "Syncappvpublishingserver.exe",  "Verclsid.exe", "Infdefaultinstall.exe", "Explorer.exe", "Installutil.exe", "Netsh.exe",  "Wab.exe", "Dnscmd.exe", "At.exe", "Pcalua.exe", "Msconfig.exe")) by Processes.dest  Processes.user Processes.parent_process Processes.process_name Processes.process  Processes.process_id Processes.parent_process_id | `drop_dm_object_name(Processes)`  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `wmiprsve_lolbas_execution_process_spawn_filter`'



<li><a href="#">NAME: WMI Permanent Event Subscription

DESCRIPTION:  |-  The following analytic detects the creation of permanent event subscriptions using Windows Management Instrumentation (WMI), which is used by attackers to achieve persistence in a compromised system. By creating a permanent event subscription, an attacker can run malicious scripts or binaries in response to specific system events that enables them to maintain access to the system undetected. The detection is made by using Sysmon Event ID 5 data to detect instances where the consumers of these events are not the expected "NTEventLogEventConsumer." The detection is important because it identifies unusual or unexpected subscription creation, which suggests that an attacker is attempting to achieve persistence within the environment and might be executing malicious scripts or binaries in response to specific system events. The impact of such an attack can be severe, potentially leading to data theft, ransomware, or other damaging outcomes. False positives might occur since False positives might occur since WMI event subscriptions can be used for legitimate purposes by system administrators. You must have a thorough understanding of WMI activity within the context of the monitored environment to effectively differentiate between legitimate and malicious activity.Next steps include investigating the associated scripts or binaries and identifying the source of the attack.

SEARCH:  '`wmi` EventCode=5861 Binding | rex field=Message "Consumer =\s+(?<consumer>[^;|^$]+)"  | search consumer!="NTEventLogEventConsumer=\"SCM Event Log Consumer\"" | stats  count min(_time) as firstTime max(_time) as lastTime by ComputerName, consumer,  Message | `security_content_ctime(firstTime)`| `security_content_ctime(lastTime)`  | rename ComputerName as dest | `wmi_permanent_event_subscription_filter`'



<li><a href="#">NAME: WMI Permanent Event Subscription - Sysmon

DESCRIPTION:  'This analytic looks for the creation of WMI permanent event subscriptions.  The following analytic identifies the use of WMI Event Subscription to establish  persistence or perform privilege escalation.  WMI can be used to install event filters,  providers, consumers, and bindings that execute code when a defined event occurs.  WMI subscription execution is proxied by the WMI Provider Host process (WmiPrvSe.exe)  and thus may result in elevated SYSTEM privileges. This analytic is restricted by  commonly added process execution and a path. If the volume is low enough, remove  the values and flag on any new subscriptions.\  All event subscriptions have three components \  1. Filter - WQL Query for the events we want. EventID = 19 \  1. Consumer - An action to take upon triggering the filter. EventID = 20 \  1. Binding - Registers a filter to a consumer. EventID = 21 \  Monitor for the creation of new WMI EventFilter, EventConsumer, and FilterToConsumerBinding.  It may be pertinent to review all 3 to identify the flow of execution. In addition,  EventCode 4104 may assist with any other PowerShell script usage that registered  the subscription.'

SEARCH:  '`sysmon` EventCode=21 | rename host as dest | table _time, dest, user, Operation,  EventType, Query, Consumer, Filter | `wmi_permanent_event_subscription___sysmon_filter`'



<li><a href="#">NAME: WMI Recon Running Process Or Services

DESCRIPTION:  The following analytic identifies suspicious PowerShell script execution  via EventCode 4104, where WMI is performing an event query looking for running processes  or running services. This technique is commonly found in malware and APT events  where the adversary will map all running security applications or services on the  compromised machine. During triage, review parallel processes within the same timeframe.  Review the full script block to identify other related artifacts.

SEARCH:  '`powershell` EventCode=4104 ScriptBlockText= "*SELECT*" AND (ScriptBlockText="*Win32_Process*"  OR ScriptBlockText="*Win32_Service*") | stats count min(_time) as firstTime max(_time)  as lastTime by EventCode ScriptBlockText Computer UserID | rename Computer as dest | rename UserID as user | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `wmi_recon_running_process_or_services_filter`'



<li><a href="#">NAME: WMI Temporary Event Subscription

DESCRIPTION:  "The following analytic detects the creation of WMI temporary event subscriptions. WMI (Windows Management Instrumentation) is a management technology that allows administrators to perform various tasks on Windows-based systems. Temporary event subscriptions are created to monitor specific events or changes on a system that help to detect potential threats early and take proactive measures to protect the organization's systems and data. The detection is made by using the Splunk query `wmi` EventCode=5860 Temporary to search for events with EventCode 5860, which indicates the creation of a temporary WMI event subscription. To further refine the search results, the query uses regular expressions (rex) to extract the query used in the event subscription. Then, it filters known benign queries related to system processes such as 'wsmprovhost.exe' and 'AntiVirusProduct', 'FirewallProduct', 'AntiSpywareProduct', which helps to focus on potentially malicious or suspicious queries. The detection is important because it indicates malicious activity since attackers use WMI to run commands, gather information, or maintain persistence within a compromised system. False positives might occur since legitimate uses of WMI event subscriptions in the environment might trigger benign activities to be flagged. Therefore, an extensive triage is necessary to review the specific query and assess its intent. Additionally, capturing and inspecting relevant on-disk artifacts and analyzing concurrent processes can help to identify the source of the attack. Detecting the creation of these event subscriptions to identify potential threats early and take appropriate actions to mitigate the risks."

SEARCH:  '`wmi` EventCode=5860 Temporary | rex field=Message "NotificationQuery =\s+(?<query>[^;|^$]+)"  | search query!="SELECT * FROM Win32_ProcessStartTrace WHERE ProcessName = ''wsmprovhost.exe''"  AND query!="SELECT * FROM __InstanceOperationEvent WHERE TargetInstance ISA ''AntiVirusProduct''  OR TargetInstance ISA ''FirewallProduct'' OR TargetInstance ISA ''AntiSpywareProduct''"  | stats count min(_time) as firstTime max(_time) as lastTime by ComputerName, query  |  `security_content_ctime(firstTime)`| `security_content_ctime(lastTime)` | `wmi_temporary_event_subscription_filter`'



<li><a href="#">NAME: Wscript Or Cscript Suspicious Child Process

DESCRIPTION:  This analytic identifies a suspicious spawned process by WScript or CScript  process. This technique was a common technique used by adversaries and malware to  execute different LOLBIN, other scripts like PowerShell or spawn a suspended process  to inject its code as a defense evasion. This TTP may detect some normal script  that using several application tool that are in the list of the child process it  detects but a good pivot and indicator that a script is may execute suspicious code.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where Processes.parent_process_name  IN ("cscript.exe", "wscript.exe") Processes.process_name IN ("regsvr32.exe", "rundll32.exe","winhlp32.exe","certutil.exe","msbuild.exe","cmd.exe","powershell*","wmic.exe","mshta.exe")  by Processes.dest Processes.user Processes.parent_process_name Processes.parent_process  Processes.process_name Processes.process Processes.process_id Processes.parent_process_id  | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `wscript_or_cscript_suspicious_child_process_filter`'



<li><a href="#">NAME: Wsmprovhost LOLBAS Execution Process Spawn

DESCRIPTION:  The following analytic identifies `Wsmprovhost.exe` spawning a LOLBAS  execution process. When adversaries execute code on remote endpoints abusing the  Windows Remote Management (WinRm) protocol, the executed command is spawned as a  child processs of `Wsmprovhost.exe`. The LOLBAS project documents Windows native  binaries that can be abused by threat actors to perform tasks like executing malicious  code. Looking for child processes of Wsmprovhost.exe that are part of the LOLBAS  project can help defenders identify lateral movement activity.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where (Processes.parent_process_name=wsmprovhost.exe)  (Processes.process_name IN ("Regsvcs.exe", "Ftp.exe", "OfflineScannerShell.exe",  "Rasautou.exe", "Schtasks.exe", "Xwizard.exe", "Dllhost.exe", "Pnputil.exe", "Atbroker.exe",  "Pcwrun.exe", "Ttdinject.exe","Mshta.exe", "Bitsadmin.exe", "Certoc.exe", "Ieexec.exe",  "Microsoft.Workflow.Compiler.exe", "Runscripthelper.exe", "Forfiles.exe", "Msbuild.exe",  "Register-cimprovider.exe", "Tttracer.exe", "Ie4uinit.exe", "Bash.exe", "Hh.exe",  "SettingSyncHost.exe", "Cmstp.exe", "Mmc.exe", "Stordiag.exe", "Scriptrunner.exe",  "Odbcconf.exe", "Extexport.exe", "Msdt.exe", "WorkFolders.exe", "Diskshadow.exe",  "Mavinject.exe", "Regasm.exe", "Gpscript.exe", "Rundll32.exe", "Regsvr32.exe", "Msiexec.exe",  "Wuauclt.exe", "Presentationhost.exe", "Wmic.exe", "Runonce.exe", "Syncappvpublishingserver.exe",  "Verclsid.exe", "Infdefaultinstall.exe", "Explorer.exe", "Installutil.exe", "Netsh.exe",  "Wab.exe", "Dnscmd.exe", "At.exe", "Pcalua.exe", "Msconfig.exe")) by Processes.dest  Processes.user Processes.parent_process Processes.process_name Processes.process  Processes.process_id Processes.parent_process_id | `drop_dm_object_name(Processes)`  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`| `wsmprovhost_lolbas_execution_process_spawn_filter`'



<li><a href="#">NAME: WSReset UAC Bypass

DESCRIPTION:  This search is to detect a suspicious modification of registry related  to UAC bypass. This technique is to modify the registry in this detection, create  a registry value with the path of the payload and run WSreset.exe to bypass User  account Control.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) AS firstTime max(_time)  AS lastTime FROM datamodel=Endpoint.Processes BY _time span=1h Processes.user Processes.process_id  Processes.process_name Processes.process Processes.process_path Processes.dest Processes.parent_process_name  Processes.parent_process Processes.process_guid | `drop_dm_object_name(Processes)`  | join process_guid [| tstats `security_content_summariesonly` count FROM datamodel=Endpoint.Registry  WHERE Registry.registry_path= "*\\AppX82a6gwre4fdg3bt635tn5ctqjf8msdd2\\Shell\\open\\command*"  AND (Registry.registry_value_name = "(Default)" OR Registry.registry_value_name  = "DelegateExecute") by _time span=1h Registry.dest Registry.user Registry.registry_path  Registry.registry_key_name Registry.registry_value_name Registry.registry_value_data  Registry.process_guid | `drop_dm_object_name(Registry)`] | fields firstTime lastTime  dest user parent_process_name parent_process process_name process_path process registry_key_name  registry_path registry_value_name registry_value_data process_guid | where isnotnull(registry_value_data)  | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)` | `wsreset_uac_bypass_filter`'



<li><a href="#">NAME: XMRIG Driver Loaded

DESCRIPTION:  This analytic identifies XMRIG coinminer driver installation on the system.  The XMRIG driver name by default is `WinRing0x64.sys`. This cpu miner is an open  source project that is commonly abused by adversaries to infect and mine bitcoin.

SEARCH:  '`sysmon` EventCode=6 Signature="Noriyuki MIYAZAKI" OR ImageLoaded= "*\\WinRing0x64.sys"  |  stats  min(_time) as firstTime max(_time) as lastTime count by  dest ImageLoaded  Hashes IMPHASH Signature Signed | `security_content_ctime(firstTime)` | `security_content_ctime(lastTime)`  | `xmrig_driver_loaded_filter`'



<li><a href="#">NAME: XSL Script Execution With WMIC

DESCRIPTION:  This search is to detect a suspicious wmic.exe process or renamed wmic  process to execute malicious xsl file. This technique was seen in FIN7 to execute  its malicous jscript using the .xsl as the loader with the help of wmic.exe process.  This TTP is really a good indicator for you to hunt further for FIN7 or other attacker  that known to used this technique.

SEARCH:  '| tstats `security_content_summariesonly` count min(_time) as firstTime max(_time)  as lastTime from datamodel=Endpoint.Processes where `process_wmic` Processes.process  = "*os get*" Processes.process="*/format:*" Processes.process = "*.xsl*" by Processes.parent_process_name  Processes.parent_process Processes.process_name Processes.process_id Processes.process  Processes.dest Processes.user | `drop_dm_object_name(Processes)` | `security_content_ctime(firstTime)`  | `security_content_ctime(lastTime)` | `xsl_script_execution_with_wmic_filter`'



<li><a href="#">NAME: Zeek x509 Certificate with Punycode

DESCRIPTION:  The following analytic utilizes the Zeek x509 log. Modify the zeek_x509  macro with your index and sourcetype as needed. You will need to ensure the full  x509 is logged as the potentially malicious punycode is nested under subject alternative  names. In this particular analytic, it will identify punycode within the subject  alternative name email and other fields. Note, that OtherFields is meant to be BOOL  (true,false), therefore we may never see xn-- in that field. Upon identifying punycode,  manually copy and paste, or add CyberChef recipe to query, and decode the punycode  manually.

SEARCH:  '`zeek_x509` | rex field=san.email{} "\@(?<domain_detected>xn--.*)" | rex  field=san.other_fields{} "\@(?<domain_detected>xn--.*)" | stats values(domain_detected)  by  basic_constraints.ca source host | `zeek_x509_certificate_with_punycode_filter`'



</div>
<script>
function myFunction() {
var input, filter, ul, li, a, i, txtValue;
input = document.getElementById("myInput");
filter = input.value.toUpperCase();
ul = document.getElementById("myUL");
li = ul.getElementsByTagName("li");
for (i = 0; i < li.length; i++) {
a = li[i].getElementsByTagName("a")[0];
txtValue = a.textContent || a.innerText;
if (txtValue.toUpperCase().indexOf(filter) > -1) {
li[i].style.display = "";
} else {
li[i].style.display = "none";
}
}
}
</script>
<script src="hilitor.js"></script>
<script>
var myHilitor = new Hilitor("content"); // id of the element to parse
// myHilitor.setBreakRegExp(new RegExp('[^\\w\' -]+', "g")); // expanded to include spaces
myHilitor.apply();
</script>
<script>
window.addEventListener("DOMContentLoaded", function(e) {
var myHilitor2 = new Hilitor("playground");
myHilitor2.setMatchType("left");
document.getElementById("keywords").addEventListener("keyup", function(e) {
myHilitor2.apply(this.value);
}, false);
}, false);
</script>
</html>