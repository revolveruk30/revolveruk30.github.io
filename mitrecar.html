<html>
<title>Detection Rules</title>
<meta name="robots" content="noindex,nofollow" />
<link rel="stylesheet" href="w2.css">

<head>
<style>
html, body {
background-color: #f0f0f0;
}

.w3-topbar {
width: 100%;
height:5%;
background-color: black;
position: fixed;
top: 1px;
overflow: hidden;
}
#myInput {
background-repeat: no-repeat;
width: 40%;
border: 1px solid #ddd;
margin-left: 300px;
text-align: center;
font-family: "Roboto", sans-serif
}
#keywords {
background-repeat: no-repeat;
width: 28%;
border: 1px solid #ddd;
border: 1px solid #ddd;
margin-bottom: 2px;
margin-left: 300px;
text-align: center;
font-family: "Roboto", sans-serif
}
#myUL {
list-style-type: none;
padding: 0;
text-align: center;
margin-top: 10px;
width: 100%;
}
#myUL li a {
margin-top: -1px;
padding: 8px;
text-decoration: none;
font-size: 14px;
color: black;
display: block
}
}
</style>
</head>
<body>
<!-- Topbar -->
<div class="w3-topbar"></div>
<!-- Sidebar -->
<BR>
<p>
<BR>
<center><H3>MITRE CAR Detection Rules</H3></center>
<BR>
<input type="text" id="myInput" onkeyup="myFunction()" placeholder="Filter Paragraph by Keyword" title="Search">
<form method="GET" onsubmit="myHilitor.apply(hilite.value); return false;">
<input type="text" id="keywords" size="20" name="hilite" placeholder="Highlight Multiple Keywords">
<input type="submit" value="Apply">
<input type="button" value="Remove" onclick="myHilitor.remove();">
</span>
</form>
</nav>
<div class="w3-main w3-theme-l5" style="margin-left:100px, margin-right:50px">
<div id="playground">
<center>
<ul id="myUL">
<p>
<p>
<li><a href="#">title: Access Permission Modification submission_date: 2019/07/08 information_domain: 'Host' platforms: - Windows - Linux - macOS subtypes: - File analytic_types: - Situational Awareness contributors: - Meric Degirmenci - MITRE id: CAR-2019-07-001 description: |- Adversaries sometimes modify object access rights at the operating system level. There are varying motivations behind this action - they may not want some files/objects to be changed on systems for persistence reasons and therefore provide admin only rights; also, they may want files to be accessible with lower levels of permissions. Note - this analytic references file permissions, which are not currently in the CAR data model. coverage: - technique: T1222 tactics: - TA0005 subtechniques: - T1222.001 - T1222.002 coverage: Moderate implementations: - name: Windows - Pseudocode description: |- Windows environment logs can be noisy, so we take the following into consideration: * We need to exclude events generated by the local system (subject security ID "NT AUTHORITY\SYSTEM") and focus on actual user events. * When a permission modification is made for a folder, a new event log is generated for each subfolder and file under that folder. It is advised to group logs based on handle ID or user ID. * The Windows security log (event ID 4670) also includes information about the process that modifies the file permissions. It is advised to focus on uncommon process names, and it is also uncommon for real-users to perform this task without a GUI. code: |- log_name == "Security" AND event_code == "4670" AND object_type == "File" AND subject_security_id != "NT AUTHORITY\SYSTEM" type: Pseudocode - name: Windows - Splunk description: Splunk version of the above pseudocode. code: |- index=__your_windows_security_log_index__ EventCode=4670 Object_Type="File" Security_ID!="NT AUTHORITY\\SYSTEM" type: Splunk - name: Linux - Pseudocode description: This looks for any invocations of chmod. Note that this is likely to be more noisy than the Windows-specific implementation, although Linux does not generate logs for system triggered activities like in Windows. In addition, it may be necessary to whitelist cron jobs that regularly run and execute `chmod`. code: |- processes = search Process:Create chmod_processes = filter processes where command_line == "chmod *" output chmod_processes type: Pseudocode - description: LogPoint version of the above pseudocode for Windows. code: |- norm_id=WindowsSysmon channel="Security" event_id=4670 object_type="File" -user_id="S-1-5-18" type: LogPoint data_mode: LogPoint native unit_tests: - description: 'For Windows - right click on any file and change its permissions under properties. Or, execute the following command: `icacls "C:\<fileName>" /grant :F`' - description: 'For Linux - execute the following command: `chmod 777 "fileName"`' d3fend_mappings: - iri: d3f:SystemFileAnalysis id: D3-SFA label: System File Analysis --- 
<li><a href="#">title: Active Directory Dumping via NTDSUtil submission_date: 2019/08/13 information_domain: 'Host' platforms: - Windows subtypes: - File analytic_types: - TTP contributors: - Tony Lambert/Red Canary id: CAR-2019-08-002 description: |- The NTDSUtil tool may be used to dump a Microsoft Active Directory database to disk for processing with a credential access tool such as Mimikatz. This is performed by launching `ntdsutil.exe` as a privileged user with command line arguments indicating that media should be created for offline Active Directory installation and specifying a folder path. This process will create a copy of the Active Directory database, `ntds.dit`, to the specified folder path. This requires filesystem data to determine whether files have been created. coverage: - technique: T1003 tactics: - TA0006 subtechniques: - T1003.003 coverage: Low implementations: - name: NTDSUtil - File Create description: This base pseudocode looks for file create events where a file with a name of ntds.dit is created by the ntdsutil process. code: |- files = search File:Create ntds_dump = filter files where ( file_name = "ntds.dit" and image_path = "*ntdsutil.exe") output ntds_dump type: Pseudocode - name: NTDSUtil - File Create description: A Splunk/Sysmon version of the above pseudocode. code: |- index=__your_sysmon_index__ EventCode=11 TargetFilename="*ntds.dit" Image="*ntdsutil.exe" type: Splunk data_model: Sysmon native - name: NTDSUtil - File Create description: An EQL version of the above pseudocode. code: |- file where file_name == "ntds.dit" and process_name == "ntdsutil.exe" type: EQL data_model: EQL native - description: LogPoint version of the above pseudocode. code: |- norm_id=WindowsSysmon event_id=11 file="*ntds.dit" source_image="*ntdsutil.exe" type: LogPoint data_mode: LogPoint native data_model_references: - file/create/file_name - file/create/image_path unit_tests: - description: |- 1. Open a Windows Command Prompt or PowerShell instance as Administrator 2. Execute `ntdsutil.exe â€œac i ntdsâ€ â€œifmâ€ â€œcreate full c:\tempâ€ q q` d3fend_mappings: - iri: d3f:ProcessSpawnAnalysis id: D3-PSA label: Process Spawn Analysis --- 
<li><a href="#">title: All Logins Since Last Boot submission_date: 2015/07/17 information_domain: Host platforms: - Windows - Linux - macOS subtypes: - Login analytic_types: - Situational Awareness contributors: - MITRE id: CAR-2015-07-001 description: |- Once a credential dumper like [mimikatz]() runs, every user logged on since boot is potentially compromised, because the credentials were accessed via the memory of `lsass.exe`. When such an event occurs, this analytic will give the forensic context to identify compromised users. Those users could potentially be used in later events for additional logons. The time field indicates the first and last time a system reported a user logged into a given system. This means that activity could be intermittent between the times given and should not be considered a duration. ### Output Description A list of hostnames and the users that had been logged into the system at some point after to the system's last restart. implementations: - description: 'This analytic requires some means of accessing system logs to get records of boot times for hosts (in the example as `SystemLogs:Bootup`. It looks for the latest boot time to happen before some user-defined point in time. Once the boot time is identified, all of the important user login events can be gathered to create a list of potentially compromised accounts. This could be critical for identifying steps an adversary could have taken after stealing credentials with a tool that operates like [mimikatz]().' code: |- input target_host input event_time all_boots = search SystemLogs:BootUp where (hostname == target_host and time < event_time) boot_time = max(all_boots.time) user_logins = search UserSession:Login host_logins = filter user_logins where (hostname == target_host and boot_time < time < event_time) compromised_accounts = unique(user_logins.user) output users type: pseudocode data_model_references: - user_session/login/user 
<li><a href="#">title: AppInit DLLs submission_date: 2020/09/10 information_domain: 'Host' platforms: - Windows subtypes: - Registry analytic_types: - TTP contributors: - Olaf Hartong id: CAR-2020-09-005 description: |- Adversaries may establish persistence and/or elevate privileges by executing malicious content triggered by AppInit DLLs loaded into processes. Dynamic-link libraries (DLLs) that are specified in the AppInit_DLLs value in the Registry keys `HKEY_LOCAL_MACHINE\Software\Microsoft\Windows NT\CurrentVersion\Windows` or `HKEY_LOCAL_MACHINE\Software\Wow6432Node\Microsoft\Windows NT\CurrentVersion\Windows` are loaded by user32.dll into every process that loads user32.dll. These values can be abused to obtain elevated privileges by causing a malicious DLL to be loaded and run in the context of separate processes. Accordingly, this analytic looks for modifications to these registry keys that may be indicative of this type of abuse. coverage: - technique: T1546 coverage: Moderate subtechniques: - T1546.010 tactics: - TA0003 - TA0004 implementations: - name: Pseudocode - AppInit DLL registry modification description: This is a pseudocode representation of the below splunk search. code: |- registry_keys = search (Registry:Create AND Registry:Remove AND Registry:Edit) appinit_keys = filter registry_keys where ( key = "*\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Windows\Appinit_Dlls\*" OR key = "*\SOFTWARE\\Wow6432Node\Microsoft\Windows NT\CurrentVersion\Windows\Appinit_Dlls\*"" ) output clsid_keys data_model: CAR native type: Pseudocode - name: Splunk search - AppInit DLL registry modification description: This Splunk search looks for any registry keys that were created, deleted, or renamed, as well as any registry values that were set or renamed under the Windows AppInit DLL registry keys. code: |- index=__your_sysmon_index__ (EventCode=12 OR EventCode=13 OR EventCode=14) (TargetObject="*\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Windows\\Appinit_Dlls\\*" OR TargetObject="*\\SOFTWARE\\Wow6432Node\\Microsoft\\Windows NT\\CurrentVersion\\Windows\\Appinit_Dlls\\*") data_model: Sysmon native type: Splunk - name: LogPoint search - AppInit DLL registry modification description: This LogPoint search looks for any registry keys that were created, deleted, or renamed, as well as any registry values that were set or renamed under the Windows AppInit DLL registry keys. code: |- norm_id=WindowsSysmon event_id IN [12, 13, 14] target_object IN ["*\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Windows\Appinit_Dlls\*", "*\SOFTWARE\Wow6432Node\Microsoft\Windows NT\CurrentVersion\Windows\Appinit_Dlls\*"] data_model: LogPoint native type: LogPoint data_model_references: - registry/add/key - registry/remove/key - registry/edit/key d3fend_mappings: - iri: d3f:SystemInitConfigAnalysis id: D3-SICA label: System Init Config Analysis 
<li><a href="#">title: Attempt To Add Certificate To Untrusted Store submission_date: 2021/05/11 information_domain: Analytic platforms: - Windows subtypes: - Process analytic_types: - TTP contributors: - Splunk Threat Research <research@splunk.com> id: CAR-2021-05-001 description: Adversaries may add their own root certificate to the certificate store, to cause the web browser to trust that certificate and not display a security warning when it encounters the previously unseen certificate. This action may be the precursor to malicious activity. coverage: - technique: T1553 tactics: - TA0005 coverage: Moderate subtechniques: - T1553.004 implementations: - name: Splunk code description: You must be ingesting data that records process activity from your hosts to populate the Endpoint data model in the Processes node. You must also be ingesting logs with both the process name and command line from your endpoints. The command-line arguments are mapped to the "process" field in the Endpoint data model. code: '| tstats count min(_time) as firstTime values(Processes.process) as process max(_time) as lastTime from datamodel=Endpoint.Processes where Processes.process_name=*certutil* (Processes.process=*-addstore*) by Processes.parent_process Processes.process_name Processes.user' type: Splunk data_model: Endpoint - name: Pseudocode â€“ detect attempts to add a certificate to a certificate store description: Pseudocode implementation of the splunk search below code: |- processes = search Process:Create addstore_commands = filter processes where ( exe =â€C:\Windows\System32\certutil.exeâ€ AND command_line="*-addstore*â€ ) output addstore_commands data_model: CAR native type: Pseudocode unit_tests: - configurations: - Using Splunk [Attack Range]() description: Replay the detection [dataset]() using the Splunk attack range with the commands below commands: - python attack_range.py replay -dn data_dump [--dump NAME_OF_DUMP] - configurations: - Using [Invoke-AtomicRedTeam]() description: execute the atomic test [T1553.004]() against a Windows target. commands: - Invoke-AtomicTest T1553.004 data_model_references: - process/create/exe - process/create/command_line d3fend_mappings: - iri: d3f:ProcessSpawnAnalysis id: D3-PSA label: Process Spawn Analysis 
<li><a href="#">title: Autorun Differences submission_date: 2013/01/25 information_domain: 'Analytic, Host' platforms: - Windows subtypes: - Registry analytic_types: - Situational Awareness - TTP contributors: - MITRE id: CAR-2013-01-002 description: |- The Sysinternals tool [Autoruns](../sensors/autoruns) checks the registry and file system for known identify persistence mechanisms. It will output any tools identified, including built-in or added-on Microsoft functionality and third party software. Many of these locations are known by adversaries and used to obtain [Persistence](). Running Autoruns periodically in an environment makes it possible to collect and monitor its output for differences, which may include the removal or addition of persistent tools. Depending on the persistence mechanism and location, legitimate software may be more likely to make changes than an adversary tool. Thus, this analytic may result in significant noise in a highly dynamic environment. While Autoruns is a convenient method to scan for programs using persistence mechanisms its scanning nature does not conform well to streaming based analytics. This analytic could be replaced with one that draws from sensors that collect registry and file information if streaming analytics are desired. Utilizes the Sysinternals autoruns tool (ignoring validated Microsoft entries). Primarily not a detection analytic by itself but through analysis of results by an analyst can be used for such. Building another analytic on top of this one identifying unusual entries would likely be a beneficial alternative. coverage: - technique: T1543 tactics: - TA0003 subtechniques: - T1543.003 coverage: Moderate - technique: T1053 tactics: - TA0003 subtechniques: - T1053.005 coverage: Moderate - technique: T1547 tactics: - TA0003 subtechniques: - T1547.001 - T1547.010 - T1547.004 coverage: Moderate - technique: T1574 tactics: - TA0003 - TA0004 subtechniques: - T1574.007 - T1574.008 - T1574.009 - T1574.010 - T1574.011 coverage: Moderate - technique: T1546 tactics: - TA0004 - TA0003 subtechniques: - T1546.001 - T1546.003 - T1546.008 - T1546.010 coverage: Moderate - technique: T1112 tactics: - TA0003 - TA0002 coverage: Moderate - technique: T1037 tactics: - TA0003 subtechniques: - T1037.001 coverage: Moderate d3fend_mappings: - iri: d3f:SystemInitConfigAnalysis id: D3-SICA label: System Init Config Analysis 
<li><a href="#">title: Batch File Write to System32 submission_date: 2021/05/11 information_domain: Analytic platforms: - Windows subtypes: - Process analytic_types: - TTP contributors: - Splunk Threat Research <research@splunk.com> id: CAR-2021-05-002 description: While batch files are not inherently malicious, it is uncommon to see them created after OS installation, especially in the Windows directory. This analytic looks for the suspicious activity of a batch file being created within the C:\Windows\System32 directory tree. There will be only occasional false positives due to administrator actions. coverage: - technique: T1204 subtechniques: - T1204.002 tactics: - TA0002 coverage: Moderate implementations: - name: Pseudocode â€“ Batch file created in the Windows system32 directory tree description: Pseudocode implementation of the Splunk search below code: |- files = search File:create batch_files = filter files where ( extension =".bat" AND file_path = "C:\Windows\system32*" ) output batch_files data_model: CAR native type: Pseudocode - name: Splunk code description: You must be ingesting data that records the file-system activity from your hosts to populate the Endpoint file-system data-model node. If you are using Sysmon, you will need a Splunk Universal Forwarder on each endpoint from which you want to collect data. code: '| tstats count min(_time) as firstTime max(_time) as lastTime values(Filesystem.dest) as dest values(Filesystem.file_name) as file_name values(Filesystem.user) as user from datamodel=Endpoint.Filesystem by Filesystem.file_path | rex field=file_name "(?<file_extension>\.[^\.]+)$" | search file_path=*system32* AND file_extension=.bat' type: Splunk data_model: Endpoint unit_tests: - configurations: - Using Splunk [Attack Range]() description: Replay the detection [dataset]() using the Splunk attack range with the commands below commands: - python attack_range.py replay -dn data_dump [--dump NAME_OF_DUMP] - configurations: - Using [Invoke-AtomicRedTeam]() description: execute the atomic test [T1204.002]() against a Windows target. commands: - Invoke-AtomicTest T1204.002 data_model_references: - file/create/extension - file/create/file_path d3fend_mappings: - iri: d3f:ProcessSpawnAnalysis id: D3-PSA label: Process Spawn Analysis 
<li><a href="#">title: BCDEdit Failure Recovery Modification submission_date: 2021/05/11 information_domain: Analytic platforms: - Windows subtypes: - Process analytic_types: - TTP contributors: - Splunk Threat Research <research@splunk.com> id: CAR-2021-05-003 description: This search looks for flags passed to bcdedit.exe modifications to the built-in Windows error recovery boot configurations. This is typically used by ransomware to prevent recovery. coverage: - technique: T1490 tactics: - TA0040 coverage: Moderate implementations: - name: Pseudocode â€“ detect attempts to add a certificate to a certificate store description: Pseudocode implementation of the splunk search below code: |- processes = search Process:Create bcdedit_commands = filter processes where ( exe = "C:\Windows\System32\bcdedit.exe" AND command_line="*recoveryenabled*" ) output bcedit_commands data_model: CAR native type: Pseudocode - name: Splunk code description: You must be ingesting endpoint data that tracks process activity, including parent-child relationships from your endpoints to populate the Endpoint data model in the Processes node. Tune based on parent process names. code: '| tstats count min(_time) as firstTime max(_time) as lastTime from datamodel=Endpoint.Processes where Processes.process_name = bcdedit.exe Processes.process="*recoveryenabled*" (Processes.process="* no*") by Processes.process_name Processes.process Processes.parent_process_name Processes.dest Processes.user' type: Splunk data_model: Endpoint unit_tests: - configurations: - Using Splunk [Attack Range]() description: Replay the detection [dataset]() using the Splunk attack range with the commands below commands: - python attack_range.py replay -dn data_dump [--dump NAME_OF_DUMP] - configurations: - Using [Invoke-AtomicRedTeam]() description: execute the atomic test [T1490]() against a Windows target. commands: - Invoke-AtomicTest T1490 data_model_references: - process/create/exe - process/create/command_line d3fend_mappings: - iri: d3f:ProcessSpawnAnalysis id: D3-PSA label: Process Spawn Analysis - iri: d3f:ProcessLineageAnalysis id: D3-PLA label: Process Lineage Analysis 
<li><a href="#">title: BITS Job Persistence submission_date: 2021/05/11 information_domain: Analytic platforms: - Windows subtypes: - Process analytic_types: - TTP contributors: - Splunk Threat Research <research@splunk.com> id: CAR-2021-05-004 description: The following query identifies Microsoft Background Intelligent Transfer Service utility `bitsadmin.exe` scheduling a BITS job to persist on an endpoint. The query identifies the parameters used to create, resume or add a file to a BITS job. Typically seen combined in a oneliner or ran in sequence. If identified, review the BITS job created and capture any files written to disk. It is possible for BITS to be used to upload files and this may require further network data analysis to identify. You can use `bitsadmin /list /verbose` to list out the jobs during investigation. coverage: - technique: T1197 tactics: - TA0005 - TA0003 coverage: Moderate implementations: - name: Pseudocode â€“ detect a BITS job being scheduled description: Pseudocode implementation of the splunk search below code: |- processes = search Process:Create bitsadmin_commands = filter processes where ( exe ="C:\Windows\System32\bitsadmin.exe" AND command_line includes one of [*create*, *addfile*, *setnotifyflags*, *setnotifycmdline*, *setminretrydelay*, *setcustomheaders*,*resume*]) output bitsadmin_commands data_model: CAR native type: Pseudocode - name: Splunk code description: To successfully implement this search you need to be ingesting information on process that include the name of the process responsible for the changes from your endpoints into the `Endpoint` datamodel in the `Processes` node. code: '| tstats count min(_time) as firstTime max(_time) as lastTime from datamodel=Endpoint.Processes where Processes.process_name=bitsadmin.exe Processes.process IN (*create*, *addfile*, *setnotifyflags*, *setnotifycmdline*, *setminretrydelay*, *setcustomheaders*, *resume* ) by Processes.dest Processes.user Processes.parent_process Processes.process_name Processes.process Processes.process_id Processes.parent_process_id' type: Splunk data_model: Endpoint unit_tests: - configurations: - Using Splunk [Attack Range]() description: Replay the detection [dataset]() using the Splunk attack range with the commands below commands: - python attack_range.py replay -dn data_dump [--dump NAME_OF_DUMP] - configurations: - Using [Invoke-AtomicRedTeam]() description: execute the atomic test [T1197]() against a Windows target. commands: - Invoke-AtomicTest T1197 data_model_references: - process/create/exe - process/create/command_line d3fend_mappings: - iri: d3f:ProcessSpawnAnalysis id: D3-PSA label: Process Spawn Analysis 
<li><a href="#">title: BITSAdmin Download File submission_date: 2021/05/11 information_domain: Analytic platforms: - Windows subtypes: - Process analytic_types: - TTP contributors: - Splunk Threat Research <research@splunk.com> id: CAR-2021-05-005 description: The following query identifies Microsoft Background Intelligent Transfer Service utility `bitsadmin.exe` using the `transfer` parameter to download a remote object. In addition, look for `download` or `upload` on the command-line, the switches are not required to perform a transfer. Capture any files downloaded. Review the reputation of the IP or domain used. Typically once executed, a follow on command will be used to execute the dropped file. Note that the network connection or file modification events related will not spawn or create from `bitsadmin.exe`, but the artifacts will appear in a parallel process of `svchost.exe` with a command-line similar to `svchost.exe -k netsvcs -s BITS`. It's important to review all parallel and child processes to capture any behaviors and artifacts. In some suspicious and malicious instances, BITS jobs will be created. You can use `bitsadmin /list /verbose` to list out the jobs during investigation. coverage: - technique: T1197 tactics: - TA0005 - TA0003 coverage: Moderate - technique: T1105 tactics: - TA0011 coverage: Moderate implementations: - name: Pseudocode â€“ detect BITS transfer jobs description: Pseudocode implementation of the Splunk search below code: |- processes = search Process:Create bitsadmin_commands = filter processes where ( exe ="C:\Windows\System32\bitsadmin.exe" AND command_line = *transfer*) output bitsadmin_commands data_model: CAR native type: Pseudocode - name: Splunk code description: To successfully implement this search you need to be ingesting information on process that include the name of the process responsible for the changes from your endpoints into the `Endpoint` datamodel in the `Processes` node. code: '| tstats count min(_time) as firstTime max(_time) as lastTime from datamodel=Endpoint.Processes where Processes.process_name=bitsadmin.exe Processes.process=*transfer* by Processes.dest Processes.user Processes.parent_process Processes.process_name Processes.process Processes.process_id Processes.parent_process_id' type: Splunk data_model: Endpoint unit_tests: - configurations: - Using Splunk [Attack Range]() description: Replay the detection [dataset]() using the Splunk attack range with the commands below commands: - python attack_range.py replay -dn data_dump [--dump NAME_OF_DUMP] - configurations: - Using [Invoke-AtomicRedTeam]() description: execute the atomic test [T1197]() against a Windows target. commands: - Invoke-AtomicTest T1197 data_model_references: - process/create/exe - process/create/command_line d3fend_mappings: - iri: d3f:ProcessSpawnAnalysis id: D3-PSA label: Process Spawn Analysis 
<li><a href="#">title: Boot or Logon Initialization Scripts submission_date: 2020/11/30 information_domain: Host platforms: - Windows subtypes: - Registry - Process analytic_types: - TTP contributors: - Olaf Hartong id: CAR-2020-11-001 description: |- Adversaries may schedule software to run whenever a user logs into the system; this is done to establish persistence and sometimes for lateral movement. This trigger is established through the registry key HKEY_CURRENT_USER\Environment*UserInitMprLogonScript*. This signature looks edits to existing keys or creation of new keys in that path. Users purposefully adding benign scripts to this path will result in false positives; that case is rare, however. There are other ways of running a script at startup or login that are not covered in this signature. Note that this signature overlaps with the Windows Sysinternals Autoruns tool, which would also show changes to this registry path. coverage: - technique: T1037 tactics: - TA0003 - TA0008 subtechniques: - T1037.001 coverage: Moderate implementations: - name: Pseudocode - logon run script key added to registry using reg.exe on commandline, or new logon scipt keys in registry from any source. description: This is a pseudocode representation of the below splunk search. code: |- processes = search Process:Create logon_script_key_processes = filter processes where ( command_line = "*reg*add*\Environment*UserInitMprLogonScript") registry = search (Registry:Add OR Registry:Edit) registry_logon_key_events = filter registry where ( key = "*\Environment*UserInitMprLogonScript") output (logon_script_key_processes, registry_logon_key_events) data_model: CAR native type: Pseudocode - name: Splunk Search -- logon scripts description: Look for commands for adding a logon script as a registry value, as well as direct registry events for the same thing. code: |- (index=__your_sysmon_index__ EventCode=1 Image="C:\\Windows\\System32\\reg.exe" CommandLine="*add*\\Environment*UserInitMprLogonScript") OR (index=__your_sysmon_index__ (EventCode=12 OR EventCode=14 OR EventCode=13) TargetObject="*\\Environment*UserInitMprLogonScript") data_model: Sysmon native type: Splunk - name: LogPoint Search -- logon scripts description: Look for commands for adding a logon script as a registry value, as well as direct registry events for the same thing. code: |- norm_id=WindowsSysmon ((event_id=1 image="C:\Windows\System32\reg.exe" command="*add*\Environment*UserInitMprLogonScript") OR (event_id IN [12, 13, 14] target_object="*\Environment*UserInitMprLogonScript")) data_model: LogPoint native type: LogPoint data_model_references: - process/create/command_line - process/create/exe - registry/add/key - registry/edit/key d3fend_mappings: - iri: d3f:SystemInitConfigAnalysis id: D3-SICA label: System Init Config Analysis 
<li><a href="#">title: CertUtil Download With URLCache and Split Arguments submission_date: 2021/05/11 information_domain: Analytic platforms: - Windows subtypes: - Process analytic_types: - TTP contributors: - Splunk Threat Research <research@splunk.com> id: CAR-2021-05-006 description: Certutil.exe may download a file from a remote destination using `-urlcache`. This behavior does require a URL to be passed on the command-line. In addition, `-f` (force) and `-split` (Split embedded ASN.1 elements, and save to files) will be used. It is not entirely common for `certutil.exe` to contact public IP space. However, it is uncommon for `certutil.exe` to write files to world writeable paths.\ During triage, capture any files on disk and review. Review the reputation of the remote IP or domain in question. coverage: - technique: T1105 tactics: - TA0011 coverage: Moderate implementations: - name: Pseudocode â€“ CertUtil download description: Pseudocode implementation of the Splunk search below code: |- processes = search Process:Create certutil_downloads = filter processes where ( exe ="C:\Windows\System32\certutil.exe" AND command_line = *urlcache* AND command_line = *split*) output certutil_downloads data_model: CAR native type: Pseudocode - name: Splunk code description: To successfully implement this search you need to be ingesting information on process that include the name of the process responsible for the changes from your endpoints into the `Endpoint` datamodel in the `Processes` node. code: '| tstats count min(_time) as firstTime max(_time) as lastTime from datamodel=Endpoint.Processes where Processes.process_name=certutil.exe Processes.process=*urlcache* Processes.process=*split* by Processes.dest Processes.user Processes.parent_process Processes.process_name Processes.process Processes.process_id Processes.parent_process_id' type: Splunk data_model: Endpoint unit_tests: - configurations: - Using Splunk [Attack Range]() description: Replay the detection [dataset]() using the Splunk attack range with the commands below commands: - python attack_range.py replay -dn data_dump [--dump NAME_OF_DUMP] - configurations: - Using [Invoke-AtomicRedTeam]() description: execute the atomic test [T1105]() against a Windows target. commands: - Invoke-AtomicTest T1105 data_model_references: - process/create/exe - process/create/command_line d3fend_mappings: - iri: d3f:ProcessSpawnAnalysis id: D3-PSA label: Process Spawn Analysis 
<li><a href="#">title: CertUtil Download With VerifyCtl and Split Arguments submission_date: 2021/05/11 information_domain: Analytic platforms: - Windows subtypes: - Process analytic_types: - TTP contributors: - Splunk Threat Research <research@splunk.com> id: CAR-2021-05-007 description: 'Certutil.exe may download a file from a remote destination using `-VerifyCtl`. This behavior does require a URL to be passed on the command-line. In addition, `-f` (force) and `-split` (Split embedded ASN.1 elements, and save to files) will be used. It is not entirely common for `certutil.exe` to contact public IP space. \ During triage, capture any files on disk and review. Review the reputation of the remote IP or domain in question. Using `-VerifyCtl`, the file will either be written to the current working directory or `%APPDATA%\..\LocalLow\Microsoft\CryptnetUrlCache\Content\<hash>`. ' coverage: - technique: T1105 tactics: - TA0011 coverage: Moderate implementations: - name: Pseudocode â€“ CertUtil download with VerifyCtl description: Pseudocode implementation of the Splunk search below code: |- processes = search Process:Create certutil_downloads = filter processes where ( exe = "C:\Windows\System32\certutil.exe" AND command_line = *verifyctl* AND command_line = *split*) output certutil_downloads data_model: CAR native type: Pseudocode - name: Splunk code description: To successfully implement this search you need to be ingesting information on process that include the name of the process responsible for the changes from your endpoints into the `Endpoint` datamodel in the `Processes` node. code: '| tstats count min(_time) as firstTime max(_time) as lastTime from datamodel=Endpoint.Processes where Processes.process_name=certutil.exe Processes.process=*verifyctl* Processes.process=*split* by Processes.dest Processes.user Processes.parent_process Processes.process_name Processes.process Processes.process_id Processes.parent_process_id' type: Splunk data_model: Endpoint unit_tests: - configurations: - Using Splunk [Attack Range]() description: Replay the detection [dataset]() using the Splunk attack range with the commands below commands: - python attack_range.py replay -dn data_dump [--dump NAME_OF_DUMP] - configurations: - Using [Invoke-AtomicRedTeam]() description: execute the atomic test [T1105]() against a Windows target. commands: - Invoke-AtomicTest T1105 data_model_references: - process/create/exe - process/create/command_line d3fend_mappings: - iri: d3f:ProcessSpawnAnalysis id: D3-PSA label: Process Spawn Analysis 
<li><a href="#">title: Certutil exe certificate extraction submission_date: 2021/05/11 information_domain: Analytic platforms: - Windows subtypes: - Process analytic_types: - TTP contributors: - Splunk Threat Research <research@splunk.com> id: CAR-2021-05-008 description: This search looks for arguments to certutil.exe indicating the manipulation or extraction of Certificate. This certificate can then be used to sign new authentication tokens specially inside Federated environments such as Windows ADFS. coverage: - technique: T1606 subtechniques: - T1606.002 tactics: - TA0006 coverage: Moderate implementations: - name: Pseudocode â€“ CertUtil certificate extraction description: Pseudocode implementation of the Splunk search below code: |- processes = search Process:Create certutil_downloads = filter processes where ( exe =â€C:\Windows\System32\certutil.exeâ€ AND command_line = * -exportPFX * ) output certutil_downloads data_model: CAR native type: Pseudocode - name: Splunk code description: Splunk implementation code: '| tstats count min(_time) as firstTime values(Processes.process) as process max(_time) as lastTime from datamodel=Endpoint.Processes where Processes.process_name=certutil.exe Processes.process = "* -exportPFX *" by Processes.parent_process Processes.process_name Processes.process Processes.user' type: Splunk data_model: Endpoint unit_tests: - configurations: - Using Splunk [Attack Range]() description: Replay the detection [dataset]() using the Splunk attack range with the commands below commands: - python attack_range.py replay -dn data_dump [--dump NAME_OF_DUMP] - configurations: - Using [Invoke-AtomicRedTeam]() description: execute the atomic test [T1606.002]() against a Windows target. commands: - Invoke-AtomicTest T1606.002 data_model_references: - process/create/exe - process/create/command_line d3fend_mappings: - iri: d3f:ProcessSpawnAnalysis id: D3-PSA label: Process Spawn Analysis 
<li><a href="#">title: CertUtil With Decode Argument submission_date: 2021/05/11 information_domain: Analytic platforms: - Windows subtypes: - Process analytic_types: - TTP contributors: - Splunk Threat Research <research@splunk.com> id: CAR-2021-05-009 description: CertUtil.exe may be used to `encode` and `decode` a file, including PE and script code. Encoding will convert a file to base64 with `-----BEGIN CERTIFICATE-----` and `-----END CERTIFICATE-----` tags. Malicious usage will include decoding a encoded file that was downloaded. Once decoded, it will be loaded by a parallel process. Note that there are two additional command switches that may be used - `encodehex` and `decodehex`. Similarly, the file will be encoded in HEX and later decoded for further execution. During triage, identify the source of the file being decoded. Review its contents or execution behavior for further analysis. coverage: - technique: T1140 tactics: - TA0005 coverage: Moderate implementations: - name: Pseudocode â€“ CertUtil with Decode Argument description: Pseudocode implementation of the Splunk search below code: |- processes = search Process:Create certutil_downloads = filter processes where ( exe =â€C:\Windows\System32\certutil.exeâ€ AND command_line = *decode* ) output certutil_downloads data_model: CAR native type: Pseudocode - name: Splunk code description: To successfully implement this search you need to be ingesting information on process that include the name of the process responsible for the changes from your endpoints into the `Endpoint` datamodel in the `Processes` node. code: '| tstats count min(_time) as firstTime max(_time) as lastTime from datamodel=Endpoint.Processes where Processes.process_name=certutil.exe Processes.process=*decode* by Processes.dest Processes.user Processes.parent_process Processes.process_name Processes.process Processes.process_id Processes.parent_process_id' type: Splunk data_model: Endpoint unit_tests: - configurations: - Using Splunk [Attack Range]() description: Replay the detection [dataset]() using the Splunk attack range with the commands below commands: - python attack_range.py replay -dn data_dump [--dump NAME_OF_DUMP] - configurations: - Using [Invoke-AtomicRedTeam]() description: execute the atomic test [T1140]() against a Windows target. commands: - Invoke-AtomicTest T1140 data_model_references: - process/create/exe - process/create/command_line d3fend_mappings: - iri: d3f:ProcessSpawnAnalysis id: D3-PSA label: Process Spawn Analysis 
<li><a href="#">title: Clear Powershell Console Command History submission_date: 2020/11/30 information_domain: Host platforms: - Windows subtypes: - Process analytic_types: - TTP contributors: - Olaf Hartong id: CAR-2020-11-005 description: |- Adversaries may attempt to conceal their tracks by deleting the history of commands run within the Powershell console, or turning off history saving to begin with. This analytic looks for several commands that would do this. This does not capture the event if it is done within the console itself; only commandline-based commands are detected. Note that the command to remove the history file directly may very a bit if the history file is not saved in the default path on a particular system. coverage: - technique: T1070 tactics: - TA0005 subtechniques: - T1070.003 coverage: Low implementations: - name: Pseudocode - clear or disable Powershell console history via commandline description: This is a pseudocode representation of the below splunk search. code: |- processes = search Process:Create clear_commands = filter processes where ( command_line ="*rm (Get-PSReadlineOption).HistorySavePath*" OR command_line="*del (Get-PSReadlineOption).HistorySavePath*" OR command_line="*Set-PSReadlineOption â€“HistorySaveStyle SaveNothing*" OR command_line="*Remove-Item (Get-PSReadlineOption).HistorySavePath*") OR command_linee="del*Microsoft\Windows\Powershell\PSReadline\ConsoleHost_history.txt") output clear_commands data_model: CAR native type: Pseudocode - name: Splunk Search - clear command history via Powershell description: Look for powershell commands that would clear command history code: |- (index=__your_sysmon_index__ EventCode=1) (CommandLine="*rm (Get-PSReadlineOption).HistorySavePath*" OR CommandLine="*del (Get-PSReadlineOption).HistorySavePath*" OR CommandLine="*Set-PSReadlineOption â€“HistorySaveStyle SaveNothing*" OR CommandLine="*Remove-Item (Get-PSReadlineOption).HistorySavePath*" OR CommandLine="del*Microsoft\\Windows\\Powershell\\PSReadline\\ConsoleHost_history.txt") data_model: Sysmon native type: Splunk - name: LogPoint Search - clear command history via Powershell description: Look for powershell commands that would clear command history code: |- norm_id=WindowsSysmon event_id=1 (command="*rm (Get-PSReadlineOption).HistorySavePath*" OR command="*del (Get-PSReadlineOption).HistorySavePath*" OR command="*Set-PSReadlineOption â€“HistorySaveStyle SaveNothing*" OR command="*Remove-Item (Get-PSReadlineOption).HistorySavePath*" OR command="del*Microsoft\Windows\Powershell\PSReadline\ConsoleHost_history.txt") data_model: LogPoint native type: LogPoint data_model_references: - process/create/exe - process/create/command_line d3fend_mappings: - iri: d3f:ProcessSpawnAnalysis id: D3-PSA label: Process Spawn Analysis 
<li><a href="#">title: Clearing Windows Logs with Wevtutil submission_date: 2020/12/02 information_domain: 'Host' platforms: - Windows subtypes: - Process analytic_types: - TTP contributors: - Cyware Labs id: CAR-2021-01-003 description: |- In an attempt to clear traces after compromising a machine, threat actors often try to clear Windows Event logs. This is often done using â€œwevtutilâ€, a legitimate tool provided by Microsoft. This action interferes with event collection and notification, and may lead to a security event going undetected, thereby potentially leading to further compromise of the network. coverage: - technique: T1070 coverage: Low subtechniques: - T1070.001 tactics: - TA0005 implementations: - name: Splunk search - Detecting log clearing with wevtutil description: This search query looks for an instance where wevtutil is invoked along with a command that may cause the system to remove Windows Event logs. code: |- index=__your_sysmon_index__ sourcetype= __your__windows__sysmon__sourcetype EventCode=1 Image=*wevtutil* CommandLine=*cl* (CommandLine=*System* OR CommandLine=*Security* OR CommandLine=*Setup* OR CommandLine=*Application*) data_model: Sysmon native type: Splunk data_model_references: - process/create/command_line d3fend_mappings: - iri: d3f:ProcessSpawnAnalysis id: D3-PSA label: Process Spawn Analysis --- 
<li><a href="#">title: CMSTP submission_date: 2020/11/30 information_domain: Host platforms: - Windows subtypes: - Process analytic_types: - TTP contributors: - Olaf Hartong - MITRE id: CAR-2020-11-010 description: |- CMSTP.exe is the Microsoft Connection Manager Profile Installer, which can be leveraged to setup listeners that will receive and install malware from remote sources in trusted fashion. When CMSTP.exe is seen in combination with an external connection, it is a good indication of this TTP. coverage: - technique: T1218 tactics: - TA0005 subtechniques: - T1218.003 coverage: High implementations: - name: Pseudocode - CMSTP description: This is a pseudocode representation of the below splunk search. code: |- processes = search Process:Create target_processes = filter processes where ( exe="C:\Windows\System32\CMSTP.exe" AND src_ip NOT IN [10.0.0.0/8,192.168.0.0/16, 172.16.0.0/12] ) output target_processes data_model: CAR native type: Pseudocode - name: Splunk Search - CMSTP description: looks for instances of CMSTP.exe that are combined with external communication code: |- (index=__your_sysmon_index__ EventCode=3) Image="C:\\Windows\\System32\\CMSTP.exe" | where ((!cidrmatch("10.0.0.0/8", SourceIp) AND !cidrmatch("192.168.0.0/16", SourceIp) AND !cidrmatch("172.16.0.0/12", SourceIp)) data_model: Sysmon native type: Splunk - name: LogPoint Search - CMSTP description: looks for instances of CMSTP.exe that are combined with external communication code: |- norm_id=WindowsSysmon event_id=3 image="C:\Windows\System32\CMSTP.exe" -source_address IN HOMENET data_model: LogPoint native type: LogPoint data_model_references: - process/create/exe - process/create/src_ip d3fend_mappings: - iri: d3f:ProcessSpawnAnalysis id: D3-PSA label: Process Spawn Analysis 
<li><a href="#">title: Command Launched from WinLogon submission_date: 2014/11/19 information_domain: Host platforms: - Windows subtypes: - Process analytic_types: - TTP contributors: - MITRE id: CAR-2014-11-008 description: |- An adversary can use [accessibility features]() (Ease of Access), such as StickyKeys or Utilman, to launch a command shell from the logon screen and gain SYSTEM access. Since an adversary does not have physical access to the machine, this technique must be run within [Remote Desktop](). To prevent an adversary from getting to the login screen without first authenticating, Network-Level Authentication (NLA) must be enabled. If a debugger is set up for one of the accessibility features, then it will intercept the process launch of the feature and instead execute a new command line. This analytic looks for instances of `cmd.exe` or `powershell.exe` launched directly from the logon process, `winlogon.exe`. It should be used in tandem with [CAR-2014-11-003](../CAR-2014-11-003), which detects the accessibility programs in the command line. Several accessibility programs can be run using the Ease of Access center - `sethc.exe` handles StickyKeys - `utilman.exe` is the Ease of Access menu - `osk.exe` runs the On-Screen Keyboard - `narrator.exe` reads screen text over audio - `magnify.exe` magnifies the view of the screen near the cursor coverage: - technique: T1546 tactics: - TA0004 - TA0003 subtechniques: - T1546.008 coverage: Moderate implementations: - description: 'Look for instances of processes where the parent executable is winlogon.exe and the child is an instance of a command prompt. ' code: |- processes = search Process:Create winlogon_cmd = filter processes where (parent_exe == "winlogon.exe" and exe == "cmd.exe") output winlogon_cmd type: pseudocode - description: Splunk version of the above pseudocode. code: |- index=__your_sysmon_index__ EventCode=1 ParentImage="C:\\Windows\\*\\winlogon.exe" Image="C:\\Windows\\*\\cmd.exe" type: Splunk data_model: Sysmon native - description: EQL version of the above pseudocode. code: |- process where subtype.create and (process_name == "cmd.exe" and parent_process_name == "winlogon.exe") type: EQL data_model: EQL native - description: LogPoint version of the above pseudocode. code: |- norm_id=WindowsSysmon event_id=1 parent_image="C:\Windows\System32\winlogon.exe" parent_image="C:\Windows\System32\cmd.exe" type: LogPoint data_model: LogPoint native data_model_references: - process/create/exe - process/create/parent_exe d3fend_mappings: - iri: d3f:ProcessLineageAnalysis id: D3-PLA label: Process Lineage Analysis 
<li><a href="#">title: Command Line Usage of Archiving Software submission_date: 2013/07/31 information_domain: Host platforms: - Windows - Linux - macOS subtypes: - Process analytic_types: - TTP contributors: - MITRE id: CAR-2013-07-005 description: |- Before [exfiltrating data]() that an adversary has [collected](), it is very likely that a [compressed archive]() will be created, so that transfer times are minimized and fewer files are transmitted. There is variety between the tools used to compress data, but the command line usage and context of archiving tools, such as ZIP, RAR, and 7ZIP, should be monitored. In addition to looking for RAR or 7z program names, command line usage of 7Zip or RAR can be detected with the flag usage of "`\* a \*`". This is helpful, as adversaries may change program names. coverage: - technique: T1560 tactics: - TA0010 subtechniques: - T1560.001 coverage: Moderate implementations: - description: 'This analytic looks for the command line argument `a`, which is used by RAR. However, there may be other programs that have this as a legitimate argument and may need to be filtered out.' code: |- processes = search Process:Create rar_argument = filter processes where (command_line == "* a *") output rar_argument type: pseudocode - description: DNIF version of the above pseudocode. code: |- _fetch * from event where $LogName=WINDOWS-SYSMON AND $EventID=1 AND $Process=regex(.* a .*)i limit 100 type: DNIF data_model: Sysmon native - description: LogPoint version of the above pseudocode. code: |- norm_id=WindowsSysmon event_id=1 command="* a *" type: LogPoint data_model: LogPoint native data_model_references: - process/create/command_line unit_tests: - configurations: - Windows 7 description: 'Download 7zip or other archiving software you plan to monitor. Create an innocuous text file for testing, or substitute an existing file.' commands: - 7z.exe a test.zip test.txt d3fend_mappings: - iri: d3f:ProcessSpawnAnalysis id: D3-PSA label: Process Spawn Analysis 
<li><a href="#">title: Common Windows Process Masquerading submission_date: 2021/02/12 information_domain: Host platforms: - Windows subtypes: - Process analytic_types: - TTP contributors: - Sebastien Damaye id: CAR-2021-04-001 description: |- [Masquerading (T1036)]() is defined by ATT&CK as follows: "Masquerading occurs when the name or location of an object, legitimate or malicious, is manipulated or abused for the sake of evading defenses and observation. This may include manipulating file metadata, tricking users into misidentifying the file type, and giving legitimate task or service names." Malware authors often use this technique to hide malicious executables behind legitimate Windows executable names (e.g. `lsass.exe`, `svchost.exe`, etc). There are several sub-techniques, but this analytic focuses on [Match Legitimate Name or Location]() only. **Analytic Methodology** With process monitoring, hunt for processes matching these criteria: * process name is `svchost.exe`, `smss.exe`, `wininit.exe`, `taskhost.exe`, etc. * process path is not `C:\Windows\System32\` or `C:\Windows\SysWow64\` Examples (true positive): `C:\Users\administrator\svchost.exe` To make sure the rule doesn't miss cases where the executable would be started from a sub-folder of these locations, the entire path is checked for the process path. The below example should be considered as suspicious: `C:\Windows\System32\srv\svchost.exe` coverage: - technique: T1036 tactics: - TA0005 subtechniques: - T1036.005 coverage: Moderate implementations: - name: Pseudocode - Common Windows Process Masquerading description: Looks for mismatches between process names and their image paths. code: |- processes = search Process:* suspicious_processes = filter processes where ( (exe=svchost.exe AND (image_path!="C:\\Windows\\System32\\svchost.exe" OR process_path!="C:\\Windows\\SysWow64\\svchost.exe")) OR (exe=smss.exe AND image_path!="C:\\Windows\\System32\\smss.exe") OR (exe=wininit.exe AND image_path!="C:\\Windows\\System32\\wininit.exe") OR (exe=taskhost.exe AND image_path!="C:\\Windows\\System32\\taskhost.exe") OR (exe=lasass.exe AND image_path!="C:\\Windows\\System32\\lsass.exe") OR (exe=winlogon.exe AND image_path!="C:\\Windows\\System32\\winlogon.exe") OR (exe=csrss.exe AND image_path!="C:\\Windows\\System32\\csrss.exe") OR (exe=services.exe AND image_path!="C:\\Windows\\System32\\services.exe") OR (exe=lsm.exe AND image_path!="C:\\Windows\\System32\\lsm.exe") OR (exe=explorer.exe AND image_path!="C:\\Windows\\explorer.exe") ) output suspicious_processes data_model: CAR native type: Pseudocode - name: Splunk Search - Common Windows Process Masquerading description: Splunk search version of the above pseudocode. code: |- index=__your_sysmon_index__ source="XmlWinEventLog:Microsoft-Windows-Sysmon/Operational" AND ( (process_name=svchost.exe AND NOT (process_path="C:\\Windows\\System32\\svchost.exe" OR process_path="C:\\Windows\\SysWow64\\svchost.exe")) OR (process_name=smss.exe AND NOT process_path="C:\\Windows\\System32\\smss.exe") OR (process_name=wininit.exe AND NOT process_path="C:\\Windows\\System32\\wininit.exe") OR (process_name=taskhost.exe AND NOT process_path="C:\\Windows\\System32\\taskhost.exe") OR (process_name=lasass.exe AND NOT process_path="C:\\Windows\\System32\\lsass.exe") OR (process_name=winlogon.exe AND NOT process_path="C:\\Windows\\System32\\winlogon.exe") OR (process_name=csrss.exe AND NOT process_path="C:\\Windows\\System32\\csrss.exe") OR (process_name=services.exe AND NOT process_path="C:\\Windows\\System32\\services.exe") OR (process_name=lsm.exe AND NOT process_path="C:\\Windows\\System32\\lsm.exe") OR (process_name=explorer.exe AND NOT process_path="C:\\Windows\\explorer.exe") ) data_model: Sysmon native type: Splunk data_model_references: - process/create/exe - process/create/image_path - process/access/exe - process/access/image_path - process/terminate/exe - process/terminate/image_path d3fend_mappings: - iri: d3f:ProcessSpawnAnalysis id: D3-PSA label: Process Spawn Analysis 
<li><a href="#">title: Compiled HTML Access submission_date: 2020/11/30 information_domain: Host platforms: - Windows subtypes: - Process analytic_types: - TTP contributors: - Olaf Hartong id: CAR-2020-11-009 description: |- Adversaries may hide malicious code in .chm compiled HTML files. When these files are read, Windows uses the HTML help executable named hh.exe, which is the signature for this analytic. coverage: - technique: T1218 tactics: - TA0005 subtechniques: - T1218.001 coverage: High implementations: - name: Pseudocode - instances of hh.exe description: This is a pseudocode representation of the below splunk search. code: |- processes = search Process:Create target_processes = filter processes where (exe="C:\Windows\syswow64\hh.exe" OR exe="C:\Windows\system32\hh.exe") output target_processes data_model: CAR native type: Pseudocode - name: Splunk Search - hh.exe description: looks all instances of hh.exe code: |- (index=__your_sysmon_index__ EventCode=1) (Image="C:\\Windows\\syswow64\\hh.exe" OR Image="C:\\Windows\\system32\\hh.exe") data_model: Sysmon native type: Splunk - name: LogPoint Search - hh.exe description: looks all instances of hh.exe code: |- norm_id=WindowsSysmon event_id=1 (image="C:\Windows\syswow64\hh.exe" OR image="C:\Windows\system32\hh.exe") data_model: LogPoint native type: LogPoint data_model_references: - process/create/exe d3fend_mappings: - iri: d3f:ProcessSpawnAnalysis id: D3-PSA label: Process Spawn Analysis 
<li><a href="#">title: Component Object Model Hijacking submission_date: 2020/09/10 information_domain: 'Host' platforms: - Windows subtypes: - Registry analytic_types: - Situational Awareness contributors: - Olaf Hartong id: CAR-2020-09-002 description: |- Adversaries may establish persistence or escalate privileges by executing malicious content triggered by hijacked references to Component Object Model (COM) objects. This is typically done by replacing COM object registry entries under the HKEY_CURRENT_USER\Software\Classes\CLSID or HKEY_LOCAL_MACHINE\SOFTWARE\Classes\CLSID keys. Accordingly, this analytic looks for any changes under these keys. coverage: - technique: T1546 coverage: Moderate subtechniques: - T1546.015 tactics: - TA0003 - TA0004 implementations: - name: Pseudocode - COM object registry entry modification description: This is a pseudocode representation of the below splunk search. code: |- registry_keys = search (Registry:Create AND Registry:Remove AND Registry:Edit) clsid_keys = filter registry_keys where ( key = "*\Software\Classes\CLSID\*") output clsid_keys data_model: CAR native type: Pseudocode - name: Splunk search - COM object registry entry modification description: This Splunk search looks for any registry keys that were created, deleted, or renamed, as well as any registry values that were set or renamed under the Windows COM Object registry key. code: |- index=__your_sysmon_index__ (EventCode=12 OR EventCode=13 OR EventCode=14) TargetObject="*\\Software\\Classes\\CLSID\\*" data_model: Sysmon native type: Splunk - name: LogPoint search - COM object registry entry modification description: This LogPoint search looks for any registry keys that were created, deleted, or renamed, as well as any registry values that were set or renamed under the Windows COM Object registry key. code: |- norm_id=WindowsSysmon event_id IN [12, 13, 14] target_object="*\Software\Classes\CLSID\*" data_model: LogPoint native type: LogPoint data_model_references: - registry/add/key - registry/remove/key - registry/edit/key d3fend_mappings: - iri: d3f:SystemInitConfigAnalysis id: D3-SICA label: System Init Config Analysis --- 
<li><a href="#">title: Create local admin accounts using net exe submission_date: 2021/05/11 information_domain: Analytic platforms: - Windows subtypes: - Process analytic_types: - TTP contributors: - Splunk Threat Research <research@splunk.com> id: CAR-2021-05-010 description: This search looks for the creation of local administrator accounts using net.exe. coverage: - technique: T1136 subtechniques: - T1136.001 tactics: - TA0003 coverage: Moderate implementations: - name: Pseudocode â€“ CertUtil certificate extraction description: Pseudocode implementation of the Splunk search below code: |- processes = search Process:Create certutil_downloads = filter processes where ( (exe = C:\Windows\System32\net.exe OR exe = C:\Windows\System32\net1.exe ) AND command_line = * -exportPFX * ) output certutil_downloads data_model: CAR native type: Pseudocode - name: Splunk code description: You must be ingesting data that records process activity from your hosts to populate the Endpoint data model in the Processes node. You must also be ingesting logs with both the process name and command line from your endpoints. The command-line arguments are mapped to the "process" field in the Endpoint data model. code: '| tstats count values(Processes.user) as user values(Processes.parent_process) as parent_process min(_time) as firstTime max(_time) as lastTime from datamodel=Endpoint.Processes where (Processes.process_name=net.exe OR Processes.process_name=net1.exe) AND (Processes.process=*localgroup* OR Processes.process=*/add* OR Processes.process=*user*) by Processes.process Processes.process_name Processes.dest |`create_local_admin_accounts_using_net_exe_filter`' type: Splunk data_model: Endpoint unit_tests: - configurations: - Using Splunk [Attack Range]() description: Replay the detection [dataset]() using the Splunk attack range with the commands below commands: - python attack_range.py replay -dn data_dump [--dump NAME_OF_DUMP] - configurations: - Using [Invoke-AtomicRedTeam]() description: execute the atomic test [T1136.001]() against a Windows target. commands: - Invoke-AtomicTest T1136.001 data_model_references: - process/create/exe - process/create/command_line d3fend_mappings: - iri: d3f:ProcessSpawnAnalysis id: D3-PSA label: Process Spawn Analysis 
<li><a href="#">title: Create Remote Process via WMIC submission_date: 2016/03/28 information_domain: Host platforms: - Windows subtypes: - Process analytic_types: - TTP contributors: - MITRE id: CAR-2016-03-002 description: |- Adversaries may use [Windows Management Instrumentation]() (WMI) to move laterally, by launching executables remotely.The analytic [CAR-2014-12-001](../CAR-2014-12-001) describes how to detect these processes with network traffic monitoring and process monitoring on the target host. However, if the command line utility `wmic.exe` is used on the source host, then it can additionally be detected on an analytic. The command line on the source host is constructed into something like `wmic.exe /node:"\<hostname\>" process call create "\<command line\>"`. It is possible to also connect via IP address, in which case the string `"\<hostname\>"` would instead look like `IP Address`. Although this analytic was created after [CAR-2014-12-001](../CAR-2014-12-001), it is a much simpler (although more limited) approach. Processes can be created remotely via WMI in a few other ways, such as more direct API access or the built-in utility [PowerShell](). coverage: - technique: T1047 tactics: - TA0002 coverage: Low implementations: - description: |- Looks for instances of wmic.exe as well as the substrings in the command line: * `process call create` * `/node:` code: |- processes = search Process:Create wmic = filter processes where (exe == "wmic.exe" and command_line == "* process call create *" and command_line == "* /node:*") output wmic type: pseudocode - description: Splunk version of the above pseudocode. code: |- index=__your_sysmon_index__ EventCode=1 Image="C:\\Windows\\*\\wmic.exe" CommandLine="* process call create *"|search CommandLine="* /node:*" type: Splunk data_mode: Sysmon native - description: EQL version of the above pseudocode. code: |- process where subtype.create and (process_name == "wmic.exe" and command_line == "* process call create ") |filter command_line == "* /node:*" type: EQL data_mode: EQL native - description: LogPoint version of the above pseudocode. code: |- norm_id=WindowsSysmon event_id=1 image="C:\\Windows\\*\\wmic.exe" command="* process call create *" command="* /node:*" type: LogPoint data_mode: LogPoint native data_model_references: - process/create/exe - process/create/command_line d3fend_mappings: - iri: d3f:ProcessSpawnAnalysis id: D3-PSA label: Process Spawn Analysis --- 
<li><a href="#">title: Create Remote Thread into LSASS submission_date: 2021/05/11 information_domain: Analytic platforms: - Windows subtypes: - Process analytic_types: - TTP contributors: - Splunk Threat Research <research@splunk.com> id: CAR-2021-05-011 description: Actors may create a remote thread into the LSASS service as part of a workflow to dump credentials. coverage: - technique: T1003 subtechniques: - T1003.001 tactics: - TA0006 coverage: Moderate implementations: - name: Pseudocode â€“ Remote thread creation into LSASS description: Pseudocode implementation of the Splunk search below. The CAR data model does not currently contain a Target Image field, for remote thread creation, so this code Is somewhat inexact. See the Splunk implementation for a more precise search for the lsass image target. code: |- remote_threads = search Thread:remote_create lsass_remote_create = filter remote_threads where "lsass" in raw event output lsass_remote_create data_model: CAR native type: Pseudocode - name: Splunk code description: This search needs Sysmon Logs with a Sysmon configuration, which includes EventCode 8 with lsass.exe. This search uses an input macro named `sysmon`. We strongly recommend that you specify your environment-specific configurations (index, source, sourcetype, etc.) for Windows Sysmon logs. Replace the macro definition with configurations for your Splunk environment. The search also uses a post-filter macro designed to filter out known false positives. code: '`sysmon` EventID=8 TargetImage=*lsass.exe | stats count min(_time) as firstTime max(_time) as lastTime by Computer, EventCode, TargetImage, TargetProcessId | rename Computer as dest' type: Splunk data_model: '' unit_tests: - configurations: - Using Splunk [Attack Range]() description: Replay the detection [dataset]() using the Splunk attack range with the commands below commands: - python attack_range.py replay -dn data_dump [--dump NAME_OF_DUMP] - configurations: - Using [Invoke-AtomicRedTeam]() description: execute the atomic test [T1003.001]() against a Windows target. commands: - Invoke-AtomicTest T1003.001 data_model_references: - thread/remote_create d3fend_mappings: - iri: d3f:SystemCallAnalysis id: D3-SCA label: System Call Analysis 
<li><a href="#">title: Create Service In Suspicious File Path submission_date: 2021/05/11 update_date: 2021/04/05 information_domain: Analytic platforms: - Windows subtypes: - Process analytic_types: - TTP contributors: - Splunk Threat Research <research@splunk.com> id: CAR-2021-05-012 description: This detection is to identify a creation of "user mode service" where the service file path is located in non-common service folder in windows. coverage: - technique: T1569 subtechniques: - T1569.001 - T1569.002 tactics: - TA0002 coverage: Moderate implementations: - name: Pseudocode â€“ Service in Suspicious File Path description: Pseudocode implementation of the Splunk search below. code: |- services = search Service:create suspicious_services = filter services where image_path = "*\.exe" AND image_path does not contain ["C:\\Windows\\*", "%windir%\\*", "C:\\Program File*", "C:\\Programdata\\*", "%systemroot%\\*"] ) output suspicious_services data_model: CAR native type: Pseudocode - name: Splunk code description: To successfully implement this search, you need to be ingesting logs with the Service name, Service File Name Service Start type, and Service Type from your endpoints. code: ' `wineventlog_system` EventCode=7045 Service_File_Name = "*\.exe" NOT (Service_File_Name IN ("C:\\Windows\\*", "%windir%\\*", "C:\\Program File*", "C:\\Programdata\\*", "%systemroot%\\*")) Service_Type = "user mode service" | stats count min(_time) as firstTime max(_time) as lastTime by EventCode Service_File_Name Service_Name Service_Start_Type Service_Type' type: Splunk data_model: Endpoint unit_tests: - configurations: - Using Splunk [Attack Range]() description: Replay the detection [dataset]() using the Splunk attack range with the commands below commands: - python attack_range.py replay -dn data_dump [--dump NAME_OF_DUMP] - configurations: - Using [Invoke-AtomicRedTeam]() description: execute the atomic test [T1569.001]() against a Windows target. commands: - Invoke-AtomicTest T1569.001 data_model_references: - service/create/image_path d3fend_mappings: - iri: d3f:ProcessSpawnAnalysis id: D3-PSA label: Process Spawn Analysis 
<li><a href="#">title: Credential Dumping via Mimikatz submission_date: 2019/04/29 information_domain: 'Host' platforms: - Windows subtypes: - Process analytic_types: - TTP contributors: - MITRE id: CAR-2019-04-004 description: |- Credential dumpers like Mimikatz can be loaded into memory and from there read data from another processes. This analytic looks for instances where processes are requesting specific permissions to read parts of the LSASS process in order to detect when credential dumping is occurring. One weakness is that all current implementations are â€œovertunedâ€ to look for common access patterns used by Mimikatz. *This requires information about process access, e.g. Sysmon Event ID 10. That currently doesnâ€™t have a CAR data model mapping, since we currently lack any open/access actions for Processes. If this changes, we will update the data model requirements.* coverage: - technique: T1003 tactics: - TA0006 subtechniques: - T1003.001 coverage: Low implementations: - name: Common Mimikatz GrantedAccess Patterns description: This is specific to the way Mimikatz works currently, and thus is fragile to both future updates and non-default configurations of Mimikatz. code: |- index=__your_sysmon_data__ EventCode=10 TargetImage="C:\\WINDOWS\\system32\\lsass.exe" (GrantedAccess=0x1410 OR GrantedAccess=0x1010 OR GrantedAccess=0x1438 OR GrantedAccess=0x143a OR GrantedAccess=0x1418) CallTrace="C:\\windows\\SYSTEM32\\ntdll.dll+*|C:\\windows\\System32\\KERNELBASE.dll+20edd|UNKNOWN(*)" | table _time hostname user SourceImage GrantedAccess type: splunk data_model: Sysmon native - name: Outliers description: This is an outlier version of the above without including the specific call trace. This should work in more (but not all) situations however runs more slowly and will have more false positives - typically installers. code: |- earliest=-d@d latest=now() index=__your_sysmon_data__ EventCode=10 TargetImage="C:\\WINDOWS\\system32\\lsass.exe" (GrantedAccess=0x1410 OR GrantedAccess=0x1010 OR GrantedAccess=0x1438 OR GrantedAccess=0x143a OR GrantedAccess=0x1418) | search NOT [ search earliest=-7d@d latest=-2d@d index=__your_sysmon_data__ EventCode=10 TargetImage="C:\\WINDOWS\\system32\\lsass.exe" (GrantedAccess=0x1410 OR GrantedAccess=0x1010 OR GrantedAccess=0x1438 OR GrantedAccess=0x143a OR GrantedAccess=0x1418) | dedup SourceImage | fields SourceImage ] | table _time hostname user SourceImage GrantedAccess type: splunk data_model: Sysmon native - description: LogPoint version of the above pseudocode. code: |- norm_id=WindowsSysmon event_id=10 image="C:\Windows\system32\lsass.exe" (access="0x1410" OR access="0x1010" OR access="0x1438" OR access="0x143a" OR access="0x1418") call_trace="C:\windows\SYSTEM32\ntdll.dll+*|C:\windows\System32\KERNELBASE.dll+20edd|UNKNOWN(*)" | fields log_ts, host, user, source_image, access type: LogPoint data_mode: LogPoint native references: - Credit to [Cyb3rWard0g](), dim0x69 (blog.3or.de), and Mark Russinovich for providing much of the information used to construct these analytics. d3fend_mappings: - iri: d3f:ProcessSpawnAnalysis id: D3-PSA label: Process Spawn Analysis --- 
<li><a href="#">title: Credential Dumping via Windows Task Manager submission_date: 2019/08/05 information_domain: 'Host' platforms: - Windows subtypes: - File analytic_types: - TTP contributors: - Tony Lambert/Red Canary id: CAR-2019-08-001 description: |- The Windows Task Manager may be used to dump the memory space of `lsass.exe` to disk for processing with a credential access tool such as Mimikatz. This is performed by launching Task Manager as a privileged user, selecting `lsass.exe`, and clicking "Create dump file". This saves a dump file to disk with a deterministic name that includes the name of the process being dumped. This requires filesystem data to determine whether files have been created. coverage: - technique: T1003 tactics: - TA0006 subtechniques: - T1003.001 coverage: Low implementations: - name: Procdump - File Create description: This base pseudocode looks for file create events where a file with a name similar to lsass.dmp is created by the Windows task manager process. code: |- files = search File:Create lsass_dump = filter files where ( file_name = "lsass*.dmp" and image_path = "C:\Windows\*\taskmgr.exe") output lsass_dump type: Pseudocode - name: Procdump - File Create description: A Splunk/Sysmon version of the above pseudocode. code: |- index=__your_sysmon_index__ EventCode=11 TargetFilename="*lsass*.dmp" Image="C:\\Windows\\*\\taskmgr.exe" type: Splunk data_model: Sysmon native - name: Procdump - File Create description: An EQL version of the above pseudocode. code: |- file where file_name == "lsass*.dmp" and process_name == "taskmgr.exe" type: EQL data_model: EQL native - description: LogPoint version of the above pseudocode. code: |- norm_id=WindowsSysmon event_id=11 file="*lsass*.dmp" source_image="C:\Windows\*\taskmgr.exe" type: LogPoint data_mode: LogPoint native data_model_references: - file/create/file_name - file/create/image_path unit_tests: - description: |- 1. Open Windows Task Manager as Administrator 2. Select lsass.exe 3. Right-click on lsass.exe and select "Create dump file". true_positives: - source: 'Mordor (Sysmon)' description: 'Sysmon event from the Mordor [Interactive Task Manager lsass dump dataset]().' event_snippet: 'CAR-2019-08-001-mordor-01-snippet.json' full_event: 'CAR-2019-08-001-mordor-01.json' d3fend_mappings: - iri: d3f:FileCreationAnalysis id: D3-FCA label: File Creation Analysis --- 
<li><a href="#">title: Credentials in Files & Registry submission_date: 2020/09/10 information_domain: 'Host' platforms: - Windows subtypes: - Process - Registry analytic_types: - TTP contributors: - Olaf Hartong id: CAR-2020-09-004 description: |- Adversaries may search the Windows Registry on compromised systems for insecurely stored credentials for credential access. This can be accomplished using the query functionality of the reg.exe system utility, by looking for keys and values that contain strings such as "password". In addition, adversaries may use toolkits such as [PowerSploit]() in order to dump credentials from various applications such as IIS.Accordingly, this analytic looks for invocations of reg.exe in this capacity as well as that of several powersploit modules with similar functionality. coverage: - technique: T1552 coverage: Low subtechniques: - T1552.001 - T1552.002 tactics: - TA0006 implementations: - name: Pseudocode - reg.exe password search & powersploit modules description: This is a pseudocode representation of the below splunk search. code: |- processes = search Process:Create cred_processes = filter processes where ( command_line = "*reg* query HKLM /f password /t REG_SZ /s*" OR command_line = "reg* query HKCU /f password /t REG_SZ /s" OR command_line = "*Get-UnattendedInstallFile*" OR command_line = "*Get-Webconfig*" OR command_line = "*Get-ApplicationHost*" OR command_line = "*Get-SiteListPassword*" OR command_line = "*Get-CachedGPPPassword*" OR command_line = "*Get-RegistryAutoLogon*") output cred_processes data_model: CAR native type: Pseudocode - name: Splunk Search - reg.exe password search & powersploit modules description: This Splunk search looks for command lines of reg.exe used to search for passwords, as well as those of powersploit modules for the same purpose. code: |- ((index=__your_sysmon_index__ EventCode=1) OR (index=__your_win_syslog_index__ EventCode=4688)) (CommandLine="*reg* query HKLM /f password /t REG_SZ /s*" OR CommandLine="reg* query HKCU /f password /t REG_SZ /s" OR CommandLine="*Get-UnattendedInstallFile*" OR CommandLine="*Get-Webconfig*" OR CommandLine="*Get-ApplicationHost*" OR CommandLine="*Get-SiteListPassword*" OR CommandLine="*Get-CachedGPPPassword*" OR CommandLine="*Get-RegistryAutoLogon*") data_model: Sysmon native type: Splunk - name: LogPoint search - reg.exe password search & powersploit modules description: This LogPoint search looks for command lines of reg.exe used to search for passwords, as well as those of powersploit modules for the same purpose. code: |- norm_id=WindowsSysmon event_id=1 command IN ["*reg* query HKLM /f password /t REG_SZ /s*", "reg* query HKCU /f password /t REG_SZ /s", "*Get-UnattendedInstallFile*", "*Get-Webconfig*", "*Get-ApplicationHost*", "*Get-SiteListPassword*", "*Get-CachedGPPPassword*", "*Get-RegistryAutoLogon*"] data_model: LogPoint native type: LogPoint data_model_references: - process/create/command_line d3fend_mappings: - iri: d3f:ProcessSpawnAnalysis id: D3-PSA label: Process Spawn Analysis --- 
<li><a href="#">title: Debuggers for Accessibility Applications submission_date: 2014/11/21 information_domain: Host platforms: - Windows subtypes: - Process analytic_types: - TTP contributors: - MITRE id: CAR-2014-11-003 description: |- The Windows Registry location `HKLM\Software\Microsoft\Windows NT\CurrentVersion\Image File Execution Options` allows for parameters to be set for applications during execution. One feature used by malicious actors is the "Debugger" option. When a key has this value enabled, a Debugging command line can be specified. Windows will launch the Debugging command line, and pass the original command line in as an argument. Adversaries can set a Debugger for [Accessibility Applications](). The analytic looks for the original command line as an argument to the Debugger. When the strings "sethc.exe", "utilman.exe", "osk.exe", "narrator.exe", and "Magnify.exe" are detected in the arguments, but not as the main executable, it is very likely that a Debugger is set. This analytic could depend on the possibility of the known strings used as arguments for other applications used in the day-to-day environment. Although the chance of the string "sethc.exe" being used as an argument for another application is unlikely, it still is a possibility. coverage: - technique: T1546 tactics: - TA0004 - TA0003 subtechniques: - T1546.008 coverage: Moderate implementations: - description: 'One simple way to implement this technique is to note that in a default Windows configuration there are no spaces in the path to the `system32` folder. If the accessibility programs are ever run with a Debugger set, then Windows will launch the Debugger process and append the command line to the accessibility program. As a result, a space is inserted in the command line before the path. Looking for any instances of a space in the command line before the name of an accessibility program will help identify when Debuggers are set.' code: |- process = search Process:Create debuggers = filter process where (command_line match "$.* .*(sethc{{pipe}}utilman{{pipe}}osk{{pipe}}narrator{{pipe}}magnify)\.exe") output debuggers type: pseudocode - description: LogPoint version of the above pseudocode. code: |- norm_id=WindowsSysmon event_id=1 command IN ["$* *sethc.exe", "$* *utilman.exe", "$* *osk.exe", "$* *narrator.exe", "$* *magnify.exe"] type: LogPoint data_model: LogPoint native data_model_references: - process/create/command_line - process/create/exe unit_tests: - configurations: - Windows 7 description: 'Although it does not actually utilize the Debugging command line, an easy way to test this analytic to run cmd.exe from a command window, supplying one of the strings as arguments.' commands: - cmd.exe Magnify.exe d3fend_mappings: - iri: d3f:ProcessLineageAnalysis id: D3-PLA label: Process Lineage Analysis 
<li><a href="#">title: Detecting Shadow Copy Deletion or Resize submission_date: 2020/12/11 update_date: 2022/02/03 information_domain: 'Host' platforms: - Windows subtypes: - Process analytic_types: - TTP contributors: - Cyware Labs, Lucas Heiligenstein id: CAR-2021-01-009 description: |- After compromising a network of systems, threat actors often try to delete/resize Shadow Copy in an attempt to prevent administrators from restoring the systems to versions present before the attack. This is often done via vssadmin, a legitimate Windows tool to interact with shadow copies. This action is often employed by ransomware, may lead to a failure in recovering systems after an attack. The pseudo code detection focus on Windows Security and Sysmon process creation (4688 and 1). The use of wmic to delete shadow copy generates WMI-Activity Operationnal 5857 event and could generate 5858 (if the operation fails). These 2 EventIDs could be interesting when attackers use wmic without process creation and/or for forensics. coverage: - technique: T1490 coverage: Low tactics: - TA0040 implementations: - name: Splunk Search - Detecting Shadow Copy Deletion or Resize description: This query looks for the deletion or resizing of shadow copy volumes, which may possibly indicate malicious activity. code: |- ((EventCode="4688" OR EventCode="1") (CommandLine="*vssadmin* *delete* *shadows*" OR CommandLine="*wmic* *shadowcopy* *delete*" OR CommandLine="*vssadmin* *resize* *shadowstorage*")) OR (EventCode="5857" ProviderName="MSVSS__PROVIDER") OR (EventCode="5858" Operation="*Win32_ShadowCopy*") type: Splunk - name: Elastic Search - Detecting Shadow Copy Deletion or Resize description: This query looks for the deletion or resizing of shadow copy volumes, which may possibly indicate malicious activity. code: |- (EventCode:("4688" OR "1") AND process.command_line:(*vssadmin*\ *delete*\ *shadows* OR *wmic*\ *shadowcopy*\ *delete* OR *vssadmin*\ *resize*\ *shadowstorage*)) OR (EventCode:"5857" AND ProviderName:"MSVSS__PROVIDER") OR (EventCode:"5858" AND Operation:*Win32_ShadowCopy*) type: Elastic - name: LogPoint Search - Detecting Shadow Copy Deletion or Resize description: This query looks for the deletion or resizing of shadow copy volumes, which may possibly indicate malicious activity. code: |- (EventCode IN ["4688", "1"] CommandLine IN ["*vssadmin* *delete* *shadows*", "*wmic* *shadowcopy* *delete*", "*vssadmin* *resize* *shadowstorage*"]) OR (EventCode IN "5857" ProviderName IN "MSVSS__PROVIDER") OR (EventCode IN "5858" Operation IN "*Win32_ShadowCopy*") type: LogPoint data_model_references: - process/create/command_line d3fend_mappings: - iri: d3f:ProcessSpawnAnalysis id: D3-PSA label: Process Spawn Analysis unit_tests: - description: Shadow copy deletion with vssadmin commands: - 'vssadmin.exe delete shadows /all /quiet' - description: Shadow copy deletion with wmic commands: - 'wmic shadowcopy delete' - description: Shadow copy resize with vssadmin commands: - 'vssadmin resize shadowstorage /for=c: /on=c: /maxsize=401MB' --- 
<li><a href="#">title: Detecting Tampering of Windows Defender Command Prompt submission_date: 2020/12/11 information_domain: 'Host' platforms: - Windows subtypes: - Process analytic_types: - TTP contributors: - Cyware Labs id: CAR-2021-01-007 description: |- In an attempt to avoid detection after compromising a machine, threat actors often try to disable Windows Defender. This is often done using â€œscâ€ [service control], a legitimate tool provided by Microsoft for managing services. This action interferes with event detection and may lead to a security event going undetected, thereby potentially leading to further compromise of the network. coverage: - technique: T1562 coverage: Medium subtechniques: - T1562.001 tactics: - TA0005 implementations: - name: Splunk search - Detecting Tampering of Windows Defender Command Prompt description: This query looks for the specific use of service control for querying or trying to stop Windows Defender. code: |- index= __your_sysmon__index__ EventCode=1 Image = "C:\\Windows\\System32\\sc.exe" | regex CommandLine="^sc\s*(config|stop|query)\sWinDefend$" data_model: Sysmon native type: Splunk - name: Splunk search - Detecting Tampering of Windows Defender Command Prompt description: This query looks for the specific use of service control for querying or trying to stop Windows Defender. code: |- processes = search Process:Create target_processes = filter processes where ( (exe="C:\\Windows\\System32\\sc.exe") AND (command_line="sc *config*" OR command_line="sc *stop*" OR command_line="sc *query*") ) output target_processes type: pseudocode data_model_references: - process/create/command_line d3fend_mappings: - iri: d3f:ProcessSpawnAnalysis id: D3-PSA label: Process Spawn Analysis --- 
<li><a href="#">title: Disable UAC submission_date: 2020/12/11 information_domain: 'Host' platforms: - Windows subtypes: - Process analytic_types: - TTP contributors: - Cyware Labs id: CAR-2021-01-008 description: |- Threat actors often, after compromising a machine, try to disable User Access Control (UAC) to escalate privileges. This is often done by changing the registry key for system policies using â€œreg.exeâ€, a legitimate tool provided by Microsoft for modifying the registry via command prompt or scripts. This action interferes with UAC and may enable a threat actor to escalate privileges on the compromised system, thereby allowing further exploitation of the system. coverage: - technique: T1548 coverage: Medium subtechniques: - T1548.002 tactics: - TA0004 implementations: - name: Detect disabling of UAC via reg.exe description: This query looks for the specific use of reg.exe in correlation to commands aimed at disabling UAC. code: |- sourcetype = __your_sysmon_index__ ParentImage = "C:\\Windows\\System32\\cmd.exe" | where like(CommandLine,"reg.exe%HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System%REG_DWORD /d 0%") data_model: Sysmon native type: Splunk - name: Detect disabling of UAC via reg.exe description: This query looks for the specific use of reg.exe in correlation to commands aimed at disabling UAC. code: |- processes = search Process:Create cmd_processes = filter processes where ( (parent_image = "C:\\Windows\\System32\\cmd.exe") AND (command_line = "reg.exe%HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System%REG_DWORD /d 0%") ) data_model: Sysmon native type: pseudocode data_model_references: - process/create/image_path - process/create/command_line d3fend_mappings: - iri: d3f:ProcessSpawnAnalysis id: D3-PSA label: Process Spawn Analysis --- 
<li><a href="#">title: Disable Windows Event Logging submission_date: 2022/03/14 information_domain: 'Host' platforms: - Windows subtypes: - Process analytic_types: - TTP contributors: - Lucas Heiligenstein id: CAR-2022-03-001 description: |- Adversaries may disable Windows event logging to limit data that can be leveraged for detections and audits. Windows event logs record user and system activity such as login attempts, process creation, and much more. This data is used by security tools and analysts to generate detections. There are different ways to perform this attack. 1. The first one is to create the Registry Key `HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\MiniNt`. This action will not generate Security EventLog 4657 or Sysmon EventLog 13 because the value of the key remains empty. However, if an attacker uses powershell to perform this attack (and not cmd), a Security EventLog 4663 will be generated (but 4663 generates a lot of noise). 2. The second way is to disable the service EventLog (display name Windows Event Log). After disabed, attacker must reboot the system. The action of disabling or put in manual the service will modify the Registry Key value `HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\EventLog\start`, therefore Security EventLog 4657 or Sysmon EventLog 13 will be generated on the system. 3. The third way is linked with the second. By default, the EventLog service cannot be stopped. If an attacker tries to stop the service, this one will restart immediately. Why ? Because to stop completely, this service must stop others, one in particular called netprofm (display name Network List Service). This service remains running until it is disabled. So Attacker must either disable EventLog and after to stop it or disable netprofm and after stop EventLog. Only stopping the service (even as admin) will not have an effect on the EventLog service because of the link with netprofm. Security EventLog 1100 will log the stop of the EventLog service (but also generates a lot of noise because it will generate a log everytime the system shutdown). 4. The fourth way is to use auditpol.exe to modify the audit configuration and disable/modify important parameters that will lead to disable the creation of EventLog. 5. The last one is to modify the Registry Key value `HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\EventLog\Security\file` (or other kind of log) to modify the path where the EventLog are stocked. Importantly, with this technique, the EventViewer will use the value of the Registry Key "file" to know where to find the Log. Thus, using the EventViewer will always show the current event logs, but the old one will be stocked in another evtx. Also, the path must be in a folder that the Eventlog process has access (like it doesnâ€™t work if attacker set up the new path in the Desktop). Attacker can also decrease the maxsize value of the Log to force the system to rewrite on the older EventLog (but the minimum cannot be less than 1028 KB). As the Registry key is modified, Security EventLog 4657 or Sysmon EventLog 13 will be generated on the system. All of these attacks required administrative right. Attacks number three, four and five do not require a system reboot to be effective immediately. coverage: - technique: T1562 subtechniques: - T1562.002 tactics: - TA0005 coverage: Moderate implementations: - name: Detection of Disable Windows Event Logging description: This detects the disabling of Windows Event Logging, via process command line or registry key value manipulation. code: |- processes = search Process:create susp_processes = filter processes where ((command_line CONTAINS("*New-Item*") OR command_line CONTAINS("*reg add*")) OR command_line CONTAINS("*MiniNt*")) OR (command_line CONTAINS("*Stop-Service*")AND command_line CONTAINS("*EventLog*")) OR (command_line CONTAINS("*EventLog*") AND (command_line CONTAINS("*Set-Service*") OR command_line CONTAINS("*reg add*") OR command_line CONTAINS("*Set-ItemProperty*") OR command_line CONTAINS("*New-ItemProperty*") OR command_line CONTAINS("*sc config*"))) OR (command_line CONTAINS("*auditpol*") AND (command_line CONTAINS("*/set*") OR command_line CONTAINS("*/clear*") OR command_line CONTAINS("*/revove*"))) OR ((command_line CONTAINS("*wevtutil*") AND (command_line CONTAINS("*sl*") OR command_line CONTAINS("*set-log*")))) reg_keys = search Registry:value_edit event_log_reg_keys = filter reg_keys where Key="*EventLog*" AND (value="Start" OR value="File" OR value="MaxSize") output susp_processes, event_log_reg_keys type: Pseudocode - name: Detection of Disable Windows Event Logging description: Splunk version of the CAR pseudocode. code: |- ((EventCode="4688" OR EventCode="1") ((CommandLine="*New-Item*" OR CommandLine="*reg add*") CommandLine="*MiniNt*")OR (CommandLine="*Stop-Service*" CommandLine="*EventLog*")OR (CommandLine="*EventLog*" (CommandLine="*Set-Service*" OR CommandLine="*reg add*" OR CommandLine="*Set-ItemProperty*" OR CommandLine="*New-ItemProperty*" OR CommandLine="*sc config*")) OR (CommandLine="*auditpol*" (CommandLine="*/set*" OR CommandLine="*/clear*" OR CommandLine="*/revove*")) OR ((CommandLine="*wevtutil*" (CommandLine="*sl*" OR CommandLine="*set-log*")))) OR (EventCode="4719") OR ((EventCode="4657" OR EventCode="13") (ObjectName="*EventLog*") (ObjectValueName="Start" OR ObjectValueName="File" OR ObjectValueName="MaxSize")) type: Splunk - name: Detection of Disable Windows Event Logging description: LogPoint version of the CAR pseudocode. code: |- ((((((EventCode IN ["4688", "1"] CommandLine="*New-Item*" CommandLine="*reg add*" CommandLine IN "*MiniNt*") OR (CommandLine="*Stop-Service*" CommandLine="*EventLog*")) OR (CommandLine IN ["*Set-Service*", "*reg add*", "*Set-ItemProperty*", "*New-ItemProperty*", "*sc config*"] CommandLine IN "*EventLog*")) OR (CommandLine IN "*auditpol*" CommandLine IN ["*/set*", "*/clear*", "*/revove*"])) OR (CommandLine IN "*wevtutil*" CommandLine IN ["*sl*", "*set-log*"]) OR EventCode IN "4719") OR (EventCode IN ["4657", "13"] ObjectName IN "*EventLog*" ObjectValueName IN ["Start", "File", "MaxSize"])) type: LogPoint unit_tests: - description: MiniNt Registry Key creation with cmd. commands: - reg add "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\MiniNt" - description: MiniNt Registry Key creation with powershell. commands: - New-Item -Path "HKLM:\SYSTEM\CurrentControlSet\Control\MiniNt" - description: Disable EvenLog Service with Set-Service. commands: - Set-Service -Name EventLog -StartupType Disabled - description: Registry Key modification to disable EventLog Service. commands: - reg add "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\EventLog" /v start /t REG_DWORD /d 0x00000004 /f - description: Stop EventLog Service with Stop-Service. commands: - Stop-Service -Name EventLog -Force - description: Audit configuration modification to disable EventLog with auditpol. commands: - auditpol.exe /set /subcategory:"Process Creation" /success:Disable /failure:Disable - description: Modification of Security EventLog path with wevtutil. commands: - wevtutil.exe sl Security /logfilename:"C:\Windows\System32\winevt\Not-Important-Log.evtx" data_model_references: - registry/value_edit/value - process/create/command_line references: -  d3fend_mappings: - iri: d3f:ProcessSpawnAnalysis id: D3-PSA label: Process Spawn Analysis 
<li><a href="#">title: DLL Injection via Load Library submission_date: 2013/10/07 information_domain: Host platforms: - Windows subtypes: - Process DLL analytic_types: - TTP contributors: - MITRE id: CAR-2013-10-002 description: |- Microsoft Windows allows for processes to remotely create threads within other processes of the same privilege level. This functionality is provided via the Windows API [CreateRemoteThread](). Both Windows and third-party software use this ability for legitimate purposes. For example, the Windows process [csrss.exe]() creates threads in programs to send signals to registered callback routines. Both adversaries and host-based security software use this functionality to [inject DLLs](), but for very different purposes. An adversary is likely to inject into a program to [evade defenses]() or [bypass User Account Control](), but a security program might do this to gain increased monitoring of API calls. One of the most common methods of [DLL Injection]() is through the Windows API [LoadLibrary](). - Allocate memory in the target program with [VirtualAllocEx]() - Write the name of the DLL to inject into this program with [WriteProcessMemory]() - Create a new thread and set its entry point to [LoadLibrary]() using the API [CreateRemoteThread](). This behavior can be detected by looking for thread creations across processes, and resolving the entry point to determine the function name. If the function is `LoadLibraryA` or `LoadLibraryW`, then the intent of the remote thread is clearly to inject a DLL. When this is the case, the source process must be examined so that it can be ignored when it is both expected and a trusted process. coverage: - technique: T1055 tactics: - TA0005 subtechniques: - T1055.001 coverage: Moderate - technique: T1548 tactics: - TA0004 subtechniques: - T1548.002 coverage: Moderate implementations: - description: 'Search for remote thread creations that start at LoadLibraryA or LoadLibraryW. Depending on the tool, it may provide additional information about the DLL string that is an argument to the function. If there is any security software that legitimately injects DLLs, it must be carefully whitelisted. ' code: |- remote_thread = search Thread:RemoteCreate remote_thread = filter (start_function == "LoadLibraryA" or start_function == "LoadLibraryW") remote_thread = filter (src_image_path != "C:\Path\To\TrustedProgram.exe") output remote_thread type: pseudocode - description: LogPoint version of the above pseudocode. code: |- norm_id=WindowsSysmon event_id=8 start_function IN ["LoadLibraryA", "LoadLibraryW"] -source_image="C:\Path\To\TrustedProgram.exe" type: LogPoint data_model: LogPoint native data_model_references: - thread/remote_create/src_pid - thread/remote_create/start_function true_positives: - source: 'Mordor (Sysmon)' description: 'Sysmon event from the Mordor [Empire DLL Injection dataset]().' event_snippet: 'CAR-2013-10-002-mordor-01-snippet.json' full_event: 'CAR-2013-10-002-mordor-01.json' d3fend_mappings: - iri: d3f:SystemCallAnalysis id: D3-SCA label: System Call Analysis 
<li><a href="#">title: DLL Injection with Mavinject submission_date: 2020/11/30 information_domain: Host platforms: - Windows subtypes: - Process analytic_types: - TTP contributors: - Olaf Hartong id: CAR-2020-11-003 description: |- Injecting a malicious DLL into a process is a common adversary TTP. Although the ways of doing this are numerous, mavinject.exe is a commonly used tool for doing so because it roles up many of the necessary steps into one, and is available within Windows. Attackers may rename the executable, so we also use the common argument "INJECTRUNNING" as a related signature here. Whitelisting certain applications may be necessary to reduce noise for this analytic. coverage: - technique: T1055 tactics: - TA0004 - TA0005 subtechniques: - T1055.001 coverage: Low implementations: - name: Pseudocode - mavinject process and its common argument description: This is a pseudocode representation of the below splunk search. code: |- processes = search Process:Create mavinject_processes = filter processes where ( exe = "C:\\Windows\\SysWOW64\\mavinject.exe" OR Image="C:\\Windows\\System32\\mavinject.exe" OR command_line = "*/INJECTRUNNING*" output mavinject_processes data_model: CAR native type: Pseudocode - name: Splunk Search - mavinject description: Search for instances of mavinject.exe or mavinject32.exe code: |- (index=__your_sysmon_index__ EventCode=1) (Image="C:\\Windows\\SysWOW64\\mavinject.exe" OR Image="C:\\Windows\\System32\\mavinject.exe" OR CommandLine="*\INJECTRUNNING*") data_model: Sysmon native type: Splunk - name: LogPoint Search - mavinject description: Search for instances of mavinject.exe or mavinject32.exe code: |- norm_id=WindowsSysmon event_id=1 (image="C:\Windows\SysWOW64\mavinject.exe" OR image="C:\Windows\System32\mavinject.exe" OR command="*\INJECTRUNNING*") data_model: LogPoint native type: LogPoint data_model_references: - process/create/exe - process/create/command_line d3fend_mappings: - iri: d3f:ProcessSpawnAnalysis id: D3-PSA label: Process Spawn Analysis 
<li><a href="#">title: Execution with AT submission_date: 2013/05/13 information_domain: Host platforms: - Windows subtypes: - Process analytic_types: - TTP contributors: - MITRE id: CAR-2013-05-004 description: |- In order to gain [persistence](), [privilege escalation](), or [remote execution](), an adversary may use the Windows built-in command AT (at.exe) to [schedule a command]() to be run at a specified time, date, and even host. This method has been used by adversaries and administrators alike. Its use may lead to detection of compromised hosts and compromised users if it is used to move laterally. The built-in Windows tool schtasks.exe ([CAR-2013-08-001](../CAR-2013-08-001)) offers greater flexibility when creating, modifying, and enumerating tasks. For these reasons, schtasks.exe is more commonly used by administrators, tools/scripts, and power users. coverage: - technique: T1053 tactics: - TA0002 - TA0003 - TA0004 subtechniques: - T1053.002 coverage: Moderate implementations: - description: 'Instances of the process `at.exe` running imply the querying or creation of tasks. Although the command_line is not essential for the analytic to run, it is critical when identifying the command that was scheduled.' code: |- process = search Process:Create at = filter process where (exe == "at.exe") output at type: pseudocode - description: Splunk version of the above pseudocode. code: |- index=__your_sysmon_index__ Image="C:\\Windows\\*\\at.exe"|stats values(CommandLine) as "Command Lines" by ComputerName type: Splunk data_model: Sysmon native - description: EQL version of the above pseudocode. code: |- process where subtype.create and process_name == "at.exe" type: EQL data_model: EQL native - description: DNIF version of the above pseudocode. code: |- _fetch * from event where $LogName=WINDOWS-SYSMON AND $EventID=1 AND $App=at.exe limit 100 type: DNIF data_model: Sysmon native - description: LogPoint version of the above pseudocode. code: |- norm_id=WindowsSysmon event_id=1 image="*\at.exe" type: LogPoint data_model: LogPoint native data_model_references: - process/create/command_line - process/create/exe unit_tests: - configurations: - Windows 7 description: |- - From an admin account, open Windows command prompt (right click, run as administrator). - Execute "at 10:00 calc.exe," substituting a time in the near future for 10:00. - The program should respond with â€œAdded a new job with job ID = 1â€ where the job ID is dependent on what tasks are scheduled. - The program should execute at the time specified. This is what the analytic should fire on. - To remove the scheduled task, execute "at 1 /delete" where you replace "1" with the job ID output in step 2a above. commands: - 'at 10:00 calc.exe // returns a job number X' - at X /delete d3fend_mappings: - iri: d3f:ScheduledJobAnalysis id: D3-SJA label: Scheduled Job Analysis 
<li><a href="#">title: Execution with schtasks submission_date: 2013/08/07 information_domain: Host platforms: - Windows subtypes: - Process analytic_types: - TTP contributors: - MITRE id: CAR-2013-08-001 description: 'The Windows built-in tool `schtasks.exe` provides the creation, modification, and running of [scheduled tasks]() on a local or remote computer. It is provided as a more flexible alternative to `at.exe`, described in [CAR-2013-05-004](../CAR-2013-05-004). Although used by adversaries, the tool is also legitimately used by administrators, scripts, and software configurations. The scheduled tasks tool can be used to gain [Persistence]() and can be used in combination with a [Lateral Movement]() technique to remotely gain [execution](). Additionally, the command has parameters to specify the user and password responsible for creating the task, as well as the user and password combination that the task will run as. The `/s` flag specifies the remote system on which the task should be scheduled, usually indicating [Lateral Movement]().' coverage: - technique: T1053 tactics: - TA0003 subtechniques: - T1053.005 coverage: Moderate implementations: - description: 'Look for instances of `schtasks.exe` running as processes. The `command_line` field is necessary to disambiguate between types of schtasks commands. These include the flags `/create`, `/run`, `/query`, `/delete`, `/change`, and `/end`.' code: |- process = search Process:Create schtasks = filter process where (exe == "schtasks.exe") output schtasks type: pseudocode - description: DNIF version of the above pseudocode. code: |- _fetch * from event where $LogName=WINDOWS-SYSMON AND $EventID=1 AND $App=schtasks.exe AND $Process=regex(.*(\/create|\/run|\/query|\/delete|\/change|\/end).*)i limit 100 type: DNIF data_model: Sysmon native - description: LogPoint version of the above pseudocode. code: |- norm_id=WindowsSysmon event_id=1 image="*\schtasks.exe" command IN ["*/create*", "*/run*", "*/query*", "*/delete*", "*/change*", "*/end*"] type: LogPoint data_model: LogPoint native data_model_references: - process/create/exe - process/create/command_line unit_tests: - configurations: - Windows 7 description: |- Create a new scheduled task with schtasks.exe and verify the analytic fires when the task executes. * From an admin account, open Windows command prompt (right click, run as administrator) * Execute `schtasks /Create /SC ONCE /ST 19:00 /TR C:\Windows\System32\calc.exe /TN calctask`, substituting a time in the near future for 19:00 * The program should respond with â€œSUCCESS: The scheduled task â€œcalctaskâ€ has successfully been created.â€ * The program should execute at the time specified. This is what the analytic should fire on. * To remove the scheduled task, execute `schtasks /Delete /TN calctask`. * The program should respond with â€œSUCCESS: The scheduled task â€œcalctaskâ€ was successfully deleted.â€ commands: - 'schtasks /Create /SC ONCE /ST 19:00 /TR C:\Windows\System32\calc.exe /TN calctask' - schtasks /Delete /TN calctask d3fend_mappings: - iri: d3f:ScheduledJobAnalysis id: D3-SJA label: Scheduled Job Analysis 
<li><a href="#">title: Generic Regsvr32 submission_date: 2019/04/24 information_domain: 'Host' platforms: - Windows subtypes: - Process analytic_types: - Situational Awareness contributors: - MITRE id: CAR-2019-04-002 description: |- Regsvr32 can be used to execute arbitrary code in the context of a Windows signed binary, which can be used to bypass application whitelisting. This analytic looks for suspicious usage of the tool. It's not likely that you'll get millions of hits, but it does occur during normal activity so some form of baselining would be necessary for this to be an alerting analytic. Alternatively, it can be used for hunt by looking for new or anomalous DLLs manually. coverage: - technique: T1218 tactics: - TA0005 subtechniques: - T1218.010 coverage: Low implementations: - name: Main Pattern description: This just looks for all executions of regsvr32.exe that have a parent of regsvr32.exe but are not regsvr32.exe themselves (which happens). This will have a very high FP rate, but likely not on the order of millions. code: |- index=__your_sysmon_data__ EventCode=1 regsvr32.exe | search ParentImage="*regsvr32.exe" AND Image!="*regsvr32.exe*" type: splunk data_model: Sysmon native - name: Main Pattern - pseudocode description: This is a pseudocode version of the above main pattern. code: |- processes = search Process:Create regsvr_processes = filter processes where ( parent_image_path == "*regsvr32.exe" and image_path != "*regsvr32.exe*" ) output regsvr_processes type: pseudocode data_model: CAR - name: New items since last month description: This uses the same logic as above, but adds lightweight baselining by ignoring all results that also showed up in the previous 30 days (it runs over 1 day). code: |- index=__your_sysmon_data__ earliest=-d@d latest=now() EventCode=1 regsvr32.exe | search ParentImage="*regsvr32.exe" AND Image!="*regsvr32.exe*" | search NOT [ search index=__your_sysmon_data__ earliest=-60d@d latest=-30d@d EventCode=1 regsvr32.exe | search ParentImage="*regsvr32.exe" AND Image!="*regsvr32.exe*" | dedup CommandLine | fields CommandLine ] type: splunk data_model: Sysmon native - name: Spawning child processes description: This looks for child processes that may be spawend by regsvr32, while attempting to eliminate some of the common false positives such as werfault (Windows Error Reporting). code: |- index=__your_sysmon_data__ EventCode=1 (ParentImage="C:\\Windows\\System32\\regsvr32.exe" OR ParentImage="C:\\Windows\\SysWOW64\\regsvr32.exe") AND Image!="C:\\Windows\\System32\\regsvr32.exe" AND Image!="C:\\Windows\\SysWOW64\\regsvr32.exe" AND Image!="C:\\WINDOWS\\System32\\regsvr32.exe" AND Image!="C:\\WINDOWS\\SysWOW64\\regsvr32.exe" AND Image!="C:\\Windows\\SysWOW64\\WerFault.exe" AND Image!="C:\\Windows\\System32\\wevtutil.exe" AND Image!="C:\\Windows\\System32\\WerFault.exe"|stats values(ComputerName) as "Computer Name" values(ParentCommandLine) as "Parent Command Line" count(Image) as ImageCount by Image type: splunk data_model: Sysmon native - name: Spawning child processes - pseudocode description: This is a pseudocode version of the above Splunk query for spawning child processes. code: |- processes = search Process:Create regsvr_processes = filter processes where ( (parent_image_path == "C:\Windows\System32\regsvr32.exe" or parent_image_path == "C:\Windows\SysWOW64\regsvr32.exe") and image_path != "C:\Windows\System32\regsvr32.exe" and image_path != "C:\Windows\SysWOW64\regsvr32.exe" and image_path != "C:\Windows\SysWOW64\WerFault.exe" and image_path != "C:\Windows\System32\WerFault.exe" and image_path != "C:\Windows\System32\wevtutil.exe" ) output regsvr_processes type: pseudocode data_model: CAR - name: Loading unsigned images description: This looks for unsigned images that may be loaded by regsvr32, while attempting to eliminate false positives stemming from Windows/Program Files binaries. code: |- index=__your_sysmon_data__ EventCode=7 (Image="C:\\Windows\\System32\\regsvr32.exe" OR Image="C:\\Windows\\SysWOW64\\regsvr32.exe") Signed=false ImageLoaded!="C:\\Program Files*" ImageLoaded!="C:\\Windows\\*"|stats values(ComputerName) as "Computer Name" count(ImageLoaded) as ImageLoadedCount by ImageLoaded type: splunk data_model: Sysmon native - name: Loading unsigned images - pseudocode description: This is a pseudocode version of the above Splunk query for loading unsigned images. code: |- modules = search Module:Load unsigned_modules = filter modules where ( (image_path == "C:\Windows\System32\regsvr32.exe" or image_path == "C:\Windows\SysWOW64\regsvr32.exe") and signer == null and module_path != "C:\Program Files*" and module_path != "C:\Windows\*" ) output unsigned_modules type: pseudocode data_model: CAR unit_tests: - description: Any of the [Atomic Red Team tests for regsvr32.exe]() should trigger this. data_model_references: - process/create/exe - process/create/parent_exe - process/create/command_line - process/create/image - process/create/parent_image d3fend_mappings: - iri: d3f:ProcessLineageAnalysis id: D3-PLA label: Process Lineage Analysis --- 
<li><a href="#">title: Get System Elevation submission_date: 2021/01/15 information_domain: Host platforms: - Windows subtypes: - Process analytic_types: - TTP contributors: - Sebastien Damaye id: CAR-2021-02-002 description: |- Cyber actors frequently escalate to the SYSTEM account after gaining entry to a Windows host, to enable them to carry out various attacks more effectively. Tools such as Meterpreter, Cobalt Strike, and Empire carry out automated steps to "Get System", which is the same as switching over to the System user account. Most of these tools utilize multiple techniques to try and attain SYSTEM: in the first technique, they create a named pipe and connects an instance of cmd.exe to it, which allows them to impersonate the security context of cmd.exe, which is SYSTEM. In the second technique, a malicious DLL is injected into a process that is running as SYSTEM; the injected DLL steals the SYSTEM token and applies it where necessary to escalate privileges. This analytic looks for both of these techniques. coverage: - technique: T1548 tactics: - TA0004 - TA0005 coverage: Moderate implementations: - name: Pseudocode - Meterpreter and Cobalt Strike description: This is a pseudocode representation of the below splunk search. code: |- processes = search Process suspicious_processes = filter processes where ( (parent_image_path == C:\Windows\System32\services.exe" AND image_path == "C:\Windows\System32\cmd.exe" AND command_line == "*echo*" AND command_line == "*\pipe\*") OR (image_path == "C:\Windows\System32\rundll32.exe" AND command_line == "*,a /p:*")) output suspicious_processes data_model: CAR native type: Pseudocode - name: Splunk Search - Meterpreter and Cobalt Strike description: Look for instances GetSystem elevation performed by Meterpreter or Cobalt Strike code: |- index=__your_sysmon_index__ (ParentImage="C:\\Windows\\System32\\services.exe" Image="C:\\Windows\\System32\\cmd.exe" (CommandLine="*echo*" AND CommandLine="*\\pipe\\*")) OR (Image="C:\\Windows\\System32\\rundll32.exe" CommandLine="*,a /p:*") data_model: Sysmon native type: Splunk - name: Pseudocode - Empire and PoshC2 description: This is a pseudocode representation of the below splunk search. code: |- processes = search Process suspicious_processes = filter processes where ( (image_path == "C:\Windows\System32\cmd.exe" OR command_line == "*%COMSPEC%*") AND command_line == "*echo*" AND command_line == "*\pipe\*")) output suspicious_processes data_model: CAR native type: Pseudocode - name: Splunk Search - Empire and PoshC2 description: Look for instances GetSystem elevation performed by Empire or PoshC2 code: |- index=__your_sysmon_index__ (Image="C:\\Windows\\System32\\cmd.exe" OR CommandLine="*%COMSPEC%*") (CommandLine="*echo*" AND CommandLine="*\pipe\*") data_model: Sysmon native type: Splunk unit_tests: - description: GetSystem in Meterpreter & Cobalt Strikeâ€™s Beacon commands: - 'cmd.exe /c echo ba80ae80df9 > \\.\pipe\66bee3' - 'cmd.exe /c echo fvxens > \\.\pipe\fvxens' - 'rundll32.exe C:\Users\user\AppData\Local\Temp\fvxens.dll,a /p:fvxens' - description: GetSystem in Empire & PoshC2 commands: - 'cmd.exe /C start %COMSPEC% /C `"timeout /t 3 >nul&&echo TestSVC > \\.\pipe\TestSVC' data_model_references: - process/create/exe - process/create/parent_exe - process/create/command_line - service/create/command_line d3fend_mappings: - iri: d3f:ProcessLineageAnalysis id: D3-PLA label: Process Lineage Analysis --- 
<li><a href="#">title: Host Discovery Commands submission_date: 2016/03/24 information_domain: Host platforms: - Windows - Linux - macOS subtypes: - Process analytic_types: - TTP contributors: - MITRE id: CAR-2016-03-001 description: |- When entering on a host for the first time, an adversary may try to [discover]() information about the host. There are several built-in Windows commands that can be used to learn about the software configurations, active users, administrators, and networking configuration. These commands should be monitored to identify when an adversary is learning information about the system and environment. The information returned may impact choices an adversary can make when [establishing persistence](), [escalating privileges](), or [moving laterally](). Because these commands are built in, they may be run frequently by power users or even by normal users. Thus, an analytic looking at this information should have well-defined white- or blacklists, and should consider looking at an anomaly detection approach, so that this information can be learned dynamically. Within the built-in Windows Commands: - `hostname` - `ipconfig` - `net` - `quser` - `qwinsta` - `sc` with flags `query`, `queryex`, `qc` - `systeminfo` - `tasklist` - `dsquery` - `whoami` **Note** `dsquery` is only pre-existing on Windows servers. coverage: - technique: T1087 tactics: - TA0007 subtechniques: - T1087.001 - T1087.002 coverage: Moderate - technique: T1069 tactics: - TA0007 subtechniques: - T1069.001 - T1069.002 coverage: Moderate - technique: T1016 tactics: - TA0007 coverage: Moderate - technique: T1082 tactics: - TA0007 coverage: Moderate - technique: T1033 tactics: - TA0007 coverage: Moderate - technique: T1057 tactics: - TA0007 coverage: Moderate - technique: T1007 tactics: - TA0007 coverage: Moderate implementations: - description: 'To be effective in deciphering malicious and benign activity, the full command line is essential. Similarly, having information about the parent process can help with making decisions and tuning to an environment.' code: |- process = search Process:Create info_command = filter process where ( exe == "hostname.exe" or exe == "ipconfig.exe" or exe == "net.exe" or exe == "quser.exe" or exe == "qwinsta.exe" or exe == "sc" and (command_line match " query" or command_line match " qc")) or exe == "systeminfo.exe" or exe == "tasklist.exe" or exe == "whoami.exe" ) output info_command type: pseudocode - description: Splunk version of the above pseudocode search. code: |- index=__your_sysmon_index__ EventCode=1 (Image="C:\\Windows\\*\\hostname.exe" OR Image="C:\\Windows\\*\\ipconfig.exe" OR Image="C:\\Windows\\*\\net.exe" OR Image="C:\\Windows\\*\\quser.exe" OR Image="C:\\Windows\\*\\qwinsta.exe" OR (Image="C:\\Windows\\*\\sc.exe" AND (CommandLine="* query *" OR CommandLine="* qc *")) OR Image="C:\\Windows\\*\\systeminfo.exe" OR Image="C:\\Windows\\*\\tasklist.exe" OR Image="C:\\Windows\\*\\whoami.exe")|stats values(Image) as "Images" values(CommandLine) as "Command Lines" by ComputerName type: Splunk data_mode: Sysmon native - description: EQL version of the above pseudocode search. code: |- process where subtype.create and (process_name == "hostname.exe" or process_name == "ipconfig.exe" or process_name == "net.exe" or process_name == "quser.exe" process_name == "qwinsta.exe" or process_name == "systeminfo.exe" or process_name == "tasklist.exe" or process_name == "whoami.exe" or (process_name == "sc.exe" and (command_line == "* query *" or command_line == "* qc *"))) type: EQL data_mode: EQL native - description: LogPoint version of the above pseudocode. code: |- norm_id=WindowsSysmon event_id=1 (image in ["*\hostname.exe", "*\ipconfig.exe", "*\net.exe", "*\quser.exe", "*\qwinsta.exe", "*\systeminfo.exe", "*\tasklist.exe", "*\whoami.exe"] OR (image="*\sc.exe" command IN ["* query *", "* qc *")) type: LogPoint data_model: LogPoint native data_model_references: - process/create/command_line - process/create/exe true_positives: - source: 'Mordor (Sysmon) - net.exe' description: 'Sysmon net.exe event from the Mordor [Empire Net Start dataset]().' event_snippet: 'CAR-2016-03-001-mordor-01-snippet.json' full_event: 'CAR-2016-03-001-mordor-01.json' - source: 'Mordor (Sysmon) - whoami.exe' description: 'Sysmon whoami.exe event from the Mordor [Empire Net Start dataset]().' event_snippet: 'CAR-2016-03-001-mordor-02-snippet.json' full_event: 'CAR-2016-03-001-mordor-02.json' d3fend_mappings: - iri: d3f:ProcessSpawnAnalysis id: D3-PSA label: Process Spawn Analysis 
<li><a href="#">title: Identifying Port Scanning Activity submission_date: 2020/10/23 information_domain: 'Network' platforms: - Windows - Linux subtypes: - Flow analytic_types: - Situational Awareness contributors: - Cyware Labs id: CAR-2021-01-001 description: |- After compromising an initial machine, adversaries commonly attempt to laterally move across the network. The first step to attempt the lateral movement often involves conducting host identification, port and service scans on the internal network via the compromised machine using tools such as Nmap, Cobalt Strike, etc. coverage: - technique: T1046 coverage: Moderate tactics: - TA0007 implementations: - name: Splunk search - Identifying Internal hosts and services for lateral movement description: It should be noted that when a host/ port/ service scan is performed from a compromised machine, a single machine makes multiple calls to other hosts in the network to identify live hosts and services. This can be detected using the following query code: |- sourcetype='firewall_logs' dest_ip = 'internal_subnet' | stats dc(dest_port) as pcount by src_ip | where pcount >5 data_model: Sysmon native type: Splunk data_model_references: - flow/start/dest_ip d3fend_mappings: - iri: d3f:ConnectionAttemptAnalysis id: D3-CAA label: Connection Attempt Analysis --- 
<li><a href="#">title: Indicator Blocking - Driver Unloaded submission_date: 2020/09/10 information_domain: 'Host' platforms: - Windows subtypes: - Process analytic_types: - TTP contributors: - Olaf Hartong id: CAR-2020-09-003 description: |- Adversaries may attempt to evade system defenses by unloading minifilter drivers used by host-based sensors such as Sysmon through the use of the fltmc command-line utility. Accordingly, this analytic looks for command-line invocations of this utility when used to unload minifilter drivers. coverage: - technique: T1562 coverage: Low subtechniques: - T1562.006 tactics: - TA0005 implementations: - name: Pseudocode - fltmc invocation description: This is a pseudocode representation of the below splunk search. code: |- processes = search Process:Create fltmc_processes = filter processes where ( exe = "fltmc.exe" AND command_line = "*unload*") output fltmc_processes data_model: CAR native type: Pseudocode - name: Splunk search - fltmc invocation description: This Splunk search looks for process create events for the fltmc.exe utility and the specific command line used to unload minifilter drivers. code: |- index=client EventCode=1 CommandLine="*unload*" (Image="C:\\Windows\\SysWOW64\\fltMC.exe" OR Image="C:\\Windows\\System32\\fltMC.exe") data_model: Sysmon native type: Splunk - name: LogPoint search - fltmc invocation description: This LogPoint search looks for process create events for the fltmc.exe utility and the specific command line used to unload minifilter drivers. code: |- norm_id=WindowsSysmon command="*unload*" (image="C:\Windows\SysWOW64\fltMC.exe" OR image="C:\Windows\System32\fltMC.exe") data_model: LogPoint native type: LogPoint data_model_references: - process/create/exe - process/create/command_line d3fend_mappings: - iri: d3f:ProcessSpawnAnalysis id: D3-PSA label: Process Spawn Analysis --- 
<li><a href="#">title: Local Network Sniffing submission_date: 2020/11/30 information_domain: Host platforms: - Windows subtypes: - Process analytic_types: - Situational Awareness contributors: - Olaf Hartong id: CAR-2020-11-002 description: |- Adversaries may use a variety of tools to gain visibility on the current status of things on the network: which processes are listening on which ports, which services are running on other hosts, etc. This analytic looks for the names of the most common network sniffing tools. While this may be noisy on networks where sysadmins are using any of these tools on a regular basis, in most networks their use is noteworthy. coverage: - technique: T1040 tactics: - TA0006 - TA0007 coverage: Moderate implementations: - name: Pseudocode - commands containing known network sniffing application names description: This is a pseudocode representation of the below splunk search. code: |- processes = search Process:Create sniffer_processes = filter processes where ( exe = "tshark.exe" OR exe = "windump.exe" OR (exe = "logman.exe" AND parent_exe exists AND parent_exe!="C:\Program Files\Windows Event Reporting\Core\EventReporting.AgentService.exe") OR exe = "tcpdump.exe" OR exe = "wprui.exe" OR exe = "wpr.exe" ) output sniffer_processes data_model: CAR native type: Pseudocode - name: Splunk Search - common network traffic sniffing apps being run description: look for common network traffic sniffing apps being run code: |- (index=__your_sysmon_index__ EventCode=1) (Image="*tshark.exe" OR Image="*windump.exe" OR (Image="*logman.exe" AND ParentImage!="?" AND ParentImage!="C:\\Program Files\\Windows Event Reporting\\Core\\EventReporting.AgentService.exe") OR Image="*tcpdump.exe" OR Image="*wprui.exe" OR Image="*wpr.exe") data_model: Sysmon native type: Splunk - name: LogPoint Search - common network traffic sniffing apps being run description: look for common network traffic sniffing apps being run code: |- norm_id=WindowsSysmon event_id=1 (image="*\tshark.exe" OR image="*\windump.exe" OR (image="*\logman.exe" -parent_image="?" -parent_image="C:\Program Files\Windows Event Reporting\Core\EventReporting.AgentService.exe") OR image="*\tcpdump.exe" OR image="*\wprui.exe" OR image="*\wpr.exe") data_model: LogPoint native type: LogPoint data_model_references: - process/create/exe - process/create/parent_exe d3fend_mappings: - iri: d3f:ProcessLineageAnalysis id: D3-PLA label: Process Lineage Analysis 
<li><a href="#">title: Local Permission Group Discovery submission_date: 2020/11/30 information_domain: Host platforms: - Windows subtypes: - Process analytic_types: - TTP contributors: - Olaf Hartong id: CAR-2020-11-006 description: |- Cyber actors frequently enumerate local or domain permissions groups. The net utility is usually used for this purpose. This analytic looks for any instances of net.exe, which is not normally used for benign purposes, although system administrator actions may trigger false positives. coverage: - technique: T1069 tactics: - TA0007 subtechniques: - T1069.001 - T1069.002 coverage: Moderate implementations: - name: Pseudocode - net.exe instances description: This is a pseudocode representation of the below splunk search. code: |- processes = search Process:Create net_processes = filter processes where ( exe = "net.exe" AND ( command_line="*net* user*" OR command_line="*net* group*" OR command_line="*net* localgroup*" OR command_line="*get-localgroup*" OR command_line="*get-ADPrincipalGroupMembership*" ) output net_processes data_model: CAR native type: Pseudocode - name: Splunk Search - net.exe instances description: Look for instances of net.exe code: |- (index=__your_sysmon_index__ EventCode=1) Image="C:\\Windows\\System32\\net.exe" AND (CommandLine="* user*" OR CommandLine="* group*" OR CommandLine="* localgroup*" OR CommandLine="*get-localgroup*" OR CommandLine="*get-ADPrincipalGroupMembership*") data_model: Sysmon native type: Splunk - name: LogPoint Search - net.exe instances description: Look for instances of net.exe code: |- norm_id=WindowsSysmon event_id=1 image="C:\Windows\System32\net.exe" (command="* user*" OR command="* group*" OR command="* localgroup*" OR command="*get-localgroup*" OR command="*get-ADPrincipalGroupMembership*") data_model: LogPoint native type: LogPoint data_model_references: - process/create/exe - process/create/command_line d3fend_mappings: - iri: d3f:ProcessSpawnAnalysis id: D3-PSA label: Process Spawn Analysis 
<li><a href="#">title: Lsass Process Dump via Procdump submission_date: 2019/07/29 information_domain: 'Host' platforms: - Windows subtypes: - Process analytic_types: - TTP contributors: - Kaushal Parikh/Cyware Labs - Tony Lambert/Red Canary - MITRE id: CAR-2019-07-002 description: |- [ProcDump]() is a sysinternal command-line utility whose primary purpose is monitoring an application for CPU spikes and generating crash dumps during a spike that an administrator or developer can use to determine the cause of the spike. ProcDump may be used to dump the memory space of lsass.exe to disk for processing with a credential access tool such as Mimikatz. This is performed by launching procdump.exe as a privileged user with command line options indicating that lsass.exe should be dumped to a file with an arbitrary name. Note - the CAR data model currently does not support process access actions, so the pseudocode implementation is based around process creates. coverage: - technique: T1003 tactics: - TA0006 subtechniques: - T1003.001 coverage: Low implementations: - name: Procdump - Process Create description: This base pseudocode looks for process create events where an instance of procdump is executed that references lsass in the command-line. code: |- processes = search Process:Create procdump_lsass = filter processes where ( exe = "procdump*.exe" and command_line = "*lsass*") output procdump_lsass type: Pseudocode - name: Procdump - Process Create description: A Splunk/Sysmon version of the above pseudocode. code: |- index=__your_sysmon_index__ EventCode=1 Image="*\\procdump*.exe" CommandLine="*lsass*" type: Splunk data_model: Sysmon native - name: Procdump - Process Create description: 'An [EQL Version]() of the above pseudocode.' type: EQL - name: Procdump - Process Access description: A related Splunk search, which instead of looking for process create events looks for process access events that target lsass.exe. code: |- index=__your_sysmon_index__ EventCode=10 TargetImage="C:\\WINDOWS\\system32\\lsass.exe" GrantedAccess="0x1FFFFF" ("procdump") type: Splunk data_model: Sysmon native - name: Procdump - Process Access description: 'A [Sigma Version]() of the above Splunk search, with some more stringent criteria around calltrace.' type: Sigma - description: LogPoint version of the above pseudocode. code: |- norm_id=WindowsSysmon event_id=1 image="*\procdump*.exe" command="*lsass*" type: LogPoint data_mode: LogPoint native data_model_references: - process/create/exe - process/create/command_line unit_tests: - description: |- 1. Open a Windows Command Prompt or PowerShell instance. 2. Navigate to folder containing ProcDump. 3. Execute procdump.exe -ma lsass.exe lsass_dump d3fend_mappings: - iri: d3f:ProcessSpawnAnalysis id: D3-PSA label: Process Spawn Analysis --- 
<li><a href="#">title: MiniDump of LSASS submission_date: 2020/05/04 information_domain: 'Host' platforms: - Windows subtypes: - Process analytic_types: - TTP contributors: - Cyber National Mission Force (CNMF) id: CAR-2020-05-001 description: |- This analytic detects the minidump variant of credential dumping where a process opens lsass.exe in order to extract credentials using the Win32 API call [MiniDumpWriteDump](). Tools like [SafetyKatz](), [SafetyDump](), and [Outflank-Dumpert]() default to this variant and may be detected by this analytic, though keep in mind that not all options for using those tools will result in this specific behavior. The analytic is based on a [Sigma analytic]() contributed by Samir Bousseaden and written up in a [blog on MENASEC](). It looks for a call trace that includes either dbghelp.dll or dbgcore.dll, which export the relevant functions/permissions to perform the dump. It also detects using the Windows Task Manager (taskmgr.exe) to dump lsass, which is described in [CAR-2019-08-001](/analytics/CAR-2019-08-001/). In this iteration of the Sigma analytic, the `GrantedAccess` filter isn't included because it didn't seem to filter out any false positives and introduces the potential for evasion. This analytic was tested both in a lab and in a production environment with a very low false-positive rate. werfault.exe and tasklist.exe, both standard Windows processes, showed up multiple times as false positives. NOTE - this analytic has no corresponding pseudocode implementation because the CAR data model doesn't currently support process access events. coverage: - technique: T1003 tactics: - TA0006 subtechniques: - T1003.003 coverage: Low implementations: - name: Lsass Process Access description: This Splunk query looks for process access events where lsass.exe is accessed with a specific call trace that indicates the use of MiniDumpWriteDump. code: |- index=__your_sysmon_index__ EventCode=10 TargetImage="C:\\windows\\system32\\lsass.exe" (CallTrace="*dbghelp.dll*" OR CallTrace="*dbgcore.dll*")| table _time host SourceProcessId SourceImage type: Splunk data_model: Sysmon native - description: LogPoint version of the above pseudocodes. code: |- norm_id=WindowsSysmon event_id=10 image="C:\Windows\system32\lsass.exe" call_trace IN ["*dbghelp.dll*", "*dbgcore.dll*"] | fields log_ts host source_process_id source_image type: LogPoint data_mode: LogPoint native d3fend_mappings: - iri: d3f:SystemCallAnalysis id: D3-SCA label: System Call Analysis --- 
<li><a href="#">title: Modification of Default Startup Folder in the Registry Key 'Common Startup' submission_date: 2021/12/06 information_domain: Host platforms: - Windows subtypes: - Process - Registry analytic_types: - TTP contributors: - Lucas Heiligenstein id: CAR-2021-12-002 description: Detection of the modification of the registry key `Common Startup` located in `HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\User Shell Folders\` and `HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\User Shell Folders\`. When a user logs on, any files located in the Startup Folder are launched. Attackers may modify these folders with other files in order to evade detection set on these default folders. This detection focuses on EventIDs 4688 and 1 for process creation and EventID 4657 for the modification of the Registry Keys. coverage: - technique: T1547 tactics: - TA0003 - TA0004 subtechniques: - T1547.001 coverage: Medium - technique: T1112 tactics: - TA0005 coverage: Medium implementations: - name: Common Startup Registry Key Modification description: This detects modification of the `Common Startup` registry key value, either via a new process (command line) or direct registry manipulation. code: |- processes = search Process:create logon_reg_processes = filter processes where (command_line CONTAINS("*reg*") AND command_line CONTAINS("*add*") AND command_line CONTAINS("*/d*") OR (command_line CONTAINS("*Set-ItemProperty*") AND command_line CONTAINS("*-value*")) AND command_line CONTAINS("*Common Startup*")) reg_keys = search Registry:value_edit logon_reg_keys = filter reg_keys where value="Common Startup" output logon_reg_processes, logon_reg_keys data_model: CAR native type: Pseudocode - name: Splunk Search - Modification of default Startup Folder in the Registry Key "Common Startup" description: This is a Splunk representation of the above pseudocode search. code: |- (((EventCode="4688" OR EventCode="1") (CommandLine="*reg*" AND CommandLine="*add*" AND CommandLine="*/d*") OR (CommandLine="*Set-ItemProperty*" AND CommandLine="*-value*") CommandLine="*Common Startup*") OR ((EventCode="4657" ObjectValueName="Common Startup") OR (EventCode="13" TargetObject="*Common Startup"))) type: Splunk - name: Elastic Search - Modification of default Startup Folder in the Registry Key "Common Startup" description: This is an ElasticSeearech representation of the above pseudocode search. code: |- ((EventLog:"Security" AND (winlog.event_id:"4688" OR winlog.event_id:"1") AND ((process.command_line:*reg* AND process.command_line:*add* AND process.command_line:*\/d*) OR (process.command_line:*Set\-ItemProperty* AND process.command_line:*\-value*)) AND process.command_line:*Common\ Startup*) OR (winlog.event_id:"4657" AND winlog.event_data.ObjectValueName:"Common\ Startup") OR (winlog.event_id:"13" AND winlog.event_data.TargetObject:"*Common Startup")) type: Elastic - name: LogPoint Search - Modification of default Startup Folder in the Registry Key "Common Startup" description: This is a LogPoint representation of the above pseudocode search. code: |- ((EventLog="Security" (event_id="4688" OR event_id="1") ((CommandLine="*reg*" CommandLine="*add*" CommandLine="*/d*") OR (CommandLine="*Set-ItemProperty*" CommandLine="*-value*")) CommandLine="*Common Startup*") OR (event_id="4657" ObjectValueName="Common Startup") OR (event_id="13" TargetObject="*Common Startup")) type: LogPoint unit_tests: - description: Modification on Registry Key with cmd. Files in new_malicious_startup_folder will be launched when user logon commands: - reg add "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\User Shell Folders" /v "Common Startup" /d "C:\Users\Lucas\Documents\new_malicious_startup_folder" /f - description: Modification on Registry Key with Powershell. Files in new_malicious_startup_folder will be launched when user logon commands: - Set-ItemProperty -Path "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\User Shell Folders" -Name "Common Startup" -Value C:\Users\Lucas\Documents\new_malicious_startup_folder data_model_references: - process/create/command_line - registry/add/key d3fend_mappings: - iri: d3f:ProcessSpawnAnalysis id: D3-PSA label: Process Spawn Analysis --- 
<li><a href="#">title: MSBuild and msxsl submission_date: 2020/11/30 information_domain: Host platforms: - Windows subtypes: - Process analytic_types: - TTP contributors: - Olaf Hartong id: CAR-2020-11-008 description: |- Trusted developer utilities such as MSBuild may be leveraged to run malicious code with elevated privileges. This analytic looks for any instances of msbuild.exe, which will execute any C# code placed within a given XML document; and msxsl.exe, which processes xsl transformation specifications for XML files and will execute a variaty of scripting languages contained within the XSL file. Both of these executables are rarely used outside of Visual Studio. coverage: - technique: T1127 tactics: - TA0005 subtechniques: - T1127.001 coverage: High implementations: - name: Pseudocode - msbuild description: This is a pseudocode representation of the below splunk search. code: |- processes = search Process:Create target_processes = filter processes where ( (exe="C:\Program Files (x86)\Microsoft Visual Studio\*\bin\MSBuild.exe" OR exe="C:\Windows\Microsoft.NET\Framework*\msbuild.exe" OR exe="C:\users\*\appdata\roaming\microsoft\msxsl.exe") AND image_path!="*Microsoft Visual Studio*") output target_processes data_model: CAR native type: Pseudocode - name: Splunk Search - msbuild description: Looks for all instances of msbuild.exe or msxsl.exe code: |- (index=__your_sysmon_index__ EventCode=1) (Image="C:\\Program Files (x86)\\Microsoft Visual Studio\\*\\bin\\MSBuild.exe" OR Image="C:\\Windows\\Microsoft.NET\\Framework*\\msbuild.exe" OR Image="C:\\users\\*\\appdata\\roaming\\microsoft\\msxsl.exe") ParentImage!="*\\Microsoft Visual Studio*") data_model: Sysmon native type: Splunk - name: LogPoint Search - msbuild description: Looks for all instances of msbuild.exe or msxsl.exe code: |- norm_id=WindowsSysmon event_id=1 (image IN ["C:\Program Files (x86)\Microsoft Visual Studio\*\bin\MSBuild.exe", "C:\Windows\Microsoft.NET\Framework*\msbuild.exe", "C:\Users\*\appdata\roaming\microsoft\msxsl.exe") -parent_image="*\Microsoft Visual Studio*") data_model: LogPoint native type: LogPoint data_model_references: - process/create/exe - process/create/image_path d3fend_mappings: - iri: d3f:ProcessSpawnAnalysis id: D3-PSA label: Process Spawn Analysis 
<li><a href="#">title: Network Share Connection Removal submission_date: 2020/11/30 information_domain: Host platforms: - Windows subtypes: - Process analytic_types: - TTP contributors: - Olaf Hartong id: CAR-2020-11-007 description: |- Adversaries may use network shares to exfliltrate date; they will then remove the shares to cover their tracks. This analytic looks for the removal of network shares via commandline, which is otherwise a rare event. coverage: - technique: T1070 tactics: - TA0005 subtechniques: - T1070.005 coverage: High implementations: - name: Pseudocode - network shares being removed via the command line description: This is a pseudocode representation of the below splunk search. code: |- processes = search Process:Create target_processes = filter processes where ( (exe="C:\\Windows\\System32\\net.exe" AND command_line="*delete*") OR command_line="*Remove-SmbShare*" OR comman_line="*Remove-FileShare*" ) output target_processes data_model: CAR native type: Pseudocode - name: Splunk Search - delete network shares description: looks network shares being deleted from the command line code: |- (index=__your_sysmon_index__ EventCode=1) ((Image="C:\\Windows\\System32\\net.exe" AND CommandLine="*delete*") OR CommandLine="*Remove-SmbShare*" OR CommandLine="*Remove-FileShare*") data_model: Sysmon native type: Splunk - name: LogPoint Search - delete network shares description: looks network shares being deleted from the command line code: |- norm_id=WindowsSysmon event_id=1 ((image="C:\Windows\System32\net.exe" command="*delete*") OR command="*Remove-SmbShare*" OR command="*Remove-FileShare*") data_model: LogPoint native type: LogPoint data_model_references: - process/create/exe - process/create/command_line d3fend_mappings: - iri: d3f:ProcessSpawnAnalysis id: D3-PSA label: Process Spawn Analysis 
<li><a href="#">title: NTFS Alternate Data Stream Execution - LOLBAS submission_date: 2020/08/03 information_domain: 'Host' platforms: - Windows subtypes: - Process analytic_types: - TTP contributors: - MITRE id: CAR-2020-08-002 description: |- NTFS Alternate Data Streams (ADSs) may be used by adversaries as a means of evading security tools by storing malicious data or binaries in file attribute metadata. ADSs are also powerful because their contents can be directly executed by various Windows tools; accordingly, this analytic looks at common ways of executing ADSs using Living off the Land Binaries and Scripts (LOLBAS). coverage: - technique: T1564 tactics: - TA0005 subtechniques: - T1564.004 coverage: Low implementations: - name: NTFS ADS - pseudocode description: This is generic pseudocode that lines up with the below Splunk queries. code: |- processes = search Process:Create ads_processes = filter processes where ( exe == "control.exe OR appvlp.exe OR cmd.exe OR ftp.exe OR bash.exe OR mavinject.exe OR bitsadmin.exe" and command_line.matches("__some_regex__") ) output ads_processes type: pseudocode data_model: CAR native - name: NTFS ADS - control description: This Splunk query looks for invocations of control.exe used to execute NTFS alternate data streams. code: |- index=__sysmon_index__ EventCode=1 (Image=C:\\Windows\System32\\control.exe OR Image=C:\\Windows\SysWOW64\\control.exe) | regex CommandLine="(\w+(\.\w+)?):(\w+\.dll)" type: splunk data_model: Sysmon native - name: NTFS ADS - appvlp description: This Splunk query looks for invocations of appvlp.exe used to execute NTFS alternate data streams. code: |- index=__sysmon_index__ EventCode=1 (Image="C:\\Program Files\\Microsoft Office\\root\\Client\\AppVLP.exe" OR Image="C:\\Program Files (x86)\\Microsoft Office\\root\\Client\\AppVLP.exe") | regex CommandLine="(\w+(\.\w+)?):(\w+(\.\w+)?)" type: splunk data_model: Sysmon native - name: NTFS ADS - cmd description: This Splunk query looks for invocations of cmd.exe used to execute NTFS alternate data streams. code: |- index=__sysmon_index__ EventCode=1 (Image=C:\\Windows\\System32\\cmd.exe OR Image=C:\\Windows\\SysWOW64\\cmd.exe) | regex CommandLine="-\s+<.*\b(\w+(\.\w+)?):(\w+(\.\w+)?)" type: splunk data_model: Sysmon native - name: NTFS ADS - ftp description: This Splunk query looks for invocations of ftp.exe used to execute NTFS alternate data streams. code: |- index=__sysmon_index__ EventCode=1 (Image=C:\\Windows\\System32\\ftp.exe OR Image=C:\\Windows\\SysWOW64\\ftp.exe) | regex CommandLine="-s:(\w+(\.\w+)?):(\w+(\.\w+)?)" type: splunk data_model: Sysmon native - name: NTFS ADS - bash description: This Splunk query looks for invocations of bash.exe used to execute NTFS alternate data streams. code: |- index=__sysmon_index__ EventCode=1 (Image=C:\\Windows\\System32\\bash.exe OR C:\\Windows\\SysWOW64\\bash.exe) | regex CommandLine="-c.*(\w+(\.\w+)?):(\w+(\.\w+)?)" type: splunk data_model: Sysmon native - name: NTFS ADS - mavinject description: This Splunk query looks for invocations of mavinject.exe used to execute NTFS alternate data streams. code: |- index=__sysmon_index__ EventCode=1 (Image=C:\\Windows\\System32\\mavinject.exe OR C:\\Windows\\SysWOW64\\mavinject.exe) | regex CommandLine="\d+\s+\/INJECTRUNNING.*\b(\w+(\.\w+)?):(\w+(\.\w+)?)" type: splunk data_model: Sysmon native - name: NTFS ADS - bitsadmin description: This Splunk query looks for invocations of bitsadmin.exe used to execute NTFS alternate data streams. code: |- index=__sysmon_index__ EventCode=1 (Image=C:\\Windows\\System32\\bitsadmin.exe OR C:\\Windows\\SysWOW64\\bitsadmin.exe) | regex CommandLine="\/create.*\/addfile.*\/SetNotifyCmdLine.*\b(\w+\.\w+):(\w+(\.\w+)?)" type: splunk data_model: Sysmon native data_model_references: - process/create/exe - process/create/command_line references: - The [LOLBAS project]() is an amazing resource and was used as the basis for many of these analytics. - Oddvar Moe has created an excellent NTFS ADS execution reference [here on github](). d3fend_mappings: - iri: d3f:ProcessSpawnAnalysis id: D3-PSA label: Process Spawn Analysis --- 
<li><a href="#">title: NTFS Alternate Data Stream Execution - System Utilities submission_date: 2020/08/03 information_domain: 'Host' platforms: - Windows subtypes: - Process analytic_types: - TTP contributors: - MITRE id: CAR-2020-08-001 description: |- NTFS Alternate Data Streams (ADSs) may be used by adversaries as a means of evading security tools by storing malicious data or binaries in file attribute metadata. ADSs are also powerful because they can be directly executed by various Windows tools; accordingly, this analytic looks at common ways of executing ADSs using system utilities such as powershell. coverage: - technique: T1564 tactics: - TA0005 subtechniques: - T1564.004 coverage: Low implementations: - name: NTFS ADS - pseudocode description: This is generic pseudocode that lines up with the below Splunk queries. code: |- processes = search Process:Create ads_processes = filter processes where ( exe == "powershell.exe OR rundll32.exe OR wmic.exe OR wscript.exe OR cscript.exe" and command_line.matches("__some_regex__") ) output ads_processes type: pseudocode data_model: CAR native - name: NTFS ADS - powershell description: This Splunk query looks for invocations of powershell used to execute NTFS alternate data streams. code: |- index=__sysmon_index__ EventCode=1 Image=C:\\Windows\\*\\powershell.exe|regex CommandLine="Invoke-CimMethod\s+-ClassName\s+Win32_Process\s+-MethodName\s+Create.*\b(\w+(\.\w+)?):(\w+(\.\w+)?)|-ep bypass\s+-\s+<.*\b(\w+(\.\w+)?):(\w+(\.\w+)?)|-command.*Get-Content.*-Stream.*Set-Content.*start-process .*(\w+(\.\w+)?)" type: splunk data_model: Sysmon native - name: NTFS ADS - wmic description: This Splunk query looks for invocations of WMIC used to execute NTFS alternate data streams. code: |- index=__sysmon_index__ EventCode=1 Image=C:\\Windows\\*\\wmic.exe | regex CommandLine="process call create.*\"(\w+(\.\w+)?):(\w+(\.\w+)?)" type: splunk data_model: Sysmon native - name: NTFS ADS - rundll32 description: This Splunk query looks for invocations of rundll32 used to execute NTFS alternate data streams. code: |- index=__sysmon_index__ EventCode=1 Image=C:\\Windows\\*\\rundll32.exe | regex CommandLine="\"?(\w+(\.\w+)?):(\w+(\.\w+)?)?\"?,\w+\|(advpack\.dll\|ieadvpack\.dll),RegisterOCX\s+(\w+\.\w+):(\w+(\.\w+)?)\|(shdocvw\.dll\|ieframe\.dll),OpenURL.*(\w+\.\w+):(\w+(\.\w+)?)" type: splunk data_model: Sysmon native - name: NTFS ADS - wscript/cscript description: This Splunk query looks for invocations of the windows scripting host used to execute NTFS alternate data streams. code: |- index=__sysmon_index__ EventCode=1 (Image=C:\\Windows\\*\\wscript.exe OR Image=C:\\Windows\\*\\cscript.exe) | regex CommandLine="(?<!\/)\b\w+(\.\w+)?:\w+(\.\w+)?$" type: splunk data_model: Sysmon native data_model_references: - process/create/exe - process/create/command_line references: - Oddvar Moe has created an excellent NTFS ADS execution reference [here on github](), which was used as the basis for many of these analytics. - The [LOLBAS project]() is an amazing resource for anything LOLBAS. d3fend_mappings: - iri: d3f:ProcessSpawnAnalysis id: D3-PSA label: Process Spawn Analysis --- 
<li><a href="#">title: Outlier Parents of Cmd submission_date: 2014/11/06 information_domain: Host platforms: - Windows subtypes: - Process analytic_types: - Anomaly - TTP contributors: - MITRE id: CAR-2014-11-002 description: |- Many programs create command prompts as part of their normal operation including malware used by attackers. This analytic attempts to identify suspicious programs spawning `cmd.exe` by looking for programs that do not normally create `cmd.exe`. While this analytic does not take the user into account, doing so could generate further interesting results. It is very common for some programs to spawn cmd.exe as a subprocess, for example to run batch files or windows commands. However many process donâ€™t routinely launch a command prompt â€“ for example Microsoft Outlook. A command prompt being launched from a process that normally doesnâ€™t launch command prompts could be the result of malicious code being injected into that process, or of an attacker replacing a legitimate program with a malicious one. ### Output Description The time and host the new process was started as well as its parent coverage: - technique: T1059 tactics: - TA0002 subtechniques: - T1059.003 coverage: Moderate implementations: - description: 'Create a baseline of parents of `cmd.exe` seen over the last 30 days and a list of parents of `cmd.exe` seen today. Remove parents in the baseline from parents seen today, leaving a list of new parents.' code: |- processes = search Process:Create cmd = filter processes where (exe == "cmd.exe") cmd = from cmd select parent_exe historic_cmd = filter cmd (where timestamp < now - 1 day AND timestamp > now - 1 day) current_cmd = filter cmd (where timestamp >= now - 1 day) new_cmd = historic_cmd - current_cmd output new_cmd type: pseudocode data_model_references: - process/create/exe - process/create/parent_exe d3fend_mappings: - iri: d3f:ProcessLineageAnalysis id: D3-PLA label: Process Lineage Analysis 
<li><a href="#">title: Powershell Execution submission_date: 2014/04/11 information_domain: Host platforms: - Windows subtypes: - Process analytic_types: - TTP contributors: - MITRE id: CAR-2014-04-003 description: |- [PowerShell]() is a scripting environment included with Windows that is used by both attackers and administrators. Execution of PowerShell scripts in most Windows versions is opaque and not typically secured by antivirus which makes using PowerShell an easy way to circumvent security measures. This analytic detects execution of PowerShell scripts. Powershell can be used to hide monitored command line execution such as: - `net use` - `sc start` coverage: - technique: T1059 tactics: - TA0002 subtechniques: - T1059.001 coverage: High - technique: T1059 tactics: - TA0005 subtechniques: - T1059.001 coverage: Moderate implementations: - description: 'Look for versions of `PowerShell` that were not launched interactively.' code: |- process = search Process:Create powershell = filter process where (exe == "powershell.exe" AND parent_exe != "explorer.exe" ) output powershell type: pseudocode - description: Splunk version of the above pseudocode. code: |- index=__your_sysmon_index__ EventCode=1 Image="C:\\Windows\\*\\powershell.exe" ParentImage!="C:\\Windows\\explorer.exe"|stats values(CommandLine) as "Command Lines" values(ParentImage) as "Parent Images" by ComputerName type: Splunk data_model: Sysmon native - description: EQL version of the above pseudocode. code: |- process where subtype.create and (process_name == "powershell.exe" and parent_process_name != "explorer.exe") type: EQL data_model: EQL native - description: DNIF version of the above pseudocode. code: |- _fetch * from event where $LogName=WINDOWS-SYSMON AND $EventID=1 AND $App=powershell.exe NOT $ParentProcess=regex(.*explorer.exe.*)i limit 30 type: DNIF data_model: Sysmon native - description: LogPoint version of the above pseudocode. code: |- norm_id=WindowsSysmon event_id=1 image="*\powershell.exe" -parent_image="C:\Windows\explorer.exe" type: LogPoint data_model: LogPoint native data_model_references: - process/create/exe - process/create/parent_exe true_positives: - source: 'Mordor (Sysmon)' description: 'Sysmon event from the Mordor [Empire Userland Registry dataset]().' event_snippet: 'CAR-2014-04-003-mordor-01-snippet.json' full_event: 'CAR-2014-04-003-mordor-01.json' d3fend_mappings: - iri: d3f:ProcessSpawnAnalysis id: D3-PSA label: Process Spawn Analysis 
<li><a href="#">title: Processes Spawning cmd.exe submission_date: 2013/02/05 information_domain: Host platforms: - Windows subtypes: - Process analytic_types: - Situational Awareness contributors: - MITRE id: CAR-2013-02-003 description: 'The Windows [Command Prompt]() (`cmd.exe`) is a utility that provides a command line interface to Windows operating systems. It provides the ability to run additional programs and also has several built-in commands such as `dir`, `copy`, `mkdir`, and `type`, as well as batch scripts (`.bat`). Typically, when a user runs a command prompt, the parent process is `explorer.exe` or another instance of the prompt. There may be automated programs, logon scripts, or administrative tools that launch instances of the command prompt in order to run scripts or other built-in commands. Spawning the process `cmd.exe` from certain parents may be more indicative of malice. For example, if Adobe Reader or Outlook launches a command shell, this may suggest that a malicious document has been loaded and should be investigated. Thus, by looking for abnormal parent processes of `cmd.exe`, it may be possible to detect adversaries.' coverage: - technique: T1059 tactics: - TA0002 subtechniques: - T1059.003 coverage: Moderate implementations: - code: |- process = search Process:Create cmd = filter process where (exe == "cmd.exe") output cmd type: pseudocode - description: DNIF version of the above pseudocode. code: |- _fetch * from event where $LogName=WINDOWS-SYSMON AND $EventID=1 AND $Process=regex(.*cmd\.exe.*)i limit 100 type: DNIF data_model: Sysmon native - description: LogPoint version of the above pseudocode. code: |- norm_id=WindowsSysmon event_id=1 image="*\cmd.exe" type: LogPoint data_model: LogPoint native data_model_references: - process/create/exe - process/create/parent_exe unit_tests: - configurations: - Windows 7 description: 'Within a command prompt or powershell, run cmd.exe' d3fend_mappings: - iri: d3f:ProcessLineageAnalysis id: D3-PLA label: Process Lineage Analysis 
<li><a href="#">title: Processes Started From Irregular Parent submission_date: 2020/11/30 information_domain: Host platforms: - Windows subtypes: - Process analytic_types: - TTP contributors: - Olaf Hartong id: CAR-2020-11-004 description: |- Adversaries may start legitimate processes and then use their memory space to run malicious code. This analytic looks for common Windows processes that have been abused this way in the past; when the processes are started for this purpose they may not have the standard parent that we would expect. This list is not exhaustive, and it is possible for cyber actors to avoid this discepency. These signatures only work if Sysmon reports the parent process, which may not always be the case if the parent dies before sysmon processes the event. coverage: - technique: T1055 tactics: - TA0005 subtechniques: - T1055.012 coverage: Low implementations: - name: Pseudocode - common processes that do not have the correct parent description: This is a pseudocode representation of the below splunk search. code: |- processes = search Process:Create mismatch_processes = filter processes where ( parent_exe exists AND (exe="smss.exe" AND (parent_exe!="smss.exe" AND parent_exe!="System") OR (exe="csrss.exe" AND (parent_exe!="smss.exe" AND parent_exe!="svchost.exe")) OR (exe="wininit.exe" AND parent_exe!="smss.exe") OR (exe="winlogon.exe" AND parent_exe!="smss.exe") OR (exe="lsass.exe" AND (parent_exe!="wininit.exe" AND parent_exe!="winlogon.exe")) OR (exe="LogonUI.exe" AND (parent_exe!="winlogon.exe" AND parent_exe!="wininit.exe")) OR (exe="services.exe" AND parent_exe!="wininit.exe") OR (exe="spoolsv.exe" AND parent_exe!="services.exe") OR (exe="taskhost.exe" AND (parent_exe!="services.exe" AND parent_exe!="svchost.exe")) OR (exe="taskhostw.exe" AND (parent_exe!="services.exe" AND parent_exe!="svchost.exe")) OR (exe="userinit.exe" AND (parent_exe!="dwm.exe" AND parent_exe!="winlogon.exe")) output mismatch_processes data_model: CAR native type: Pseudocode - name: Splunk Search - parent/child mismatch description: Looks for processes that do not have the expected parent. Common Splunk forwarder applications that break these rules are whitelisted; unique environments may require additional whitelist items. code: |- (index=__your_sysmon_index__ EventCode=1) AND ParentImage!="?" AND ParentImage!="C:\\Program Files\\SplunkUniversalForwarder\\bin\\splunk-regmon.exe" AND ParentImage!="C:\\Program Files\\SplunkUniversalForwarder\\bin\\splunk-powershell.exe" AND ((Image="C:\\Windows\System32\\smss.exe" AND (ParentImage!="C:\\Windows\\System32\\smss.exe" AND ParentImage!="System")) OR (Image="C:\\Windows\\System32\\csrss.exe" AND (ParentImage!="C:\\Windows\\System32\\smss.exe" AND ParentImage!="C:\\Windows\\System32\\svchost.exe")) OR (Image="C:\\Windows\\System32\\wininit.exe" AND ParentImage!="C:\\Windows\\System32\\smss.exe") OR (Image="C:\\Windows\\System32\\winlogon.exe" AND ParentImage!="C:\\Windows\\System32\\smss.exe") OR (Image="C:\\Windows\\System32\\lsass.exe" and ParentImage!="C:\\Windows\\System32\\wininit.exe") OR (Image="C:\\Windows\\System32\\LogonUI.exe" AND (ParentImage!="C:\\Windows\\System32\\winlogon.exe" AND ParentImage!="C:\\Windows\\System32\\wininit.exe")) OR (Image="C:\\Windows\\System32\\services.exe" AND ParentImage!="C:\\Windows\\System32\\wininit.exe") OR (Image="C:\\Windows\\System32\\spoolsv.exe" AND ParentImage!="C:\\Windows\\System32\\services.exe") OR (Image="C:\\Windows\\System32\\taskhost.exe" AND (ParentImage!="C:\\Windows\\System32\\services.exe" AND ParentImage!="C:\\Windows\\System32\\svchost.exe")) OR (Image="C:\\Windows\\System32\\taskhostw.exe" AND (ParentImage!="C:\\Windows\\System32\\services.exe" AND ParentImage!="C:\\Windows\\System32\\svchost.exe")) OR (Image="C:\\Windows\System32\\userinit.exe" AND (ParentImage!="C:\\Windows\\System32\\dwm.exe" AND ParentImage!="C:\\Windows\\System32\\winlogon.exe"))) data_model: Sysmon native type: Splunk - name: LogPoint Search - parent/child mismatch description: Looks for processes that do not have the expected parent. Unique environments may require additional whitelist items. code: |- norm_id=WindowsSysmon event_id=1 -parent_image="?" ((image="*\smss.exe" (-parent_image="*\smss.exe" -parent_image="*\System")) OR (image="*\csrss.exe" (-parent_image="*\smss.exe" -parent_image="*\svchost.exe")) OR (image="*\wininit.exe" -parent_image="*\smss.exe") OR (image="*\winlogon.exe" -parent_image="*\smss.exe") OR (image="*\lsass.exe" (-parent_image="*\wininit.exe" -parent_image="*\winlogon.exe")) OR (image="*\LogonUI.exe" (-parent_image="*\winlogon.exe" -parent_image="*\wininit.exe")) OR (image="*\services.exe" -parent_image="*\wininit.exe") OR (image="*\spoolsv.exe" -parent_image="*\services.exe") OR (image="*\taskhost.exe" (-parent_image="*\services.exe" -parent_image="*\svchost.exe")) OR (image="*\taskhostw.exe" (-parent_image="*\services.exe" -parent_image="*\svchost.exe")) OR (image="*\userinit.exe" (-parent_image="*\dwm.exe" -parent_image="*\winlogon.exe"))) data_model: LogPoint native type: LogPoint data_model_references: - process/create/exe - process/create/parent_exe d3fend_mappings: - iri: d3f:ProcessLineageAnalysis id: D3-PLA label: Process Lineage Analysis 
<li><a href="#">title: Quick execution of a series of suspicious commands submission_date: 2013/04/11 information_domain: 'Analytic, Host' platforms: - Windows - Linux - macOS subtypes: - Process analytic_types: - TTP contributors: - MITRE id: CAR-2013-04-002 description: |- Certain commands are frequently used by malicious actors and infrequently used by normal users. By looking for execution of these commands in short periods of time, we can not only see when a malicious user was on the system but also get an idea of what they were doing. Commands of interest: - arp.exe - at.exe - attrib.exe - cscript.exe - dsquery.exe - hostname.exe - ipconfig.exe - mimikatz.exe - nbstat.exe - net.exe - netsh.exe - nslookup.exe - ping.exe - quser.exe - qwinsta.exe - reg.exe - runas.exe - sc.exe - schtasks.exe - ssh.exe - systeminfo.exe - taskkill.exe - telnet.exe - tracert.exe - wscript.exe - xcopy.exe ### Output Description The host on which the commands were executed, the time of execution, and what commands were executed coverage: - technique: T1087 tactics: - TA0007 subtechniques: - T1087.001 - T1087.002 coverage: Low - technique: T1003 tactics: - TA0006 subtechniques: - T1003.002 coverage: Low - technique: T1069 tactics: - TA0007 subtechniques: - T1069.001 - T1069.002 coverage: Low - technique: T1057 tactics: - TA0007 coverage: Low - technique: T1021 tactics: - TA0008 subtechniques: - T1021.002 coverage: Low - technique: T1543 tactics: - TA0003 - TA0004 subtechniques: - T1543.003 coverage: Low - technique: T1112 tactics: - TA0005 coverage: Low - technique: T1574 tactics: - TA0003 - TA0004 subtechniques: - T1574.011 coverage: Low - technique: T1018 tactics: - TA0007 coverage: Low - technique: T1569 tactics: - TA0002 subtechniques: - T1569.002 coverage: Low - technique: T1053 tactics: - TA0003 - TA0004 - TA0002 subtechniques: - T1053.002 - T1053.005 coverage: Low - technique: T1029 tactics: - TA0010 coverage: Low - technique: T1033 tactics: - TA0007 coverage: Low - technique: T1007 tactics: - TA0007 coverage: Low - technique: T1082 tactics: - TA0007 coverage: Low - technique: T1049 tactics: - TA0007 coverage: Low - technique: T1016 tactics: - TA0007 coverage: Low - technique: T1010 tactics: - TA0007 coverage: Low - technique: T1518 tactics: - TA0007 subtechniques: - T1518.001 coverage: Low - technique: T1046 tactics: - TA0007 coverage: Low - technique: T1562 tactics: - TA0005 subtechniques: - T1562.001 - T1562.006 coverage: Low - technique: T1098 tactics: - TA0006 coverage: Low - technique: T1059 tactics: - TA0002 subtechniques: - T1059.005 coverage: Moderate - technique: T1012 tactics: - TA0007 coverage: Low implementations: - code: |- processes = search Process:Create reg_processes = filter processes where (exe == "arp.exe" or exe == "at.exe" or exe == "attrib.exe" or exe == "cscript.exe" or exe == "dsquery.exe" or exe == "hostname.exe" or exe == "ipconfig.exe" or exe == "mimikatz.exe" or exe == "nbstat.exe" or exe == "net.exe" or exe == "netsh.exe" or exe == "nslookup.exe" or exe == "ping.exe" or exe == "quser.exe" or exe == "qwinsta.exe" or exe == "reg.exe" or exe == "runas.exe" or exe == "sc.exe" or exe == "schtasks.exe" or exe == "ssh.exe" or exe == "systeminfo.exe" or exe == "taskkill.exe" or exe == "telnet.exe" or exe == "tracert.exe" or exe == "wscript.exe" or exe == "xcopy.exe") reg_grouped = group reg by hostname, ppid where(max time between two events is 30 minutes) output reg_grouped type: pseudocode - description: '[Sigma version]() of the above pseudocode, with some modifications.' type: Sigma - description: DNIF version of the above pseudocode. code: |- _fetch * from event where $LogName=WINDOWS-SYSMON AND $EventID=1 AND $App=regex(arp\.exe|at\.exe|attrib\.exe|cscript\.exe|dsquery\.exe|hostname\.exe|ipconfig\.exe|mimikatz.exe|nbstat\.exe|net\.exe|netsh\.exe|nslookup\.exe|ping\.exe|quser\.exe|qwinsta\.exe|reg\.exe|runas\.exe|sc\.exe|schtasks\.exe|ssh\.exe|systeminfo\.exe|taskkill\.exe|telnet\.exe|tracert\.exe|wscript\.exe|xcopy\.exe)i group count_unique $App limit 100 >>_agg count >>_checkif int_compare Count > 1 include type: DNIF data_model: Sysmon native - description: LogPoint version of the above pseudocode. code: |- norm_id=WindowsSysmon event_id=1 image IN ["*\arp.exe", "*\at.exe", "*\attrib.exe", "*\cscript.exe", "*\dsquery.exe", "*\hostname.exe", "*\ipconfig.exe", "*\mimikatz.exe", "*\nbstat.exe", "*\net.exe", "*\netsh.exe", "*\nslookup.exe", "*\ping.exe", "*\quser.exe", "*\qwinsta.exe", "*\reg.exe", "*\runas.exe", "*\sc.exe", "*\schtasks.exe", "*\ssh.exe", "*\systeminfo.exe", "*\taskkill.exe", "*\telnet.exe", "*\tracert.exe", "*\wscript.exe", "*\xcopy.exe"] | chart count() as cnt by host | search cnt > 1 type: LogPoint data_model: LogPoint native data_model_references: - process/create/hostname - process/create/ppid - process/create/exe unit_tests: - configurations: - Windows 7 description: 'Within a command window, execute several of the commands in quick succession.' commands: - ipconfig /all - hostname - systeminfo - reg.exe Query HKLM\Software\Microsoft d3fend_mappings: - iri: d3f:ProcessLineageAnalysis id: D3-PLA label: Process Lineage Analysis 
<li><a href="#">title: Rare LolBAS Command Lines submission_date: 2020/05/04 information_domain: 'Host' platforms: - Windows subtypes: - Process analytic_types: - TTP contributors: - Cyber National Mission Force (CNMF) id: CAR-2020-05-003 description: |- [LoLBAS]() are binaries and scripts that are built in to Windows, frequently are signed by Microsoft, and may be used by an attacker. Some LoLBAS are used very rarely and it might be possible to alert every time they're used (this would depend on your environment), but many others are very common and can't be simply alerted on. This analytic takes all instances of LoLBAS execution and then looks for instances of command lines that are not normal in the environment. This can detect attackers (which will tend to need the binaries for something different than normal usage) but will also tend to have false positives. The analytic needs to be tuned. The `1.5` in the query is the number of standard deviations away to look. It can be tuned up to filter out more noise and tuned down to get more results. This means it is probably best as a hunting analytic when you have analysts looking at the screen and able to tune the analytic up and down, because the threshold may not be stable for very long. Note - this analytic is related to [CAR-2013-04-002](/analytics/CAR-2013-04-002), but differs by looking for a different set of binaries and also looking at standard deviation across command lines of these binaries instead of their execution within a short time window. coverage: - technique: T1012 tactics: - TA0007 coverage: Low - technique: T1112 tactics: - TA0005 coverage: Low - technique: T1547 tactics: - TA0003 subtechniques: - T1547.001 coverage: Low - technique: T1574 tactics: - TA0003 - TA0004 subtechniques: - T1574.011 coverage: Low implementations: - name: LolBAS Rare Commands description: Pseudocode version of the below Splunk query. code: |- processes = search Process:Create lolbas_processes = filter processes where (exe = "At.exe" OR exe = "Atbroker.exe" OR exe = "Bash.exe" OR exe = "Bitsadmin.exe" OR exe = "Certutil.exe" OR exe = "Cmd.exe" OR exe = "Cmdkey.exe" OR exe = "Cmstp.exe" OR exe = "Control.exe" OR exe = "Csc.exe" OR exe = "Cscript.exe" OR exe = "Dfsvc.exe" OR exe = "Diskshadow.exe" OR exe = "Dnscmd.exe" OR exe = "Esentutl.exe" OR exe = "Eventvwr.exe" OR exe = "Expand.exe" OR exe = "Extexport.exe" OR exe = "Extrac32.exe" OR exe = "Findstr.exe" OR exe = "Forfiles.exe" OR exe = "Ftp.exe" OR exe = "Gpscript.exe" OR exe = "Hh.exe" OR exe = "Ie4uinit.exe" OR exe = "Ieexec.exe" OR exe = "Infdefaultinstall.exe" OR exe = "Installutil.exe" OR exe = "Jsc.exe" OR exe = "Makecab.exe" OR exe = "Mavinject.exe" OR exe = "Microsoft.Workflow.r.exe" OR exe = "Mmc.exe" OR exe = "Msbuild.exe" OR exe = "Msconfig.exe" OR exe = "Msdt.exe" OR exe = "Mshta.exe" OR exe = "Msiexec.exe" OR exe = "Odbcconf.exe" OR exe = "Pcalua.exe" OR exe = "Pcwrun.exe" OR exe = "Presentationhost.exe" OR exe = "Print.exe" OR exe = "Reg.exe" OR exe = "Regasm.exe" OR exe = "Regedit.exe" OR exe = "Register-cimprovider.exe" OR exe = "Regsvcs.exe" OR exe = "Regsvr32.exe" OR exe = "Replace.exe" OR exe = "Rpcping.exe" OR exe = "Rundll32.exe" OR exe = "Runonce.exe" OR exe = "Runscripthelper.exe" OR exe = "Sc.exe" OR exe = "Schtasks.exe" OR exe = "Scriptrunner.exe" OR exe = "SyncAppvPublishingServer.exe" OR exe = "Tttracer.exe" OR exe = "Verclsid.exe" OR exe = "Wab.exe" OR exe = "Wmic.exe" OR exe = "Wscript.exe" OR exe = "Wsreset.exe" OR exe = "Xwizard.exe" OR exe = "Advpack.dll OR exe = "Comsvcs.dll OR exe = "Ieadvpack.dll OR exe = "Ieaframe.dll OR exe = "Mshtml.dll OR exe = "Pcwutl.dll OR exe = "Setupapi.dll OR exe = "Shdocvw.dll OR exe = "Shell32.dll OR exe = "Syssetup.dll OR exe = "Url.dll OR exe = "Zipfldr.dll OR exe = "Appvlp.exe" OR exe = "Bginfo.exe" OR exe = "Cdb.exe" OR exe = "csi.exe" OR exe = "Devtoolslauncher.exe" OR exe = "dnx.exe" OR exe = "Dxcap.exe" OR exe = "Excel.exe" OR exe = "Mftrace.exe" OR exe = "Msdeploy.exe" OR exe = "msxsl.exe" OR exe = "Powerpnt.exe" OR exe = "rcsi.exe" OR exe = "Sqler.exe" OR exe = "Sqlps.exe" OR exe = "SQLToolsPS.exe" OR exe = "Squirrel.exe" OR exe = "te.exe" OR exe = "Tracker.exe" OR exe = "Update.exe" OR exe = "vsjitdebugger.exe" OR exe = "Winword.exe" OR exe = "Wsl.exe" OR exe = "CL_Mutexverifiers.ps1 OR exe = "CL_Invocation.ps1 OR exe = "Manage-bde.wsf OR exe = "Pubprn.vbs OR exe = "Slmgr.vbs OR exe = "Syncappvpublishingserver.vbs OR exe = "winrm.vbs OR exe = "Pester.bat) process_count = count(lolbas_processes) by process process_count_avg = average(process_count) process_count_stdev = standard_deviation(process_count) lower_bound = process_count_avg - stdev * 1.5 outliers = filter lolbas_processes where (process_count < lower_bound) return outliers type: Pseudocode data_model: CAR native - name: LolBAS Rare Commands description: This Splunk query looks for instances of LoLBAS commands being executed, then stacks by rare command lines using a stddev. code: |- index=__your_sysmon_index__ EventCode=1 (OriginalFileName = At.exe OR OriginalFileName = Atbroker.exe OR OriginalFileName = Bash.exe OR OriginalFileName = Bitsadmin.exe OR OriginalFileName = Certutil.exe OR OriginalFileName = Cmd.exe OR OriginalFileName = Cmdkey.exe OR OriginalFileName = Cmstp.exe OR OriginalFileName = Control.exe OR OriginalFileName = Csc.exe OR OriginalFileName = Cscript.exe OR OriginalFileName = Dfsvc.exe OR OriginalFileName = Diskshadow.exe OR OriginalFileName = Dnscmd.exe OR OriginalFileName = Esentutl.exe OR OriginalFileName = Eventvwr.exe OR OriginalFileName = Expand.exe OR OriginalFileName = Extexport.exe OR OriginalFileName = Extrac32.exe OR OriginalFileName = Findstr.exe OR OriginalFileName = Forfiles.exe OR OriginalFileName = Ftp.exe OR OriginalFileName = Gpscript.exe OR OriginalFileName = Hh.exe OR OriginalFileName = Ie4uinit.exe OR OriginalFileName = Ieexec.exe OR OriginalFileName = Infdefaultinstall.exe OR OriginalFileName = Installutil.exe OR OriginalFileName = Jsc.exe OR OriginalFileName = Makecab.exe OR OriginalFileName = Mavinject.exe OR OriginalFileName = Microsoft.Workflow.r.exe OR OriginalFileName = Mmc.exe OR OriginalFileName = Msbuild.exe OR OriginalFileName = Msconfig.exe OR OriginalFileName = Msdt.exe OR OriginalFileName = Mshta.exe OR OriginalFileName = Msiexec.exe OR OriginalFileName = Odbcconf.exe OR OriginalFileName = Pcalua.exe OR OriginalFileName = Pcwrun.exe OR OriginalFileName = Presentationhost.exe OR OriginalFileName = Print.exe OR OriginalFileName = Reg.exe OR OriginalFileName = Regasm.exe OR OriginalFileName = Regedit.exe OR OriginalFileName = Register-cimprovider.exe OR OriginalFileName = Regsvcs.exe OR OriginalFileName = Regsvr32.exe OR OriginalFileName = Replace.exe OR OriginalFileName = Rpcping.exe OR OriginalFileName = Rundll32.exe OR OriginalFileName = Runonce.exe OR OriginalFileName = Runscripthelper.exe OR OriginalFileName = Sc.exe OR OriginalFileName = Schtasks.exe OR OriginalFileName = Scriptrunner.exe OR OriginalFileName = SyncAppvPublishingServer.exe OR OriginalFileName = Tttracer.exe OR OriginalFileName = Verclsid.exe OR OriginalFileName = Wab.exe OR OriginalFileName = Wmic.exe OR OriginalFileName = Wscript.exe OR OriginalFileName = Wsreset.exe OR OriginalFileName = Xwizard.exe OR OriginalFileName = Advpack.dll OR OriginalFileName = Comsvcs.dll OR OriginalFileName = Ieadvpack.dll OR OriginalFileName = Ieaframe.dll OR OriginalFileName = Mshtml.dll OR OriginalFileName = Pcwutl.dll OR OriginalFileName = Setupapi.dll OR OriginalFileName = Shdocvw.dll OR OriginalFileName = Shell32.dll OR OriginalFileName = Syssetup.dll OR OriginalFileName = Url.dll OR OriginalFileName = Zipfldr.dll OR OriginalFileName = Appvlp.exe OR OriginalFileName = Bginfo.exe OR OriginalFileName = Cdb.exe OR OriginalFileName = csi.exe OR OriginalFileName = Devtoolslauncher.exe OR OriginalFileName = dnx.exe OR OriginalFileName = Dxcap.exe OR OriginalFileName = Excel.exe OR OriginalFileName = Mftrace.exe OR OriginalFileName = Msdeploy.exe OR OriginalFileName = msxsl.exe OR OriginalFileName = Powerpnt.exe OR OriginalFileName = rcsi.exe OR OriginalFileName = Sqler.exe OR OriginalFileName = Sqlps.exe OR OriginalFileName = SQLToolsPS.exe OR OriginalFileName = Squirrel.exe OR OriginalFileName = te.exe OR OriginalFileName = Tracker.exe OR OriginalFileName = Update.exe OR OriginalFileName = vsjitdebugger.exe OR OriginalFileName = Winword.exe OR OriginalFileName = Wsl.exe OR OriginalFileName = CL_Mutexverifiers.ps1 OR OriginalFileName = CL_Invocation.ps1 OR OriginalFileName = Manage-bde.wsf OR OriginalFileName = Pubprn.vbs OR OriginalFileName = Slmgr.vbs OR OriginalFileName = Syncappvpublishingserver.vbs OR OriginalFileName = winrm.vbs OR OriginalFileName = Pester.bat)|eval CommandLine=lower(CommandLine)|eventstats count(process) as procCount by process|eventstats avg(procCount) as avg stdev(procCount) as stdev|eval lowerBound=(avg-stdev*1.5)|eval isOutlier=if((procCount < lowerBound),1,0)|where isOutlier=1|table host, Image, ParentImage, CommandLine, ParentCommandLine, procCount type: Splunk data_model: Sysmon native d3fend_mappings: - iri: d3f:ProcessSpawnAnalysis id: D3-PSA label: Process Spawn Analysis --- 
<li><a href="#">title: RDP Connection Detection submission_date: 2013/07/24 information_domain: 'Analytic, Network' subtypes: - Map building - Anomaly - Hostflow analytic_types: - Situational Awareness - TTP contributors: - MITRE id: CAR-2013-07-002 description: |- The [Remote Desktop Protocol]() (RDP), built in to Microsoft operating systems, allows a user to remotely log in to the desktop of another host. It allows for interactive access of the running windows, and forwards key presses, mouse clicks, etc. Network administrators, power users, and end-users may use RDP for day-to-day operations. From an adversary's perspective, RDP provides a means to [laterally move]() to a new host. Determining which RDP connections correspond to adversary activity can be a difficult problem in highly dynamic environments, but will be useful in identifying the scope of a compromise. Remote Desktop can be detected in several ways - Network connections to port 3389/tcp (assuming use of the default port) - Packet capture analysis - Windows security logs (Event ID 4624, 4634, 4647, 4778) - Detecting network connections from `mstsc.exe` - Execution of the process `rdpclip.exe` - Runs as the clipboard manager on the RDP target if clipboard sharing is enabled ### Output Description The time of the Connection, the source, the destination, and the user name used coverage: - technique: T1021 tactics: - TA0008 subtechniques: - T1021.001 coverage: Medium implementations: - code: |- flow_start = search Flow:Start flow_end = search Flow:End rdp_start = filter flow_start where (port == "3389") rdp_end = filter flow_start where (port == "3389") rdp = group flow_start, flow_end by src_ip, src_port, dest_ip, dest_port output rdp type: pseudocode - name: Sigma (Localhost Login) description: '[Sigma]() rule, focusing on RDP localhost login.' type: Sigma data_model_references: - flow/end/dest_port - flow/start/dest_ip - flow/start/dest_port - flow/start/src_ip d3fend_mappings: - iri: d3f:RemoteTerminalSessionDetection id: D3-RTSD label: Remote Terminal Session Detection 
<li><a href="#">title: Reg.exe called from Command Shell submission_date: 2013/03/28 information_domain: Host platforms: - Windows subtypes: - Process analytic_types: - TTP contributors: - MITRE id: CAR-2013-03-001 description: |- Registry modifications are often essential in establishing persistence via known Windows mechanisms. Many legitimate modifications are done graphically via `regedit.exe` or by using the corresponding channels, or even calling the Registry APIs directly. The built-in utility `reg.exe` provides a [command-line interface]() to the registry, so that queries and modifications can be performed from a shell, such as `cmd.exe`. When a user is responsible for these actions, the parent of `cmd.exe` will likely be `explorer.exe`. Occasionally, power users and administrators write scripts that do this behavior as well, but likely from a different process tree. These background scripts must be learned so they can be tuned out accordingly. ### Output Description The sequence of processes that resulted in `reg.exe` being started from a shell. That is, a hierarchy that looks like - `great-grand_parent.exe` - `grand_parent.exe` - `parent.exe` - `reg.exe` coverage: - technique: T1012 tactics: - TA0007 coverage: Moderate - technique: T1112 tactics: - TA0005 coverage: Moderate - technique: T1547 tactics: - TA0003 subtechniques: - T1547.001 coverage: Moderate - technique: T1574 tactics: - TA0003 - TA0004 subtechniques: - T1574.011 coverage: Moderate implementations: - description: 'To gain better context, it may be useful to also get information about the cmd process to know its parent. This may be helpful when tuning the analytic to an environment, if this behavior happens frequently. This may also help to rule out instances of users running ' code: |- processes = search Process:Create reg = filter processes where (exe == "reg.exe" and parent_exe == "cmd.exe") cmd = filter processes where (exe == "cmd.exe" and parent_exe != "explorer.exe"") reg_and_cmd = join (reg, cmd) where (reg.ppid == cmd.pid and reg.hostname == cmd.hostname) output reg_and_cmd type: pseudocode - description: DNIF version of the above pseudocode. code: |- _fetch * from event where $LogName=WINDOWS-SYSMON AND $EventID=1 AND $Process=regex(.*reg\.exe.*)i AND $ParentProcess=regex(.*cmd\.exe.*)i as #A limit 100 >>_fetch * from event where $LogName=WINDOWS-SYSMON AND $EventID=1 AND $Process=regex(.*cmd\.exe.*)i NOT $ParentProcess=regex(.*explorer\.exe.*)i as #B limit 100 >>_checkif sjoin #B.$PPID = #A.$CPID str_compare #B.$SystemName eq #A.$SystemName include type: DNIF data_model: Sysmon native data_model_references: - process/create/command_line - process/create/hostname - process/create/exe - process/create/parent_exe - process/create/pid - process/create/ppid unit_tests: - configurations: - Windows 7 description: 'Execute reg.exe from cmd.exe. Note that the analytic joins back to the grandparent process, which in this case is explorer.exe. The query time window must include the user log on. For example, if you logged in at 8am and tested the analytic at 10am, the query needs to search from 8am to 10am, not just at 10am. Within a command window, run the command.' commands: - reg.exe QUERY HKLM\Software\Microsoft d3fend_mappings: - iri: d3f:ProcessLineageAnalysis id: D3-PLA label: Process Lineage Analysis 
<li><a href="#">title: Registry Edit from Screensaver submission_date: 2020/11/30 information_domain: Host platforms: - Windows subtypes: - Process analytic_types: - TTP contributors: - Olaf Hartong id: CAR-2020-11-011 description: |- Adversaries may use screensaver files to run malicious code. This analytic triggers on suspicious edits to the screensaver registry keys, which dictate which .scr file the screensaver runs. coverage: - technique: T1546 tactics: - TA0003 - TA0004 subtechniques: - T1546.002 coverage: High implementations: - name: Pseudocode - Screensaver description: This is a pseudocode representation of the below splunk search. code: |- reg_events = search Registry:add or Registry:edit scr_reg_events = filter processes where ( key="*\\Software\\Policies\\Microsoft\\Windows\\Control Panel\\Desktop\\SCRNSAVE.EXE" AND output scr_reg_events data_model: CAR native type: Pseudocode - name: Splunk Search - Screensaver description: looks creations of edits of the SCRNSAVE.exe registry key code: |- index=your_sysmon_index (EventCode=12 OR EventCode=13 OR EventCode=14) TargetObject="*\\Software\\Policies\\Microsoft\\Windows\\Control Panel\\Desktop\\SCRNSAVE.EXE" data_model: Sysmon native type: Splunk - name: LogPoint Search - Screensaver description: looks creations of edits of the SCRNSAVE.exe registry key code: |- norm_id=WindowsSysmon event_id IN [12, 13, 14] target_object="*\Software\Policies\Microsoft\Windows\Control Panel\Desktop\SCRNSAVE.EXE" data_model: LogPoint native type: LogPoint data_model_references: - registry/edit/key - registry/add/key d3fend_mappings: - iri: d3f:UserSessionInitConfigAnalysis id: D3-USICA label: User Session Init Config Analysis --- 
<li><a href="#">title: Registry Edit with Creation of SafeDllSearchMode Key Set to 0 submission_date: 2021/11/24 information_domain: Host platforms: - Windows subtypes: - Process - Registry analytic_types: - TTP contributors: - Lucas Heiligenstein id: CAR-2021-11-001 description: Detection of creation of registry key HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\Session Manager\SafeDllSearchMode. The key SafeDllSearchMode, if set to 0, will block the Windows mechanism for the search DLL order and adversaries may execute their own malicious dll. coverage: - technique: T1574 tactics: - TA0003 - TA0004 - TA0005 subtechniques: - T1574.001 coverage: Medium - technique: T1112 tactics: - TA0005 coverage: Medium implementations: - name: Creation of SafeDllSearchMode description: This detects SafeDllSearchMode creation, either via a new process (command line) or direct registry manipulation. code: |- processes = search Process:create safe_dll_search_processes = filter processes where command_line CONTAINS("*SafeDllSearchMode*") AND ((command_line CONTAINS("*reg*") AND command_line CONTAINS("*add*") AND command_line CONTAINS("*/d*")) OR (command_line CONTAINS("*Set-ItemProperty*") AND command_line CONTAINS(*-value*)) OR ((command_line CONTAINS("*00000000*") AND command_line CONTAINS(*0*))) reg_keys = search Registry:value_edit safe_dll_reg_keys = filter reg_keys where value="SafeDllSearchMode" AND value_data="0" output safe_dll_search_processes, safe_dll_reg_keys data_model: CAR native type: Pseudocode - name: Splunk Search - Creation of SafeDllSearchMode description: This is a Splunk representation of the above pseudocode. code: |- (source="WinEventLog:*" ((((EventCode="4688" OR EventCode="1") ((CommandLine="*reg*" CommandLine="*add*" CommandLine="*/d*") OR (CommandLine="*Set-ItemProperty*" CommandLine="*-value*")) (CommandLine="*00000000*" OR CommandLine="*0*") CommandLine="*SafeDllSearchMode*") OR ((EventCode="4657") ObjectValueName="SafeDllSearchMode" value="0")) OR ((EventCode="13") EventType="SetValue" TargetObject="*SafeDllSearchMode" Details="DWORD (0x00000000)"))) data_model: Win. Eventlog/Sysmon native type: Splunk - name: Elastic Search - Creation of SafeDllSearchMode description: This is an Elastic representation of the above pseudocode. code: |- (((EventCode:("4688" OR "1") AND ((process.command_line:*reg* AND process.command_line:*add* AND process.command_line:*\/d*) OR (process.command_line:*Set\-ItemProperty* AND process.command_line:*\-value*)) AND process.command_line:(*00000000* OR *0*) AND process.command_line:*SafeDllSearchMode*) OR (EventCode:"4657" AND winlog.event_data.ObjectValueName:"SafeDllSearchMode" AND value:"0")) OR (EventCode:"13" AND winlog.event_data.EventType:"SetValue" AND winlog.event_data.TargetObject:*SafeDllSearchMode AND winlog.event_data.Details:"DWORD\ \(0x00000000\)")) data_model: Win. Eventlog/Sysmon native type: Elastic - name: LogPoint Search - Creation of SafeDllSearchMode description: This is a LogPoint representation of the above pseudocode. code: |- (((EventCode IN ["4688", "1"] ((CommandLine="*reg*" CommandLine="*add*" CommandLine="*/d*") OR (CommandLine="*Set-ItemProperty*" CommandLine="*-value*")) CommandLine IN ["*00000000*", "*0*"] CommandLine="*SafeDllSearchMode*") OR (EventCode IN "4657" ObjectValueName="SafeDllSearchMode" value="0")) OR (EventCode IN "13" EventType="SetValue" TargetObject="*SafeDllSearchMode" Details="DWORD (0x00000000)")) data_model: Win. Eventlog/Sysmon native type: LogPoint unit_tests: - description: Execute command with cmd commands: - reg add "HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\Session Manager" /v SafeDllSearchMode /d 0 - description: Execute command with powershell commands: - Set-ItemProperty -Path "HKLM:\System\CurrentControlSet\Control\Session Manager" -Name SafeDllSearchMode -Value 0 data_model_references: - process/create/command_line - registry/add/key d3fend_mappings: - iri: d3f:ProcessSpawnAnalysis id: D3-PSA label: Process Spawn Analysis 
<li><a href="#">title: Registry Edit with Modification of Userinit, Shell or Notify submission_date: 2021/11/28 information_domain: Host platforms: - Windows subtypes: - Process - Registry analytic_types: - TTP contributors: - Lucas Heiligenstein id: CAR-2021-11-002 description: |- Detection of modification of the registry key values of `Notify`, `Userinit`, and `Shell` located in `HKEY_LOCAL_MACHINE\Software\Microsoft\Windows NT\CurrentVersion\Winlogon\` and `HKEY_LOCAL_USER\Software\Microsoft\Windows NT\CurrentVersion\Winlogon\`. When a user logs on, the Registry key values of `Notify`, `Userinit` and `Shell` are used to load dedicated Windows component. Attackers may insert malicious payload following the legitimate value to launch a malicious payload. coverage: - technique: T1547 tactics: - TA0003 - TA0004 subtechniques: - T1547.004 coverage: Medium - technique: T1112 tactics: - TA0005 coverage: Medium implementations: - name: Userinit/Shell/Notify Registry Modifications description: This detects logon registry key modification, either via a new process (command line) or direct registry manipulation. code: |- processes = search Process:create logon_reg_processes = filter processes where command_line CONTAINS("*\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon*") AND (command_line CONTAINS("*Userinit*") OR command_line CONTAINS("*Shell*") OR command_line CONTAINS("*Notify*")) AND (((command_line CONTAINS("*reg*") OR command_line CONTAINS("*add*") OR command_line CONTAINS("*/d*")) OR (command_line CONTAINS("*Set-ItemProperty*") OR command_line CONTAINS("*New-ItemProperty*") OR command_line CONTAINS("*-value*")))) reg_keys = search Registry:value_edit logon_reg_keys = filter reg_keys where (value="Userinit" OR value="Shell" OR value="Notify") output logon_reg_processes, logon_reg_keys data_model: CAR native type: Pseudocode - name: Splunk Search - Modification of Userinit, Shell or Notify description: This is a Splunk representation of the above pseudocode. code: |- (((((EventCode="4688" OR EventCode="1") ((CommandLine="*reg*" CommandLine="*add*" CommandLine="*/d*") OR ((CommandLine="*Set-ItemProperty*" OR CommandLine="*New-ItemProperty*") CommandLine="*-value*")) CommandLine="*\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon*" (CommandLine="*Userinit*" OR CommandLine="*Shell*" OR CommandLine="*Notify*")) OR ((EventCode="4657") (ObjectValueName="Userinit" OR ObjectValueName="Shell" OR ObjectValueName="Notify"))) OR ((EventCode="13") (TargetObject="*Userinit" OR TargetObject="*Shell" OR TargetObject="*Notify")))) type: Splunk - name: Elastic Search - Modification of Userinit, Shell or Notify description: This is an ElasticSearch representation of the above pseudocode. code: |- (((EventCode:("4688" OR "1") AND ((process.command_line:*reg* AND process.command_line:*add* AND process.command_line:*\/d*) OR (process.command_line:(*Set\-ItemProperty* OR *New\-ItemProperty*) AND process.command_line:*\-value*)) AND process.command_line:*\\Microsoft\\Windows\ NT\\CurrentVersion\\Winlogon* AND process.command_line:(*Userinit* OR *Shell* OR *Notify*)) OR (EventCode:"4657" AND winlog.event_data.ObjectValueName:("Userinit" OR "Shell" OR "Notify"))) OR (EventCode:"13" AND winlog.event_data.TargetObject:(*Userinit OR *Shell OR *Notify))) type: Elastic - name: LogPoint Search - Modification of Userinit, Shell or Notify description: This is a LogPoint representation of the above pseudocode. code: |- (((EventCode IN ["4688", "1"] ((CommandLine="*reg*" CommandLine="*add*" CommandLine="*/d*") OR (CommandLine IN ["*Set-ItemProperty*", "*New-ItemProperty*"] CommandLine="*-value*")) CommandLine="*\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon*" CommandLine IN ["*Userinit*", "*Shell*", "*Notify*"]) OR (EventCode IN "4657" ObjectValueName IN ["Userinit", "Shell", "Notify"])) OR (EventCode IN "13" TargetObject IN ["*Userinit", "*Shell", "*Notify"])) type: LogPoint unit_tests: - description: Modification on Registry Key with cmd. Calc.exe will be launched when user will login commands: - reg add "HKEY_CURRENT_USER\Software\Microsoft\Windows NT\CurrentVersion\Winlogon" /v Userinit /d C:\Windows\system32\userinit.exe,C:\Windows\system32\calc.exe - description: Modification on Registry Key with Powershell. Calc.exe will be launched when user will login commands: - Set-ItemProperty -Path "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon" -Name Userinit -Value C:\Windows\system32\userinit.exe,C:\Windows\system32\calc.exe data_model_references: - process/create/command_line - registry/add/key d3fend_mappings: - iri: d3f:ProcessSpawnAnalysis id: D3-PSA label: Process Spawn Analysis 
<li><a href="#">title: Remote Desktop Logon submission_date: 2016/04/19 information_domain: Host platforms: - Windows subtypes: - Login analytic_types: - Situational Awareness contributors: - MITRE/NSA id: CAR-2016-04-005 description: 'A remote desktop logon, through [RDP](), may be typical of a system administrator or IT support, but only from select workstations. Monitoring remote desktop logons and comparing to known/approved originating systems can detect lateral movement of an adversary.' coverage: - technique: T1021 tactics: - TA0008 subtechniques: - T1021.001 coverage: Moderate implementations: - description: 'Look in the system logs for remote logons using RDP.' code: |- [EventCode] == 4624 and [AuthenticationPackageName] == 'Negotiate' and [Severity] == "Information" and [LogonType] == 10 type: pseudocode - description: '[Sigma version]() of the above pseudocode, with some modifications.' type: Sigma - description: LogPoint version of the above pseudocode. code: |- norm_id=WinServer event_id=4624 package="Negotiate" log_level="INFO" logon_type=10 type: LogPoint data_mode: LogPoint native d3fend_mappings: - iri: d3f:RemoteTerminalSessionDetection id: D3-RTSD label: Remote Terminal Session Detection --- 
<li><a href="#">title: Remote PowerShell Sessions submission_date: 2014/11/19 information_domain: 'Host, Network' platforms: - Windows subtypes: - Process analytic_types: - TTP contributors: - MITRE id: CAR-2014-11-004 description: |- According to [ATT&CK](), [PowerShell]() can be used over WinRM to remotely run commands on a host. When a remote PowerShell session starts, svchost.exe executes wsmprovhost.exe For this to work, certain registry keys must be set, and the WinRM service must be enabled. The PowerShell command `Enter-PSSession -ComputerName \<RemoteHost\>` creates a remote PowerShell session. coverage: - technique: T1059 tactics: - TA0002 subtechniques: - T1059.001 coverage: Moderate - technique: T1021 tactics: - TA0008 subtechniques: - T1021.006 coverage: Moderate implementations: - code: |- process = search Process:Create wsmprovhost = filter process where (exe == "wsmprovhost.exe" and parent_exe == "svchost.exe") type: pseudocode - description: EQL version of the above pseudocode. code: |- process where subtype.create and (process_name == "wsmprovhost.exe" and parent_process_name == "svchost.exe") type: EQL data_model: EQL native - description: LogPoint version of the above pseudocode. code: |- norm_id=WindowsSysmon event_id=1 image="*\wsmprovhost.exe" parent_image="*\svchost.exe" type: LogPoint data_model: LogPoint native data_model_references: - process/create/exe - process/create/parent_exe d3fend_mappings: - iri: d3f:ProcessLineageAnalysis id: D3-PLA label: Process Lineage Analysis 
<li><a href="#">title: Remote Registry submission_date: 2014/11/19 information_domain: 'Host, Network' platforms: - Windows subtypes: - Network Registry File - PCAP analytic_types: - TTP contributors: - MITRE id: CAR-2014-11-005 description: |- An adversary can remotely [manipulate the registry]() of another machine if the RemoteRegistry service is enabled and valid credentials are obtained. While the registry is remotely accessed, it can be used to prepare a [Lateral Movement]() technique, [discover]() the configuration of a host, achieve [Persistence](), or anything that aids an adversary in achieving the mission. Like most ATT&CK techniques, this behavior can be used legitimately, and the reliability of an analytic depends on the proper identification of the pre-existing legitimate behaviors. Although this behavior is disabled in many Windows configurations, it is possible to [remotely enable]() the RemoteRegistry service, which can be detected with [CAR-2014-03-005](../CAR-2014-03-005). Remote access to the registry can be achieved via - Windows API function [RegConnectRegistry]() - command line via `reg.exe` - graphically via `regedit.exe` All of these behaviors call into the Windows API, which uses the NamedPipe `WINREG` over SMB to handle the protocol information. This network can be decoded with wireshark or a similar sensor, and can also be detected by hooking the API function. coverage: - technique: T1112 tactics: - TA0005 coverage: Moderate implementations: - code: |- flows = search Flow:Message winreg = filter flows where (dest_port == 445 and proto_info.pipe == "WINREG") winreg_modify = filter flows where (proto_info.function == "Create*" or proto_info.function == "SetValue*") output winreg_modify type: pseudocode data_model_references: - flow/message/dest_port - flow/message/proto_info d3fend_mappings: - iri: d3f:IPCTrafficAnalysis id: D3-IPCTA label: IPC Traffic Analysis 
<li><a href="#">title: Remote Windows Management Instrumentation (WMI) over RPC submission_date: 2014/11/19 information_domain: 'Host, Network' platforms: - Windows subtypes: - API RPC - PCAP - Hostflow analytic_types: - TTP contributors: - MITRE id: CAR-2014-11-007 description: |- As described in ATT&CK, an adversary can use [Windows Management Instrumentation]() (WMI) to view or manipulate objects on a remote host. It can be used to remotely edit configuration, start services, query files, and anything that can be done with a WMI class. When remote WMI requests are over RPC ([CAR-2014-05-001](../CAR-2014-05-001)), it connects to a DCOM interface within the RPC group netsvcs. To detect this activity, a sensor is needed at the network level that can decode RPC traffic or on the host where the communication can be detected more natively, such as [Event Tracing for Windows](). Using wireshark/tshark decoders, the WMI interfaces can be extracted so that WMI activity over RPC can be detected. Although the description details how to detect remote WMI precisely, a decent estimate has been to look for the string RPCSS within the initial RPC connection on 135/tcp. It returns a superset of this activity, and will trigger on all DCOM-related services running within RPC, which is likely to also be activity that should be detected between hosts. More about RPCSS at : [rpcss_dcom_interfaces.html]() ### Output Description Identifies the connection in which WMI traffic is seen, as well as the process(es) responsible for owning the connection. coverage: - technique: T1047 tactics: - TA0002 coverage: Moderate implementations: - description: 'To detect WMI over RPC (using DCOM), a sensor needs to exist that has the insight into individual connections and can actually decode and make sense of RPC traffic. Specifically, WMI can be detected by looking at RPC traffic where the target interface matches that of WMI, which is IRemUnknown2. ' code: |- flows = search Flow:Message wmi_flow = filter flows where (dest_port == 135 and proto_info.rpc_interface == "IRemUnknown2") output wmi_flow type: pseudocode data_model_references: - flow/message/proto_info d3fend_mappings: - iri: d3f:RPCTrafficAnalysis id: D3-RTA label: RPC Traffic Analysis 
<li><a href="#">title: Remotely Launched Executables via Services submission_date: 2014/03/18 information_domain: 'Host, Network' platforms: - Windows subtypes: - Network Process - Hostflow analytic_types: - TTP contributors: - MITRE id: CAR-2014-03-005 description: |- There are several ways to cause code to [execute]() on a remote host. One of the most common methods is via the Windows [Service Control Manager]() (SCM), which allows authorized users to remotely create and modify services. Several tools, such as [PsExec](), use this functionality. When a client remotely communicates with the Service Control Manager, there are two observable behaviors. First, the client connects to the [RPC Endpoint Mapper](../CAR-2014-05-001) over 135/tcp. This handles authentication, and tells the client what port the endpointâ€”in this case the SCMâ€”is listening on. Then, the client connects directly to the listening port on `services.exe`. If the request is to start an existing service with a known command line, the the SCM process will run the corresponding command. This compound behavior can be detected by looking for `services.exe` receiving a network connection and immediately spawning a child process. coverage: - technique: T1543 tactics: - TA0003 subtechniques: - T1543.003 coverage: Moderate - technique: T1569 tactics: - TA0002 subtechniques: - T1569.002 coverage: Moderate implementations: - description: 'Look for processes launched from `services.exe` within 1 second of services.exe receiving a network connection.' code: |- process = search Process:Create flow = search Flow:Start service = filter process where (parent_exe == "services.exe") remote_start = join (flow, service ) where ( flow.hostname == service.hostname and flow.pid == service.pid and (flow.time < service.time < flow.time + 1 second) ) output remote_start type: pseudocode data_model_references: - flow/start/pid - process/create/parent_exe - process/create/pid d3fend_mappings: - iri: d3f:RPCTrafficAnalysis id: D3-RTA label: RPC Traffic Analysis 
<li><a href="#">title: Remotely Launched Executables via WMI submission_date: 2014/12/02 information_domain: 'Host, Network' platforms: - Windows subtypes: - PCAP analytic_types: - TTP contributors: - MITRE id: CAR-2014-12-001 description: |- Adversaries can use [Windows Management Instrumentation (WMI)]() to move laterally by launching executables remotely. For adversaries to achieve this, they must open a WMI connection to a remote host. This RPC activity is currently detected by [CAR-2014-11-007](../CAR-2014-11-007). After the WMI connection has been initialized, a process can be remotely launched using the command: `wmic /node:"<hostname>" process call create "<command line>"`, which is detected via [CAR-2016-03-002](../CAR-2016-03-002). This leaves artifacts at both a network (RPC) and process (command line) level. When wmic.exe (or the schtasks API) is used to remotely create processes, Windows uses RPC (135/tcp) to communicate with the the remote machine. After RPC authenticates, the RPC endpoint mapper opens a high port connection, through which the schtasks Remote Procedure Call is actually implemented. With the right packet decoders, or by looking for certain byte streams in raw data, these functions can be identified. When the command line is executed, it has the parent process of `C:\windows\system32\wbem\WmiPrvSE.exe`. This analytic looks for these two events happening in sequence, so that the network connection and target process are output. Certain strings can be identifiers of the WMI by looking up the interface UUID for IRemUnknown2 in different formats - UUID `00000143-0000-0000-c000-000000000046` (decoded) - Hex `43 01 00 00 00 00 00 00 c0 00 00 00 00 00 00 46` (raw) - ASCII `CF` (printable text only) This identifier is present three times during the RPC request phase. Any sensor that has access to the byte code as raw, decoded, or ASCII could implement this analytic. The transfer syntax is - UUID `8a885d04-1ceb-11c9-9fe8-08002b104860` (decoded) - Hex `04 5d 88 8a eb 1c c9 11 9f e8 08 00 2b 10 48 60` (raw) - ASCII \`]+H\`\` (printable text only) Thus, a great ASCII based signature is - `*CF*]+H*CF*CF*host*"` ### Output Description Identifies the process that initiated the RPC request (such as wmic.exe or powershell.exe), as well as the source and destination information of the network connection that triggered the alert. coverage: - technique: T1047 tactics: - TA0002 coverage: High implementations: - description: 'Look for instances of the WMI querying in network traffic, and find the cases where a process is launched immediately after a connection is seen. This essentially merges the request to start a remote process via WMI with the process execution. If other processes are spawned from `wmiprvse.exe` in this time frame, it is possible for race conditions to occur, and the wrong process may be merged. If this is the case, it may be useful to look deeper into the network traffic to see if the desired command can be extracted.' code: |- processes = search Process:Create wmi_children = filter processes where (parent_exe == "wmiprvse.exe") flows = search Flow:Message wmi_flow = filter flows where (src_port >= 49152 and dest_port >= 49152 and proto_info.rpc_interface == "IRemUnknown2") remote_wmi_process = join wmi_children, wmi_flow where ( wmi_flow.time < wmi_children.time < wmi_flow.time + 1sec and wmi_flow.hostname == wmi_children.hostname ) output remote_wmi_process type: pseudocode data_model_references: - flow/message/dest_port - flow/message/proto_info - flow/message/src_port - process/create/command_line - process/create/exe - process/create/parent_exe d3fend_mappings: - iri: d3f:ProcessLineageAnalysis id: D3-PLA label: Process Lineage Analysis 
<li><a href="#">title: Remotely Scheduled Tasks via AT submission_date: 2015/04/29 information_domain: 'Host, Network' platforms: - Windows subtypes: - File API - PCAP analytic_types: - TTP contributors: - MITRE id: CAR-2015-04-001 description: |- When AT.exe is used to remotely [schedule tasks](), Windows uses named pipes over [SMB]() to communicate with the API on the remote machine. After authentication over SMB, the Named Pipe "ATSVC" is opened, over which the JobAdd function is called. On the remote host, the job files are created by the Task Scheduler and follow the convention `C:\Windows\System32\AT<job\_id>`. Unlike [CAR-2013-05-004](../CAR-2013-05-004), this analytic specifically focuses on uses of AT that can be detected between hosts, indicating remotely gained [execution](). This pipe activity could be discovered with a network decoder, such as that in wireshark, that can inspect SMB traffic to identify the use of pipes. It could also be detected by looking for raw packet capture streams or from a custom sensor on the host that hooks the appropriate API functions. If no network or API level of visibility is possible, this traffic may inferred by looking at SMB connections over 445/tcp followed by the creation of files matching the pattern `C:\Windows\System32\AT\<job_id\>`. coverage: - technique: T1053 tactics: - TA0002 subtechniques: - T1053.002 coverage: Moderate implementations: - description: 'To detect AT via network traffic, a sensor is needed that has the ability to extract and decode PCAP information. Specifically, it needs to properly decode SMB and the functions that are implemented over it via NamedPipes. If a sensor meets these criteria, then the PCAP data needs to search for instances of the command `JobAdd` over the pipe `ATSVC`, which is all implemented over Windows SMB 445/tcp.' code: |- flows = search Flow:Message at_proto = filter flows where (dest_port == 445 and proto_info.pipe == "ATSVC") at_create = filter flows where (proto_info.function == "JobAdd") output at_create type: pseudocode data_model_references: - flow/message/proto_info d3fend_mappings: - iri: d3f:IPCTrafficAnalysis id: D3-IPCTA label: IPC Traffic Analysis 
<li><a href="#">title: Remotely Scheduled Tasks via Schtasks submission_date: 2015/04/29 information_domain: 'Host, Network' platforms: - Windows subtypes: - Network API RPC - PCAP analytic_types: - TTP contributors: - MITRE id: CAR-2015-04-002 description: |- An adversary can [move laterally]() using the `schtasks` command to remotely [schedule tasks/jobs](). Although these events can be detected with command line analytics [CAR-2013-08-001](../CAR-2013-08-001), it is possible for an adversary to use the API directly, via the Task Scheduler GUI or with a scripting language such as [PowerShell](). In this cases, an additional source of data becomes necessary to detect adversarial behavior. When scheduled tasks are created remotely, Windows uses RPC (135/tcp) to communicate with the Task Scheduler on the remote machine. Once an RPC connection is established ([CAR-2014-05-001](../CAR-2014-05-001)), the client communicates with the Scheduled Tasks endpoint, which runs within the service group netsvcs. With packet capture and the right packet decoders or byte-stream based signatures, remote invocations of these functions can be identified. Certain strings can be identifiers of the schtasks, by looking up the interface UUID of ITaskSchedulerService in different formats - UUID `86d35949-83c9-4044-b424-db363231fd0c` (decoded) - Hex `49 59 d3 86 c9 83 44 40 b4 24 db 36 32 31 fd 0c` (raw) - ASCII `IYD@$621` (printable bytes only) This identifier is present three times during the RPC request phase. Any sensor that has access to the byte code as raw, decoded, or ASCII could implement this analytic. coverage: - technique: T1053 tactics: - TA0002 subtechniques: - T1053.005 coverage: Moderate implementations: - description: 'Look for RPC traffic after being mapped, which implies a destination port of at least 49152. If network inspection is available via packet captures or a NIDS, then traffic through the `ITaskSchedulerService` interface can be detected. Microsoft has a list of the possible methods that are implemented for the `ITaskSchedulerService` interface, which may be useful in differentiating read and query operations from creations and modifications.' code: |- flows = search Flow:Message schtasks_rpc = filter flows where ( src_port >= 49152 and dest_port >= 49152 and proto_info.rpc_interface == "ITaskSchedulerService" ) output schtasks_rpc type: pseudocode data_model_references: - flow/message/dest_port - flow/message/src_port - flow/message/proto_info d3fend_mappings: - iri: d3f:RPCTrafficAnalysis id: D3-RTA label: RPC Traffic Analysis 
<li><a href="#">title: RPC Activity submission_date: 2014/05/01 information_domain: Network platforms: - Windows subtypes: - Netflow analytic_types: - TTP - Situational Awareness contributors: - MITRE id: CAR-2014-05-001 description: |- Microsoft Windows uses its implementation of [Distributed Computing Environment/Remote Procedure Call]() (DCE/RPC), which it calls [Microsoft RPC](), to call certain APIs remotely. A Remote Procedure Call is initiated by communicating to the RPC Endpoint Mapper, which exists as the Windows service RpcEptMapper and listens on the port 135/tcp. The endpoint mapper resolves a requested endpoint/interface and responds to the client with the port that the service is listening on. Since the RPC endpoints are assigned ports when the services start, these ports are dynamically assigned from 49152 to 65535. The connection to the endpoint mapper then terminates and the client program can communicate directly with the requested service. RPC is a legitimate functionality of Windows that allows remote interaction with a variety of services. For a Windows environment to be properly configured, several programs use RPC to communicate legitimately with servers. The background and benign RPC activity may be enormous, but must be learned, especially peer-to-peer RPC between workstations, which is often indicative of [Lateral Movement](). According to ATT&CK, adversaries frequently use RPC connections to remotely - [Create/modify]() and [execute]() services ([CAR-2014-03-005](CAR-2014-03-005)) - [Schedule Tasks]() ([CAR-2015-04-002](../CAR-2015-04-002)) - Query ([CAR-2014-11-007](../CAR-2014-11-007)) and Invoke ([CAR-2014-12-001](../CAR-2014-12-001)) - [Windows Management Instrumentation (WMI)]() Additional endpoints are detailed at [here](). coverage: - technique: T1021 tactics: - TA0008 subtechniques: - T1021.002 - T1021.003 - T1021.006 coverage: Moderate implementations: - description: 'Traffic to the RPC Endpoint Mapper will always have the destination port of 135. Assuming success, RPC traffic will continue to the endpoint. The endpoint and the client both bind to dynamically assigned ports (on Windows, this is typically greater than 49152). The traffic between the client and endpoint can be detected by looking at traffic to 135 followed by traffic where the source and destination ports are at least 49152. ' code: |- flows = search Flow:Start rpc_mapper = filter flows where (dest_port == 135) rpc_endpoint = filter flows where (dest_port >= 49152 and src_port >= 49152) rpc = join rpc_mapper, rpc_endpoint where ( (rpc_mapper.time < rpc_endpoint.time < rpc_mapper.time + 2 seconds) and (rpc_mapper.src_ip == rpc_endpoint.src_ip and rpc_mapper.dest_ip == rpc_endpoint.dest_ip) ) output rpc type: pseudocode data_model_references: - flow/start/dest_port - flow/start/src_port d3fend_mappings: - iri: d3f:RPCTrafficAnalysis id: D3-RTA label: RPC Traffic Analysis 
<li><a href="#">title: RunDLL32.exe monitoring submission_date: 2014/03/28 information_domain: Host platforms: - Windows subtypes: - Process analytic_types: - TTP contributors: - MITRE id: CAR-2014-03-006 description: 'Adversaries may find it necessary to use [Dyanamic-link Libraries]() (DLLs) to [evade defenses](). One way these DLLs can be "executed" is through the use of the built-in Windows utility [RunDLL32](), which allows a user to execute code in a DLL, providing the name and optional arguments to an exported entry point. Windows uses RunDll32 legitimately in its normal operation, but with a proper baseline and understanding of the environment, monitoring its usage could be fruitful.' coverage: - technique: T1218 tactics: - TA0005 subtechniques: - T1218.011 coverage: Moderate implementations: - description: 'When looking for all instances of RunDLL32, it is imperative to also have the `command_line` information, which contains the DLL information, including the name, entry point, and optional arguments.' code: |- process = search Process:Create rundll32 = filter process where (exe == "rundll32.exe") output rundll32 type: pseudocode - description: DNIF version of the above pseudocode. code: |- _fetch * from event where $LogName=WINDOWS-SYSMON AND $EventID=1 AND $App=rundll32.exe limit 100 type: DNIF data_model: Sysmon native - description: LogPoint version of the above pseudocode. code: |- norm_id=WindowsSysmon event_id=1 image="*\rundll32.exe" type: LogPoint data_model: LogPoint native data_model_references: - process/create/exe - process/create/command_line unit_tests: - configurations: - Windows 7 description: Execute rundll32.exe from a command window commands: - 'c:\windows\syswow64\rundll32.exe' - 'RUNDLL32.EXE SHELL32.DLL,Control_RunDLL desk.cpl,,0' d3fend_mappings: - iri: d3f:ProcessSpawnAnalysis id: D3-PSA label: Process Spawn Analysis 
<li><a href="#">title: Running executables with same hash and different names submission_date: 2013/05/23 information_domain: Host platforms: - Windows - Linux - macOS subtypes: - Process analytic_types: - TTP contributors: - MITRE id: CAR-2013-05-009 description: |- Executables are generally not renamed, thus a given hash of an executable should only have ever one name. Identifying instances where multiple process names share the same hash may find cases where tools are copied by attackers to different folders or hosts to [avoid detection](). Although this analytic was initially based on MD5 hashes, it is equally applicable to any hashing convention. ### Output Description A list of hashes and the different executables associated with each one coverage: - technique: T1036 tactics: - TA0005 subtechniques: - T1036.003 coverage: Moderate implementations: - name: Basic Query description: This is a basic Splunk search that will output all of the sysmon-reported process images and their respective hashes, for cases where an image has more than one set of hashes. Thus, this will output a large amount of data and should be filtered by the analyst in order to make the results more useful. code: |- index=__your_sysmon_index__ EventCode=1|stats dc(Hashes) as Num_Hashes values(Hashes) as "Hashes" by Image|where Num_Hashes > 1 type: splunk data_model: Sysmon native - name: Sigma/Sysmon description: '[Sigma includes]() a Sysmon-specific rule for detecting this, using the OriginalFilename field.' type: Sigma - name: Sigma (renamed powershell) description: '[Sigma includes]() a rule specifically for detecting instances of Powershell being renamed.' type: Sigma - name: Sigma (renamed paexec) description: '[Sigma includes]() a rule specifically for detecting instances of paexec being renamed.' type: Sigma - description: DNIF version of the above pseudocode. code: |- _fetch * from event where $LogName=WINDOWS-SYSMON AND $EventID=1 group count_unique $App, $HashMD5 limit 100 >>_agg count_unique $HashMD5 >>_checkif int_compare count_unique > 1 include type: DNIF data_model: Sysmon native - description: LogPoint version of the above pseudocode. code: |- norm_id=WindowsSysmon event_id=1 | chart distinct_count(hash) as cnt by image | search cnt > 1 type: LogPoint data_model: LogPoint native data_model_references: - process/create/exe - process/create/md5_hash d3fend_mappings: - iri: d3f:ServiceBinaryVerification id: D3-SBV label: Service Binary Verification - iri: d3f:SystemFileAnalysis id: D3-SFA label: System File Analysis 
<li><a href="#">title: Scheduled Task - FileAccess submission_date: 2020/09/10 information_domain: 'Host' platforms: - Windows subtypes: - File analytic_types: - Situational Awareness contributors: - Olaf Hartong id: CAR-2020-09-001 description: |- In order to gain persistence, privilege escalation, or remote execution, an adversary may use the Windows Task Scheduler to schedule a command to be run at a specified time, date, and even host. Task Scheduler stores tasks as files in two locations - C:\Windows\Tasks (legacy) or C:\Windows\System32\Tasks. Accordingly, this analytic looks for the creation of task files in these two locations. coverage: - technique: T1053 subtechniques: - T1053.005 tactics: - TA0002 - TA0003 - TA0004 coverage: Low implementations: - name: Pseudocode - Windows task file creation description: This is a pseudocode representation of the below splunk search. code: |- files = search File:Create task_files = filter files where ( (file_path = "C:\Windows\System32\Tasks\*" or file_path = "C:\Windows\Tasks\*") and image_path != "C:\WINDOWS\system32\svchost.exe") output task_files data_model: CAR native type: Pseudocode - name: Splunk search - Windows task file creation description: This Splunk search looks for any files created under the Windows tasks directories. code: |- index=__your_sysmon_index__ EventCode=11 Image!="C:\\WINDOWS\\system32\\svchost.exe" (TargetFilename="C:\\Windows\\System32\\Tasks\\ *" OR TargetFilename="C:\\Windows\\Tasks\\*") data_model: Sysmon native type: Splunk - name: LogPoint search - Windows task file creation description: This LogPoint search looks for any files created under the Windows tasks directories. code: |- norm_id=WindowsSysmon event_id=11 -source_image="C:\WINDOWS\system32\svchost.exe" (path="C:\Windows\System32\Tasks*" OR path="C:\Windows\Tasks*") data_model: LogPoint native type: LogPoint data_model_references: - file/create/file_path - file/create/image_path d3fend_mappings: - iri: d3f:FileCreationAnalysis id: D3-FCA label: File Creation Analysis --- 
<li><a href="#">title: Scheduled Task Creation or Modification Containing Suspicious Scripts, Extensions or User Writable Paths submission_date: 2021/12/04 information_domain: Host platforms: - Windows subtypes: - Process analytic_types: - TTP contributors: - Lucas Heiligenstein id: CAR-2021-12-001 description: Detection of the creation or modification of Scheduled Tasks with a suspicious script, extension or user writable path. Attackers may create or modify Scheduled Tasks for the persistent execution of malicious code. This detection focuses at the same time on EventIDs 4688 and 1 with process creation (SCHTASKS) and EventID 4698, 4702 for Scheduled Task creation/modification event log. coverage: - technique: T1053 tactics: - TA0002 - TA0003 - TA0004 subtechniques: - T1053.005 coverage: Medium implementations: - name: Creation of Suspicious Scheduled Tasks description: This detects the creation of suspicious scheduled tasks, either via a new process (command line) or direct through the corresponding Windows EIDs. code: |- processes = search Process:create susp_tasks_processes = filter processes where command_line CONTAINS("*SCHTASKS*") AND (command_line CONTAINS("*/CREATE*") OR command_line CONTAINS("*/CHANGE*")) AND (command_line CONTAINS("*.cmd*") OR command_line CONTAINS("*.ps1*") OR command_line CONTAINS("*.vbs*") OR command_line CONTAINS("*.py*") OR command_line CONTAINS("*.js*") OR command_line CONTAINS("*.exe*") OR command_line CONTAINS("*.bat*") OR (command_line CONTAINS("*javascript*") OR command_line CONTAINS("*powershell*") OR command_line CONTAINS("*wmic*") OR command_line CONTAINS("*rundll32*") OR command_line CONTAINS("*cmd*") OR command_line CONTAINS("*cscript*") OR command_line CONTAINS("*wscript*") OR command_line CONTAINS("*regsvr32*") OR command_line CONTAINS("*mshta*") OR command_line CONTAINS("*bitsadmin*") OR command_line CONTAINS("*certutil*") OR command_line CONTAINS("*msiexec*") OR command_line CONTAINS("*javaw*") OR (command_line CONTAINS("*%APPDATA%*") OR command_line CONTAINS("*\\AppData\\Roaming*") OR command_line CONTAINS("*%PUBLIC%*") OR command_line CONTAINS("*C:\\Users\\Public*") OR command_line CONTAINS("*%ProgramData%*") OR command_line CONTAINS("*C:\\ProgramData*") OR command_line CONTAINS("*%TEMP%*") OR command_line CONTAINS("*\\AppData\\Local\\Temp*") OR command_line CONTAINS("*\\Windows\\PLA\\System*") OR command_line CONTAINS("*\\tasks*") OR command_line CONTAINS("*\\Registration\\CRMLog*") OR command_line CONTAINS("*\\FxsTmp*") OR command_line CONTAINS("*\\spool\\drivers\\color*") OR command_line CONTAINS("*\\tracing*")))) tasks = search Task:create susp_tasks = filter tasks where (task_content CONTAINS("*.cmd*") OR task_content CONTAINS("*.ps1*") OR task_content CONTAINS("*.vbs*") OR task_content CONTAINS("*.py*") OR task_content CONTAINS("*.js*") OR task_content CONTAINS("*.exe*") OR task_content CONTAINS("*.bat*") OR (task_content CONTAINS("*javascript*") OR task_content CONTAINS("*powershell*") OR task_content CONTAINS("*wmic*") OR task_content CONTAINS("*rundll32*") OR task_content CONTAINS("*cmd*") OR task_content CONTAINS("*cscript*") OR task_content CONTAINS("*wscript*") OR task_content CONTAINS("*regsvr32*") OR task_content CONTAINS("*mshta*") OR task_content CONTAINS("*bitsadmin*") OR task_content CONTAINS("*certutil*") OR task_content CONTAINS("*msiexec*") OR task_content CONTAINS("*javaw*") OR (task_content CONTAINS("*%APPDATA%*") OR task_content CONTAINS("*\\AppData\\Roaming*") OR task_content CONTAINS("*%PUBLIC%*") OR task_content CONTAINS("*C:\\Users\\Public*") OR task_content CONTAINS("*%ProgramData%*") OR task_content CONTAINS("*C:\\ProgramData*") OR task_content CONTAINS("*%TEMP%*") OR task_content CONTAINS("*\\AppData\\Local\\Temp*") OR task_content CONTAINS("*\\Windows\\PLA\\System*") OR task_content CONTAINS("*\\tasks*") OR task_content CONTAINS("*\\Registration\\CRMLog*") OR task_content CONTAINS("*\\FxsTmp*") OR task_content CONTAINS("*\\spool\\drivers\\color*") OR task_content CONTAINS("*\\tracing*")))) output susp_tasks_processes, susp_tasks data_model: CAR native type: Pseudocode - name: Splunk Search - Scheduled Task creation or modification containing suspicious script, extension or user writable path. description: This is a Splunk representation of the above pseudocode search. code: |- (((EventCode="4688" OR EventCode="1") CommandLine="*SCHTASKS*" (CommandLine="*/CREATE*" OR CommandLine="*/CHANGE*")) ((CommandLine="*.cmd*" OR CommandLine="*.ps1*" OR CommandLine="*.vbs*" OR CommandLine="*.py*" OR CommandLine="*.js*" OR CommandLine="*.exe*" OR CommandLine="*.bat*") OR (CommandLine="*javascript*" OR CommandLine="*powershell*" OR CommandLine="*wmic*" OR CommandLine="*rundll32*" OR CommandLine="*cmd*" OR CommandLine="*cscript*" OR CommandLine="*wscript*" OR CommandLine="*regsvr32*" OR CommandLine="*mshta*" OR CommandLine="*bitsadmin*" OR CommandLine="*certutil*" OR CommandLine="*msiexec*" OR CommandLine="*javaw*") OR (CommandLine="*%APPDATA%*" OR CommandLine="*\\AppData\\Roaming*" OR CommandLine="*%PUBLIC%*" OR CommandLine="*C:\\Users\\Public*" OR CommandLine="*%ProgramData%*" OR CommandLine="*C:\\ProgramData*" OR CommandLine="*%TEMP%*" OR CommandLine="*\\AppData\\Local\\Temp*" OR CommandLine="*\\Windows\\PLA\\System*" OR CommandLine="*\\tasks*" OR CommandLine="*\\Registration\\CRMLog*" OR CommandLine="*\\FxsTmp*" OR CommandLine="*\\spool\\drivers\\color*" OR CommandLine="*\\tracing*"))) OR ((EventCode="4698" OR EventCode="4702") ((TaskContent="*.cmd*" OR TaskContent="*.ps1*" OR TaskContent="*.vbs*" OR TaskContent="*.py*" OR TaskContent="*.js*" OR TaskContent="*.exe*" OR TaskContent="*.bat*") OR (TaskContent="*javascript*" OR TaskContent="*powershell*" OR TaskContent="*wmic*" OR TaskContent="*rundll32*" OR TaskContent="*cmd*" OR TaskContent="*cscript*" OR TaskContent="*wscript*" OR TaskContent="*regsvr32*" OR TaskContent="*mshta*" OR TaskContent="*bitsadmin*" OR TaskContent="*certutil*" OR TaskContent="*msiexec*" OR TaskContent="*javaw*") OR (TaskContent="*%APPDATA%*" OR TaskContent="*\\AppData\\Roaming*" OR TaskContent="*%PUBLIC%*" OR TaskContent="*C:\\Users\\Public*" OR TaskContent="*%ProgramData%*" OR TaskContent="*C:\\ProgramData*" OR TaskContent="*%TEMP%*" OR TaskContent="*\\AppData\\Local\\Temp*" OR TaskContent="*\\Windows\\PLA\\System*" OR TaskContent="*\\tasks*" OR TaskContent="*\\Registration\\CRMLog*" OR TaskContent="*\\FxsTmp*" OR TaskContent="*\\spool\\drivers\\color*" OR TaskContent="*\\tracing*"))) type: Splunk - name: Elastic Search - Scheduled Task creation or modification containing suspicious script, extension or user writable path. description: This is an ElasticSearch representation of the above pseudocode search. code: |- ((winlog.event_id:("4688" OR "1") AND process.command_line:*SCHTASKS* AND process.command_line:(*\/CREATE* OR *\/CHANGE*)) AND (process.command_line:(*.cmd* OR *.ps1* OR *.vbs* OR *.py* OR *.js* OR *.exe* OR *.bat*) OR process.command_line:(*javascript* OR *powershell* OR *wmic* OR *rundll32* OR *cmd* OR *cscript* OR *wscript* OR *regsvr32* OR *mshta* OR *bitsadmin* OR *certutil* OR *msiexec* OR *javaw*) OR process.command_line:(*%APPDATA%* OR *\\AppData\\Roaming* OR *%PUBLIC%* OR *C\:\\Users\\Public* OR *%ProgramData%* OR *C\:\\ProgramData* OR *%TEMP%* OR *\\AppData\\Local\\Temp* OR *\\Windows\\PLA\\System* OR *\\tasks* OR *\\Registration\\CRMLog* OR *\\FxsTmp* OR *\\spool\\drivers\\color* OR *\\tracing*))) OR (winlog.event_id:("4698" OR "4702") AND (winlog.event_data.TaskContent:(*.cmd* OR *.ps1* OR *.vbs* OR *.py* OR *.js* OR *.exe* OR *.bat*) OR winlog.event_data.TaskContent:(*javascript* OR *powershell* OR *wmic* OR *rundll32* OR *cmd* OR *cscript* OR *wscript* OR *regsvr32* OR *mshta* OR *bitsadmin* OR *certutil* OR *msiexec* OR *javaw*) OR winlog.event_data.TaskContent:(*%APPDATA%* OR *\\AppData\\Roaming* OR *%PUBLIC%* OR *C\:\\Users\\Public* OR *%ProgramData%* OR *C\:\\ProgramData* OR *%TEMP%* OR *\\AppData\\Local\\Temp* OR *\\Windows\\PLA\\System* OR *\\tasks* OR *\\Registration\\CRMLog* OR *\\FxsTmp* OR *\\spool\\drivers\\color* OR *\\tracing*))) type: Elastic - name: LogPoint Search - Scheduled Task creation or modification containing suspicious script, extension or user writable path. description: This is a LogPoint representation of the above pseudocode search. code: |- ((event_id IN ["4688", "1"] CommandLine="*SCHTASKS*" CommandLine IN ["*/CREATE*", "*/CHANGE*"]) (CommandLine IN ["*.cmd*", "*.ps1*", "*.vbs*", "*.py*", "*.js*", "*.exe*", "*.bat*"] OR CommandLine IN ["*javascript*", "*powershell*", "*wmic*", "*rundll32*", "*cmd*", "*cscript*", "*wscript*", "*regsvr32*", "*mshta*", "*bitsadmin*", "*certutil*", "*msiexec*", "*javaw*"] OR CommandLine IN ["*%APPDATA%*", "*\\AppData\\Roaming*", "*%PUBLIC%*", "*C:\\Users\\Public*", "*%ProgramData%*", "*C:\\ProgramData*", "*%TEMP%*", "*\\AppData\\Local\\Temp*", "*\\Windows\\PLA\\System*", "*\\tasks*", "*\\Registration\\CRMLog*", "*\\FxsTmp*", "*\\spool\\drivers\\color*", "*\\tracing*"])) OR (event_id IN ["4698", "4702"] (TaskContent IN ["*.cmd*", "*.ps1*", "*.vbs*", "*.py*", "*.js*", "*.exe*", "*.bat*"] OR TaskContent IN ["*javascript*", "*powershell*", "*wmic*", "*rundll32*", "*cmd*", "*cscript*", "*wscript*", "*regsvr32*", "*mshta*", "*bitsadmin*", "*certutil*", "*msiexec*", "*javaw*"] OR TaskContent IN ["*%APPDATA%*", "*\\AppData\\Roaming*", "*%PUBLIC%*", "*C:\\Users\\Public*", "*%ProgramData%*", "*C:\\ProgramData*", "*%TEMP%*", "*\\AppData\\Local\\Temp*", "*\\Windows\\PLA\\System*", "*\\tasks*", "*\\Registration\\CRMLog*", "*\\FxsTmp*", "*\\spool\\drivers\\color*", "*\\tracing*"])) type: LogPoint unit_tests: - description: Creation Scheduled Task with cmd. Calc.exe will be launched every minute commands: - SCHTASKS /CREATE /SC MINUTE /MO 1 /TN "CALC_TASK" /TR "C:\Windows\System32\calc.exe" - description: Creation Scheduled Task with cmd. Ping will be launched every minute commands: - SCHTASKS /CREATE /SC MINUTE /MO 1 /TN "PING_TASK" /TR "cmd /c ping 8.8.8.8" data_model_references: - process/create/command_line d3fend_mappings: - iri: d3f:ProcessSpawnAnalysis id: D3-PSA label: Process Spawn Analysis 
<li><a href="#">title: Service Binary Modifications submission_date: 2014/02/14 information_domain: Host platforms: - Windows subtypes: - Registry File Process analytic_types: - Situational Awareness - TTP contributors: - MITRE id: CAR-2014-02-001 description: |- Adversaries may modify the binary file for an existing service to achieve [Persistence]() while potentially [evading defenses](). If a newly created or modified runs as a service, it may indicate APT activity. However, services are frequently installed by legitimate software. A well-tuned baseline is essential to differentiating between benign and malicious service modifications. ### Output Description The Service Name and approximate time in which changes occurred on each host coverage: - technique: T1543 tactics: - TA0003 - TA0004 subtechniques: - T1543.003 coverage: Moderate - technique: T1574 tactics: - TA0003 - TA0004 subtechniques: - T1574.010 coverage: Moderate - technique: T1569 tactics: - TA0002 subtechniques: - T1569.002 coverage: Moderate implementations: - description: 'Look for events where a file was created and then later run as a service. In these cases, a new service has been created or the binary has been modified. Many programs, such as `msiexec.exe`, do these behaviors legitimately and can be used to help validate legitimate service creations/modifications.' code: |- legitimate_installers = ["C:\windows\system32\msiexec.exe", "C:\windows\syswow64\msiexec.exe", ...] file_change = search File:Create,Modify process = search Process:Create service_process = filter processes where (parent_exe == "services.exe") modified_service = join (search, filter) where ( file_change.time < service_process.time and file_change.file_path == service_process.image_path ) modified_service = filter modified_service where (modified_service.file_change.image_path not in legitimate_installers) output modified_service type: pseudocode data_model_references: - file/create/file_path - file/create/image_path - process/create/image_path - process/create/parent_exe d3fend_mappings: - iri: d3f:ServiceBinaryVerification id: D3-SBV label: Service Binary Verification 
<li><a href="#">title: Service Outlier Executables submission_date: 2013/09/23 information_domain: Host platforms: - Windows subtypes: - Process analytic_types: - Detection contributors: - MITRE id: CAR-2013-09-005 description: New executables that are started as a service are suspicious. This analytic looks for anomalous service executables. coverage: - technique: T1543 tactics: - TA0003 subtechniques: - T1543.003 coverage: Moderate implementations: - description: 'Create a baseline of services seen over the last 30 days and a list of services seen today. Remove services in the baseline from services seen today, leaving a list of new services.' code: |- processes = search Process:Create services = filter processes where (parent_image_path == "C:\Windows\System32\services.exe") historic_services = filter services (where timestamp < now - 1 day AND timestamp > now - 1 day) current_services = filter services (where timestamp >= now - 1 day) new_services = historic_services - current_services output new_services type: pseudocode - name: Sigma (Windows Event Log) description: '[Sigma/Windows Event Log]() rule with similar logic to the above pseudocode' type: Sigma - description: LogPoint version of the above sigma rule. code: |- norm_id=WinServer event_id=7045 | chart count() as cnt by file | search cnt < 5 type: LogPoint data_model: LogPoint native data_model_references: - process/create/parent_image_path d3fend_mappings: - iri: d3f:ProcessLineageAnalysis id: D3-PLA label: Process Lineage Analysis 
<li><a href="#">title: Service Search Path Interception submission_date: 2014/07/17 information_domain: Host platforms: - Windows subtypes: - Process analytic_types: - TTP contributors: - MITRE id: CAR-2014-07-001 description: 'According to [ATT&CK](), an adversary may [escalate privileges]() by [intercepting the search path]() for legitimately installed services. As a result, Windows will launch the target executable instead of the desired binary and command line. This can be done when there are spaces in the binary path and the path is unquoted. Search path interception should never happen legitimately and will likely be the result of an adversary abusing a system misconfiguration. With a few regular expressions, it is possible to identify the execution of services with intercepted search paths.' coverage: - technique: T1574 tactics: - TA0004 - TA0003 subtechniques: - T1574.009 coverage: High implementations: - description: 'Look over all service creations that have a quoted path for the first argument. Assuming these still have an absolute path, look for cases in which the command line has a space, but the exe field is not part of the command line. This would indicate that a different process was intended, but the path was intercepted at an earlier space.' code: |- process = search Process:Create services = filter processes where (parent_exe == "services.exe") unquoted_services = filter services where (command_line != "\"*" and command_line == "* *") intercepted_service = filter unquoted_service where (image_path != "* *" and exe not in command_line) output intercepted_service type: pseudocode data_model_references: - process/create/command_line - process/create/image_path - process/create/parent_exe d3fend_mappings: - iri: d3f:ProcessLineageAnalysis id: D3-PLA label: Process Lineage Analysis 
<li><a href="#">title: Services launching Cmd submission_date: 2014/05/05 information_domain: Host platforms: - Windows subtypes: - Process analytic_types: - TTP contributors: - MITRE id: CAR-2014-05-002 description: |- Windows runs the [Service Control Manager]() (SCM) within the process `services.exe`. Windows launches services as independent processes or DLL loads within a [svchost.exe]() group. To be a legitimate service, a process (or DLL) must have the appropriate service entry point [SvcMain](). If an application does not have the entry point, then it will timeout (default is 30 seconds) and the process will be killed. To survive the timeout, [adversaries and red teams]() can create services that direct to `cmd.exe` with the flag `/c`, followed by the desired command. The `/c` flag causes the command shell to run a command and immediately exit. As a result, the desired program will remain running and it will report an error starting the service. This analytic will catch that command prompt instance that is used to launch the actual malicious executable. Additionally, the children and descendants of services.exe will run as a SYSTEM user by default. Thus, services are a convenient way for an adversary to gain [Persistence]() and [Privilege Escalation](). coverage: - technique: T1543 tactics: - TA0003 - TA0004 subtechniques: - T1543.003 coverage: Moderate implementations: - description: 'Returns all processes named `cmd.exe` that have `services.exe` as a parent process. Because this should never happen, the `/c` flag is redundant in the search.' code: |- process = search Process:Create cmd = filter process where (exe == "cmd.exe" and parent_exe == "services.exe") output cmd type: pseudocode - description: The Splunk version of the above pseudocode. code: |- index=__your_sysmon_index__ EventCode=1 Image="C:\\Windows\\*\\cmd.exe" ParentImage="C:\\Windows\\*\\services.exe" type: Splunk data_model: Sysmon native - description: EQL version of the above pseudocode. code: |- process where subtype.create and (process_name == "cmd.exe" and parent_process_name == "services.exe") type: EQL data_model: EQL native - description: DNIF version of the above pseudocode. code: |- _fetch * from event where $LogName=WINDOWS-SYSMON AND $EventID=1 AND $App=cmd.exe AND $ParentProcess=regex(.*services.exe.*)i limit 30 type: DNIF data_model: Sysmon native - description: LogPoint version of the above pseudocode. code: |- norm_id=WindowsSysmon event_id=1 image="C:\Windows\System32\cmd.exe" parent_image="C:\Windows\System32\services.exe" type: LogPoint data_model: LogPoint native data_model_references: - process/create/exe - process/create/parent_exe d3fend_mappings: - iri: d3f:ProcessLineageAnalysis id: D3-PLA label: Process Lineage Analysis 
<li><a href="#">title: Shadow Copy Deletion submission_date: 2020/04/10 information_domain: 'Host' platforms: - Windows subtypes: - Process analytic_types: - TTP id: CAR-2020-04-001 description: |- This analytic has been deprecated in favor of [CAR-2021-01-009](/analytics/CAR-2021-01-009), which covers the same technique with some additional detections. --- 
<li><a href="#">title: Simultaneous Logins on a Host submission_date: 2013/02/18 information_domain: Host platforms: - Windows - Linux - macOS subtypes: - Login analytic_types: - Situational Awareness contributors: - MITRE id: CAR-2013-02-008 description: |- Multiple users logged into a single machine at the same time, or even within the same hour, do not typically occur in networks we have observed. Logon events are Windows Event Code 4624 for Windows Vista and above, 518 for pre-Vista. Logoff events are 4634 for Windows Vista and above, 538 for pre-Vista. Logon types 2, 3, 9 and 10 are of interest. For more details see the Logon Types table on Microsoft's [Audit Logon Events]((v=ws.10)) page. coverage: - technique: T1078 tactics: - TA0001 subtechniques: - T1078.002 - T1078.003 coverage: Low implementations: - code: |- users_list = search UserSession:Login users_grouped = group users_list by hostname users_grouped = from users_grouped select min(time) as earliest_time, max(time) as latest_time count(user) as user_count multiple_logins = filter users_grouped where (latest_time - earliest_time <= 1 hour and user_count > 1) output multiple_logins type: pseudocode data_model_references: - user_session/login/user - user_session/login/hostname d3fend_mappings: - iri: d3f:AuthenticationEventThresholding id: D3-ANET label: Authentication Event Thresholding 
<li><a href="#">title: SMB Copy and Execution submission_date: 2013/05/13 information_domain: 'Host, Network' platforms: - Windows - Linux - macOS subtypes: - Network Process File - PCAP analytic_types: - TTP contributors: - MITRE id: CAR-2013-05-005 description: |- An adversary needs to gain access to other hosts to move throughout an environment. In many cases, this is a twofold process. First, a file is remotely written to a host via an SMB share (detected by [CAR-2013-05-003](../CAR-2013-05-003)). Then, a variety of [Execution]() techniques can be used to remotely establish execution of the file or script. To detect this behavior, look for files that are written to a host over SMB and then later run directly as a process or in the command line arguments. SMB File Writes and Remote Execution may happen normally in an environment, but the combination of the two behaviors is less frequent and more likely to indicate adversarial activity. This can possibly extend to more copy protocols in order to widen its reach, or it could be tuned more finely to focus on specific program run locations (e.g. `%SYSTEMROOT%\system32`) to gain a higher detection rate. coverage: - technique: T1021 tactics: - TA0008 subtechniques: - T1021.002 coverage: Moderate - technique: T1078 tactics: - TA0005 subtechniques: - T1078.002 - T1078.003 coverage: Moderate - technique: T1570 tactics: - TA0008 coverage: Moderate implementations: - code: |- process = search Process:Create smb_write = run Analytic:CAR-2013-05-003 remote_start = join (smb_write, process) where ( smb_write.hostname == process.hostname and smb_write.file_path == process.image_path (smb_write.time < process.time) ) output remote_start type: pseudocode data_model_references: - process/create/image_path - process/create/proto_info - process/create/hostname d3fend_mappings: - iri: d3f:IPCTrafficAnalysis id: D3-IPCTA label: IPC Traffic Analysis 
<li><a href="#">title: SMB Events Monitoring submission_date: 2013/01/25 information_domain: Network platforms: - N/A subtypes: - PCAP analytic_types: - Situational Awareness contributors: - MITRE id: CAR-2013-01-003 description: |- [Server Message Block]( Block) (SMB) is used by Windows to allow for file, pipe, and printer sharing over port 445/tcp. It allows for enumerating, and reading from and writing to file shares for a remote computer. Although it is heavily used by Windows servers for legitimate purposes and by users for file and printer sharing, many adversaries also use SMB to achieve [Lateral Movement](). Looking at this activity more closely to obtain an adequate sense of situational awareness may make it possible to detect adversaries moving between hosts in a way that deviates from normal activity. Because SMB traffic is heavy in many environments, this analytic may be difficult to turn into something that can be used to quickly detect an APT. In some cases, it may make more sense to run this analytic in a forensic fashion. Looking through and filtering its output after an intrusion has been discovered may be helpful in identifying the scope of compromise. ### Output Description The source, destination, content, and time of each event. coverage: - technique: T1039 tactics: - TA0009 coverage: Moderate - technique: T1021 tactics: - TA0008 subtechniques: - T1021.002 coverage: Moderate implementations: - description: 'Although there may be more native ways to detect detailed SMB events on the host, they can be extracted out of network traffic. With the right protocol decoders, port 445 traffic can be filtered and even the file path (relative to the share) can be retrieved. ' code: |- flow = search Flow:Message smb_events = filter flow where (dest_port == "445" and protocol == "smb") smb_events.file_name = smb_events.proto_info.file_name output smb_write type: pseudocode data_model_references: - flow/message/dest_port - flow/message/proto_info d3fend_mappings: - iri: d3f:IPCTrafficAnalysis id: D3-IPCTA label: IPC Traffic Analysis 
<li><a href="#">title: SMB Session Setups submission_date: 2013/09/12 information_domain: Network subtypes: - PCAP analytic_types: - Situational Awareness contributors: - MITRE id: CAR-2013-09-003 description: |- Account usage within SMB can be used to identify compromised credentials, and the hosts accessed with them. This analytic monitors SMB activity that deals with user activity rather than file activity. coverage: - technique: T1187 tactics: - TA0006 coverage: Low implementations: - code: |- flow = search Flow:Message smb_setup = filter flow where (dest_port == 445 and protocol == smb.setup) smb_setup.user = smb_write.proto_info.user_name smb_setup.target_host = smb_write.proto_info.hostname output smb_write type: pseudocode data_model_references: - flow/message/dest_port - flow/message/proto_info - flow/message/protocol d3fend_mappings: - iri: d3f:IPCTrafficAnalysis id: D3-IPCTA label: IPC Traffic Analysis 
<li><a href="#">title: SMB Write Request - NamedPipes submission_date: 2014/03/03 information_domain: 'Host, Network' platforms: - Windows - Linux - macOS subtypes: - Process - Netflow analytic_types: - Situational Awareness contributors: - MITRE id: CAR-2014-03-001 description: |- An SMB write can be an indicator of lateral movement, especially when combined with other information such as execution of that written file. Named pipes are a subset of SMB write requests. Named pipes such as msftewds may not be alarming; however others, such as lsarpc, may. Monitoring SMB write requests still creates some noise, particulary with named pipes. As a result, SMB is now split between writing named pipes and writing other files. coverage: - technique: T1570 tactics: - TA0008 coverage: Low implementations: - description: |- Look for SMB network connections over port 445. Using a sensor that can decode protocol information, extract out the name of the pipe and potentially other information. This happens legitimately so certain pipes, such as `spoolss` should be appropriately white-listed. Certain pipes do correspond to adversary activity, including: * `WINREG` - Windows Remote Registry ([CAR-2014-11-005](../CAR-2014-11-005)) * `ATSVC` - Windows AT command ([CAR-2015-04-001](../CAR-2015-04-001)) code: |- flow = search Flow:Message smb_write = filter flow where (dest_port == "445" and protocol == "smb.write_pipe") smb_write.pipe_name = smb_write.proto_info.pipe_name output smb_write type: pseudocode data_model_references: - flow/message/proto_info - flow/start/dest_port d3fend_mappings: - iri: d3f:IPCTrafficAnalysis id: D3-IPCTA label: IPC Traffic Analysis 
<li><a href="#">title: SMB Write Request submission_date: 2013/05/13 information_domain: 'Host, Network' platforms: - Windows - Linux - macOS subtypes: - Network - Netflow - PCAP analytic_types: - Situational Awareness - TTP contributors: - MITRE id: CAR-2013-05-003 description: 'As described in [CAR-2013-01-003](../CAR-2013-01-003), SMB provides a means of remotely managing a file system. Adversaries often use SMB to move laterally to a host. SMB is commonly used to upload files. It may be used for staging in [Exfiltration]() or as a [Lateral Movement]() technique. Unlike SMB Reads, SMB Write requests typically require an additional level of access, resulting in less activity. Focusing on SMB Write activity narrows the field to find techniques that actively change remote hosts, instead of passively reading files.' coverage: - technique: T1570 tactics: - TA0008 coverage: Moderate - technique: T1021 tactics: - TA0008 subtechniques: - T1021.002 coverage: Moderate - technique: T1078 tactics: - TA0005 subtechniques: - T1078.002 - T1078.003 coverage: Moderate implementations: - code: |- flow = search Flow:Message smb_write = filter flow where (dest_port == "445" and protocol == "smb.write") smb_write.file_name = smb_write.proto_info.file_name output smb_write type: pseudocode data_model_references: - flow/message/proto_info - flow/message/dest_port d3fend_mappings: - iri: d3f:IPCTrafficAnalysis id: D3-IPCTA label: IPC Traffic Analysis 
<li><a href="#">title: Squiblydoo submission_date: 2019/04/24 information_domain: 'Host' platforms: - Windows subtypes: - Process analytic_types: - TTP contributors: - MITRE id: CAR-2019-04-003 description: |- Squiblydoo is a specific usage of regsvr32.dll to load a COM scriptlet directly from the internet and execute it in a way that bypasses application whitelisting. It can be seen by looking for regsvr32.exe executions that load the scrobj.dll (which execute the COM scriptlet) or, if that is too noisy, those that also load content directly via HTTP or HTTPS. Squiblydoo was first written up by Casey Smith at Red Canary, though that blog post is no longer accessible. coverage: - technique: T1218 tactics: - TA0005 subtechniques: - T1218.010 coverage: Moderate implementations: - description: This looks for any and all usage of the scrobj DLL, which is what is used to run COM scriptlets, so it'll detect both loading from network as well as filesystem. This will have almost zero false positives so is suitable for alerting. code: |- index=__your_sysmon_events__ EventCode=1 regsvr32.exe scrobj.dll | search Image="*regsvr32.exe" type: splunk data_model: Sysmon native - description: EQL version of the above Splunk search. code: |- process where subtype.create and (process_path == "*regsvr32.exe" and command_line == "*scrobj.dll") type: EQL data_model: EQL native - description: Pseudocode version of the above Splunk search. code: |- processes = search Process:Create squiblydoo_processes = filter processes where ( image_path == "*regsvr32.exe" and command_line == "*scrobj.dll" ) output squiblydoo_processes type: psuedocode data_model: CAR - description: LogPoint version of the above pseudocode. code: |- norm_id=WindowsSysmon event_id=1 image="*\regsvr32.exe" command="*scrobj.dll" type: LogPoint data_mode: LogPoint native unit_tests: - description: The [Atomic Red Team test for Squiblydoo]() is a good test case for this. data_model_references: - process/create/exe - process/create/command_line references: - As usual, credit to Roberto Rodriguez and the [ThreatHunter Playbook](). d3fend_mappings: - iri: d3f:ProcessSpawnAnalysis id: D3-PSA label: Process Spawn Analysis --- 
<li><a href="#">title: Successful Local Account Login submission_date: 2016/04/18 information_domain: Host platforms: - Windows subtypes: - Login analytic_types: - Situational Awareness contributors: - MITRE/NSA id: CAR-2016-04-004 description: 'The successful use of [Pass The Hash]() for lateral movement between workstations would trigger event ID 4624, with an event level of Information, from the security log. This behavior would be a LogonType of 3 using NTLM authentication where it is not a domain logon and not the ANONYMOUS LOGON account.' coverage: - technique: T1550 tactics: - TA0008 subtechniques: - T1550.002 coverage: Moderate implementations: - description: 'This analytic will look for remote logins, using a non domain login, from one host to another, using NTL authentication where the account is not "ANONYMOUS LOGON" ' code: |- EventCode == 4624 and [target_user_name] != "ANONYMOUS LOGON" and [authentication_package_name] == "NTLM" type: pseudocode unit_tests: - configurations: - Windows 7 description: As an adminstrator, create a new user. Then, logon to the host with that new user. This is generate the event. commands: - net user 'test' 'test' /add d3fend_mappings: - iri: d3f:LocalAccountMonitoring id: D3-LAM label: Local Account Monitoring 
<li><a href="#">title: Suspicious Arguments submission_date: 2013/07/05 information_domain: Host platforms: - Windows - Linux - macOS subtypes: - Process analytic_types: - TTP contributors: - MITRE id: CAR-2013-07-001 description: |- Malicious actors may rename built-in commands or external tools, such as those provided by SysInternals, to better [blend in]() with the environment. In those cases, the file path name is arbitrary and may blend in well with the background. If the arguments are closely inspected, it may be possible to infer what tools are running and understand what an adversary is doing. When any legitimate software shares the same command lines, it must be whitelisted according to the expected parameters. Any tool of interest with commonly known command line usage can be detecting by command line analysis. Known substrings of command lines include - PuTTY - port forwarding `-R * -pw` - secure copy (scp) `-pw * * *@*` - mimikatz `sekurlsa::` - RAR `* -hp *` - Archive`* a *` Additionally, it may be useful to find IP addresses in the command line - `\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}` Logically this analytic makes use of [CAR-2014-03-005](../CAR-2014-03-005). coverage: - technique: T1003 tactics: - TA0006 subtechniques: - T1003.001 coverage: Low - technique: T1021 tactics: - TA0008 coverage: Moderate - technique: T1105 tactics: - TA0011 - TA0008 coverage: Moderate implementations: - description: 'Identify process launches that contain substrings that belong to known tools and do not match the expected process names. These will help to indicate instances of tools that have been renamed. ' code: |- process = search Process:Create port_fwd = filter process where (command_line match "-R .* -pw") scp = filter process where (command_line match "-pw .* .* .*@.*" mimikatz = filter process where (command_line match "sekurlsa") rar = filter process where (command_line match " -hp ") archive = filter process where (command_line match ".* a .*") ip_addr = filter process where (command_line match \d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}) output port_fwd, scp, mimikatz, rar, archive, ip_addr type: pseudocode - description: Splunk version of the above pseudocode, excluding the IP address search. code: |- index=__your_sysmon_index__ EventCode=1 (CommandLine="* -R * -pw*" OR CommandLine="* -pw * *@*" OR CommandLine="*sekurlsa*" OR CommandLine="* -hp *" OR CommandLine="* a *") type: splunk data_model: Sysmon native - description: EQL version of the above pseudocode, excluding the IP address search. code: |- process where subtype.create and (command_line == "* -R * -pw*" or command_line == "* -pw * *@*" or command_line == "*sekurlsa*" or command_line == "* -hp *" or command_line == "* a *") type: EQL data_model: EQL native - description: Splunk version of the above pseudocode, solely for the IP address search. Note that this will likely result in many false positives, since things like software version numbers can also be valid IPv4 addresses. code: |- index=__your_sysmon_index__ EventCode=1 |regex CommandLine=".*\b(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)(\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}\b.*" type: splunk data_model: Sysmon native - description: DNIF version of the above pseudocode. code: |- _fetch * from event where $LogName=WINDOWS-SYSMON AND $EventID=1 AND $Process=regex(.*(\-r.*\-pw|\-pw.*\@|sekurlsa|\-hp| a |\\d\{1\,3\}\\\.\\d\{1\,3\}\\\.\\d\{1\,3\}).*)i limit 100 type: DNIF data_model: Sysmon native - description: LogPoint version of the above pseudocode. code: |- norm_id=WindowsSysmon event_id=1 (command="* -R * -pw*" OR command="* -pw * *@*" OR command="*sekurlsa*" OR command="* -hp *" OR command="* a *") type: LogPoint data_model: LogPoint native data_model_references: - process/create/command_line - process/create/exe unit_tests: - configurations: - Windows 7 description: 'Download and run Putty from the command line to connect to an SSH server using remote port forwarding. Note that this requires specifying your remote system password on the command line, where it will be logged and visible. It is highly recommended that you specify an incorrect password and not complete the login, or use a temporary password.' commands: - 'putty.exe -pw <password> -R <port>:<host> <user>@<host>' - configurations: - Windows 7 description: 'Download 7zip or other archiving software you plan to monitor. Create an innocuous text file for testing, or substitute an existing file.' commands: - 7z.exe a test.zip test.txt d3fend_mappings: - iri: d3f:ProcessSpawnAnalysis id: D3-PSA label: Process Spawn Analysis 
<li><a href="#">title: Suspicious Run Locations submission_date: 2013/05/07 information_domain: Host platforms: - Windows subtypes: - Process analytic_types: - TTP contributors: - MITRE id: CAR-2013-05-002 description: |- In Windows, files should never execute out of certain directory locations. Any of these locations may exist for a variety of reasons, and executables may be present in the directory but should not execute. As a result, some defenders make the mistake of ignoring these directories and assuming that a process will never run from one. There are known TTPs that have taken advantage of this fact to go undetected. This fact should inform defenders to monitor these directories more closely, knowing that they should never contain running processes. Monitors the directories - `*:\RECYCLER` - `*:\SystemVolumeInformation` - `%systemroot%\Tasks` - `%systemroot%\debug` coverage: - technique: T1036 tactics: - TA0005 coverage: Low implementations: - description: 'The RECYCLER and SystemVolumeInformation directories will be present on every drive. Replace %systemroot% and %windir% with the actual paths as configured by the endpoints. ' code: |- processes = search Process:Create suspicious_locations = filter process where ( image_path == "*:\RECYCLER\*" or image_path == "*:\SystemVolumeInformation\*" or image_path == "%windir%\Tasks\*" or image_path == "%systemroot%\debug\*" ) output suspicious_locations type: pseudocode - description: DNIF version of the above pseudocode. code: |- _fetch * from event where $LogName=WINDOWS-SYSMON AND $EventID=1 AND $Process=regex(.*(\:\\recycler\\|\:\\systemvolumeinformation\\|\%windir\%\\tasks\\|\%systemroot\%\\debug\\).*)i group count_unique $App limit 100 type: DNIF data_model: Sysmon native - description: '[Sigma version]() of the above pseudocode, with some modifications.' type: Sigma - description: LogPoint version of the above pseudocode. code: |- norm_id=WindowsSysmon event_id=1 image IN ["*:\RECYCLER\*", "*:\SystemVolumeInformation\*", "C:\Windows\Tasks\*", "C:\Windows\System32\debug\*"] type: LogPoint data_model: LogPoint native data_model_references: - process/create/image_path unit_tests: - configurations: - Windows 7 description: |- - Typically %systemroot% is C:\\Windows but you can check this by running "echo %systemdrive%" at the command line. - Copy C:\\Windows\\system32\\notepad to C:\\Windows\\Tasks. - Run notepad. The analytic should fire. - Delete the executable to clean up from the test. commands: - 'copy C:\windows\system32\notepad.exe C:\windows\tasks' - 'start C:\windows\tasks\notepad.exe' - 'del C:\windows\tasks\notepad.exe' d3fend_mappings: - iri: d3f:ProcessSpawnAnalysis id: D3-PSA label: Process Spawn Analysis 
<li><a href="#">title: UAC Bypass submission_date: 2019/04/19 information_domain: 'Host' platforms: - Windows subtypes: - Process analytic_types: - TTP contributors: - MITRE id: CAR-2019-04-001 description: |- Bypassing user account control (UAC Bypass) is generally done by piggybacking on a system process that has auto-escalate privileges. This analytic looks to detect those cases as described by the open-source [UACME]() tool. coverage: - technique: T1548 tactics: - TA0005 subtechniques: - T1548.002 coverage: Low implementations: - description: This Splunk query looks for specific invocations of UACME, representing different ways to bypass user account control. code: |- index=_your_sysmon_index_ EventCode=1 IntegrityLevel=High|search (ParentCommandLine="\"c:\\windows\\system32\\dism.exe\"*""*.xml" AND Image!="c:\\users\\*\\appdata\\local\\temp\\*\\dismhost.exe") OR ParentImage=c:\\windows\\system32\\fodhelper.exe OR (CommandLine="\"c:\\windows\\system32\\wusa.exe\"*/quiet*" AND User!=NOT_TRANSLATED AND CurrentDirectory=c:\\windows\\system32\\ AND ParentImage!=c:\\windows\\explorer.exe) OR CommandLine="*.exe\"*cleanmgr.exe /autoclean*" OR (ParentImage="c:\\windows\\*dccw.exe" AND Image!="c:\\windows\\system32\\cttune.exe") OR Image="c:\\program files\\windows media player\\osk.exe" OR ParentImage="c:\\windows\\system32\\slui.exe"|eval PossibleTechniques=case(like(lower(ParentCommandLine),"%c:\\windows\\system32\\dism.exe%"), "UACME #23", like(lower(Image),"c:\\program files\\windows media player\\osk.exe"), "UACME #32", like(lower(ParentImage),"c:\\windows\\system32\\fodhelper.exe"), "UACME #33", like(lower(CommandLine),"%.exe\"%cleanmgr.exe /autoclean%"), "UACME #34", like(lower(Image),"c:\\windows\\system32\\wusa.exe"), "UACME #36", like(lower(ParentImage),"c:\\windows\\%dccw.exe"), "UACME #37", like(lower(ParentImage),"c:\\windows\\system32\\slui.exe"), "UACME #45") type: splunk data_model: Sysmon native - description: This is a pseudocode version of the above Splunk query. code: |- processes = search Process:Create possible_uac_bypass = filter processes where ( integrity_level == "High" and (parent_image_path == "c:\windows\system32\fodhelper.exe") or (command_line == "*.exe\"*cleanmgr.exe /autoclean*") or (image_path == "c:\program files\windows media player\osk.exe") or (parent_image_path == "c:\windows\system32\slui.exe") or (parent_command_line == '"c:\windows\system32\dism.exe"*""*.xml"' and image_path != "c:\users\*\appdata\local\temp\*\dismhost.exe") or (command_line == '"c:\windows\system32\wusa.exe"*/quiet*' and user != "NOT_TRANSLATED" and current_working_directory == "c:\windows\system32\" and parent_image_path != "c:\windows\explorer.exe") or (parent_image_path == "c:\windows\*dccw.exe" and image_path != "c:\windows\system32\cttune.exe") ) output possible_uac_bypass type: pseudocode data_model: CAR - name: Sigma/Sysmon (Eventvwr) description: '[Sigma]() rule for detecting eventvwr-based UAC bypass.' type: Sigma - name: Sigma/Sysmon (sdclt) description: '[Sigma]() rule for detecting sdclt-based UAC bypass.' type: Sigma - description: LogPoint version of the above pseudocode. code: |- norm_id=WindowsSysmon event_id=1 integrity_level="High" ((parent_image="c:\windows\system32\fodhelper.exe" OR command='*.exe"*cleanmgr.exe /autoclean*' OR image="c:\program files\windows media player\osk.exe" OR parent_image="c:\windows\system32\slui.exe") OR (parent_command='"c:\windows\system32\dism.exe"*""*.xml"' -image="c:\users\*\appdata\local\temp\*\dismhost.exe") OR (parent_image="c:\windows\*dccw.exe" -image="c:\windows\system32\cttune.exe") OR (command='"c:\windows\system32\wusa.exe"*/quiet*' -user="NOT_TRANSLATED" path="c:\windows\system32\" -parent_image="c:\windows\explorer.exe")) type: LogPoint data_mode: LogPoint native data_model_references: - process/create/image_path - process/create/parent_image_path - process/create/integrity_level - process/create/user - process/create/parent_command_line d3fend_mappings: - iri: d3f:ProcessLineageAnalysis id: D3-PLA label: Process Lineage Analysis --- 
<li><a href="#">title: Unusual Child Process for Spoolsv.Exe or Connhost.Exe submission_date: 2020/12/03 information_domain: 'Host' platforms: - Windows subtypes: - Process analytic_types: - Anomaly contributors: - Cyware Labs id: CAR-2021-01-004 description: |- After gaining initial access to a system, threat actors attempt to escalate privileges as they may be operating within a lower privileged process which does not allow them to access protected information or carry out tasks which require higher permissions. A common way of escalating privileges in a system is by externally invoking and exploiting spoolsv or connhost executables, both of which are legitimate Windows applications. This query searches for an invocation of either of these executables by a user, thus alerting us of any potentially malicious activity. coverage: - technique: T1068 coverage: Low tactics: - TA0004 implementations: - name: Splunk search - Unusual Child Process For Spoolsv.exe Or Connhost.exe description: This query looks for processes spawned by spoolsv.exe or connhost.exe externally, thus alerting us of potentially malicious activity. code: |- (index=__your_sysmon_index__ EventCode=1) (Image=C:\\Windows\\System32\\spoolsv.exe* OR Image=C:\\Windows\\System32\\conhost.exe) ParentImage = "C:\\Windows\\System32\\cmd.exe" data_model: Sysmon native type: Splunk data_model_references: - process/create/command_line d3fend_mappings: - iri: d3f:ProcessSpawnAnalysis id: D3-PSA label: Process Spawn Analysis --- 
<li><a href="#">title: Unusual Child Process spawned using DDE exploit submission_date: 2020/12/03 information_domain: 'Host' platforms: - Windows subtypes: - Process analytic_types: - TTP contributors: - Cyware Labs id: CAR-2021-01-006 description: |- Adversaries may use Windows Dynamic Data Exchange (DDE) to execute arbitrary commands. DDE is a client-server protocol for one-time and/or continuous inter-process communication (IPC) between applications. Once a link is established, applications can autonomously exchange transactions consisting of strings, warm data links (notifications when a data item changes), hot data links (duplications of changes to a data item), and requests for command execution. coverage: - technique: T1559 coverage: Low subtechniques: - T1559.002 tactics: - TA0002 implementations: - name: Splunk search - Unusual Child Process spawned using DDE exploit description: This Splunk query looks for any executable invocations from an Excel file. code: |- index = __your_sysmon__index__ (ParentImage="*excel.exe" OR ParentImage="*word.exe" OR ParentImage="*outlook.exe") Image="*.exe" data_model: Sysmon native type: Splunk - name: Splunk search - Unusual Child Process spawned using DDE exploit description: This Splunk query looks for any executable invocations from an Excel file. code: |- processes = search Process:Create target_processes = filter processes where ( (parent_image="*excel.exe" OR parent_image="*word.exe" OR parent_image="*outlook.exe") AND image="*.exe" ) type: Pseudocode data_model_references: - process/create/command_line d3fend_mappings: - iri: d3f:ProcessSpawnAnalysis id: D3-PSA label: Process Spawn Analysis --- 
<li><a href="#">title: Unusually Long Command Line Strings submission_date: 2020/11/27 information_domain: 'Host' platforms: - Windows subtypes: - Process analytic_types: - Anomaly contributors: - Cyware Labs id: CAR-2021-01-002 description: |- Often, after a threat actor gains access to a system, they will attempt to run some kind of malware to further infect the victim machine. These malware often have long command line strings, which could be a possible indicator of attack. Here, we use sysmon and Splunk to first find the average command string length and search for command strings that stretch over multiple lines, thus identifying anomalies and possibly malicious commands. coverage: - technique: T1059 coverage: Low tactics: - TA0002 implementations: - name: Splunk search - Identifying possible malware activity via unusually long command line strings description: This is a Splunk query that determines the average length of a command per user and searches for a command string that is multiple times longer than the average length code: |- index=* sourcetype="xmlwineventlog" EventCode=4688 |eval cmd_len=len(CommandLine) | eventstats avg(cmd_len) as avg by host| stats max(cmd_len) as maxlen, values(avg) as avgperhost by host, CommandLine | where maxlen > 10*avgperhost data_model: Sysmon native type: Splunk data_model_references: - process/create/command_line d3fend_mappings: - iri: d3f:ProcessSpawnAnalysis id: D3-PSA label: Process Spawn Analysis --- 
<li><a href="#">title: User Activity from Clearing Event Logs submission_date: 2016/04/14 information_domain: Host platforms: - Windows - Linux - macOS subtypes: - Event Records - Process analytic_types: - Anomaly contributors: - MITRE/NSA - Cyware Labs - Lucas Heiligenstein id: CAR-2016-04-002 description: 'It is unlikely that event log data would be cleared during normal operations, and it is likely that malicious attackers may try to cover their tracks by clearing an event log. When an event log gets cleared, it is suspicious. 1. This is often done using `wevtutil`, a legitimate tool provided by Microsoft. This action interferes with event collection and notification, and may lead to a security event going undetected, thereby potentially leading to further compromise of the network. 2. Alerting when a `Clear Event Log` is generated could point to this intruder technique. Centrally collecting events has the added benefit of making it much harder for attackers to cover their tracks. Event Forwarding permits sources to forward multiple copies of a collected event to multiple collectors, thus enabling redundant event collection. Using a redundant event collection model can minimize the single point of failure risk.' 3. Attackers may set the option of the sources of events with `Limit-EventLog -LogName Security -OverflowAction DoNotOverwrite` to not delete old Evenlog when the .evtx is full. By default the Security Log size is configured with the minimum value of 20 480KB (~23 000 EventLog). So if this option is enabled, all the new EventLogs will be automatically deleted. We can detect this behavior with the Security EventLog 1104. 4. Attackers may delete .evtx with `del C:\Windows\System32\winevt\logs\Security.evtx` or `Remove-Item C:\Windows\System32\winevt\logs\Security.evtx` after having disabled and stopped the Eventlog service. As the EventLog service is disabled and stopped, the .evtx files are no longer used by this service and can be deleted. The new EventLog will be Unavailable until the configuration is reset. 5. Attackers may use the powershell command `Remove-EventLog -LogName Security` to unregister source of events that are part of Windows (Application, Securityâ€¦). This command deletes the security EventLog (which also generates EventId 1102) but the new Eventlogs are still recorded until the system is rebooted . After the System is rebooted, the Security log is unregistered and doesnâ€™t log any new Eventlog. However logs generated between the command and the reboot are still available in the .evtx file. coverage: - technique: T1070 tactics: - TA0005 subtechniques: - T1070.001 coverage: Moderate implementations: - name: PseudoCode for dedicated EventID EventLog deletion description: 'When an eventlog is cleared, a new event is created that alerts that the eventlog was cleared. For Security logs, its event code 1100 and 1102. For System logs, it is event code 104.' code: |- ([log_name] == "Security" and [event_code] in [1100, 1102, 1104]) or ([log_name] == "System" and [event_code] == 104) type: pseudocode - name: Sigma rule (System log) description: '[Sigma version]() of the above pseudocode, focusing only on the System log.' type: Sigma - name: Sigma rule (Security log) description: '[Sigma version]() of the above pseudocode, focusing only on the Security log.' type: Sigma - name: LogPoint version of the above pseudocode. description: LogPoint version of the above pseudocode. code: |- norm_id=WinServer ((channel="Security" event_id IN [1100,1102]) OR (channel="System" event_id=104)) type: LogPoint data_mode: LogPoint native - name: Splunk search - Detecting log clearing with wevtutil description: This search query looks for wevtutil, Clear-EventLog, Limit-EventLog, Remove-Item or Remove-EventLog inside a command that may cause the system to remove Windows Event logs. code: |- index=__your_sysmon_index__ sourcetype= __your__windows__sysmon__sourcetype EventCode=1 (Image=*wevtutil* CommandLine=*cl* (CommandLine=*System* OR CommandLine=*Security* OR CommandLine=*Setup* OR CommandLine=*Application*) OR Clear-EventLog OR Limit-EventLog OR (Remove-Item AND .evtx) OR Remove-EventLog) data_model: Sysmon native type: Splunk unit_tests: - description: You can use the powershell cmdlet â€œClear-Eventlogâ€ to clear event logs. Open Powershell as administrator and execute Clear-Eventlog `Clear-EventLog [-LogName] \<String[]\>`. [Additional information here](). commands: - Clear-Eventlog Security - Clear-Eventlog System - description: Command to not Overwrite old EventLog commands: - Limit-EventLog -LogName Security -OverflowAction DoNotOverwrite - description: Cmd and Powershell command to delete EventLog (only possible after turning off the EventLog service) commands: - del C:\Windows\System32\winevt\logs\Security.evtx - Remove-Item C:\Windows\System32\winevt\logs\Security.evtx - description: Unregister EventLog source commands: - Remove-EventLog -LogName Security data_model_references: - process/create/command_line references: -  d3fend_mappings: - iri: d3f:RPCTrafficAnalysis id: D3-RTA label: RPC Traffic Analysis 
<li><a href="#">title: User Activity from Stopping Windows Defensive Services submission_date: 2016/04/15 information_domain: Host platforms: - Windows subtypes: - Process analytic_types: - Situational Awareness contributors: - MITRE/NSA id: CAR-2016-04-003 description: |- Spyware and malware remain a serious problem and Microsoft developed security services, Windows Defender and Windows Firewall, to combat this threat. In the event Windows Defender or Windows Firewall is turned off, administrators should correct the issue immediately to prevent the possibility of infection or further infection and investigate to determine if caused by crash or user manipulation. Stopping services events are Windows Event Code 7036. coverage: - technique: T1562 tactics: - TA0005 subtechniques: - T1562.001 coverage: Low implementations: - description: Windows Event code 7036 from the System log identifies if a service has stopped or started. This analytic looks for "Windows Defender" or "Windows Firewall" that has stopped. code: |- log_name == "System" AND event_code == "7036" param1 in ["Windows Defender", "Windows Firewall"] AND param2 == "stopped" type: pseudocode - description: LogPoint version of the above pseudocode. code: |- norm_id=WinServer channel="System" event_id=7036 param1 in ["Windows Defender", "Windows Firewall"] param2="stopped" type: LogPoint data_mode: LogPoint native unit_tests: - configurations: - Windows 7 description: From an administrative user powershell console, run the Stop-Service command. commands: - Stop-Service -displayname "Windows Firewall" - Stop-Service -displayname "Windows Defender" d3fend_mappings: - iri: d3f:SystemDaemonMonitoring id: D3-SDM label: System Daemon Monitoring 
<li><a href="#">title: User Logged in to Multiple Hosts submission_date: 2013/02/27 information_domain: Host platforms: - Windows - Linux - macOS subtypes: - Login analytic_types: - Situational Awareness contributors: - MITRE id: CAR-2013-02-012 description: |- Most users use only one or two machines during the normal course of business. User accounts that log in to multiple machines, especially over a short period of time, may be compromised. Remote logins among multiple machines may be an indicator of [Lateral Movement](). Certain users will likely appear as being logged into several machines and may need to be "whitelisted." Such users would include network admins or user names that are common to many hosts. ### Output Description User Name, Machines logged into, the earliest and latest times in which users were logged into the host, the type of logon, and logon ID. coverage: - technique: T1078 tactics: - TA0008 subtechniques: - T1078.002 - T1078.003 coverage: Moderate d3fend_mappings: - iri: d3f:AuthenticationEventThresholding id: D3-ANET label: Authentication Event Thresholding 
<li><a href="#">title: User Login Activity Monitoring submission_date: 2013/10/03 information_domain: 'Host, Network' platforms: - Windows - Linux - macOS subtypes: - Login - Netflow analytic_types: - Situational Awareness contributors: - MITRE id: CAR-2013-10-001 description: |- Monitoring logon and logoff events for hosts on the network is very important for situational awareness. This information can be used as an indicator of unusual activity as well as to corroborate activity seen elsewhere. Could be applied to a number of different types of monitoring depending on what information is desired. Some use cases include monitoring for all remote connections and building login timelines for users. Logon events are Windows Event Code 4624 for Windows Vista and above, 518 for pre-Vista. Logoff events are 4634 for Windows Vista and above, 538 for pre-Vista. ### Output Description The time of login events for distinct users on individual systems coverage: - technique: T1021 tactics: - TA0008 subtechniques: - T1021.001 coverage: Moderate - technique: T1078 tactics: - TA0005 subtechniques: - T1078.002 - T1078.003 coverage: Moderate implementations: - name: Account Logon with Filtering description: This base pseudocode looks for user logon events and filters out the top 30 account names to reduce the occurrence of noisy service accounts and the like. It is meant as a starting point for situational awareness around such events. code: |- logon_events = search User_Session:Login filtered_logons = filter logon_events where ( user NOT IN TOP30(user)) output filtered_logons type: Pseudocode - name: Account Logon with Filtering description: Splunk version of the above pseudocode. NOTE - this is liable to be quite noisy and will need tweaking, especially in terms of the number of top users filtered out. code: |- index=__your_win_event_log_index__ EventCode=4624|search NOT [search index=__your_win_event_log_index__ EventCode=4624|top 30 Account_Name|table Account_Name] type: Splunk - name: Account Logon with Filtering description: DNIF version of the above pseudocode. code: |- _fetch * from event where $LogName=WINDOWS-NXLOG-AUDIT AND $SubSystem=AUTHENTICATION AND $Action=LOGIN group count_unique $ScopeID, $User limit 30 >>_store in_disk david_test win_top_30 stack_replace >>_fetch * from event where $LogName=WINDOWS-NXLOG-AUDIT AND $SubSystem=AUTHENTICATION AND $Action=LOGIN limit 10000 >>_checkif lookup david_test win_top_30 join $ScopeID = $ScopeID str_compare $User eq $User exclude type: DNIF data_model: Sysmon native d3fend_mappings: - iri: d3f:AuthenticationEventThresholding id: D3-ANET label: Authentication Event Thresholding 
<li><a href="#">title: Webshell-Indicative Process Tree submission_date: 2020/11/29 information_domain: Host platforms: - Windows subtypes: - Process analytic_types: - TTP contributors: - Nichols Jasper id: CAR-2021-02-001 description: |- A web shell is a web script placed on an openly accessible web server to allow an adversary to use the server as a gatway in a network. As the shell operates, commands will be issued from within the web application into the broader server operating system. This analytic looks for host enumeration executables initiated by any web service that would not normally be executed within that environment. coverage: - technique: T1505 tactics: - TA0003 subtechniques: - T1505.003 coverage: Moderate implementations: - name: Pseudocode - Look for suspicious process tree beginning with web service description: This is a pseudocode representation of the below splunk search. code: |- processes = search Process:Create suspicious_processes = filter processes where ( (parent_exe == "w3wp.exe" OR parent_exe == "httpd.exe" OR parent_exe == "tomcat*.exe" OR parent_exe == "nginx.exe" ) AND (exe == "cmd.exe" OR exe == "powershell.exe" OR exe == "net.exe" OR exe == "whoami.exe" OR exe == "hostname.exe" OR exe == "systeminfo.exe" OR exe == "ipconfig.exe) ) output suspicious_processes data_model: CAR native type: Pseudocode - name: Splunk Search - webshell-indicative process tree description: Look for host enumeration commands spawned by web services. code: |- (index=__your_sysmon_index__ EventCode=1) (ParentImage="C:\\Windows\\System32\\*w3wp.exe" OR ParentImage="*httpd.exe" OR ParentImage="*tomcat*.exe" OR ParentImage="*nginx.exe") (Image="C:\\Windows\\System32\\cmd.exe OR Image="C:\\Windows\\SysWOW64\\cmd.exe" OR Image="C:\\Windows\\System32\\*\\powershell.exe OR Image="C:\\Windows\SysWOW64\\*\powershell.exe OR Image="C:\\Windows\\System32\\net.exe" OR Image="C:\\Windows\\System32\\hostname.exe" OR Image="C:\\Windows\\System32\\whoami.exe" OR Image="*systeminfo.exe OR Image="C:\\Windows\\System32\\ipconfig.exe") data_model: Sysmon native type: Splunk data_model_references: - process/create/exe - process/create/parent_exe d3fend_mappings: - iri: d3f:ProcessSpawnAnalysis id: D3-PSA label: Process Spawn Analysis --- 
<li><a href="#">title: Windows Remote Management (WinRM) submission_date: 2014/11/19 information_domain: 'Host, Network' platforms: - Windows subtypes: - Network - Netflow analytic_types: - Situational Awareness contributors: - MITRE id: CAR-2014-11-006 description: 'When a [Windows Remote Management]() connection is opened, the client sends HTTP requests to port 5985 for HTTP or 5986 for HTTPS on the target host. Each HTTP(S) request to the URI "/wsman" is called, and other information is set in the headers. Depending on the operation, the HTTP method may vary (i.e., GET, POST, etc.). This analytic would detect Remote PowerShell, as well as other communications that rely on WinRM. Additionally, it outputs the executable on the client host, the connection information, and the hostname of the target host.' coverage: - technique: T1021 tactics: - TA0008 subtechniques: - T1021.006 coverage: Moderate implementations: - description: 'Look for network connections to port 5985 and 5986. To really decipher what is going on, these outputs should be fed into something that can do packet analysis. ' code: |- flow = search Flow:Start winrm = filter flow where (dest_port == 5985) winrm_s = filter flow where (dest_port == 5986) output winrm, winrm_s type: pseudocode data_model_references: - flow/start/dest_port d3fend_mappings: - iri: d3f:AdministrativeNetworkActivityAnalysis id: D3-ANAA label: Administrative Network Activity Analysis 

</div>
<script>
function myFunction() {
var input, filter, ul, li, a, i, txtValue;
input = document.getElementById("myInput");
filter = input.value.toUpperCase();
ul = document.getElementById("myUL");
li = ul.getElementsByTagName("li");
for (i = 0; i < li.length; i++) {
a = li[i].getElementsByTagName("a")[0];
txtValue = a.textContent || a.innerText;
if (txtValue.toUpperCase().indexOf(filter) > -1) {
li[i].style.display = "";
} else {
li[i].style.display = "none";
}
}
}
</script>
<script src="hilitor.js"></script>
<script>
var myHilitor = new Hilitor("content"); // id of the element to parse
// myHilitor.setBreakRegExp(new RegExp('[^\\w\' -]+', "g")); // expanded to include spaces
myHilitor.apply();
</script>
<script>
window.addEventListener("DOMContentLoaded", function(e) {
var myHilitor2 = new Hilitor("playground");
myHilitor2.setMatchType("left");
document.getElementById("keywords").addEventListener("keyup", function(e) {
myHilitor2.apply(this.value);
}, false);
}, false);
</script>
</html>