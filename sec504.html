<html>
<title>SANS Notes</title>
<meta name="robots" content="noindex,nofollow" />

<link rel="stylesheet" href="w2.css">
<link rel="stylesheet" href="w3-theme-black.css">
<link rel="stylesheet" href="roboto.css">
<link rel="stylesheet" href="font-awesome.min.css">
<head>
<style>



html, body {
-webkit-user-select: none;
-moz-user-select: none;
-ms-user-select: none;
user-select: none;
oncontextmenu="return false";
onselectstart="return false";
ondragstart="return false";
background-color: #f0f0f0;
}



* {
  box-sizing: border-box;
}

.w3-sidebar {
	z-index: 3;
	width: 345px;
	top: 30px;
	bottom: 0;
	height: inherit;
	text-align: justify
	height: 100%;
	background-color: #f0f0f0;
	position: fixed;
	overflow: auto;
	line-height: 0.2
}
.w3-searchbox {
	height: 25%;
	width: 110%;
	left:405px;
	top: 23px;
	overflow: hidden;
	background-color: black;
	position: fixed;
	z-index: 1;
	line-height: 2;
 margin-top: -7px; 

}

.w3-topbar {
	width: 100%;
	height:5%;
	background-color: black;
	position: fixed;
	top: -3px;
	overflow: hidden;

	
}


#myInput {
  background-repeat: no-repeat;
  width: 40%;
  border: 1px solid #ddd;
 margin-top: 20px; 
 margin-bottom: 12px;
  margin-left: 95px;
  text-align: center;
 font-family: "Roboto", sans-serif

}

#keywords {
  background-repeat: no-repeat;
  width: 20%;
  border: 1px solid #ddd;
  border: 1px solid #ddd;
  margin-bottom: 12px;
  margin-left: 120px;

 text-align: center;
 font-family: "Roboto", sans-serif

}
#myUL {
  list-style-type: none;
  padding: 0;
  text-align: justify;
  margin-top: 150px;
  width: 70%;
}

#myUL li a {
  margin-top: -1px; 
  padding: 8px;
  text-decoration: none;
  font-size: 14px;
  color: black;
  display: block
}

}
</style>
</head>

<body>
<!-- Topbar -->
<div class="w3-topbar"></div>

<!-- Sidebar -->
<nav class="w3-sidebar w3-bar-block w3-collapse w3-small w3-theme-l5" id="mySidebar">

<BR>
<p>
<BR>
<center><H3>SANS COURSE NOTES</H3></center>
<BR>
<p>
<BR>
<a class=" w3-button w3-hover-blue" href="sec401.html">SEC 401 - Security Essentials</a>
<a class="w3-button w3-hover-blue" href="sec450.html">SEC 450 - Blue Team Fundamentals</a>
<a class="w3-button w3-hover-green" href="for500.html">FOR 500 - Windows Forensic Analysis</a>
<a class="w3-button w3-hover-blue" href="sec502.html">SEC 502 - Perimeter Protection</a>
<a class="w3-button w3-hover-red" href="sec504.html">SEC 504 - Hacker Tools</a>
<a class="w3-button w3-hover-blue" href="sec506.html">SEC 506 - Linux/Unix Security</a>
<a class="w3-button w3-hover-green" href="for508.html">FOR 508 - Incident Response Forensics</a>
<a class="w3-button w3-hover-blue" href="sec511.html">SEC 511 - Continuous Monitoring</a>
<a class="w3-button w3-hover-blue" href="sec555.html">SEC 555 - SIEM with Tactical Analytics</a>
<P>
<center>
<a class="w3-button" href="standards.html">Security Standards</a><br>
<a class="w3-button" href="books.html">Security Books</a><br>
<a class="w3-button" href="tools.html">Security Tools</a>
</center>
</nav>
<nav class="w3-searchbox" id="searchbox">

<input type="text" id="myInput" onkeyup="myFunction()" placeholder="Filter Paragraph by Keyword" title="Search">
<form method="GET" onsubmit="myHilitor.apply(hilite.value); return false;">
<input type="text" id="keywords" size="20" name="hilite" placeholder="Highlight Multiple Keywords">
<input type="submit" value="Apply">
<input type="button" value="Remove" onclick="myHilitor.remove();">
</span>
</form>

</nav>


<div class="w3-main w3-theme-l5" style="margin-left:300px"> 
<div class="w3-row w3-padding-64">               
<h2 class="w3-text-teal"></h2>
<div id="playground">


<center>




<ul id="myUL">

    <p>Hacker Tools, Techniques, Exploits, and Incident Handling, John Strand<p>

<li><a href="#">Offense must inform defense . That is, to be a solid defender, you need to understand the attacks your systems and networks will face every day. Along with that notion is the concept that to be a good attacker (such as a penetration tester or red teamer), you need to know the defenses. When offense informs defense, security personnel, such as digital forensics experts, can anticipate attacker’s moves an and analyze or counter them much more effectively.


<li><a href="#">Incident handling is the action or plan for dealing with intrusions, cyber-theft, denial of service and other computer security-related events. The scope of incident handling is greater than just intrusions; it covers insider crime and intentional and unintentional events that cause a loss of availability.


<li><a href="#">The best way to act on an incident and minimize your chance of a mistake is by having proper procedures in place. Well-documented procedures ensure that you know what to do when an incident occurs and minimize the chances that you will forget something.


<li><a href="#">The steady-state, day-to-day practices of most incident handlers are the first two steps: Preparation and Identification. We spend a lot of our time getting ready to fight the next battle and looking for events that could be signs of trouble. The middle of an incident is not a good time to ponder your incident-response process, wonder if there is a command that will enable you to audit an operating system, or figure out how to create a trustworthy forensics image.


<li><a href="#">It is easy to teach the incident-handling process at a general level. What takes persistence and concentration is to hone the skills needed by the on-site, at the console, incident handler. Knowing one method of image creation is not enough; you need to be ready to move to an alternate approach if something goes wrong. Knowing how to read the audit logs and investigate a tile system requires knowing the operating system.


<li><a href="#">How do you detect an incident? The bulk of all detects will come from either sensor platforms or the things people just happen to notice. Sensors include firewalls or intrusion detection systems and system logs.


<li><a href="#">People can be your eyes and ears, and they are also spread around the organization. The trick is to give them the training to know that something is wrong and make sure they are aware of the risks and know to whom to report.


<li><a href="#">Ideally, it’s best to deploy two people to handle each incident to gather evidence more thoroughly. Therefore, assign a primary handler, and a helper.


<li><a href="#">Our network perimeter is monitored by firewalls, routers that generate logs, external-facing intrusion detection systems, Intrusion Prevention Systems, and other machines on the DMZ. These systems can give us earlier warnings about attacks as they monitor our borders with the Internet and other external networks.


<li><a href="#">The next layer down is the host perimeter, where we monitor activities across each host system’s interface, analyzing what the machine is sending out to and receiving from the network. This border can be monitored using personal firewalls and host-based Intrusion Prevention Systems, local firewalls, and port sentry tools.


<li><a href="#">The next level of detection is host-based, where we monitor the actions on the host systems themselves. Antivirus tools, file integrity checkers, and endpoint security suites often operate at this level, Also, a user noticing strange behavior on her desktop or laptop system falls into this category.


<li><a href="#">The final level is the application level, which is typically monitored via the logs generated by the application. The application may be a web application, a server-side application used by thick clients, or even a cloud-based service. Ideally, you want to catch the attack at your perimeter, but sometimes (often, in fact), detection only occurs at the host or application level.


<li><a href="#">For network perimeter and host perimeter analysis, when you determine a listening port number, you should look up the port to see its official assignment, as well as potential malicious use of that port. There are a couple of relevant port lists. The official port list is maintained by IANA, and you may also want to consult a port list for commonly used Trojans and or malicious code.


<li><a href="#">When working through the incident response process, it is often better to start with suspicious network connections discovered via the suspect system or NetFlow data and work back through the associated services and files.


<li><a href="#">A lot of today’s malware (such as bots, backdoors) are activated using a registry key designed to execute programs when the system boots up or when a user logs on. A diligent system administrator who suspects system compromise should check out the values assigned under these registry keys. One of the best tools for reviewing the Auto Start Entry Points (ASEs) on a Windows system is autoruns.exe from Microsoft.


<li><a href="#">Administrators also need a good feel for what tasks are normally scheduled to run on their systems. The Task Scheduler GUI and the schtasks command can be used to list scheduled tasks.


<li><a href="#">Beyond the built-in capabilities of Windows, some favorite additional tools for checking the security status of a machine include the TCPView tool, which shows listening TCP and UDP ports, as well as the program name that is listening on those ports.


<li><a href="#">Two other useful process-analysis tools are Process Explorer and Process Monitor from Microsoft Sysinternals. The Center for Internet Security also has hardening templates and scoring tools for Windows. They are amazingly useful starting points for hardening Windows systems.


<li><a href="#">One of the most important responsibilities of a senior incident handler is to maintain situational awareness. What is the effect of the vulnerability, can it be remotely exploited, is an exploit available, or is this a zero-day attack (an attack that was previously unannounced)? These types of questions help the handler come to a reasonable initial assessment.


<li><a href="#">Is a public exploit available for the vulnerability? One source to check is the Common Vulnerabilities and Exposures page at cve.mitre.org, also bugtraq and isc.sans.edu. If there is no mention of a public exploit you may be dealing with a zero-day (not previously announced) vulnerability and exploit. This could be evidence of a high-end attacker and raises the stakes.


<li><a href="#">The goal of containment is to keep the problem from getting worse. Before we fire, we should take the time to aim! Try to do a decent survey and review of the situation before altering the system. Containment includes three sub-phases: short-term containment just to stop the damage, followed by system back-up, followed by long-term containment to make sure the bad guy is denied access.


<li><a href="#">The FIRST organization distributes an incident case classification document that recommends characterizing an incident based on three areas: it’s general category, the criticality of impacted systems and data, and the sensitivity with which information about the case itself should be treated.


<li><a href="#">From a category perspective, most incidents fall into one or more areas of the list shown above. It is important to note that a single incident may be in multiple categories, such as Compromised Information, Malware, External Hacking, and E-mail, all in the same incident.


<li><a href="#">The criticality rating of an incident will help determine how quickly you’ll need to assign a team and deploy to handle the situation. For highly critical incidents, you may want to establish a baseline of response time at 60 minutes, or perhaps even less for some organizations with critical computing needs.


<li><a href="#">The sensitivity metric here determines the types of personnel with whom information about the incident can be shared. For a case that is extremely sensitive, we may only want to share information with the incident response team and management. For sensitive cases, we may add in the system owners and the operations teams. For less sensitive cases, we may inform more employees, such as in the case of an isolated virus infection.


<li><a href="#">For short-term containment, we just want to stop the attacker’s progress, without making any changes to the impacted system itself. We want to keep the target machines’ drive image intact until we can back it up. Therefore, this short-term containment typically involves disconnecting network access and/or power. Containment (both short- and long-term) might stop the system from performing various business actions. Therefore, make sure you get approval before taking action that will impact business. Call the business unit teams before dropping a system.


<li><a href="#">If you do not make good forensics of the system before you start doing detailed analysis, you drastically reduce the chance of that system information being usable in court. The other attorney could claim that you modified the system. If you must do things on the system before backing it up, and sometimes this is necessary, try to log each command you type and the system’s response.


<li><a href="#">The initial forensics image in the Containment phase serves as a source for forensics analysis. Make sure to get a copy of both memory and the file system. You will not be able to make forensics images for all systems in all incidents. Some incidents may require you to rely on network domain and live forensics.


<li><a href="#">Make sure to watch out for trust relationships concerning the affected system. The most important trust relationship is often the desktop of the system administrator to the system and to other systems they administer. Look over the logs from nearby systems and trusted machines. Try to get a feel for how far the bad guy may have penetrated.


<li><a href="#">For critical production systems, extended downtime is usually not permissible. In such cases, the incident handlers must stay in the Containment phase, performing long-term containment actions on a live system to keep it running.


<li><a href="#">There are several long-term containment activities, but the most likely, by far, is just patching the system if the attacker compromised it by exploiting a vulnerability. Handlers should also patch other nearby or similar systems to ensure that they do not get compromised. If patching is impractical over the short term, you may want to consider deploying an in-line Intrusion Prevention System.


<li><a href="#">Other long-term containment options that allow us to keep the system in production include null routing, in which we configure routers to drop packets associated with a given source or destination lP address used in the attack.


<li><a href="#">Firewall rules and router access control lists may need to be tightened to prevent deeper attacks as well. Of course, you may need to remove accounts created by the bad guy and kill any processes that offer the attacker backdoor access of the machine.


<li><a href="#">Now, we turn our attention to what is probably the hardest problem in incident handling: Complete and safe total removal of any malicious code and other artifacts left by the attacker on the system, such as pirated software, pornography, and other illicit data.


<li><a href="#">There are many cases where handlers have taken systems down and reloaded the operating system only to have the box compromised again a few days later. The best course of action is to determine what the cause of the incident was, to find the vector of infection, and take action to prevent this from happening again.


<li><a href="#">It is also common for an attacker to use common and legitimate services, such as SSH and Remote Desktop, to persist and spread. It is incredibly important to monitor the logs of these services for irregularities, like strange source IP addresses and multiple concurrent logins from a single user ID.


<li><a href="#">One of the most important things for incident handlers to do in the Recovery phase and in the months following an incident is to check regularly to see if the attacker has returned. Most human attackers that compromise machines do return to the scene of the crime, making the same or similar changes to the system that they made upon initial compromise.


<li><a href="#">Because of this fact, we urge handlers to write up one or more simple scripts that they can run on a daily basis to look for artifacts left by the attacker in the previous compromise cycle. If the attacker comes back and recreates the same artifacts, your script should detect that fact and notify you. We recommend running the script daily or even more often.


<li><a href="#">The only one that really can or will write the incident report is the on-site handler. The handler submits the draft to the head of the incident-handling team. The chief edits the document and interacts with the handler to make sure the document reflects what occurred.


<li><a href="#">When we are working any incident, the first thing our responders ask for is the logs for the egress connections from the firewall, the DNS cache or DNS logs and, finally, the logs from whatever external web filtering device the organization is using.


<li><a href="#">One of the tactics we use as part of initial incident response is to compare the current cache of the DNS server with a list of evil IPs and domains by using a tool like dns-blacklists.py. One of our favorite lists to compare with is the one from Malware Domain List.


<li><a href="#">Espionage is not limited to governments and the military in any way. The focus of most espionage is not military; it is economic, and this includes the work done by government intelligence agencies.


<li><a href="#">Businesses routinely are involved in the activities of collecting information about their competition or trying to prevent the competition from getting information about their activities. As long as this is legal, we generally refer to this as competitive intelligence.


<li><a href="#">A great way to thumbprint critical files is to invent an acronym that doesn't exist and plant it into the document. Then, if you have content-sensing firewalls, intrusion detection systems, or network-based Intrusion Prevention Systems, they can be set to look for the string.


<li><a href="#">For incidents involving unauthorized use, the attacker is allowed normal access in the course of doing business. However, the attacker abuses this access, using it in an unauthorized fashion.


<li><a href="#">The best way to identify insider activity is to gather intelligence through proactive scanning and monitoring. You should always be alert for anomalies and keep copious records of those anomalies. These records assist you in identifying a threat to the business. Detection of anomalies can be accomplished by two means: intelligence gathering on your systems and intelligence gathering on your employees' activities.


<li><a href="#">The goal is to review not only allocated file space, but deleted files, slack space, swap space, and so on. Tools such as Expert Witness allow you to search the image file for specific file types and character strings. This enables you to determine if the suspect had accessed data without authorization and provide you insight into what else the suspect may be doing. A search for hacking tools, log files, and such helps you identify how the suspect is accessing data.




<li><a href="#">An attack starts with reconnaissance (step I), whereby an attacker conducts an open-source investigation to gain information about a target. Step 2 is scanning. An attacker uses a variety of mechanisms to survey a target to find holes in the target’s defenses. Step 3 involves exploiting systems. In this phase, an attacker tries to gain access, undermine an application, or deny access to other users. In step 4, the attacker maintains access by manipulating the software installed on the system to achieve backdoor access. Finally, in step 5, the attackers maintain their hard-fought access by covering their tracks. They use a variety of techniques to hide from users and system administrators.


<li><a href="#">One of the big infosec stories of recent times involves attackers learning to make money from their activities, ranging from exploiting browser holes for grabbing financial data to utilizing worms as vehicles for Denial of Service extortion. Indeed, we have seen attackers directly selling to the highest bidder customized malicious code to control victim machines or even renting out armies of infected systems useful for spam delivery, phishing schemes, Denial of Service attacks, or identity theft.


<li><a href="#">Attackers rifle through domain name information for useful tidbits in attacking a target. Every time you register a domain name (such as sans.org), you provide detailed contact information about your organization, including the name, postal address, phone number, and e-mail address for your technical, billing, and administrative contact. In addition, your registration information includes the IP addresses of your authoritative domain name servers.


<li><a href="#">A zone transfer allows an attacker to connect with your DNS server and grab all records associated with a particular domain. Essentially, zone transfers let an attacker grab a dump of your DNS server’s brain.


<li><a href="#">To defend against DNS-style reconnaissance, make sure you limit zone transfers. Your primary’ DNS server should allow zone transfers to be initiated by your secondary and tertiary DNS servers only. These servers, in turn, should be configured to deny all zone transfer requests.


<li><a href="#">In addition, use split DNS. With such an implementation, you have two components of your DNS infrastructure: external DNS servers and internal DN S servers. Publicly available DNS information is loaded on your external DNS servers. Internal names are loaded only on internal DNS servers. Also, make sure your DNS servers are hardened. They are among the most sensitive components of your infrastructure from a security perspective.


<li><a href="#">Corporate websites often contain contact information with phone numbers, which are useful for war dialing and social engineering. Some sites even include a description of their computing platforms and/or architecture. Attackers grab a copy of your entire website to look for juicy tidbits about your organization.


<li><a href="#">We can also use sites such as namechk to identify which social-networking sites a target user account may be using. Currently, namechk checks more than 100 social-networking sites to see if a given account is in use. This can be used by an attacker to develop Social Engineering (SE) pretexts.


<li><a href="#">You should periodically check various open sources of information to see what your company is leaking. This analysis can be done by the security organization, legal department, and public relations, because all have a vested stake in protecting your corporate information.


<li><a href="#">Pulling information from Google’s cache (and other caches on the Internet) is particularly useful for retrieving pages recently removed from a website. For example, an incident-response team may discover some sensitive information leakage through a website. If it removes that page from the site itself, but fails to remove it from the Google cache, attackers can still retrieve the page from the cache.


<li><a href="#">Beyond Google, the Wayback Machine located at www.archive.org has more thorough archives, which also include old views of various websites. This site features cached pages from billions of web pages for the last several years, including multiple views over time of each site.


<li><a href="#">To defend against these cyber reconnaissance raids, check your own environment to see what information you are leaking. Check out what information you have publicly available on your own websites and think about what an attacker could do with that data.


<li><a href="#">Also, if you find that Google has indexed a URL or cached a page that you didn’t want it to, you can use the URL re-crawl request submission form at www.google.com/addurl.html. This removes the page the next time the Google bot crawls your website, which likely occurs within the next 24 hours.


<li><a href="#">Even today, an unprotected modern provides the easiest method for penetrating a network. Whenever we perform a war dialing assessment, more often than not, we get into the target network. War dialers dial a sequence of telephone numbers attempting to locate modem carriers or a secondary dial tone.


<li><a href="#">Do not rely on MAC address filtering at your access point to implement security. Although you could allow only traffic from registered MAC addresses, such security’ is deeply flawed. MAC addresses can be easily spoofed (either by using the ifconfig command in Linux/UNIX or with PowerShell’s “Set-NetAdapter” commandlet in Windows).


<li><a href="#">An attacker wants to understand the topology of your network, mainly Internet connectivity: DMZ, perimeter networks, and your intranet. The layout of routers and hosts can show vulnerabilities or at least let the attacker know where things are.


<li><a href="#">Nmap, the popular network-analysis tool by Fyodor and the Nmap development team, can be used for network mapping and port scanning, although most people associate it with the latter. A common initial step in network mapping is to sweep through the target network addresses, sending one or more packets to each address trying to solicit a response. The response indicates that the given address is in use by some target machine.


<li><a href="#">The TTL field is especially useful in determining how the various components of a network are interconnected. The Linux and UNIX traceroute command, the Windows tracert command, and Nmap all rely on making variations in this field during network mapping to measure the paths that packets take across the network.


<li><a href="#">I’m a fan of filtering incoming ICMP messages to anything on my network, except perhaps a web or FTP server. All other ICMP coming from a hostile network (such as the Internet) can be dropped. You could disable outgoing ICMP Time Exceeded messages, but your users couldn’t traceroute all the way to you. That might not be a bad thing. Many sites are starting to block all incoming and outgoing ICMP messages.


<li><a href="#">If you notice a particularly frequent ping sweep or traceroute coming from a single lP address or network, you could filter that address in your border router or firewall. If someone is going to access your system, ports are the entry points or the doors and windows into your system. Therefore, a list of open ports gives an attacker various avenue for compromising the system.


<li><a href="#">In addition to finding out what ports are open on a system, an attacker also wants to determine on which platform the system is based. By determining the platform, an attacker can further research the system to determine the particular vulnerabilities it is subject to.


<li><a href="#">Nmap has a database of how various systems respond to these flags. By sending out various packets to both open and closed ports, Nmap can determine what type of platform the system is running. This technique is called active OS fingerprinting, because it is sending packets out to measure the response of the machine in an effort to identify the OS type. It is active because it sends packets.


<li><a href="#">When IP packets are sent across a network, at certain points in the network (usually at slower links), the packets can be broken up into smaller pieces. This process is known as fragmentation. Once a packet is fragmented, it is not reassembled until it gets to the destination. Attackers carefully utilize the techniques to hide what they are doing. Packet fragmentation can be used to confuse network-based intrusion detection systems (IDS) and Intrusion Prevention Systems (IPS).


<li><a href="#">Intrusion detection systems listen in on networks looking for signatures of known attacks. Similar to virus detection software, they perform pattern matching. They look for a certain pattern and, if they find it, they set off an alarm.


<li><a href="#">These fragmentation attacks exploit the fact that a network-based IDS and packet filters do not have the complete context of how a packet will be treated and reassembled at the end system.


<li><a href="#">The tiny fragment attack is designed to fool the IDS by creating an initial fragment that is small. It’s so small that no single fragment has everything necessary to match a signature. A very stupid IDS sensor may allow this type of attack to pass by unnoticed, because it doesn’t reassemble the packets. Today, most IDS tools are capable of detecting this type of attack. Still, a large number of tiny fragments is a burden for the IDS, which has to reassemble the fragments for analysis.


<li><a href="#">A more insidious fragment attack is the fragment overlap attack. In this scenario, the attacker creates two fragments for each IP packet. One fragment has the TCP header, including a string that is not being looked for. The second fragment has an offset value that is a lie. The offset is too small, so that when the fragments are reassembled, the second fragment overwrites part of the first, particularly the part of the first fragment that includes some data that is sensitive.


<li><a href="#">To avoid these problems, make sure that your systems reassemble packets before making filtering or intrusion detection decisions. A firewall can do this, imposing its impression of the reassembly before the IDS, IPS, and end system get the packet. Everything after the firewall has the same interpretation of the packet, because the reassembly by the firewall forces the fragments into a single packet. Furthermore, a host-based IDS has the local TCP/IP stack and the complete context of the end system. Therefore, it can avoid the problems associated with fragmentation attacks.


<li><a href="#">Vulnerability scanning tools are extremely useful because they automate security checks across a large number of systems over the network, However, understand their limitations: • The tools only check for vulnerabilities that they know. They cannot find vulnerabilities that they don’t understand. • The tools tend to be flat: They look for vulnerabilities, but most cannot exploit them and pivot beyond an initial surface target to find other targets and vulnerabilities. • The tools often don’t perform detailed correlation among many vulnerabilities to ascertain overall risk.


<li><a href="#">An additional scanning technique lets an attacker grab data from a Windows environment across Server Message Block (SMB) sessions. This powerful technique allows an attacker to grab information about available users, groups, shares, and more, all by using a non-admin username and password. Microsoft created the Server Message Block (SMB) protocol to support a variety of network-accessible features of Windows machines, including file sharing, printer sharing, domain authentication, remote administration (through commands such as reg, se, and many others, as well as via enterprise admin GUI tools), and countless other capabilities.


<li><a href="#">The Server Service on Windows implements the service side of SMB, making file shares and remote registry’ access available, again with many other features. This service is running by default on Windows workstations and servers alike. Given all the features supported by SMB, it is often subject to attack. On modern Windows machines, SMB is typically accessed using TCP port 445.


<li><a href="#">Typically, you need to allow SMB sessions only from clients to a specific set of servers (such as file servers and domain controllers). Usually, you don’t need clients to establish SMB sessions to other clients. Thus, you can implement some solid defenses by configuring routers and firewalls to block SMB sessions with TCP port 445, as well as the NetBIOS ports TCP and UDP 135 through 139. Allow such traffic only to specific systems where there is a business need for SMB.




<li><a href="#">One of the more dangerous style attacks we see is Border Gateway Protocol Hijacking. This attack relies on an attacker broadcasting an Autonomous System Number which contains a more specific route to an IP address or addresses. For example, if I have an ASN that is associated with I 00 IP addresses and you have one which just broadcasts one the more specific ASN will be the one which gets the traffic.


<li><a href="#">There are a couple of different things an attacker needs to do in order for this attack to be successful. First, they need access to an edge router on the Internet where they can modify and broadcast BGP and ASN information. This means they most likely need to compromise an ISP or be a nation-state level attacker. Also, keep in mind, these attacks are very hard to detect. The only way to be prepared is to have a good idea on how traffic would normally traceroute to your network from key locations.


<li><a href="#">We recommend running and recording what normal traceroute information looks like by using a service like traceroute.org. Also, user awareness training can play a big part in detection. If your users start to notice browser error messages and dropped sessions, it may be time to investigate.


<li><a href="#">Netcat is one of the most useful tools for hacking and cracking available today. It allows you to easily move data across a network, functioning much like the UNIX “cat” command, where data can be sent over various TCP or UDP ports instead of through programs or files.


<li><a href="#">One of the simplest uses for Netcat is to transfer data between two machines. Note that you can create stealthy data transfers by using something like UDP port 53, which would look like DNS traffic. Even for legitimate uses, it’s often easier to fire up Netcat on some port allowed on the network just to move a file around than to actually use FTP.


<li><a href="#">One of the simplest uses for Netcat is to provide a backdoor login shell. By setting up a Netcat listener on any port and activating the e (“execute”) option, Netcat runs a shell (or any other program) when someone connects on the port.


<li><a href="#">The defense against Netcat depends on the mode in which it is used. To summarize, preparation step involves: — Data transfer: Know what is running on your systems — Port scanner: Close all unused ports — Vulnerability scanner: Apply system patches — Connecting to open ports: Close all unused ports — Backdoors: Know what is running on your systems — Relays: Carefully architect your network with layered security so an attacker cannot relay around your critical-filtering capabilities • Intranet firewalls can help create chokepoints for filtering • Private VLANs (PVLANs) can also help restrict the flow of traffic between systems


<li><a href="#">Sniffers are among the most common of hacker tools. They gather traffic off of the network, which an attacker can read in real time or squirrel away in a file. Many attacks are discovered only when a sniffer log consumes all available file space. To sniff in a switched environment, the attacker needs to redirect the flow of traffic on the LAN, either by attacking the switch itself or going after the machine sending the traffic.


<li><a href="#">There is a tremendous amount of focus in the computer underground over ways to hack around and through switches. To understand these hacks, you need to understand how the MAC layer works, particularly the Address Resolution Protocol (ARP).


<li><a href="#">Your machine must determine the MAC address corresponding to a given IP address. The ARP supports mapping IP addresses to MAC addresses. I send an ARP request: What is the MAC address for IP address 10.1.1 .1? The appropriate machine sends an ARP response telling me its MAC address. My machine then caches this information in its ARP cache, typically for up to 10 minutes. As with most of these protocols, functionality is built-in, but security is not. There’s no way to verify that the ARP response came from the proper machine.


<li><a href="#">By sending ARP responses when no one asks a question, I can flood a switch’s memory or even poison the victim system’s ARP cache. ARP spoof undermines the Address Resolution Protocol (ARP). Arpspoof allows an attacker to inject spurious ARP responses into a LAN to redirect all traffic from its intended destination to the attacker running a sniffer. Then, if lP forwarding is activated, the packet routes through the attacker’s machine and gets forwarded to the true destination.


<li><a href="#">If the attacker controls the victim’s computer through a drive-by download, worm, or bot, the attacker can install his or her own cert on the machine in the browser’s store of trusted certificates. Given the large number of attacker-controlled machines on the Internet, such an approach is available to most attackers. We have seen that some malware specimens do this to give an attacker long-term control over a victim machine. Or an attacker could use social engineering e-mail or pop-up messages to trick users into inserting a bogus certificate in their browsers.


<li><a href="#">In the sslstrip attack, the client sends an HTTP request, as usual. The sslstrip tool passes this request onto the web server. The web server attempts to send a redirect telling the browser to go to https://www.mybank.com. The sslstrip tool intercepts this redirect in the response and tells the browser to continue using http. The attacker then uses https to access the site. All traffic from the browser to the attacker is cleartext http, and all traffic from the attacker to the website is SSL-encrypted https.


<li><a href="#">Session hijacking tools are particularly nasty. They allow an attacker to grab an interactive login session (for example, telnet, rlogin, ftp, and so on). The victim usually notices that his/her session disappears (“Darn network trouble!”). The users likely just try to log in again, not knowing that their session wasn’t dropped; it was just stolen.


<li><a href="#">Sessions can be stolen at the originating or destination machines so the attackers can bypass all forms of strong authentication and Virtual Private Networking. If I take over the session by grabbing the terminal from a victim on the originating or destination system, I get access to the data before it gets encrypted and sent across the network.


<li><a href="#">One area of defense that can help on sensitive networks (such as your DMZ) involves hard-coding your ARP tables. In most systems, you can set your ARP tables at system boot to have only specific IP-to-MAC address mappings. These values cannot be overwritten by gratuitous ARPs.


<li><a href="#">Additionally, consider activating port-level security on your switches. At a minimum, that implies locking down each physical port on the switch to a allow only a single MAC address. Going further, you could lock down each physical port to allow only a specific MAC address. Furthermore, if you encrypt your sessions, the attacker won’t be able to hijack them, because he/she won’t have the keys to encrypt or decrypt information.


<li><a href="#">DNS does recursive queries. When a client wants to connect to a server, it must resolve the server’s name. The client’s resolver checks the local files to see if it already knows the IP address. If not, the client requests the mapping of name to address (in the form of a DNS address record) from the local name server (which it locates based on information in UNIX’s /etc/resolv.conf or in the Windows network control panel). The local name server receives the query. If it has the information cached from a previous lookup, it sends a response. If it doesn’t have the information, it does a recursive lookup.


<li><a href="#">DNS Poisoning Defenses : — Make the source port of DNS queries difficult to predict. That way, responses with bad port numbers are rejected — Makes the attack more difficult, because bad guy must predict both Query ID number and UDP port — Patch your DNS servers — Do not accept piggybacked responses and use a hard-to-predict Query ID — Keep DNS server (BIND, Windows DNS, DJB DNS, and others) up-to—date — Configure external DNS servers to perform recursive queries only for internal systems. — Don’t let just anyone on the Internet cause your external DNS server to do recursive look ups


<li><a href="#">Of course, users must be educated to know that they should only interact with a bank over secured connections. Furthermore, just because the lock lights up in the lower corner of your browser does not mean you are dealing with the actual site you think you are! It just means that you are dealing with a site that paid VeriSign their registration fee. Users must be educated to check the credentials of the sites they are visiting if sensitive business is going on.


<li><a href="#">After identifying the problem, you need to quickly get rid of the bad DNS entries. You can do this by rebooting the DNS server or using a process to flush the server’s cache. To get back into business, patch our DNS server using the latest version, which is likely less susceptible to this form of attack.


<li><a href="#">Buffer overflow exploits are one of the most insidious information security problems. A buffet overflow essentially takes advantage of applications that do not adequately parse input by stuffing too much data into undersized receptacles. The same root cause (non-validated input) is also the cause of other attacks, such as heap overflows.


<li><a href="#">Metasploit . The tool holds a collection of exploits themselves, little snippets of code that force a victim machine to execute the attacker’s payload. Metasploit has over a thousand different exploits today, including numerous common buffer overflow attacks. Next, the tool offers a set of payloads, the code the attacker wants to run on the target machine. Some payloads create a command-shell listener on a network port, waiting for the attacker to connect and get a command prompt. Other payloads give the attacker direct control of the victim machine GUI across the network by surreptitiously installing VNC, the GUI remote-control tool.


<li><a href="#">Buffer Overflow defenses : At a minimum, keep your systems patched Vendors frequently release patches for various programs that have buffer overflows A robust patching process involves rapidly obtaining, testing, and applying patches Utilize host-based IPS that offers buffer overflow protection by — Blocking certain calls into the kernel from certain applications — Offering additional memory protection to areas like the stack Deploy application white listing software


<li><a href="#">Filter both incoming and outgoing traffic from your site to minimize the avenues an attacker has to get in or communicate out. For ‘our outbound traffic, utilize proxies wherever possible. They give you a point of control and detection.


<li><a href="#">It is also fairly safe to assume you have been compromised. Because of this it is increasingly necessary for us to start hunting for attackers who have successfully flown under the radar. Hunt teaming is an activity where we utilize a number of techniques to bypass traditional security technologies as part of our penetration tests to hunt down other attackers who may have used similar techniques.


<li><a href="#">Identifying buffer overflow attacks can be tricky. First, look for unusual server crashes. Also, IDS and IPS tools have signatures to look for buffer overflow attacks, Finally, look for new accounts on the system. Attackers frequently create new accounts when they’ve taken over a machine using a buffer overflow.


<li><a href="#">For containment, you need to quickly harden similar systems on your network. Otherwise, the attacker is likely to spread through your network using the exact same attack against other systems. For eradication and recovery, you should rebuild. If an attacker compromises your system with root privileges, you will likely have to rebuild it from scratch using the original install media and patches.




<li><a href="#">In most organizations, passwords are the first and only line of defense for protecting information and servers. Because most user IDs consist of the first initial and last name of an employee or some combination, it is fairly easy to find out valid user IDs for individuals at a company. Based on this, the only other piece of information you need to gain access is a user password. Therefore, they need to be protected and they need to be hard to guess.


<li><a href="#">To avoid account lockout when performing password guessing, some attackers employ an alternative means for testing their guessed passwords: password spraying. With this technique, instead of trying a large number of passwords for a small number of accounts on a small number of targets (traditional password guessing), attackers choose a small number of potential passwords to try. They then spray these potential password guesses across a large number of account names and machines, hoping that one works.


<li><a href="#">For example, an attacker may start with a list of just four passwords and try each for a thousand or more accounts on a dozen different machines. Then, after the bad login counter timer expires (resetting the bad login count to zero), the attacker might try another four passwords, and so on.


<li><a href="#">The fastest method for cracking passwords is a dictionary attack. This is done by testing all the words in a dictionary or word file against the password hashes. When it finds the correct password, it displays the result. There are a lot of sites that have downloadable dictionaries you can use.


<li><a href="#">The most powerful cracking method is the brute force method. This method always recovers the password, no matter how complex. it is just a matter of time. Complex passwords that use characters that are not directly available on the keyboard may take so much time that it is not feasible to crack them on a single machine using today’s hardware. But most complex passwords can be cracked in a matter of days.


<li><a href="#">Following are the main ways to protect against password cracking attacks: • Get rid of LANMAN hashes on local systems. • Disable LANMAN challenge/response authentication across the network, instead forcing network authentication to use NTLMv2. • Have a password policy. • Implement SYSKEY, which provides an extra level of I 28bit encryption of the SAM database when it is stored in the registry in the file system. SYSKEY does not protect the hashes, however, when they are in memory. Tools such as pwdump, fgdump, Cain, and the Meterpreter can pull them from memory, bypassing SYSKEY defenses. • Protect your SAM database.


<li><a href="#">An attacker can avoid the time-consuming password cracking phase by simply grabbing the hashes, loading them into memory, and using them to authenticate to a target machine via the Server Message Block (SMB) protocol, used for Windows file and print sharing and domain authentication, resulting in a pass-the-hash attack.


<li><a href="#">To defend against pass-the-hash attacks, it is vital that enterprises maintain control of their hashes. The primary levers you have to manage this control is tight host security, making sure you keep your system thoroughly patched and hardened to prevent theft of hashes. Furthermore, endpoint security suites that bundle antivirus, antispyware, personal firewall, and host-based IPS technologies can help shore up the security of your end systems. Host-based firewalls on client machines, in particular, can help block attackers from using pass-the hash techniques to jump from client to client.


<li><a href="#">Worms are automated attack tools that spread via networks. A worm hits one machine, takes it over, and uses it as a staging ground to scan for and conquer other vulnerable systems. When these new targets are under the worm’s control, the voracious spread continues as the worm jumps off these new victims to search for additional prey. Using this process, worms propagate across a network on an exponential basis.


<li><a href="#">To evade detection, foil reverse-engineering analysis, and get past filters, worm developers are increasingly using polymorphic coding techniques in the worms they develop. Polymorphic programs dynamically change their appearance each time they run, by scrambling their software code. Although the new software is made up of entirely different instructions, the code still has the same function.


<li><a href="#">First, harden your systems. A majority of worms and bots utilize buffer overflow exploits to compromise their victims. Most operating systems can be inoculated against simple stack-based buffer overflow exploits by being configured with non-executable stacks. Keep in mind that non-executable stacks can break some programs (so test these fixes before implementing them) and they do not provide a bullet-proof shield against all buffer overflow attacks. Furthermore, patching and host-based IPS can stop other buffer overflow exploits.


<li><a href="#">Account harvesting is the ability to discern valid useriDs based on how the application responds when the user tries to authenticate. This technique is based on analyzing what happens when a user types in a useriD and password. If there are different error messages that come back (if the useriD is wrong versus if the password is wrong), an attacker can determine the useriDs associated with the system.


<li><a href="#">If there are differences in the error message between an incorrect userlD and an incorrect password, attackers can use automated harvesting scripts, going through the whole possible userlD space to determine valid useriDs. So, if a web application sends back one message or error code when the userlD is wrong and another message when the password is wrong, an attacker can set up a brute force guessing script to harvest all the userlDs. Its not glamorous, but it works like a charm for applications that have differentiations between the error messages.


<li><a href="#">How do you defend yourself against this kind of attack? All authentication error messages must be consistent. If the useriD is wrong or if the password is wrong, the same message should display. Everything should be identical: The HTML as well as any information passed back in the URL location line of the browser.


<li><a href="#">In addition, you may want to have individual useriDs tracked for a given number of bad logins and presented with an account lockout message after several invalid login attempts. If users try four or five different bad passwords in a row, you could lock out their account, either permanently (requiring a call to the help desk) or for potentially just a certain amount of time.


<li><a href="#">Some web applications take input from a user and then process that input by launching a command shell to run a program to deal with the input. In a vulnerable application, an attacker can subvert this process by injecting commands for the shell to run appended to normal input. Sometimes, these commands are separated from the input by a; (on Linux) or an & (on Windows) to cause the shell to view the trailing, attacker-injected command as part of the normal call for the shell to execute the program.


<li><a href="#">Some web applications dispense with launching a shell to invoke the program, but instead just execute the program to handle the input, and the program can be tricked into further executing the attacker’s input. Either way, we have a command injection vulnerability if the web application can be tricked into running commands supplied by the attacker as user input.


<li><a href="#">These attacker commands could arrive via arbitrary forms of user input on a web application, including URL variables (passed via HTTP GET), browser form variables (passed via IITTP POST), cookies, or other input methods.


<li><a href="#">When attackers verify that command execution is possible via ping or nslookup, they can then move to more elaborate commands. In particular, some attackers inject commands causing the target machine to mount a file share on an attacker-controlled system. That way, attackers can cause the target to execute the bad guys’ code right from the file share, without even installing the software on the vulnerable target.


<li><a href="#">To defend against command-injection attacks, you need to educate your web developers to treat user input carefully, avoiding any risky activity that may result in its execution, such as launching shells or directly calling exec features on inputted data. You should also strive to conduct periodic and regular vulnerability assessments and in-depth penetration tests of your systems to find such flaws before bad folks do.


<li><a href="#">When attackers can successfully conduct a SQL injection attack, they may retrieve information that has not been authorized. They could change account information, updating various tables in the database, or perhaps even remove entire datasets, such as dropping tables or even doing fine-grained editing of the database.


<li><a href="#">Attackers try to enter special characters and pieces of a SQL statement into their user input to see if they can get them to run on the backend system. The attacker types these components directly into the web application to see if it is carried back to the backend database.


<li><a href="#">In addition to the single quotes and double quotes, may try to enter in many different other characters to see if they can get the backend database to send some information in return. They may try semicolons or asterisks, percents or underscores, or even individual elements of SQL syntax.


<li><a href="#">One level of defense against SQL Injection involves limiting permissions of the web application when accessing the database. Don’t let your web app have admin capabilities on your database! That’s incredibly dangerous. Clamping down on these permissions won’t eliminate SQL Injection, but it can limit the attacker’s ability to explore the database fully.


<li><a href="#">Also, consider using parameterized stored procedures. This technique splits up user input into individual parameters, which are fed as isolated elements into stored procedures running on the database. Because the user input is split among various parameters, SQL Injection attacks become far more difficult for the attacker.


<li><a href="#">Further bolstering your defenses, you need to build your web applications so that the server side screens out any extraneous but potentially meaningful user input. You need to filter out minus signs, semicolons, asterisks, percentage signs, underscores, or any other shell metacharacters, such as ampersands, pipes, or question marks.


<li><a href="#">Cross-Site Scripting enables an attacker to steal information (such as cookies) from users of a vulnerable website. So, if your online bank is vulnerable, we might steal your banking cookies. Cross-Site Scripting involves sending scripting code (usually JavaScript or VBScript) to a web application that sends data back to the browser. The web server has an application that reflects user input back to a web bro set. When the code gets to the browser, it is executed. Upon reaching a browser, the script on this page pops up a dialogue box. SQL Injection goes after a backend database. XSS goes after other users’ frontend browsers. Still, by filtering out the offending characters at the web app, we can protect both the backend and the frontend.


<li><a href="#">To defend browsers and other clients that process browser scripts, you could disable scripting support in the client configuration. However, turning off all scripting support for languages such as JavaScript can break many websites, which may be important to users. Another option is to use a script filter, which can allow scripts from some sites and block them from others, or alternatively, prompt a user when a suspicious browser script is encountered.


<li><a href="#">Defenders can use proxy tools to help defend against these attacks, monitoring all inbound traffic destined for their websites using Web Application Firewalls (WAFs). These tools sit in front of a web server and look for incoming requests where an attacker manipulated a cookie or other state element that is supposed to remain static. They also look for other suspicious behavior, such as input that contains SQL Injection or XSS attacks.


<li><a href="#">A denial-of-service attack involves an attacker preventing legitimate users from accessing a service. They are affectionately referred to as DoS attacks. The attacker is focused on stopping legitimate access; technical finesse is not paramount. Although many denial-of-service attacks may not be technically elegant, they can be a big problem.


<li><a href="#">You need to keep your systems patched because many DoS attacks target old versions of vulnerable systems. In addition, you need to make sure that you have adequate bandwidth and redundant paths to your critical systems. It is trivially easy for a script kiddie to completely exhaust a Tl line.


<li><a href="#">Generally speaking, there are two categories of DoS attacks: local DoS and network-based DoS. Local DoS attacks are run from an account on the victim machine. An attacker runs some program or function locally that prevents users from accessing their resources. There are two ways to execute local DoS. The attacker could simply crash a service by stopping a process from running. Another way to launch a local DoS attack is to tie up system resources.


<li><a href="#">The second category of DoS attacks are network-based. These attacks are launched across a network. Within the arena of network-based DoS attacks, we have two types: a malformed packet attack and a packet flood. A malformed packet attack involves sending a single packet or a small stream of packets to a system that are formed in a way’ not anticipated by the developers of the target machine.


<li><a href="#">The second type of network-based DoS attack is the packet flood. Indeed, this is the most common type of DoS today. It is so popular because the attack can be launched remotely, allowing the attacker to have distance between him and the victim. Packet floods involve sending more packets to a machine than it can handle. The attacker either causes all available processing power of the target machine to be tied up or even exhausts all bandwidth of the connection to the target.


<li><a href="#">DNS amplification attacks involve using spooled packets against a third party to amplify traffic to a target. These attacks, which have been known about for almost a decade, involve sending small, spoofed DNS queries to a series of DNS servers on the Internet. The DNS servers send a larger response back to the address that appeared to make the request. This results in an amplification of traffic directed to the ultimate flood target.


<li><a href="#">Instead of using a single machine or a small number of machines to launch a packet flood, an attacker could turn to a large number of systems, particularly a botnet, to launch a flood, resulting in a Distributed Denial of Service (DDoS) attack.


<li><a href="#">You should deploy egress anti-spoof filters at your border routers. These filters drop all outgoing packets that have a source address that is not located on your network. All packets leaving your network should have a source address associated with your network. If they don’t, either something is misconfigured, or an attacker is launching spoofed packets.


<li><a href="#">To defend against attacks that have a small number of zombies, you should make sure you have adequate bandwidth and redundancy. A handful of zombies can consume only so much bandwidth. If you have more bandwidth, you can avoid losing all your link capacity to an attack.


<li><a href="#">If the flood is significant, you need to call your ISP’s incident response team immediately and ask it to start implementing filters on its network. By blocking the attack at the next level upstream, your ISPs can defend you from much of the brunt of the flood. Although this is a reactive solution, it is the only practical means of surviving during a DDoS attack that involves a huge number of zombies.




<li><a href="#">Numerous attackers, once they gain access, want to keep access and will use backdoors and Trojan Horses to accomplish this technique. A backdoor is a program that allows an attacker to bypass normal security controls on a system. The normal users of a system might have to type in a useriD and a password. A backdoor can allow an attacker to get around that, so he doesn’t have to provide a useriD and password. A trojan horse is a separate concept from a backdoor. A Trojan horse is a program that looks like it has some useful function but is actually sinister. It has some hidden capability used by the attacker.


<li><a href="#">Application-level Trojan Horse backdoors involve installing an extra application on the target system without changing the operating system itself. Bots fall into this category, as does VNC (when abused as a backdoor) and Poison Ivy. User-mode rootkits go to a deeper level by modifying the existing user-mode operating system programs on the target machine so that an attacker can maintain backdoor control of the machine while hiding. Examples include the Linux rootkit family (LRK), the AFX Windows rootkit, and more.


<li><a href="#">Kernel-mode rootkits are even more insidious, modifying the heart of the operating system, the kernel itself, to achieve very powerful and subtle control of the target. Examples of kernel-mode rootkits include the Windows FUto and Linux SuperUser Control Kit.


<li><a href="#">Like many of these remote-control backdoor tools, Poison Ivy requires its user to first configure the server, setting up the communication method, file name, and various features that will be used. This configuration creates an executable suitable for installation of the server on the target. After the executable is run on the target, the attacker runs a client GUI to control the server across the network.


<li><a href="#">Wrappers take two inputs and have one output. The two inputs are programs that the wrapper will meld together into the single output executable. An attacker will take one executable program such as a game or perhaps a word processing program, and wrap nc.exe into that program. The resulting output executable can be given a name like the original host program. Attackers frequently take innocuous-looking programs and wrap backdoor Trojan Horse tools into them.


<li><a href="#">Trojan Horse backdoor tools leave an enormous amount of information in memory for an incident handler to analyze. The handler can dump memory from the machine using a large number of tools, including the MemoryDD.bat script that is part of Mandiant’s free Memoryze suite.


<li><a href="#">After a memory dump is created, you can move it off a machine using Netcat file transfer or copying it to an 5MB file share. Then, the memory capture can be analyzed using various tools. In the past few years, numerous high-quality tools have been released for analyzing memory dumps from Windows systems. Volatile Systems offers the free, open-source Volatility Framework, an excellent tool that can pull an enormous amount of information from Windows dumps, including network connections, running processes, loaded drivers, etc. Google’s Rekall framework is also outstanding. It has many of the same features as Volatility.


<li><a href="#">Contrary to what their name implies, rootkits do not allow an attacker to gain root access. Rootkits depend on the attackers already having root access, which was likely gotten with a root exploit (such as a buffer overflow or other type of attack).


<li><a href="#">Although rootkits do not let an attacker gain root access, they do allow attackers to maintain root access once they’ve gotten it. Rootkits let an attacker place a backdoor onto the system to maintain control of the machine. Some rootkits also include capabilities for gathering information from the local network through sniffing. One of the most significant areas in rootkit tools involves masking the attacker’s presence on the system. Rootkits hide logins, programs, files, and processes from a system administrator.


<li><a href="#">To accomplish these goals, rootkits alter the existing operating system on the victim machine. Rather than adding a new application to the system like we saw with application-level Trojan Horse backdoors, rootkits alter the existing programs on the machine. Because they modify existing programs, rootkits are classic examples of Trojan Horse backdoors.


<li><a href="#">For process hiding, common Linux rootkits include a replacement or redirection for ps, top, and pidof. These tools will not show the attackers processes running on the box. In addition, many rootkits replace killall so that the attacker’s processes cannot be killed using this command.


<li><a href="#">Files are hidden by changing the Is and find commands so that they do not display the attacker’s files. The du command is changed so that it omits the attacker’s file from its disk usage calculation. finally, the attackers modify syslogd so that it will not record log events associated with the attacker’s machine and/or accounts on the victim box.


<li><a href="#">Attackers use a technique called “DLL injection ” to force an unsuspecting running EXE process to accept a DCL that it never requested. Very rudely, an attacker injects code in the form of a DCL directly into the victim EXE process’s memory space.


<li><a href="#">So, attackers can inject code into any running process. Which processes lend themselves to rootkit-style attack? One particularly interesting target is the explorer.exe process. This process implements the Windows GUI that you probably stare into day in and day out. It’s always running, as long as the Windows machine is displaying a GUI.


<li><a href="#">One way to detect the presence of a rootkit is to compare the output of the Is program with the output from “echo *“ The output should include the same files “echo *“ tells the shell to show the contents of the directory. “echo ‘“ is usually not Trojaned with a rootkit. Therefore, if the unaltered “echo *“ output differs from the “Is - Ia” command, you should be suspicious. Numerous tools are available that can analyze Ibm/login to determine if a rootkit is installed. Tools like chkrootkit (available at www.chkrootkit.org) or many host-based Intrusion Detection tools can detect rootkit bin/login programs.


<li><a href="#">The best way to defend against rootkits is to be proactive. You should use a file system integrity checking tool. Such tools can create a read-only database of cryptographic hashes for critical system files. You should store this file offline and periodically check your running system to verify the integrity of its files. By using cryptographically strong hashes to create digital fingerprints of your sensitive files, and periodically checking your existing files against those fingerprints, you can detect a rootkit quickly.


<li><a href="#">When a rootkit is detected, you should completely wipe and reformat the drive, reinstall all operating system components and applications, and then thoroughly patch the machine. Restore data from a recent backup.


<li><a href="#">Because they run at the kernel-mode, kernel-mode rootkits have much more power over the system than rootkits that live at the process/program/application level. Detection is far more difficult, because detection programs themselves run at the process/program/application level and rely on the kernel to function.


<li><a href="#">In most operating systems, including UNIX and Windows, the kernel is special software that controls various extremely important elements of the machine. The kernel sits between individual running programs and the hardware itself.


<li><a href="#">A primary method for invading the Linux kernel to implement a kernel-mode rootkit involves creating an evil loadable kernel module that manipulates the existing kernel. This technique first emerged publicly in approximately 1997, and grew in popularity over subsequent years, with a huge variety of different evil module variations available today. Today, it remains the most popular technique for implementing kernel-mode rootkits on Linux systems.


<li><a href="#">Loadable kernel modules run in kernel mode, and can augment or even replace existing kernel features, all without a system reboot. Because of the convenience of this feature for injecting new code into the kernel, it’s one of the easiest methods for implementing kernel-mode rootkits on systems that support kernel modules (such as Linux and Solaris).


<li><a href="#">Similarly, by creating malicious device drivers, an attacker can undermine the Windows kernel. Device drivers run at kernel mode, and have been used to implement Windows kernel-mode roolkits by altering the system call table. Starting with Windows Vista (and following with Windows 7, Windows 2000, and Windows 8), Microsoft required mandatory device driver signing for Windows kernel components.


<li><a href="#">There are ways to subvert this process, however. One way is to steal legitimate private keys issued by Microsoft. This technique was used in the Stuxnet which relied on stolen signing keys issued to two legitimate companies. Alternatively, mandatory device driver signing could be bypassed using method 2 for altering the kernel: manipulating memory.


<li><a href="#">With root-level permissions on the box, the attacker could just replace or patch the kernel image file on the hard drive itself. That way, upon the next reboot of the system, the attacker’s evil kernel would be reloaded into the system instead of the original wholesome kernel. In the Linux file system, the kernel image is stored in a file called “vmlinuz,” typically located in the /boot directory.


<li><a href="#">Another kernel-mode rootkit alternative involves the bad guy breaking into the machine with root privileges and making the existing operating system a guest inside a virtual machine environment. Then, after starting this virtual machine containing the original system, the attacker runs underneath with his or her own hypervisor, controlling the system underneath the kernel of the guest operating system.


<li><a href="#">Hardening your systems to prevent superuser compromise is a critical first step. Microsoft ships Windows with a variety of security template files for workstations, servers, and domain controllers. However, these built-in security templates tend to be either way too weak so that any attacker can slice through them, or so strong that they render the system unusable in a real-world environment.


<li><a href="#">System hardening templates , available at http://www.cisecurity.org. These templates apply to Windows, Linux, Solaris, HP-UX, Cisco Routers, and Oracle Databases, as well as numerous other types of platforms (Microsoft Exchange Server, Microsoft SQL Server, Apache, BIND, Novell eDirectory, etc.). They serve as an excellent starting and reference point for your security configuration. You can tweak them to make them stronger or loosen their restrictions for your environment.


<li><a href="#">The Center for Internet Security has also released free scoring tools, so you can check to see how well your security settings match a given template, such as the Win2K Pro Gold Template. You run scoring tools on a local system to compare your security stance to a baseline template, giving you a summary score between 0 and 10. The higher your score, the more closely you match the template used for comparison.


<li><a href="#">There are several other tools that provide similar functionality to Rootkit Revealer. These tools all ask the system a series of questions, looking for discrepancies in the answers that could be a sign of a rootkit. Several of the tools have been released by antivirus vendors. An incident handler should consider carrying several of these tools on a USB to get multiple opinions of whether a rootkit might be present on a machine under investigation.


<li><a href="#">Although they can be tricked by very thorough kernel-mode rootkits, you should still use file integrity checking tools, such as the Tripwire, OSSEC, AIDE, and the related programs. However, a less careful attacker might forget to configure the kernel-mode rootkit to hide alterations to one or two sensitive system files. Even a single mistake in the file-hiding configuration of the kernel-mode rootkit by the bad guys could expose them to detection by your file integrity checker.


<li><a href="#">Increasingly, people are turning to network-based detection and defensive tools, in the form of network forensics applications that pull data from lots of systems and correlate events to determine what’s actually going on. By looking for unusual network behavior caused by malware infections, security personnel have a better shot at detecting the pathogenic code.


<li><a href="#">One of the most common methods for hiding files on a UNIX system is to simply give the file a name that starts with a dot. Attackers will disguise files and directories by naming them dot-space, dot-dot-space, dot-dot-dot, or even just space. This isn’t terribly sophisticated, but it works well in a pinch! Just name a file dot-dot-space, and many administrators won’t even notice the file. Essentially, the file is camouflaged, so that an unobservant user or administrator will not notice it as the redundant dots flash by on the screen.


<li><a href="#">Attackers frequently hide data inside /dev, /tmp, and /etc. The /dev directory contains information about devices on the system, such as chunks of your hard drive and references to terminals. It’s full of thousands of items and is therefore a good place to sneak additional files into.


<li><a href="#">After an attacker takes over a system, he usually wants to alter the system logs to erase the entries associated with the techniques he used to gain access to the system. Some attackers will just clean the logs out entirely, deleting everything from the log file. Such a technique is quite noticeable by the administrators, however. Therefore, more sophisticated attackers will delete selected entries from the log files. Only entries associated with the attackers gaining access, such as incorrect logins or process crashing, will be removed.


<li><a href="#">Whenever you type a command in a UNIX shell, the shell has the option (if it is configured appropriately) of recording each command. By default, the Bash shell included in Linux stores the most recent commands typed in. The default history file size is 500 commands in bash, although some Linux distros increase this to 1000 (including RedHat). An investigator can, therefore, look in the bash history file for a user to see what that user has typed recently. Bad guys don’t want the investigators to see what happened, so they will often edit the bash history file, which is written in plain ASCII. A particularly nasty attacker might plant false commands into another user’s history file to divert attention during an investigation.


<li><a href="#">UNIX systems have four files better known as the accounting entries. The utmp file stores information about all users currently logged into the system. This file is consulted by the “who” command to print a list of users with actively logged in sessions on the system. The wtmp file stores information about all users who have ever logged into the machine. The btmp file stores information about bad login attempts (i.e., failures to properly authenticate). The lastlog file shows information associated with the most recent login time and date for each user. This file is consulted by the login program when each user logs into the system to display the last login date and time for the user. Attackers want to modify these files so system administrators can’t tell what they’re up to.


<li><a href="#">The Windows NT File System (NTFS) supports a feature known as “file streaming.” File streaming applies only to NTFS partitions. An attacker can create additional streams associated with any file or directory name on the system. The attacker can then use these streams to hide his or her sensitive information, such as attack tools or sniffer logs. Any file or directory on an NTFS partition can be used to hide stich information, such as Notepad or Word.


<li><a href="#">To detect malicious software hidden in a file stream, you must make sure to use an updated antivirus tool. Over the last couple of years, most major antivirus manufacturers have included the ability to search through file streams to find malicious software.


<li><a href="#">In Windows, system logs are generated by the Event Logger service. The Windows Event Logger produces a set of buffer files (called .LOG files). The three primary Windows event types are stored temporarily in these log files: • SYSTEM.LOG • SECURITY.LOG • APPLICATION.LOG


<li><a href="#">To erase traces of activity, a perpetrator would at a minimum have to edit SECEVENT.EVT, but to be more confident that all traces of the perpetrator’s activity are gone, the attacker would possibly want to edit the other log files as well.


<li><a href="#">If the attacker has physical access to the Windows system, he or she could boot the system from a Linux floppy disk. With a specialized editing tool, the attacker would then be able to access the log files on the NTFS partition and delete elements from them. Because Windows is not running, the file is no longer write-protected.


<li><a href="#">A similar idea has been implemented in a password-resetting tool for Windows. This tool consists of a Linux boot disk that allows an attacker to edit the SAM database on a Windows system. The attacker can change the administrator password, resetting it to any value the attacker desires.


<li><a href="#">One of the most obvious and effective ways to defend your logs is to employ a separate logging server. If the system logs are sent to a remote system, the attacker will not be able to edit them on the machine that he or she has just taken over. Instead, after taking over one system, he or she will have to mount another successful attack against your logging server. Because your logging server can be dedicated to just gathering system logs, it can be very carefully secured. In UNIX, the syslog process can be easily configured to send its logs to a remote host. In addition to sending the logs to a remote logging server, you can also generate a cryptographic integrity check of the log files to protect them.


<li><a href="#">One of the most common ways to hide information as it is transmitted across a network is to use a technique called “tunneling.” With tunneling, one protocol is carried inside another protocol. For example, you can carry shell commands inside web traffic. Alternatively, you can carry shell traffic inside ICMP packets. You


<li><a href="#">Instead of carrying data via HTTP traffic, some attackers opt for other protocols. Numerous tools are readily available to carry traffic via covert channels using ICMP packets. Many networks allow outbound ICMP Echo packets and their associated responses, making ping packets a useful way to tunnel traffic in a covert fashion.


<li><a href="#">Although covert channels created by embedding one protocol entirely in a different protocol can be quite effective, covert channels can also be constructed by inserting data into unused or misused fields of protocol headers themselves. The TCP/IP protocol suite is particularly useful in carrying covert channels. Many of the fields in the TCP and IP headers have vast openings through which data can be sent. One particularly interesting tool that illustrates exploiting TCP/IP headers to create covert channels is called “Covert TCP.”


<li><a href="#">The defenses for Covert_TCP involve keeping the attackers off your systems by applying the principle of least privileges and stopping unknown processes from running on your machines. Also, employ network-based intrusion detection systems to look for anomalous behavior in the traffic.


<li><a href="#">If an attacker is using covert channels on your machines, you should scour other related systems looking for the same program. The system should be rebuilt if the attacker compromised root or admin-level accounts on the box.


<li><a href="#">Steganography involves hiding data within a file, such as an image or sound file, so that the meaning of the message and the fact that a message is being sent, is concealed. There are numerous methods allowing data to be embedded in a wide range of file types.


<li><a href="#">Detecting the presence of hidden data is quite trivial if you have the original source image. You can simply compare the two files and see whether they are different using a simple duff program. In most cases, however, you will not have the source image and will not be able to do this.


<li><a href="#">We are seeing many attacks against client-side software, such as browsers, music players, image viewing tools, etc. This will continue to be a dominant vector for some time. Also, as more features and power are added to smaller platforms like cell phones and PDAs, attackers will likely increasingly target these types of tools.


<li><a href="#">If attackers are able to manipulate infrastructure routing, they can steal massive amounts of data or shut down the Internet entirely. If they find a flaw in the Border Gateway Protocol (BGP4), they could cause major disruptions. Similarly, the domain name system underlies so much of Internet functionality. If attackers discover a major flaw in DNS systems, they can manipulate DNS to conduct numerous types of attacks.
</div>


<script>
function myFunction() {
    var input, filter, ul, li, a, i, txtValue;
    input = document.getElementById("myInput");
    filter = input.value.toUpperCase();
    ul = document.getElementById("myUL");
    li = ul.getElementsByTagName("li");
    for (i = 0; i < li.length; i++) {
        a = li[i].getElementsByTagName("a")[0];
        txtValue = a.textContent || a.innerText;
        if (txtValue.toUpperCase().indexOf(filter) > -1) {
            li[i].style.display = "";
        } else {
            li[i].style.display = "none";
        }
    }
}
</script>

<script src="hilitor.js"></script>
<script>
var myHilitor = new Hilitor("content"); // id of the element to parse
// myHilitor.setBreakRegExp(new RegExp('[^\\w\' -]+', "g")); // expanded to include spaces
myHilitor.apply();
</script>


<script>

  window.addEventListener("DOMContentLoaded", function(e) {
    var myHilitor2 = new Hilitor("playground");
    myHilitor2.setMatchType("left");
    document.getElementById("keywords").addEventListener("keyup", function(e) {
      myHilitor2.apply(this.value);
    }, false);
  }, false);

</script>
<script>
document.addEventListener("contextmenu", function(event){
event.preventDefault();
}, false);
</script>





</html>