<html>
<title>SANS Notes</title>
<meta name="robots" content="noindex,nofollow" />

<link rel="stylesheet" href="w2.css">
<link rel="stylesheet" href="w3-theme-black.css">
<link rel="stylesheet" href="roboto.css">
<link rel="stylesheet" href="font-awesome.min.css">
<head>
<style>



html, body {
-webkit-user-select: none;
-moz-user-select: none;
-ms-user-select: none;
user-select: none;
oncontextmenu="return false";
onselectstart="return false";
ondragstart="return false";
background-color: #f0f0f0;
}



* {
  box-sizing: border-box;
}

.w3-sidebar {
	z-index: 3;
	width: 345px;
	top: 30px;
	bottom: 0;
	height: inherit;
	text-align: justify
	height: 100%;
	background-color: #f0f0f0;
	position: fixed;
	overflow: auto;
	line-height: 0.2
}
.w3-searchbox {
	height: 25%;
	width: 110%;
	left:405px;
	top: 23px;
	overflow: hidden;
	background-color: black;
	position: fixed;
	z-index: 1;
	line-height: 2;
 margin-top: -7px; 

}

.w3-topbar {
	width: 100%;
	height:5%;
	background-color: black;
	position: fixed;
	top: -3px;
	overflow: hidden;

	
}


#myInput {
  background-repeat: no-repeat;
  width: 40%;
  border: 1px solid #ddd;
 margin-top: 20px; 
 margin-bottom: 12px;
  margin-left: 95px;
  text-align: center;
 font-family: "Roboto", sans-serif

}

#keywords {
  background-repeat: no-repeat;
  width: 20%;
  border: 1px solid #ddd;
  border: 1px solid #ddd;
  margin-bottom: 12px;
  margin-left: 120px;

 text-align: center;
 font-family: "Roboto", sans-serif

}
#myUL {
  list-style-type: none;
  padding: 0;
  text-align: justify;
  margin-top: 150px;
  width: 70%;
}

#myUL li a {
  margin-top: -1px; 
  padding: 8px;
  text-decoration: none;
  font-size: 14px;
  color: black;
  display: block
}

}
</style>
</head>

<body>
<!-- Topbar -->
<div class="w3-topbar"></div>

<!-- Sidebar -->
<nav class="w3-sidebar w3-bar-block w3-collapse w3-small w3-theme-l5" id="mySidebar">

<BR>
<p>
<BR>
<center><H3>SANS COURSE NOTES</H3></center>
<BR>
<p>
<BR>
<a class=" w3-button w3-hover-blue" href="sec401.html">SEC 401 - Security Essentials</a>
<a class="w3-button w3-hover-blue" href="sec450.html">SEC 450 - Blue Team Fundamentals</a>
<a class="w3-button w3-hover-green" href="for500.html">FOR 500 - Windows Forensic Analysis</a>
<a class="w3-button w3-hover-blue" href="sec502.html">SEC 502 - Perimeter Protection</a>
<a class="w3-button w3-hover-red" href="sec504.html">SEC 504 - Hacker Tools</a>
<a class="w3-button w3-hover-blue" href="sec506.html">SEC 506 - Linux/Unix Security</a>
<a class="w3-button w3-hover-green" href="for508.html">FOR 508 - Incident Response Forensics</a>
<a class="w3-button w3-hover-blue" href="sec511.html">SEC 511 - Continuous Monitoring</a>
<a class="w3-button w3-hover-blue" href="sec555.html">SEC 555 - SIEM with Tactical Analytics</a>
<P>
<center>
<a class="w3-button" href="standards.html">Security Standards</a><br>
<a class="w3-button" href="books.html">Security Books</a><br>
<a class="w3-button" href="tools.html">Security Tools</a>
</center>
</nav>
<nav class="w3-searchbox" id="searchbox">

<input type="text" id="myInput" onkeyup="myFunction()" placeholder="Filter Paragraph by Keyword" title="Search">
<form method="GET" onsubmit="myHilitor.apply(hilite.value); return false;">
<input type="text" id="keywords" size="20" name="hilite" placeholder="Highlight Multiple Keywords">
<input type="submit" value="Apply">
<input type="button" value="Remove" onclick="myHilitor.remove();">
</span>
</form>

</nav>


<div class="w3-main w3-theme-l5" style="margin-left:300px"> 
<div class="w3-row w3-padding-64">               
<h2 class="w3-text-teal"></h2>
<div id="playground">


<center>





<ul id="myUL">
<p> Perimeter Protection In-Depth, Chris Brenton<p>

<li><a href="#">It's important to note that an open listening socket is not the root cause of the system being vulnerable. Problems can occur anytime software on the system is remotely accessible. While accessing software via an open listening port is the most common attack vector, it is not the only possibility.


<li><a href="#">It's possible to formulate a payload that is specifically designed to attack the security device as it attempts to process the packets. We have seen this a number of times in the wild. While usually these attacks take the form of a denial of service attacks, there have been cases where the malicious payload has permitted the attacker to execute arbitrary code on the system. In other words, it's possible to compromise these devices even though they have no open listening sockets!


<li><a href="#">Unfortunately, many services are allowed to run as root or administrator, since some of their functionality may require a high level of system access. If the service is running under the administrator account, then the attacker's code will be executed with this level access as well. The result is that the attacker is free to create user accounts, steal password files, or do whatever they may need to do to gain access to the system.


<li><a href="#">Exactly where does your perimeter end? If you have remote VPN users, your perimeter extends to their systems. This changes our design model from layering a few firewalls at our border' to possibly needing to deploy personal firewalls on each remote user's system.


<li><a href="#">The real skill and security comes from maintaining the perimeter, not from installing it. To properly lock down the perimeter, you have to understand what is "normal" for that environment and investigate the deviations from this baseline. Maintaining a perimeter is one of those "some extra effort up front leads to less work on the back end" kind of things. Proper alerting can inform you of critical conditions so you don't need to review your logs every minute of the day. A little bit of scripting that will prune out all the known traffic patterns in your environment can help you focus on the traffic that truly needs your attention.


<li><a href="#">Decoying is simply a set of techniques which makes your perimeter appear to be different than it actually is. This could be hiding the existence of your firewall, making it appear that you have more firewall layers than you actually do, or even masking the identification of some of your services.


<li><a href="#">When the attacker could simply grab the banner, you had no knowledge that you were being targeted. When you forced the attacker to launch the attack, you made it easier to record who you needed to worry about. So decoying should never be considered a valid method of security by itself. It's just a tool we can add to the many other layers of our defense. So by making our network look different, we can cause more work for the attacker. More work means they need to generate more packets and the more packets they generate the better the chance we will identify them as being hostile and take corrective action.


<li><a href="#">When the network or IP layer talks to the link layer, an address association has to be done. The network layer speaks in IP addresses and the link layer speaks in MAC addresses. The address resolution protocol is responsible for making the association between IP addresses and MAC addresses. The host that needs to send the IP datagram to the link layer will issue an Address Resolution Protocol request to determine the MAC address of the receiver. Once determined, a frame header will be constructed that contains both the sender's and the receiver's MAC addresses.


<li><a href="#">By altering a host's ARP table, an attacker can alter the course that packets take. Although packets transmitted after the table alteration will contain the correct IP address, they will fail to reach the correct destination because their MAC address is wrong.


<li><a href="#">While ARP spoofing is typically the most effective method of hijacking traffic at layer 2, it is not the only option available. Another method is known as Mac flooding, which involves flooding the switch with bogus MAC addresses. If the MAC table becomes full, there is no room to store legitimate MAC address entries. The result is the switch now starts acting like a hub.


<li><a href="#">It may also be possible to perform port stealing. With this method, the attacker transmits packets making it appear that the victim's system has moved from its actual port to the port where the attacker is located. This causes the switch to transmit packets intended for the victim to the attacker.


<li><a href="#">If a network uses DHCP, then spoofing DHCP responses is another possibility. The attacker simply returns DHCP replies that contain all the correct information, with one minor modification. The attacker changes the default gateway entry to point at their IP address. When the victim system attempts to communicate off of the LAN, they end up sending their traffic to the attacker's system.


<li><a href="#">Finally, spoofing ICMP redirects is another possible option. With this method the attacker spoofs ICMP redirect packets to the victim making it look like the attacker's system is a preferred route to the Internet.


<li><a href="#">The network layer uses source and destination IP addresses to communicate between hosts. As users, we usually tend to refer to hosts by their hostname rather than their IP addresses. Most times, we can remember hostnames more easily than IP addresses.


<li><a href="#">The internet protocol addresses are stored in the IP header of the IP datagram. IP is concerned about getting a packet from hop to hop. This can be from the sender to the first router on its way to the destination host. Or, it can be from router to router in transit. Finally, it can be from the final router to the destination host. These IP datagrams are individual entities that are directed to the destination host as they go.


<li><a href="#">User Datagram Protocol (UDP) is considered a lightweight protocol because it is simple and makes no guarantee of reliable delivery. Unlike TCP that supports only single host to single host (unicast) communications, UDP can deliver traffic to one or more hosts. It has low overhead because it has a standard 8 byte header that carries vital information like source and destination port, UDP checksum, and a length that reflects the number of payload and UDP header bytes.


<li><a href="#">Transmission Control Protocol (TCP) has to synchronize a connection between hosts. Because of this, it is only possible for one source host to talk to one destination host. This is known as a unicast connection. TCP provides for reliable delivery. This comes in the form of a destination host acknowledging all received data. This is the only way that the sender knows that the data has been received. TCP also gives each segment of data that it sends sequence numbers. The sequence number represents the first byte of data in each TCP segment sent. Since TCP segments are transported in IP packets and since IP packets can take different routes to the destination host, it is possible for data to arrive in a different order than it was sent. Therefore, TCP is responsible for re-ordering the data by using the TCP sequence numbers.


<li><a href="#">Internet Control Message Protocol (ICMP) was created to report on problems that are not transient or likely to go away soon. ICMP is enlisted to inform the sending host that the UDP port is not reachable. The most well-known ICMP application is certainly the ICMP echo request/echo reply, or ping. Ping is used to find whether a given Internet host is reachable or not. ICMP is a lightweight protocol originally created for network troubleshooting. ICMP, like IP, has no built-in reliability. ICMP packets can be lost or dropped as well with no accountability.


<li><a href="#">Static packet filtering can be quite effective for performing "absolute" filtering. By absolute I mean that you would never under any conditions want the traffic entering your network. For example, 192.168.0.0/16 is considered to be private address space. Packets crossing the Internet should not use this address space as a source IP address. If they do, someone is leaking out packets, some hardware is misconfigured, or someone is spoofing the address space. With this in mind we can simply block this entire address space at our perimeter. It does not matter what protocol is used, or even what flags or options are set. We never want to let a packet with a source IP address with 192.168/16 into our network.


<li><a href="#">All inbound traffic with loopback as the source IP address should be blocked as well. Loopback is a special IP address that allows IP applications to communicate with other applications on the same host without needing to know the IP address that has been assigned to the host. Traffic sent to 127.0.0.1 is processed internally and is never actually transmitted on the wire. If you do see 127.0.0.1 as a source IP address, something is very broken or someone is attempting to send spoofed packets.


<li><a href="#">The concept of a "black hole" revolves around blocking a single IP or entire subnet which is known to generate attacks or unwanted traffic. For example, when reviewing your firewall logs you will most certainly come across source IP addresses that are scanning your domain for known vulnerabilities. This suggests that either the source IP has a bad guy at the terminal or the host has been compromised. In either case it may make sense to block all inbound traffic from this IP address to ensure that they do not come back later and actually find a host they can compromise.


<li><a href="#">Along with using your logs as a source of known to be bad source IP addresses, you can also use source IPs that other people have come across. For example www.dshield.org lists the top 10 source IP addresses that are launching scans and/or attacks. It may also make sense to block entire countries. For example at the time of this writing many hosts within China are launching an all out cyberwar with the U.S. If your domain is located in the U.S. and you never do business with China, it may make sense to block all traffic originating from that country.


<li><a href="#">A stateful packet filter is simply a static packet filter which has the additional ability of maintaining connection state. This might not sound like much on the surface, but ifs actually a very powerful capability. By remembering the state of a connection a stateful filter can make intelligent decisions as to which packets are true reply traffic and which packets have been crafted. The real replies can be let through while the crafted packets get filtered out.


<li><a href="#">Most stateful filters will try to match all traffic against an existing state table entry. If a match is found, the traffic is passed through. If no match is found, the packet is evaluated against the firewall rulebase. In effect the firewall is only opening a small pin hole in our perimeter security in order to allow replies back in. An attacker would have to craft a spoofed packet which matches all the state table information in order to get it through our firewall. So while static filtering was helpless against crafted ACK packets, stateful filtering can easily protect against this traffic.


<li><a href="#">In order to maintain a proper state table entry, a stateful packet filter must record the source and destination IP addresses as well as the source and destination port numbers. This is needed to distinguish between multiple hosts as well as multiple sessions that may be taking place between the same hosts.


<li><a href="#">In addition, some stateful packet filters may track additional information in order to more closely control security. For example the Cisco firewalls also record sequence numbers. This means that if an attacker attempts to craft packets in order to sneak them past the firewall, they must get the IP and port information correct as well as the sequence numbers. This makes sneaking packets through the firewall far more difficult, as sequence numbers will change every time a packet is transmitted.


<li><a href="#">When choosing a stateful firewall, pay close attention to how the state table gets stored. Firewalls that use a limited size state table (say a maximum of 50,000 entries or less) have been prone to DoS attacks in the past. An attacker simply fills up the state table with bogus entries so no new legitimate entries can be created.


<li><a href="#">One limitation of stateful packet filtering is that it does no payload verification. Traffic is controlled strictly on header information and may or may not reflect the actual data content contained within the payload of the packets.


<li><a href="#">Stateful inspection takes the concept of stateful packet filtering one step further. Instead of just maintaining state on a session like a stateful filter, a stateful inspection firewall has the ability to actually understand the protocols in use and make decisions based on the payload of these packets. This can be extremely useful when handling complex protocols.


<li><a href="#">A problem with security implementations of stateful inspection is that they been somewhat trivial to break. Remember that we are talking about pattern matching. This means that if the pattern does not exactly match the signature, it is going to get missed. So while SI may catch original versions of attacks, it's possible that even the slightest variation (like the addition of a single space character) could cause attacks to fly under the wire. Whether this is possible will depend on how the signature is written.


<li><a href="#">Port forwarding is a form of address translation that is used to support external clients attempting to access internal servers. All traffic is directed to the external IP address of the firewall. Port forwarding can then be configured to "forward" traffic on a per port basis to some internal server. The strength of port forwarding is that you can use a single legal IP address when offering multiple services. The down side is that you may not be able to support multiple servers of the same type. For example traffic to TCP/80 can only be forwarded to a single internal IP address.


<li><a href="#">Many-to-one NAT is used to support multiple workstations that need access to Internet resources. All outbound traffic has the source IP address changed so that it appears to originate from the external IP address of the firewall. The firewall will also change the source port number and use this as an accounting method to keep track of multiple sessions.


<li><a href="#">One-to-one NAT is used to map individual internal private IP addresses to a unique legal IP address. This is useful when you have one or two systems on a private address network that need to be accessed by hosts on the Internet. Note that since we have a direct one- to-one IP mapping, the firewall does not need to change the port number like it does with many-to-one NAT. This can be useful for services that attempt to assign a fixed source port as well as a fixed target port. A network-based intrusion detection system (NIDS) is a system which attempts to identify potential attacks as they travel across the network. The goal is to receive some kind of a heads up when hostile activity is taking place. Packets crossing the wire are decoded and inspected for suspect data. When the system feels it has detected an attack, an alert is triggered.


<li><a href="#">There are two primary methods of detecting suspect activity on the wire. The first is to look for known attack patterns which is referred to as signature based. The other is to look for unexpected activity known as anomaly detection or "adaptive IDS".


<li><a href="#">While most IDS are signature-based, there are systems that attempt to alert on attack patterns by identifying traffic that falls outside of what is defined to be "normal" for a given network. This technology is referred to as anomaly detection, or adaptive IDS.


<li><a href="#">Most adaptive intrusion detection systems are incapable of checking payload so any attack hitting the Web server on TCP/80 would probably go unnoticed. Also, networks tend to be an evolving entity. This means that our network's "normal" traffic flow may look drastically different a few weeks from now. With this in mind, the device needs to keep learning what is "normal" in order to keep from generating false positives.


<li><a href="#">Network intrusion systems are a great tool but need a skilled human sitting behind it that knows how to interpret the information. When a false positive is detected, you should take steps to try to prevent it from reoccurring. First thing you need to do is gather information on the exploit and take a look at the signature that generated the false positive. Can the rule be tweaked slightly to reduce the chance of generating false positives? When possible, it is always better to tighten rules rather than write exceptions.


<li><a href="#">A proxy is actually a running application that acts like a middle man between the two ends of the session. It mediates the outbound request as well as the returning data. Proxies can be deployed as a dedicated service system, such as a proxy that handles only SMTP traffic, or they can be deployed as general purpose firewalls which controls all inbound and outbound traffic across the perimeter. Proxies are powerful tools in that they are capable of fully scrutinizing the payload within the data.


<li><a href="#">Proxies are more secure when it comes to dealing with fragmentation or payload based attacks. Because a proxy completely inserts itself between the two communicating systems, it is in a much better position to screen content and secure what gets passed in the data stream. This makes proxy based firewalls better at providing security for the hosts that are being protected. Proxy firewalls do have an Achilles heel however. In order to control the data stream, they must accept inbound connections. This means that all proxies operate with one or more open listening ports which make them vulnerable to attack. One option is to leverage defense in depth. Place a Stateful Inspection firewall just behind your router, and utilize proxy based technology behind this initial perimeter. This gives you the best of both worlds and allows you to contain and control any intrusion that may occur into a proxy.


<li><a href="#">It is also possible to dedicate a proxy to a specific direction. For example forward proxies only service connections headed to the Internet from the internal network. There are a number of benefits to deploying a forward HTTP proxy. To start, a forward proxy can completely mask all of the tell tale fingerprints inherent in every IP stack and browser. This help to prevent leaking information that could be helpful to someone attempting to enumerate your environment.


<li><a href="#">We can also do the reverse, referred to as a reverse proxy, in order to service inbound connections to our Web server. A reverse proxy can help augment security as well as performance. This is how it works. The IP address for the HTTP proxy is given the DNS entry of "www". The actual Web server has no DNS entry and in fact is completely inaccessible from the Internet. When a user attempts to access "www", they are directed to the proxy. The proxy then receives the connection and processes it accordingly. For example we could configure the proxy to filter out any POST requests. This would help to prevent Internet based attacks that rely on writing to the Web server. The proxy would then forward the request to the actual Web server.


<li><a href="#">When the firewall receives a packet, it compares the packet to the rule base, starting with the first rule. It then compares the packet to every rule in order until it finds a rule that matches. The packet is then applied to the first rule that matches. If no rule is found to match, the implicit deny should drop it.


<li><a href="#">Rule order is critical to both security and performance. Place more specific rules before general rules to keep your security policy from breaking. For example place a list of banned IP addresses prior to your rule allowing all Internet users HTTP access to your Web server. When possible, put more commonly used rules first. For example if your Web server receives more traffic than your mail server place the HTTP rule first.


<li><a href="#">While it's possible to scale up firewall management to an impressive size, the trade off is an increase in complexity. With complexity comes a greater chance of mistakes, and thus security problems. All access should be strictly documented as to why it's in place, and maybe a third party should be charged with auditing and testing the firewall policies on a regular basis. Clearly the need for checks and balances increases as your firewall management becomes more complex.


<li><a href="#">Principle of Least Privilege : we could create a policy that only lets out specifically what we know we need to do business. The strength here of course is a much better security posture. The problem with this option however is that it requires a higher level of administration. Since you are only letting out what you need to, you are constantly re- evaluating your requirements and changing the firewall policy as needed. As we mentioned earlier, the more changes you make the greater the likelihood that you will break something. You also need to figure out how to deal with non-standard services like legitimate Web servers that are listening on ports other than TCP/80.


<li><a href="#">We should strive for only allowing out what is actually needed. If this is not possible, try specifically blocking critical services but let everything else out. For example we could block outbound NetBIOS/IP, SNMP, TFTP and Syslog but let out all other protocols. This is not as secure as letting out only what is specifically needed, but it's better than just blindly letting out all traffic from your internal network.


<li><a href="#">So we want to do alerting on firewall events, the question is how do we implement this? The problem is firewall matches may not be the only condition we wish to alert on. For example we may wish to see alerts if our intrusion system detects suspicious activity or if we have a host that has become compromised. What we would like to avoid is creating a number of separate alerting systems that will all require individual maintenance. With this in mind, centralized alerting on firewall events may be our best bet.


<li><a href="#">Testing the firewall after an initial install or when making any rule changes cannot be stressed highly enough. Until you have confirmed your policy, do not just assume that your perimeter is safe. The tools of choice for performing this testing are nmap and tcpdump. You use nmap to run a series of scans and tcpdump on the other side of the firewall to verify that the traffic pattern did not punch through.


<li><a href="#">When possible we want to think ahead a bit and tweak the firewall policy so that it makes log review easier. The idea is to sort detected traffic patterns so that they become easier to review at a later date.


<li><a href="#">Also keep in mind that adding signatures to your firewall policy does increase processing time and affect performance. Keep an eye on your firewall's throughput as you add additional rules. Still, the minor performance hit may more than make up for the time saved in log review and being able to run real-time alerts.


<li><a href="#">There are quite a few reasons why your perimeter may not control traffic in the manner you expect. The most popular is misconfiguration, and bugs or idiosyncrasies in the vendor's software implementation. Validating the perimeter is functioning as expected permits you to find these problems before an attacker does.


<li><a href="#">As part of your checks, don't forget to review the logs to ensure that all of your test probes were properly logged. Remember that stopping the suspicious traffic pattern is only part of the firewall's job. It should also give the local security administrator a heads up that the suspicious pattern occurred.


<li><a href="#">Perimeter tests to be performed:


<li><a href="#">· Port scans of external/internal IP


<li><a href="#">Source routed packets
<li><a href="#">Fragmented packets
<li><a href="#">Spoofed source IP addresses
<li><a href="#">Various flag values
<li><a href="#">Inbound/outbound policy test
<li><a href="#">The idea is to throw unusual packets at the firewall and see how it handles them. For example, the fragment testing should allow us to answer all of the following questions: Can the firewall pass legitimate fragments? Does the firewall simply drop the first fragment or does it perform reassembly before matching rules? Can rules that check header or payload content be circumvented with fragmentation? Are obviously crafted fragments filtered out?


<li><a href="#">With the answers to these questions, we can better decide how to handle fragments that make it through the firewall. For example, let's say our firewall does a good job handling fragments, but the content checking can be circumvented with fragmentation. With this in mind, we may wish to install an outbound HTTP proxy to eliminate the problem. What if our firewall simply passes all non-first fragments? In that case we may wish to watch fragments more closely with our IDS, install another firewall that provides better fragment protection, or possibly replace the firewall we are currently using.


<li><a href="#">Sometimes the problem can be fixed with a simple rule change. For example one of the tests was to see if unrestricted access was permitted to outbound ICMP error packets. For a firewall failing this test, it should be a simple matter of implementing an outbound rule that filters these patterns. Of course you don't know to block this unless you know it's a problem.


<li><a href="#">Principles of Host Security :


<li><a href="#">· Disable all unnecessary local services, listening ports, and applications.


<li><a href="#">Whatever is left, lock it down
<li><a href="#">Split DNS is an architectural concept. It is the logical splitting of your external name resolution and your internal name resolution. This means you will need two different sets of DNS servers, one set to service your internal network and another to service the rest of the Internet. Whether you choose to manage one or both of these sets of DNS servers is obviously a management decision.


<li><a href="#">Zone transfers are how secondary DNS servers update their zone databases from the primary (SOA) DNS servers. You want to ensure that your primary DNS server is limiting zone transfers to only the appropriate secondary DNS servers. Secondary DNS servers should not be allowing zone transfers. Zone transfers are an easy and quick method for mapping your organization's network.


<li><a href="#">Host based intrusion protection systems (HIPS) are an effort to move protection against network based attacks onto the hosts themselves. There are many benefits with this methodology. To start, network based protection begins to break down when dealing with technologies such as switching, encryption or when multiple attack vectors are possible (Internet, wireless, business partner connections, etc.). By moving protection onto the host, these problems are eliminated. On the downside, we increase the number of instances of security software on the wire so centralized management becomes key to a successful deployment.


<li><a href="#">SELinux can provide an extremely high level of security for Linux environments. Beyond that, it makes an excellent security model that can be adapted by other operating systems. SELinux has been implemented directly into the Linux kernel which means it can have absolute control over what goes on within the system. SELinux is policy-based and provides granular control over what a running process is permitted to do to a system. If we can quantify the level of access required by each running application, we can ensure that it never misbehaves by doing something unexpected. SELinux is deployed using one of two possible implementations. The first is described as "targeted", the second is defined as "strict". When running in targeted mode, SELinux is told to only control the operation of certain applications. Everything else is permitted to run unconfined relying on security built into the operating system to keep it secure (file permissions, restrictions on process owner, etc.). While this policy seems pretty loose, it can actually be quite effective. Our biggest threat comes from applications that hold open a listening socket. If we target in on writing policies for those applications, we can secure the remote entry points into the system.


<li><a href="#">With strict mode, all applications require a policy in order to run on the system. While this is certainly the most secure method of operation (an undefined backdoor process would not be allowed to execute in memory), it is also the most complex. Every single executable on the system requires an access control policy. Needless to say these configurations can become extremely complex. Management also becomes more difficult as systems which serve different roles within your environment (Web server, SMTP server, administrator's desktop, etc.) may require drastically different policies.


<li><a href="#">When you configure SELinux for operation, you have to choose between "permissive" and "enforcing" operation modes. In permissive mode, we simply log all actions that appear to break policy. This is the safest mode to run in if you are worried about breaking an application. When enforcing mode is in effect, all controlled applications are restricted to operations defined within the policy. If an application tries something unexpected, the activity is blocked and logged.


<li><a href="#">Unfortunately HIPS does not cure all that ails us. While whitelisting what an application is permitted to do on a system can be a powerful security tool, it become cumbersome give the large number of applications that are available. Imagine having to create behavioral white lists for the thousands of Windows applications that could potentially see use in a corporate environment!


<li><a href="#">Remember that the strength of HIPS is to protect us from attacks over the wire. This may be overkill for applications that do not interface with the network. If an application is not communicating with network sockets, it may be sufficient to simply determine whether we wish to grant the user permission to run the application on their system. Application control has the ability to fill this niche.


<li><a href="#">Application Control permits enforcement of "acceptable use" policy regarding software. By taking control of the software your end users can install on their system, you can limit access to only those applications that have been certified for use. If the permitted software has been properly vetted, risk to the overall environment is dramatically reduced.


<li><a href="#">One of the biggest problems we face is... that malicious patterns have a tendency of sneaking past existing security devices if the attack is of an unknown signature. Application control resolves this problem by restricting what can actually be run on the system. If an end user receives an unknown malicious file via e-mail, an application control system will prevent the file from executing. Note that what we've done is change the paradigm. We gone from "react to files that are known to be bad" to "react to files that are not known to be good".


<li><a href="#">While application control can deal with rogue applications and malicious code, the technology is not designed to deal with threats against existing software such as exposed services with remote exploits. It will provide secondary protection by preventing the exploit from writing a toolkit to the file system, but a host based intrusion prevention system is better suited to this task. Same is true for memory level attacks that do not record information to the file system. While these attacks are rare, a host based intrusion prevention system is again better suited to neutralize them.


<li><a href="#">A vulnerability scanner is a tool which will check specified target hosts for known vulnerabilities. The vulnerability scanner usually references an included database which has records for each known vulnerability. The scanner then probes remote hosts to identify which hosts have tell tale signs of being vulnerable to each of the database's listed vulnerabilities.


<li><a href="#">There are two common methods used to perform vulnerability checking. The first method is simple banner grabbing. For example, a vulnerability scanner may do nothing more than connect to TCP/80 and record the banner presented by the Web server. The vulnerability scanner then references a database and prints out all known vulnerabilities related to that software version. The up side here is that we can perform quick tests without fear of hurting our server. On the down side the scanner can easily report erroneous information because of simple banner manipulation.


<li><a href="#">The second option is to actually try the exploit or some portion there of. While this method is more dangerous (it could crash the server), it is far more accurate. For example, with the first method you could fool the vulnerability scanner by simply changing the reported version. Obviously, the second method would not be fooled by this rudimentary trick.


<li><a href="#">The goal of a vulnerability assessment is to identify if there are configuration problems or missing patches from a system. With regards to patches, there are a number of ways we can perform this verification. The first is to see what version of software is registered with the system. Another option is to perform an integrity check of the files on the system.


<li><a href="#">An audit, simply put, is verification of the integrity of a system. When you perform an audit, you are insuring that only authorized access has taken place and all changes made to the system are in accordance with your security policy. A baseline audit is simply the process of collecting information about a known to be secure system (say before it is deployed on the network) in order to create a "baseline". At later intervals, you can then check the current system status against this baseline in order to ensure its integrity is still intact. A good audit should leave as few clues as possible that a regular audit is being performed. Armed with the knowledge of what you audit and how, a potential attacker will take steps to try and cover their tracks.


<li><a href="#">Even though we will try to make our audits as complete as possible, this does not mean we will be able to detect every single system compromise. When an operating system is infected at the kernel level the malicious code effectively becomes part of the operating system itself. This means that it has full control of all system checks and data reporting. So it might be obvious to our tool that something is amiss on the system, but if the malicious code does not permit our tool to report this information we are out of luck.


<li><a href="#">Secure Socket Layer (SSL) is really a framework that pulls together a bunch of other specifications and defines how they will all work together. For example, SSL does not specify how to encrypt the data, it simply defines which algorithms are supported and leaves it to each specification to define how data privacy will be implemented.


<li><a href="#">Secure Shell (SSH) is a secure alternative to clear text applications such as Telnet and FTP. It uses TCP/22 by default to communicate and encrypts all data after the initial protocol negotiation. Even the logon name is protected from prying eyes. Additionally, SSH has the ability to tunnel just about any service between two hosts. SSH can be used to create network-to-network VPNs. This is done by tunneling services and mapping them to local listening ports. IPSec has three distinct phases. In the first phase, initial authentication takes place. This is the initial verification that both ends of the connection are in fact who they claim to be. The process can be as simple as exchanging the hash of a pre-programmed password (known as "a shared secret"). This initial authentication can also leverage technologies such as LDAP or PKI.


<li><a href="#">In phase two, the parameters of the Virtual Private Network (VPN) are negotiated. The two end points negotiate things like "What kind of encryption will be used?", "What security services will be supported?", and even "How often should we create new encryption keys?". In the final phase, the actual VPN is initialized and data is transferred in a protected format.


<li><a href="#">It is important to think of a proper security solution in terms of a complete system. In other words, no single solution will ever provide enough security to reduce risk to an acceptable level. We will typically want to connect multiple solutions into an overall security posture. The trick is identifying you greatest levels of risk so that security can properly be applied.


<li><a href="#">Achieving zero risk is not going to happen unless we shut everything down and stop doing business. As a security professional, it is easy to get caught up in trying to reduce risk to as close to zero as possible. From a business standpoint however, risk reduction needs to be balanced against other requirements like budget and work flow.


<li><a href="#">You may find it useful to define security zones within the network. A security zone is simply a numeric indicator of how much security is required in that segment. It is also an indication of the trustworthiness of that portion of the network. Why is defining security zones important? Because they will help you decide how to best allocate security resources when protecting your network.


<li><a href="#">Border routers should be stand alone devices (not virtualized on the same hardware with other internal routers). They can provide a minimal level of security, including verifying that the firewall remains in a secure state. The stateful firewall sitting behind the router needs to remain a trusted host. This device will be our gatekeeper for controlling inbound traffic flow, as well as identifying internal hosts which may become compromised. Once the stateful firewall controls traffic at a port level, we can look to other technology for analyzing the payload information. Proxies give us our best security, but can be replaced by a NIPS solution if bandwidth demands it. We can also leverage NIDS technology to detect abnormal traffic patterns or known attack signatures.


<li><a href="#">The Demilitarized Zone (DMZ) contains systems that are exposed to direct attack. The value of this security zone is probably going to be much lower than any of your internal segments. With this in mind, you would probably want to use a different physical switch than the one used for the administrative and HR folks. While we could certainly create VLANs on the DMZ using this second switch, what we want to avoid is creating a potential software bridge that could connect the DMZ to an internal segment, thus bypassing the firewall.


<li><a href="#">Encryption can be our best friend but also our worst nightmare. It can be used to protect our confidential transmissions, but it can also be used by attackers to hide their tracks. Basically, you have two options: 1) Avoid end to end encryption — This will permit you to leverage your network security devices to validate the data stream. 2) Permit end to end encryption — All verification must be done on the host system. With the first option we only encrypt data as it moves over security zones with a low level of trust. This way we can verify security. If we go with the second option, we must secure the stream after it is decrypted. Namely, on the host itself. This severely limits our security options.


<li><a href="#">The best place to learn about anyone connected to the Internet is to start by querying the whois databases. These databases include information such as administrative contacts as well as IP address information. One nice thing about starting with the whois databases is that it generates no direct traffic at the target itself. In other words, our whois queries will not generate any firewall or system log entries at the network we wish to attack.


<li><a href="#">So how do you access the perimeter security? We tell nmap to perform two port probes, one with the SYN flag set and another with the ACK flag set. If a RST is returned in both cases, there is no firewall. If the ACK returns a RST but the SYN does not, a static packet filtering firewall is in the way. If neither probe returns a RST, there is a stateful or proxy firewall protecting the host.


<li><a href="#">Once open ports have been identified, it's a simple matter of doing some banner grabbing to find out what software is running. Once we know the software and version numbers used, we can start digging for a working exploit.
</div>


<script>
function myFunction() {
    var input, filter, ul, li, a, i, txtValue;
    input = document.getElementById("myInput");
    filter = input.value.toUpperCase();
    ul = document.getElementById("myUL");
    li = ul.getElementsByTagName("li");
    for (i = 0; i < li.length; i++) {
        a = li[i].getElementsByTagName("a")[0];
        txtValue = a.textContent || a.innerText;
        if (txtValue.toUpperCase().indexOf(filter) > -1) {
            li[i].style.display = "";
        } else {
            li[i].style.display = "none";
        }
    }
}
</script>

<script src="hilitor.js"></script>
<script>
var myHilitor = new Hilitor("content"); // id of the element to parse
// myHilitor.setBreakRegExp(new RegExp('[^\\w\' -]+', "g")); // expanded to include spaces
myHilitor.apply();
</script>


<script>

  window.addEventListener("DOMContentLoaded", function(e) {
    var myHilitor2 = new Hilitor("playground");
    myHilitor2.setMatchType("left");
    document.getElementById("keywords").addEventListener("keyup", function(e) {
      myHilitor2.apply(this.value);
    }, false);
  }, false);

</script>


<script>
document.addEventListener("contextmenu", function(event){
event.preventDefault();
}, false);
</script>



</html>